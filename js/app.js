(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, copyDefault, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toESM = (module, isNodeMode) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", !isNodeMode && module && module.__esModule ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };
  var __toCommonJS = /* @__PURE__ */ ((cache) => {
    return (module, temp) => {
      return cache && cache.get(module) || (temp = __reExport(__markAsModule({}), module, 1), cache && cache.set(module, temp), temp);
    };
  })(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

  // node_modules/vue/dist/vue.js
  var require_vue = __commonJS({
    "node_modules/vue/dist/vue.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.Vue = factory());
      })(exports, function() {
        "use strict";
        var emptyObject = Object.freeze({});
        function isUndef2(v) {
          return v === void 0 || v === null;
        }
        function isDef(v) {
          return v !== void 0 && v !== null;
        }
        function isTrue(v) {
          return v === true;
        }
        function isFalse(v) {
          return v === false;
        }
        function isPrimitive2(value) {
          return typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "boolean";
        }
        function isObject2(obj) {
          return obj !== null && typeof obj === "object";
        }
        var _toString = Object.prototype.toString;
        function toRawType(value) {
          return _toString.call(value).slice(8, -1);
        }
        function isPlainObject2(obj) {
          return _toString.call(obj) === "[object Object]";
        }
        function isRegExp(v) {
          return _toString.call(v) === "[object RegExp]";
        }
        function isValidArrayIndex2(val) {
          var n = parseFloat(String(val));
          return n >= 0 && Math.floor(n) === n && isFinite(val);
        }
        function isPromise(val) {
          return isDef(val) && typeof val.then === "function" && typeof val.catch === "function";
        }
        function toString2(val) {
          return val == null ? "" : Array.isArray(val) || isPlainObject2(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
        }
        function toNumber(val) {
          var n = parseFloat(val);
          return isNaN(n) ? val : n;
        }
        function makeMap(str2, expectsLowerCase) {
          var map = /* @__PURE__ */ Object.create(null);
          var list = str2.split(",");
          for (var i = 0; i < list.length; i++) {
            map[list[i]] = true;
          }
          return expectsLowerCase ? function(val) {
            return map[val.toLowerCase()];
          } : function(val) {
            return map[val];
          };
        }
        var isBuiltInTag = makeMap("slot,component", true);
        var isReservedAttribute = makeMap("key,ref,slot,slot-scope,is");
        function remove(arr, item) {
          if (arr.length) {
            var index2 = arr.indexOf(item);
            if (index2 > -1) {
              return arr.splice(index2, 1);
            }
          }
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function hasOwn2(obj, key) {
          return hasOwnProperty.call(obj, key);
        }
        function cached(fn) {
          var cache = /* @__PURE__ */ Object.create(null);
          return function cachedFn(str2) {
            var hit = cache[str2];
            return hit || (cache[str2] = fn(str2));
          };
        }
        var camelizeRE = /-(\w)/g;
        var camelize = cached(function(str2) {
          return str2.replace(camelizeRE, function(_, c) {
            return c ? c.toUpperCase() : "";
          });
        });
        var capitalize = cached(function(str2) {
          return str2.charAt(0).toUpperCase() + str2.slice(1);
        });
        var hyphenateRE = /\B([A-Z])/g;
        var hyphenate = cached(function(str2) {
          return str2.replace(hyphenateRE, "-$1").toLowerCase();
        });
        function polyfillBind(fn, ctx) {
          function boundFn(a) {
            var l = arguments.length;
            return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
          }
          boundFn._length = fn.length;
          return boundFn;
        }
        function nativeBind(fn, ctx) {
          return fn.bind(ctx);
        }
        var bind = Function.prototype.bind ? nativeBind : polyfillBind;
        function toArray(list, start) {
          start = start || 0;
          var i = list.length - start;
          var ret = new Array(i);
          while (i--) {
            ret[i] = list[i + start];
          }
          return ret;
        }
        function extend(to, _from) {
          for (var key in _from) {
            to[key] = _from[key];
          }
          return to;
        }
        function toObject(arr) {
          var res = {};
          for (var i = 0; i < arr.length; i++) {
            if (arr[i]) {
              extend(res, arr[i]);
            }
          }
          return res;
        }
        function noop(a, b, c) {
        }
        var no = function(a, b, c) {
          return false;
        };
        var identity = function(_) {
          return _;
        };
        function genStaticKeys(modules2) {
          return modules2.reduce(function(keys, m) {
            return keys.concat(m.staticKeys || []);
          }, []).join(",");
        }
        function looseEqual(a, b) {
          if (a === b) {
            return true;
          }
          var isObjectA = isObject2(a);
          var isObjectB = isObject2(b);
          if (isObjectA && isObjectB) {
            try {
              var isArrayA = Array.isArray(a);
              var isArrayB = Array.isArray(b);
              if (isArrayA && isArrayB) {
                return a.length === b.length && a.every(function(e, i) {
                  return looseEqual(e, b[i]);
                });
              } else if (a instanceof Date && b instanceof Date) {
                return a.getTime() === b.getTime();
              } else if (!isArrayA && !isArrayB) {
                var keysA = Object.keys(a);
                var keysB = Object.keys(b);
                return keysA.length === keysB.length && keysA.every(function(key) {
                  return looseEqual(a[key], b[key]);
                });
              } else {
                return false;
              }
            } catch (e) {
              return false;
            }
          } else if (!isObjectA && !isObjectB) {
            return String(a) === String(b);
          } else {
            return false;
          }
        }
        function looseIndexOf(arr, val) {
          for (var i = 0; i < arr.length; i++) {
            if (looseEqual(arr[i], val)) {
              return i;
            }
          }
          return -1;
        }
        function once(fn) {
          var called = false;
          return function() {
            if (!called) {
              called = true;
              fn.apply(this, arguments);
            }
          };
        }
        var SSR_ATTR = "data-server-rendered";
        var ASSET_TYPES = [
          "component",
          "directive",
          "filter"
        ];
        var LIFECYCLE_HOOKS = [
          "beforeCreate",
          "created",
          "beforeMount",
          "mounted",
          "beforeUpdate",
          "updated",
          "beforeDestroy",
          "destroyed",
          "activated",
          "deactivated",
          "errorCaptured",
          "serverPrefetch"
        ];
        var config = {
          optionMergeStrategies: /* @__PURE__ */ Object.create(null),
          silent: false,
          productionTip: true,
          devtools: true,
          performance: false,
          errorHandler: null,
          warnHandler: null,
          ignoredElements: [],
          keyCodes: /* @__PURE__ */ Object.create(null),
          isReservedTag: no,
          isReservedAttr: no,
          isUnknownElement: no,
          getTagNamespace: noop,
          parsePlatformTagName: identity,
          mustUseProp: no,
          async: true,
          _lifecycleHooks: LIFECYCLE_HOOKS
        };
        var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
        function isReserved(str2) {
          var c = (str2 + "").charCodeAt(0);
          return c === 36 || c === 95;
        }
        function def2(obj, key, val, enumerable) {
          Object.defineProperty(obj, key, {
            value: val,
            enumerable: !!enumerable,
            writable: true,
            configurable: true
          });
        }
        var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");
        function parsePath(path) {
          if (bailRE.test(path)) {
            return;
          }
          var segments = path.split(".");
          return function(obj) {
            for (var i = 0; i < segments.length; i++) {
              if (!obj) {
                return;
              }
              obj = obj[segments[i]];
            }
            return obj;
          };
        }
        var hasProto = "__proto__" in {};
        var inBrowser = typeof window !== "undefined";
        var inWeex = typeof WXEnvironment !== "undefined" && !!WXEnvironment.platform;
        var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
        var UA = inBrowser && window.navigator.userAgent.toLowerCase();
        var isIE = UA && /msie|trident/.test(UA);
        var isIE9 = UA && UA.indexOf("msie 9.0") > 0;
        var isEdge = UA && UA.indexOf("edge/") > 0;
        var isAndroid = UA && UA.indexOf("android") > 0 || weexPlatform === "android";
        var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === "ios";
        var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
        var isPhantomJS = UA && /phantomjs/.test(UA);
        var isFF = UA && UA.match(/firefox\/(\d+)/);
        var nativeWatch = {}.watch;
        var supportsPassive = false;
        if (inBrowser) {
          try {
            var opts = {};
            Object.defineProperty(opts, "passive", {
              get: function get2() {
                supportsPassive = true;
              }
            });
            window.addEventListener("test-passive", null, opts);
          } catch (e) {
          }
        }
        var _isServer;
        var isServerRendering = function() {
          if (_isServer === void 0) {
            if (!inBrowser && !inWeex && typeof global !== "undefined") {
              _isServer = global["process"] && global["process"].env.VUE_ENV === "server";
            } else {
              _isServer = false;
            }
          }
          return _isServer;
        };
        var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
        function isNative2(Ctor) {
          return typeof Ctor === "function" && /native code/.test(Ctor.toString());
        }
        var hasSymbol2 = typeof Symbol !== "undefined" && isNative2(Symbol) && typeof Reflect !== "undefined" && isNative2(Reflect.ownKeys);
        var _Set;
        if (typeof Set !== "undefined" && isNative2(Set)) {
          _Set = Set;
        } else {
          _Set = /* @__PURE__ */ function() {
            function Set2() {
              this.set = /* @__PURE__ */ Object.create(null);
            }
            Set2.prototype.has = function has2(key) {
              return this.set[key] === true;
            };
            Set2.prototype.add = function add2(key) {
              this.set[key] = true;
            };
            Set2.prototype.clear = function clear() {
              this.set = /* @__PURE__ */ Object.create(null);
            };
            return Set2;
          }();
        }
        var warn2 = noop;
        var tip = noop;
        var generateComponentTrace = noop;
        var formatComponentName = noop;
        {
          var hasConsole = typeof console !== "undefined";
          var classifyRE = /(?:^|[-_])(\w)/g;
          var classify = function(str2) {
            return str2.replace(classifyRE, function(c) {
              return c.toUpperCase();
            }).replace(/[-_]/g, "");
          };
          warn2 = function(msg, vm) {
            var trace = vm ? generateComponentTrace(vm) : "";
            if (config.warnHandler) {
              config.warnHandler.call(null, msg, vm, trace);
            } else if (hasConsole && !config.silent) {
              console.error("[Vue warn]: " + msg + trace);
            }
          };
          tip = function(msg, vm) {
            if (hasConsole && !config.silent) {
              console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ""));
            }
          };
          formatComponentName = function(vm, includeFile) {
            if (vm.$root === vm) {
              return "<Root>";
            }
            var options = typeof vm === "function" && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
            var name = options.name || options._componentTag;
            var file = options.__file;
            if (!name && file) {
              var match = file.match(/([^/\\]+)\.vue$/);
              name = match && match[1];
            }
            return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : "");
          };
          var repeat = function(str2, n) {
            var res = "";
            while (n) {
              if (n % 2 === 1) {
                res += str2;
              }
              if (n > 1) {
                str2 += str2;
              }
              n >>= 1;
            }
            return res;
          };
          generateComponentTrace = function(vm) {
            if (vm._isVue && vm.$parent) {
              var tree = [];
              var currentRecursiveSequence = 0;
              while (vm) {
                if (tree.length > 0) {
                  var last = tree[tree.length - 1];
                  if (last.constructor === vm.constructor) {
                    currentRecursiveSequence++;
                    vm = vm.$parent;
                    continue;
                  } else if (currentRecursiveSequence > 0) {
                    tree[tree.length - 1] = [last, currentRecursiveSequence];
                    currentRecursiveSequence = 0;
                  }
                }
                tree.push(vm);
                vm = vm.$parent;
              }
              return "\n\nfound in\n\n" + tree.map(function(vm2, i) {
                return "" + (i === 0 ? "---> " : repeat(" ", 5 + i * 2)) + (Array.isArray(vm2) ? formatComponentName(vm2[0]) + "... (" + vm2[1] + " recursive calls)" : formatComponentName(vm2));
              }).join("\n");
            } else {
              return "\n\n(found in " + formatComponentName(vm) + ")";
            }
          };
        }
        var uid = 0;
        var Dep = function Dep2() {
          this.id = uid++;
          this.subs = [];
        };
        Dep.prototype.addSub = function addSub(sub) {
          this.subs.push(sub);
        };
        Dep.prototype.removeSub = function removeSub(sub) {
          remove(this.subs, sub);
        };
        Dep.prototype.depend = function depend() {
          if (Dep.target) {
            Dep.target.addDep(this);
          }
        };
        Dep.prototype.notify = function notify() {
          var subs = this.subs.slice();
          if (!config.async) {
            subs.sort(function(a, b) {
              return a.id - b.id;
            });
          }
          for (var i = 0, l = subs.length; i < l; i++) {
            subs[i].update();
          }
        };
        Dep.target = null;
        var targetStack = [];
        function pushTarget(target2) {
          targetStack.push(target2);
          Dep.target = target2;
        }
        function popTarget() {
          targetStack.pop();
          Dep.target = targetStack[targetStack.length - 1];
        }
        var VNode = function VNode2(tag, data2, children, text2, elm, context, componentOptions, asyncFactory) {
          this.tag = tag;
          this.data = data2;
          this.children = children;
          this.text = text2;
          this.elm = elm;
          this.ns = void 0;
          this.context = context;
          this.fnContext = void 0;
          this.fnOptions = void 0;
          this.fnScopeId = void 0;
          this.key = data2 && data2.key;
          this.componentOptions = componentOptions;
          this.componentInstance = void 0;
          this.parent = void 0;
          this.raw = false;
          this.isStatic = false;
          this.isRootInsert = true;
          this.isComment = false;
          this.isCloned = false;
          this.isOnce = false;
          this.asyncFactory = asyncFactory;
          this.asyncMeta = void 0;
          this.isAsyncPlaceholder = false;
        };
        var prototypeAccessors = { child: { configurable: true } };
        prototypeAccessors.child.get = function() {
          return this.componentInstance;
        };
        Object.defineProperties(VNode.prototype, prototypeAccessors);
        var createEmptyVNode = function(text2) {
          if (text2 === void 0)
            text2 = "";
          var node = new VNode();
          node.text = text2;
          node.isComment = true;
          return node;
        };
        function createTextVNode(val) {
          return new VNode(void 0, void 0, void 0, String(val));
        }
        function cloneVNode(vnode) {
          var cloned = new VNode(vnode.tag, vnode.data, vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
          cloned.ns = vnode.ns;
          cloned.isStatic = vnode.isStatic;
          cloned.key = vnode.key;
          cloned.isComment = vnode.isComment;
          cloned.fnContext = vnode.fnContext;
          cloned.fnOptions = vnode.fnOptions;
          cloned.fnScopeId = vnode.fnScopeId;
          cloned.asyncMeta = vnode.asyncMeta;
          cloned.isCloned = true;
          return cloned;
        }
        var arrayProto = Array.prototype;
        var arrayMethods = Object.create(arrayProto);
        var methodsToPatch = [
          "push",
          "pop",
          "shift",
          "unshift",
          "splice",
          "sort",
          "reverse"
        ];
        methodsToPatch.forEach(function(method) {
          var original = arrayProto[method];
          def2(arrayMethods, method, function mutator() {
            var args = [], len2 = arguments.length;
            while (len2--)
              args[len2] = arguments[len2];
            var result = original.apply(this, args);
            var ob = this.__ob__;
            var inserted;
            switch (method) {
              case "push":
              case "unshift":
                inserted = args;
                break;
              case "splice":
                inserted = args.slice(2);
                break;
            }
            if (inserted) {
              ob.observeArray(inserted);
            }
            ob.dep.notify();
            return result;
          });
        });
        var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
        var shouldObserve = true;
        function toggleObserving(value) {
          shouldObserve = value;
        }
        var Observer = function Observer2(value) {
          this.value = value;
          this.dep = new Dep();
          this.vmCount = 0;
          def2(value, "__ob__", this);
          if (Array.isArray(value)) {
            if (hasProto) {
              protoAugment(value, arrayMethods);
            } else {
              copyAugment(value, arrayMethods, arrayKeys);
            }
            this.observeArray(value);
          } else {
            this.walk(value);
          }
        };
        Observer.prototype.walk = function walk(obj) {
          var keys = Object.keys(obj);
          for (var i = 0; i < keys.length; i++) {
            defineReactive$$1(obj, keys[i]);
          }
        };
        Observer.prototype.observeArray = function observeArray(items) {
          for (var i = 0, l = items.length; i < l; i++) {
            observe2(items[i]);
          }
        };
        function protoAugment(target2, src) {
          target2.__proto__ = src;
        }
        function copyAugment(target2, src, keys) {
          for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            def2(target2, key, src[key]);
          }
        }
        function observe2(value, asRootData) {
          if (!isObject2(value) || value instanceof VNode) {
            return;
          }
          var ob;
          if (hasOwn2(value, "__ob__") && value.__ob__ instanceof Observer) {
            ob = value.__ob__;
          } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject2(value)) && Object.isExtensible(value) && !value._isVue) {
            ob = new Observer(value);
          }
          if (asRootData && ob) {
            ob.vmCount++;
          }
          return ob;
        }
        function defineReactive$$1(obj, key, val, customSetter, shallow) {
          var dep = new Dep();
          var property = Object.getOwnPropertyDescriptor(obj, key);
          if (property && property.configurable === false) {
            return;
          }
          var getter = property && property.get;
          var setter = property && property.set;
          if ((!getter || setter) && arguments.length === 2) {
            val = obj[key];
          }
          var childOb = !shallow && observe2(val);
          Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: true,
            get: function reactiveGetter() {
              var value = getter ? getter.call(obj) : val;
              if (Dep.target) {
                dep.depend();
                if (childOb) {
                  childOb.dep.depend();
                  if (Array.isArray(value)) {
                    dependArray(value);
                  }
                }
              }
              return value;
            },
            set: function reactiveSetter(newVal) {
              var value = getter ? getter.call(obj) : val;
              if (newVal === value || newVal !== newVal && value !== value) {
                return;
              }
              if (customSetter) {
                customSetter();
              }
              if (getter && !setter) {
                return;
              }
              if (setter) {
                setter.call(obj, newVal);
              } else {
                val = newVal;
              }
              childOb = !shallow && observe2(newVal);
              dep.notify();
            }
          });
        }
        function set3(target2, key, val) {
          if (isUndef2(target2) || isPrimitive2(target2)) {
            warn2("Cannot set reactive property on undefined, null, or primitive value: " + target2);
          }
          if (Array.isArray(target2) && isValidArrayIndex2(key)) {
            target2.length = Math.max(target2.length, key);
            target2.splice(key, 1, val);
            return val;
          }
          if (key in target2 && !(key in Object.prototype)) {
            target2[key] = val;
            return val;
          }
          var ob = target2.__ob__;
          if (target2._isVue || ob && ob.vmCount) {
            warn2("Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.");
            return val;
          }
          if (!ob) {
            target2[key] = val;
            return val;
          }
          defineReactive$$1(ob.value, key, val);
          ob.dep.notify();
          return val;
        }
        function del2(target2, key) {
          if (isUndef2(target2) || isPrimitive2(target2)) {
            warn2("Cannot delete reactive property on undefined, null, or primitive value: " + target2);
          }
          if (Array.isArray(target2) && isValidArrayIndex2(key)) {
            target2.splice(key, 1);
            return;
          }
          var ob = target2.__ob__;
          if (target2._isVue || ob && ob.vmCount) {
            warn2("Avoid deleting properties on a Vue instance or its root $data - just set it to null.");
            return;
          }
          if (!hasOwn2(target2, key)) {
            return;
          }
          delete target2[key];
          if (!ob) {
            return;
          }
          ob.dep.notify();
        }
        function dependArray(value) {
          for (var e = void 0, i = 0, l = value.length; i < l; i++) {
            e = value[i];
            e && e.__ob__ && e.__ob__.dep.depend();
            if (Array.isArray(e)) {
              dependArray(e);
            }
          }
        }
        var strats = config.optionMergeStrategies;
        {
          strats.el = strats.propsData = function(parent, child, vm, key) {
            if (!vm) {
              warn2('option "' + key + '" can only be used during instance creation with the `new` keyword.');
            }
            return defaultStrat(parent, child);
          };
        }
        function mergeData2(to, from) {
          if (!from) {
            return to;
          }
          var key, toVal, fromVal;
          var keys = hasSymbol2 ? Reflect.ownKeys(from) : Object.keys(from);
          for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            if (key === "__ob__") {
              continue;
            }
            toVal = to[key];
            fromVal = from[key];
            if (!hasOwn2(to, key)) {
              set3(to, key, fromVal);
            } else if (toVal !== fromVal && isPlainObject2(toVal) && isPlainObject2(fromVal)) {
              mergeData2(toVal, fromVal);
            }
          }
          return to;
        }
        function mergeDataOrFn(parentVal, childVal, vm) {
          if (!vm) {
            if (!childVal) {
              return parentVal;
            }
            if (!parentVal) {
              return childVal;
            }
            return function mergedDataFn() {
              return mergeData2(typeof childVal === "function" ? childVal.call(this, this) : childVal, typeof parentVal === "function" ? parentVal.call(this, this) : parentVal);
            };
          } else {
            return function mergedInstanceDataFn() {
              var instanceData = typeof childVal === "function" ? childVal.call(vm, vm) : childVal;
              var defaultData = typeof parentVal === "function" ? parentVal.call(vm, vm) : parentVal;
              if (instanceData) {
                return mergeData2(instanceData, defaultData);
              } else {
                return defaultData;
              }
            };
          }
        }
        strats.data = function(parentVal, childVal, vm) {
          if (!vm) {
            if (childVal && typeof childVal !== "function") {
              warn2('The "data" option should be a function that returns a per-instance value in component definitions.', vm);
              return parentVal;
            }
            return mergeDataOrFn(parentVal, childVal);
          }
          return mergeDataOrFn(parentVal, childVal, vm);
        };
        function mergeHook(parentVal, childVal) {
          var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
          return res ? dedupeHooks(res) : res;
        }
        function dedupeHooks(hooks2) {
          var res = [];
          for (var i = 0; i < hooks2.length; i++) {
            if (res.indexOf(hooks2[i]) === -1) {
              res.push(hooks2[i]);
            }
          }
          return res;
        }
        LIFECYCLE_HOOKS.forEach(function(hook) {
          strats[hook] = mergeHook;
        });
        function mergeAssets(parentVal, childVal, vm, key) {
          var res = Object.create(parentVal || null);
          if (childVal) {
            assertObjectType(key, childVal, vm);
            return extend(res, childVal);
          } else {
            return res;
          }
        }
        ASSET_TYPES.forEach(function(type) {
          strats[type + "s"] = mergeAssets;
        });
        strats.watch = function(parentVal, childVal, vm, key) {
          if (parentVal === nativeWatch) {
            parentVal = void 0;
          }
          if (childVal === nativeWatch) {
            childVal = void 0;
          }
          if (!childVal) {
            return Object.create(parentVal || null);
          }
          {
            assertObjectType(key, childVal, vm);
          }
          if (!parentVal) {
            return childVal;
          }
          var ret = {};
          extend(ret, parentVal);
          for (var key$1 in childVal) {
            var parent = ret[key$1];
            var child = childVal[key$1];
            if (parent && !Array.isArray(parent)) {
              parent = [parent];
            }
            ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
          }
          return ret;
        };
        strats.props = strats.methods = strats.inject = strats.computed = function(parentVal, childVal, vm, key) {
          if (childVal && true) {
            assertObjectType(key, childVal, vm);
          }
          if (!parentVal) {
            return childVal;
          }
          var ret = /* @__PURE__ */ Object.create(null);
          extend(ret, parentVal);
          if (childVal) {
            extend(ret, childVal);
          }
          return ret;
        };
        strats.provide = mergeDataOrFn;
        var defaultStrat = function(parentVal, childVal) {
          return childVal === void 0 ? parentVal : childVal;
        };
        function checkComponents(options) {
          for (var key in options.components) {
            validateComponentName(key);
          }
        }
        function validateComponentName(name) {
          if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
            warn2('Invalid component name: "' + name + '". Component names should conform to valid custom element name in html5 specification.');
          }
          if (isBuiltInTag(name) || config.isReservedTag(name)) {
            warn2("Do not use built-in or reserved HTML elements as component id: " + name);
          }
        }
        function normalizeProps(options, vm) {
          var props3 = options.props;
          if (!props3) {
            return;
          }
          var res = {};
          var i, val, name;
          if (Array.isArray(props3)) {
            i = props3.length;
            while (i--) {
              val = props3[i];
              if (typeof val === "string") {
                name = camelize(val);
                res[name] = { type: null };
              } else {
                warn2("props must be strings when using array syntax.");
              }
            }
          } else if (isPlainObject2(props3)) {
            for (var key in props3) {
              val = props3[key];
              name = camelize(key);
              res[name] = isPlainObject2(val) ? val : { type: val };
            }
          } else {
            warn2('Invalid value for option "props": expected an Array or an Object, but got ' + toRawType(props3) + ".", vm);
          }
          options.props = res;
        }
        function normalizeInject(options, vm) {
          var inject2 = options.inject;
          if (!inject2) {
            return;
          }
          var normalized = options.inject = {};
          if (Array.isArray(inject2)) {
            for (var i = 0; i < inject2.length; i++) {
              normalized[inject2[i]] = { from: inject2[i] };
            }
          } else if (isPlainObject2(inject2)) {
            for (var key in inject2) {
              var val = inject2[key];
              normalized[key] = isPlainObject2(val) ? extend({ from: key }, val) : { from: val };
            }
          } else {
            warn2('Invalid value for option "inject": expected an Array or an Object, but got ' + toRawType(inject2) + ".", vm);
          }
        }
        function normalizeDirectives(options) {
          var dirs = options.directives;
          if (dirs) {
            for (var key in dirs) {
              var def$$1 = dirs[key];
              if (typeof def$$1 === "function") {
                dirs[key] = { bind: def$$1, update: def$$1 };
              }
            }
          }
        }
        function assertObjectType(name, value, vm) {
          if (!isPlainObject2(value)) {
            warn2('Invalid value for option "' + name + '": expected an Object, but got ' + toRawType(value) + ".", vm);
          }
        }
        function mergeOptions(parent, child, vm) {
          {
            checkComponents(child);
          }
          if (typeof child === "function") {
            child = child.options;
          }
          normalizeProps(child, vm);
          normalizeInject(child, vm);
          normalizeDirectives(child);
          if (!child._base) {
            if (child.extends) {
              parent = mergeOptions(parent, child.extends, vm);
            }
            if (child.mixins) {
              for (var i = 0, l = child.mixins.length; i < l; i++) {
                parent = mergeOptions(parent, child.mixins[i], vm);
              }
            }
          }
          var options = {};
          var key;
          for (key in parent) {
            mergeField(key);
          }
          for (key in child) {
            if (!hasOwn2(parent, key)) {
              mergeField(key);
            }
          }
          function mergeField(key2) {
            var strat = strats[key2] || defaultStrat;
            options[key2] = strat(parent[key2], child[key2], vm, key2);
          }
          return options;
        }
        function resolveAsset(options, type, id, warnMissing) {
          if (typeof id !== "string") {
            return;
          }
          var assets = options[type];
          if (hasOwn2(assets, id)) {
            return assets[id];
          }
          var camelizedId = camelize(id);
          if (hasOwn2(assets, camelizedId)) {
            return assets[camelizedId];
          }
          var PascalCaseId = capitalize(camelizedId);
          if (hasOwn2(assets, PascalCaseId)) {
            return assets[PascalCaseId];
          }
          var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
          if (warnMissing && !res) {
            warn2("Failed to resolve " + type.slice(0, -1) + ": " + id, options);
          }
          return res;
        }
        function validateProp(key, propOptions, propsData, vm) {
          var prop = propOptions[key];
          var absent = !hasOwn2(propsData, key);
          var value = propsData[key];
          var booleanIndex = getTypeIndex(Boolean, prop.type);
          if (booleanIndex > -1) {
            if (absent && !hasOwn2(prop, "default")) {
              value = false;
            } else if (value === "" || value === hyphenate(key)) {
              var stringIndex = getTypeIndex(String, prop.type);
              if (stringIndex < 0 || booleanIndex < stringIndex) {
                value = true;
              }
            }
          }
          if (value === void 0) {
            value = getPropDefaultValue(vm, prop, key);
            var prevShouldObserve = shouldObserve;
            toggleObserving(true);
            observe2(value);
            toggleObserving(prevShouldObserve);
          }
          {
            assertProp(prop, key, value, vm, absent);
          }
          return value;
        }
        function getPropDefaultValue(vm, prop, key) {
          if (!hasOwn2(prop, "default")) {
            return void 0;
          }
          var def3 = prop.default;
          if (isObject2(def3)) {
            warn2('Invalid default value for prop "' + key + '": Props with type Object/Array must use a factory function to return the default value.', vm);
          }
          if (vm && vm.$options.propsData && vm.$options.propsData[key] === void 0 && vm._props[key] !== void 0) {
            return vm._props[key];
          }
          return typeof def3 === "function" && getType(prop.type) !== "Function" ? def3.call(vm) : def3;
        }
        function assertProp(prop, name, value, vm, absent) {
          if (prop.required && absent) {
            warn2('Missing required prop: "' + name + '"', vm);
            return;
          }
          if (value == null && !prop.required) {
            return;
          }
          var type = prop.type;
          var valid = !type || type === true;
          var expectedTypes = [];
          if (type) {
            if (!Array.isArray(type)) {
              type = [type];
            }
            for (var i = 0; i < type.length && !valid; i++) {
              var assertedType = assertType(value, type[i], vm);
              expectedTypes.push(assertedType.expectedType || "");
              valid = assertedType.valid;
            }
          }
          var haveExpectedTypes = expectedTypes.some(function(t) {
            return t;
          });
          if (!valid && haveExpectedTypes) {
            warn2(getInvalidTypeMessage(name, value, expectedTypes), vm);
            return;
          }
          var validator2 = prop.validator;
          if (validator2) {
            if (!validator2(value)) {
              warn2('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
            }
          }
        }
        var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
        function assertType(value, type, vm) {
          var valid;
          var expectedType = getType(type);
          if (simpleCheckRE.test(expectedType)) {
            var t = typeof value;
            valid = t === expectedType.toLowerCase();
            if (!valid && t === "object") {
              valid = value instanceof type;
            }
          } else if (expectedType === "Object") {
            valid = isPlainObject2(value);
          } else if (expectedType === "Array") {
            valid = Array.isArray(value);
          } else {
            try {
              valid = value instanceof type;
            } catch (e) {
              warn2('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
              valid = false;
            }
          }
          return {
            valid,
            expectedType
          };
        }
        var functionTypeCheckRE = /^\s*function (\w+)/;
        function getType(fn) {
          var match = fn && fn.toString().match(functionTypeCheckRE);
          return match ? match[1] : "";
        }
        function isSameType(a, b) {
          return getType(a) === getType(b);
        }
        function getTypeIndex(type, expectedTypes) {
          if (!Array.isArray(expectedTypes)) {
            return isSameType(expectedTypes, type) ? 0 : -1;
          }
          for (var i = 0, len2 = expectedTypes.length; i < len2; i++) {
            if (isSameType(expectedTypes[i], type)) {
              return i;
            }
          }
          return -1;
        }
        function getInvalidTypeMessage(name, value, expectedTypes) {
          var message = 'Invalid prop: type check failed for prop "' + name + '". Expected ' + expectedTypes.map(capitalize).join(", ");
          var expectedType = expectedTypes[0];
          var receivedType = toRawType(value);
          if (expectedTypes.length === 1 && isExplicable(expectedType) && isExplicable(typeof value) && !isBoolean(expectedType, receivedType)) {
            message += " with value " + styleValue(value, expectedType);
          }
          message += ", got " + receivedType + " ";
          if (isExplicable(receivedType)) {
            message += "with value " + styleValue(value, receivedType) + ".";
          }
          return message;
        }
        function styleValue(value, type) {
          if (type === "String") {
            return '"' + value + '"';
          } else if (type === "Number") {
            return "" + Number(value);
          } else {
            return "" + value;
          }
        }
        var EXPLICABLE_TYPES = ["string", "number", "boolean"];
        function isExplicable(value) {
          return EXPLICABLE_TYPES.some(function(elem) {
            return value.toLowerCase() === elem;
          });
        }
        function isBoolean() {
          var args = [], len2 = arguments.length;
          while (len2--)
            args[len2] = arguments[len2];
          return args.some(function(elem) {
            return elem.toLowerCase() === "boolean";
          });
        }
        function handleError(err, vm, info) {
          pushTarget();
          try {
            if (vm) {
              var cur = vm;
              while (cur = cur.$parent) {
                var hooks2 = cur.$options.errorCaptured;
                if (hooks2) {
                  for (var i = 0; i < hooks2.length; i++) {
                    try {
                      var capture = hooks2[i].call(cur, err, vm, info) === false;
                      if (capture) {
                        return;
                      }
                    } catch (e) {
                      globalHandleError(e, cur, "errorCaptured hook");
                    }
                  }
                }
              }
            }
            globalHandleError(err, vm, info);
          } finally {
            popTarget();
          }
        }
        function invokeWithErrorHandling(handler2, context, args, vm, info) {
          var res;
          try {
            res = args ? handler2.apply(context, args) : handler2.call(context);
            if (res && !res._isVue && isPromise(res) && !res._handled) {
              res.catch(function(e) {
                return handleError(e, vm, info + " (Promise/async)");
              });
              res._handled = true;
            }
          } catch (e) {
            handleError(e, vm, info);
          }
          return res;
        }
        function globalHandleError(err, vm, info) {
          if (config.errorHandler) {
            try {
              return config.errorHandler.call(null, err, vm, info);
            } catch (e) {
              if (e !== err) {
                logError2(e, null, "config.errorHandler");
              }
            }
          }
          logError2(err, vm, info);
        }
        function logError2(err, vm, info) {
          {
            warn2("Error in " + info + ': "' + err.toString() + '"', vm);
          }
          if ((inBrowser || inWeex) && typeof console !== "undefined") {
            console.error(err);
          } else {
            throw err;
          }
        }
        var isUsingMicroTask = false;
        var callbacks = [];
        var pending = false;
        function flushCallbacks() {
          pending = false;
          var copies = callbacks.slice(0);
          callbacks.length = 0;
          for (var i = 0; i < copies.length; i++) {
            copies[i]();
          }
        }
        var timerFunc;
        if (typeof Promise !== "undefined" && isNative2(Promise)) {
          var p = Promise.resolve();
          timerFunc = function() {
            p.then(flushCallbacks);
            if (isIOS) {
              setTimeout(noop);
            }
          };
          isUsingMicroTask = true;
        } else if (!isIE && typeof MutationObserver !== "undefined" && (isNative2(MutationObserver) || MutationObserver.toString() === "[object MutationObserverConstructor]")) {
          var counter = 1;
          var observer = new MutationObserver(flushCallbacks);
          var textNode = document.createTextNode(String(counter));
          observer.observe(textNode, {
            characterData: true
          });
          timerFunc = function() {
            counter = (counter + 1) % 2;
            textNode.data = String(counter);
          };
          isUsingMicroTask = true;
        } else if (typeof setImmediate !== "undefined" && isNative2(setImmediate)) {
          timerFunc = function() {
            setImmediate(flushCallbacks);
          };
        } else {
          timerFunc = function() {
            setTimeout(flushCallbacks, 0);
          };
        }
        function nextTick2(cb, ctx) {
          var _resolve;
          callbacks.push(function() {
            if (cb) {
              try {
                cb.call(ctx);
              } catch (e) {
                handleError(e, ctx, "nextTick");
              }
            } else if (_resolve) {
              _resolve(ctx);
            }
          });
          if (!pending) {
            pending = true;
            timerFunc();
          }
          if (!cb && typeof Promise !== "undefined") {
            return new Promise(function(resolve) {
              _resolve = resolve;
            });
          }
        }
        var mark;
        var measure;
        {
          var perf = inBrowser && window.performance;
          if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
            mark = function(tag) {
              return perf.mark(tag);
            };
            measure = function(name, startTag, endTag2) {
              perf.measure(name, startTag, endTag2);
              perf.clearMarks(startTag);
              perf.clearMarks(endTag2);
            };
          }
        }
        var initProxy;
        {
          var allowedGlobals = makeMap("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,require");
          var warnNonPresent = function(target2, key) {
            warn2('Property or method "' + key + '" is not defined on the instance but referenced during render. Make sure that this property is reactive, either in the data option, or for class-based components, by initializing the property. See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target2);
          };
          var warnReservedPrefix = function(target2, key) {
            warn2('Property "' + key + '" must be accessed with "$data.' + key + '" because properties starting with "$" or "_" are not proxied in the Vue instance to prevent conflicts with Vue internals. See: https://vuejs.org/v2/api/#data', target2);
          };
          var hasProxy = typeof Proxy !== "undefined" && isNative2(Proxy);
          if (hasProxy) {
            var isBuiltInModifier = makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact");
            config.keyCodes = new Proxy(config.keyCodes, {
              set: function set4(target2, key, value) {
                if (isBuiltInModifier(key)) {
                  warn2("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
                  return false;
                } else {
                  target2[key] = value;
                  return true;
                }
              }
            });
          }
          var hasHandler = {
            has: function has2(target2, key) {
              var has3 = key in target2;
              var isAllowed = allowedGlobals(key) || typeof key === "string" && key.charAt(0) === "_" && !(key in target2.$data);
              if (!has3 && !isAllowed) {
                if (key in target2.$data) {
                  warnReservedPrefix(target2, key);
                } else {
                  warnNonPresent(target2, key);
                }
              }
              return has3 || !isAllowed;
            }
          };
          var getHandler = {
            get: function get2(target2, key) {
              if (typeof key === "string" && !(key in target2)) {
                if (key in target2.$data) {
                  warnReservedPrefix(target2, key);
                } else {
                  warnNonPresent(target2, key);
                }
              }
              return target2[key];
            }
          };
          initProxy = function initProxy2(vm) {
            if (hasProxy) {
              var options = vm.$options;
              var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
              vm._renderProxy = new Proxy(vm, handlers);
            } else {
              vm._renderProxy = vm;
            }
          };
        }
        var seenObjects = new _Set();
        function traverse2(val) {
          _traverse(val, seenObjects);
          seenObjects.clear();
        }
        function _traverse(val, seen) {
          var i, keys;
          var isA = Array.isArray(val);
          if (!isA && !isObject2(val) || Object.isFrozen(val) || val instanceof VNode) {
            return;
          }
          if (val.__ob__) {
            var depId = val.__ob__.dep.id;
            if (seen.has(depId)) {
              return;
            }
            seen.add(depId);
          }
          if (isA) {
            i = val.length;
            while (i--) {
              _traverse(val[i], seen);
            }
          } else {
            keys = Object.keys(val);
            i = keys.length;
            while (i--) {
              _traverse(val[keys[i]], seen);
            }
          }
        }
        var normalizeEvent = cached(function(name) {
          var passive = name.charAt(0) === "&";
          name = passive ? name.slice(1) : name;
          var once$$1 = name.charAt(0) === "~";
          name = once$$1 ? name.slice(1) : name;
          var capture = name.charAt(0) === "!";
          name = capture ? name.slice(1) : name;
          return {
            name,
            once: once$$1,
            capture,
            passive
          };
        });
        function createFnInvoker(fns, vm) {
          function invoker() {
            var arguments$1 = arguments;
            var fns2 = invoker.fns;
            if (Array.isArray(fns2)) {
              var cloned = fns2.slice();
              for (var i = 0; i < cloned.length; i++) {
                invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
              }
            } else {
              return invokeWithErrorHandling(fns2, null, arguments, vm, "v-on handler");
            }
          }
          invoker.fns = fns;
          return invoker;
        }
        function updateListeners(on2, oldOn, add2, remove$$1, createOnceHandler2, vm) {
          var name, def$$1, cur, old, event;
          for (name in on2) {
            def$$1 = cur = on2[name];
            old = oldOn[name];
            event = normalizeEvent(name);
            if (isUndef2(cur)) {
              warn2('Invalid handler for event "' + event.name + '": got ' + String(cur), vm);
            } else if (isUndef2(old)) {
              if (isUndef2(cur.fns)) {
                cur = on2[name] = createFnInvoker(cur, vm);
              }
              if (isTrue(event.once)) {
                cur = on2[name] = createOnceHandler2(event.name, cur, event.capture);
              }
              add2(event.name, cur, event.capture, event.passive, event.params);
            } else if (cur !== old) {
              old.fns = cur;
              on2[name] = old;
            }
          }
          for (name in oldOn) {
            if (isUndef2(on2[name])) {
              event = normalizeEvent(name);
              remove$$1(event.name, oldOn[name], event.capture);
            }
          }
        }
        function mergeVNodeHook(def3, hookKey, hook) {
          if (def3 instanceof VNode) {
            def3 = def3.data.hook || (def3.data.hook = {});
          }
          var invoker;
          var oldHook = def3[hookKey];
          function wrappedHook() {
            hook.apply(this, arguments);
            remove(invoker.fns, wrappedHook);
          }
          if (isUndef2(oldHook)) {
            invoker = createFnInvoker([wrappedHook]);
          } else {
            if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
              invoker = oldHook;
              invoker.fns.push(wrappedHook);
            } else {
              invoker = createFnInvoker([oldHook, wrappedHook]);
            }
          }
          invoker.merged = true;
          def3[hookKey] = invoker;
        }
        function extractPropsFromVNodeData(data2, Ctor, tag) {
          var propOptions = Ctor.options.props;
          if (isUndef2(propOptions)) {
            return;
          }
          var res = {};
          var attrs2 = data2.attrs;
          var props3 = data2.props;
          if (isDef(attrs2) || isDef(props3)) {
            for (var key in propOptions) {
              var altKey = hyphenate(key);
              {
                var keyInLowerCase = key.toLowerCase();
                if (key !== keyInLowerCase && attrs2 && hasOwn2(attrs2, keyInLowerCase)) {
                  tip('Prop "' + keyInLowerCase + '" is passed to component ' + formatComponentName(tag || Ctor) + ', but the declared prop name is "' + key + '". Note that HTML attributes are case-insensitive and camelCased props need to use their kebab-case equivalents when using in-DOM templates. You should probably use "' + altKey + '" instead of "' + key + '".');
                }
              }
              checkProp(res, props3, key, altKey, true) || checkProp(res, attrs2, key, altKey, false);
            }
          }
          return res;
        }
        function checkProp(res, hash2, key, altKey, preserve) {
          if (isDef(hash2)) {
            if (hasOwn2(hash2, key)) {
              res[key] = hash2[key];
              if (!preserve) {
                delete hash2[key];
              }
              return true;
            } else if (hasOwn2(hash2, altKey)) {
              res[key] = hash2[altKey];
              if (!preserve) {
                delete hash2[altKey];
              }
              return true;
            }
          }
          return false;
        }
        function simpleNormalizeChildren(children) {
          for (var i = 0; i < children.length; i++) {
            if (Array.isArray(children[i])) {
              return Array.prototype.concat.apply([], children);
            }
          }
          return children;
        }
        function normalizeChildren(children) {
          return isPrimitive2(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : void 0;
        }
        function isTextNode(node) {
          return isDef(node) && isDef(node.text) && isFalse(node.isComment);
        }
        function normalizeArrayChildren(children, nestedIndex) {
          var res = [];
          var i, c, lastIndex, last;
          for (i = 0; i < children.length; i++) {
            c = children[i];
            if (isUndef2(c) || typeof c === "boolean") {
              continue;
            }
            lastIndex = res.length - 1;
            last = res[lastIndex];
            if (Array.isArray(c)) {
              if (c.length > 0) {
                c = normalizeArrayChildren(c, (nestedIndex || "") + "_" + i);
                if (isTextNode(c[0]) && isTextNode(last)) {
                  res[lastIndex] = createTextVNode(last.text + c[0].text);
                  c.shift();
                }
                res.push.apply(res, c);
              }
            } else if (isPrimitive2(c)) {
              if (isTextNode(last)) {
                res[lastIndex] = createTextVNode(last.text + c);
              } else if (c !== "") {
                res.push(createTextVNode(c));
              }
            } else {
              if (isTextNode(c) && isTextNode(last)) {
                res[lastIndex] = createTextVNode(last.text + c.text);
              } else {
                if (isTrue(children._isVList) && isDef(c.tag) && isUndef2(c.key) && isDef(nestedIndex)) {
                  c.key = "__vlist" + nestedIndex + "_" + i + "__";
                }
                res.push(c);
              }
            }
          }
          return res;
        }
        function initProvide(vm) {
          var provide2 = vm.$options.provide;
          if (provide2) {
            vm._provided = typeof provide2 === "function" ? provide2.call(vm) : provide2;
          }
        }
        function initInjections(vm) {
          var result = resolveInject(vm.$options.inject, vm);
          if (result) {
            toggleObserving(false);
            Object.keys(result).forEach(function(key) {
              {
                defineReactive$$1(vm, key, result[key], function() {
                  warn2('Avoid mutating an injected value directly since the changes will be overwritten whenever the provided component re-renders. injection being mutated: "' + key + '"', vm);
                });
              }
            });
            toggleObserving(true);
          }
        }
        function resolveInject(inject2, vm) {
          if (inject2) {
            var result = /* @__PURE__ */ Object.create(null);
            var keys = hasSymbol2 ? Reflect.ownKeys(inject2) : Object.keys(inject2);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key === "__ob__") {
                continue;
              }
              var provideKey = inject2[key].from;
              var source = vm;
              while (source) {
                if (source._provided && hasOwn2(source._provided, provideKey)) {
                  result[key] = source._provided[provideKey];
                  break;
                }
                source = source.$parent;
              }
              if (!source) {
                if ("default" in inject2[key]) {
                  var provideDefault = inject2[key].default;
                  result[key] = typeof provideDefault === "function" ? provideDefault.call(vm) : provideDefault;
                } else {
                  warn2('Injection "' + key + '" not found', vm);
                }
              }
            }
            return result;
          }
        }
        function resolveSlots2(children, context) {
          if (!children || !children.length) {
            return {};
          }
          var slots = {};
          for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i];
            var data2 = child.data;
            if (data2 && data2.attrs && data2.attrs.slot) {
              delete data2.attrs.slot;
            }
            if ((child.context === context || child.fnContext === context) && data2 && data2.slot != null) {
              var name = data2.slot;
              var slot = slots[name] || (slots[name] = []);
              if (child.tag === "template") {
                slot.push.apply(slot, child.children || []);
              } else {
                slot.push(child);
              }
            } else {
              (slots.default || (slots.default = [])).push(child);
            }
          }
          for (var name$1 in slots) {
            if (slots[name$1].every(isWhitespace)) {
              delete slots[name$1];
            }
          }
          return slots;
        }
        function isWhitespace(node) {
          return node.isComment && !node.asyncFactory || node.text === " ";
        }
        function isAsyncPlaceholder(node) {
          return node.isComment && node.asyncFactory;
        }
        function normalizeScopedSlots(slots, normalSlots, prevSlots) {
          var res;
          var hasNormalSlots = Object.keys(normalSlots).length > 0;
          var isStable = slots ? !!slots.$stable : !hasNormalSlots;
          var key = slots && slots.$key;
          if (!slots) {
            res = {};
          } else if (slots._normalized) {
            return slots._normalized;
          } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
            return prevSlots;
          } else {
            res = {};
            for (var key$1 in slots) {
              if (slots[key$1] && key$1[0] !== "$") {
                res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
              }
            }
          }
          for (var key$2 in normalSlots) {
            if (!(key$2 in res)) {
              res[key$2] = proxyNormalSlot(normalSlots, key$2);
            }
          }
          if (slots && Object.isExtensible(slots)) {
            slots._normalized = res;
          }
          def2(res, "$stable", isStable);
          def2(res, "$key", key);
          def2(res, "$hasNormal", hasNormalSlots);
          return res;
        }
        function normalizeScopedSlot(normalSlots, key, fn) {
          var normalized = function() {
            var res = arguments.length ? fn.apply(null, arguments) : fn({});
            res = res && typeof res === "object" && !Array.isArray(res) ? [res] : normalizeChildren(res);
            var vnode = res && res[0];
            return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) ? void 0 : res;
          };
          if (fn.proxy) {
            Object.defineProperty(normalSlots, key, {
              get: normalized,
              enumerable: true,
              configurable: true
            });
          }
          return normalized;
        }
        function proxyNormalSlot(slots, key) {
          return function() {
            return slots[key];
          };
        }
        function renderList(val, render2) {
          var ret, i, l, keys, key;
          if (Array.isArray(val) || typeof val === "string") {
            ret = new Array(val.length);
            for (i = 0, l = val.length; i < l; i++) {
              ret[i] = render2(val[i], i);
            }
          } else if (typeof val === "number") {
            ret = new Array(val);
            for (i = 0; i < val; i++) {
              ret[i] = render2(i + 1, i);
            }
          } else if (isObject2(val)) {
            if (hasSymbol2 && val[Symbol.iterator]) {
              ret = [];
              var iterator = val[Symbol.iterator]();
              var result = iterator.next();
              while (!result.done) {
                ret.push(render2(result.value, ret.length));
                result = iterator.next();
              }
            } else {
              keys = Object.keys(val);
              ret = new Array(keys.length);
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                ret[i] = render2(val[key], key, i);
              }
            }
          }
          if (!isDef(ret)) {
            ret = [];
          }
          ret._isVList = true;
          return ret;
        }
        function renderSlot(name, fallbackRender, props3, bindObject) {
          var scopedSlotFn = this.$scopedSlots[name];
          var nodes;
          if (scopedSlotFn) {
            props3 = props3 || {};
            if (bindObject) {
              if (!isObject2(bindObject)) {
                warn2("slot v-bind without argument expects an Object", this);
              }
              props3 = extend(extend({}, bindObject), props3);
            }
            nodes = scopedSlotFn(props3) || (typeof fallbackRender === "function" ? fallbackRender() : fallbackRender);
          } else {
            nodes = this.$slots[name] || (typeof fallbackRender === "function" ? fallbackRender() : fallbackRender);
          }
          var target2 = props3 && props3.slot;
          if (target2) {
            return this.$createElement("template", { slot: target2 }, nodes);
          } else {
            return nodes;
          }
        }
        function resolveFilter(id) {
          return resolveAsset(this.$options, "filters", id, true) || identity;
        }
        function isKeyNotMatch(expect, actual) {
          if (Array.isArray(expect)) {
            return expect.indexOf(actual) === -1;
          } else {
            return expect !== actual;
          }
        }
        function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
          var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
          if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
            return isKeyNotMatch(builtInKeyName, eventKeyName);
          } else if (mappedKeyCode) {
            return isKeyNotMatch(mappedKeyCode, eventKeyCode);
          } else if (eventKeyName) {
            return hyphenate(eventKeyName) !== key;
          }
          return eventKeyCode === void 0;
        }
        function bindObjectProps(data2, tag, value, asProp, isSync) {
          if (value) {
            if (!isObject2(value)) {
              warn2("v-bind without argument expects an Object or Array value", this);
            } else {
              if (Array.isArray(value)) {
                value = toObject(value);
              }
              var hash2;
              var loop = function(key2) {
                if (key2 === "class" || key2 === "style" || isReservedAttribute(key2)) {
                  hash2 = data2;
                } else {
                  var type = data2.attrs && data2.attrs.type;
                  hash2 = asProp || config.mustUseProp(tag, type, key2) ? data2.domProps || (data2.domProps = {}) : data2.attrs || (data2.attrs = {});
                }
                var camelizedKey = camelize(key2);
                var hyphenatedKey = hyphenate(key2);
                if (!(camelizedKey in hash2) && !(hyphenatedKey in hash2)) {
                  hash2[key2] = value[key2];
                  if (isSync) {
                    var on2 = data2.on || (data2.on = {});
                    on2["update:" + key2] = function($event) {
                      value[key2] = $event;
                    };
                  }
                }
              };
              for (var key in value)
                loop(key);
            }
          }
          return data2;
        }
        function renderStatic(index2, isInFor) {
          var cached2 = this._staticTrees || (this._staticTrees = []);
          var tree = cached2[index2];
          if (tree && !isInFor) {
            return tree;
          }
          tree = cached2[index2] = this.$options.staticRenderFns[index2].call(this._renderProxy, null, this);
          markStatic(tree, "__static__" + index2, false);
          return tree;
        }
        function markOnce(tree, index2, key) {
          markStatic(tree, "__once__" + index2 + (key ? "_" + key : ""), true);
          return tree;
        }
        function markStatic(tree, key, isOnce) {
          if (Array.isArray(tree)) {
            for (var i = 0; i < tree.length; i++) {
              if (tree[i] && typeof tree[i] !== "string") {
                markStaticNode(tree[i], key + "_" + i, isOnce);
              }
            }
          } else {
            markStaticNode(tree, key, isOnce);
          }
        }
        function markStaticNode(node, key, isOnce) {
          node.isStatic = true;
          node.key = key;
          node.isOnce = isOnce;
        }
        function bindObjectListeners(data2, value) {
          if (value) {
            if (!isPlainObject2(value)) {
              warn2("v-on without argument expects an Object value", this);
            } else {
              var on2 = data2.on = data2.on ? extend({}, data2.on) : {};
              for (var key in value) {
                var existing = on2[key];
                var ours = value[key];
                on2[key] = existing ? [].concat(existing, ours) : ours;
              }
            }
          }
          return data2;
        }
        function resolveScopedSlots2(fns, res, hasDynamicKeys, contentHashKey) {
          res = res || { $stable: !hasDynamicKeys };
          for (var i = 0; i < fns.length; i++) {
            var slot = fns[i];
            if (Array.isArray(slot)) {
              resolveScopedSlots2(slot, res, hasDynamicKeys);
            } else if (slot) {
              if (slot.proxy) {
                slot.fn.proxy = true;
              }
              res[slot.key] = slot.fn;
            }
          }
          if (contentHashKey) {
            res.$key = contentHashKey;
          }
          return res;
        }
        function bindDynamicKeys(baseObj, values) {
          for (var i = 0; i < values.length; i += 2) {
            var key = values[i];
            if (typeof key === "string" && key) {
              baseObj[values[i]] = values[i + 1];
            } else if (key !== "" && key !== null) {
              warn2("Invalid value for dynamic directive argument (expected string or null): " + key, this);
            }
          }
          return baseObj;
        }
        function prependModifier(value, symbol) {
          return typeof value === "string" ? symbol + value : value;
        }
        function installRenderHelpers(target2) {
          target2._o = markOnce;
          target2._n = toNumber;
          target2._s = toString2;
          target2._l = renderList;
          target2._t = renderSlot;
          target2._q = looseEqual;
          target2._i = looseIndexOf;
          target2._m = renderStatic;
          target2._f = resolveFilter;
          target2._k = checkKeyCodes;
          target2._b = bindObjectProps;
          target2._v = createTextVNode;
          target2._e = createEmptyVNode;
          target2._u = resolveScopedSlots2;
          target2._g = bindObjectListeners;
          target2._d = bindDynamicKeys;
          target2._p = prependModifier;
        }
        function FunctionalRenderContext(data2, props3, children, parent, Ctor) {
          var this$1 = this;
          var options = Ctor.options;
          var contextVm;
          if (hasOwn2(parent, "_uid")) {
            contextVm = Object.create(parent);
            contextVm._original = parent;
          } else {
            contextVm = parent;
            parent = parent._original;
          }
          var isCompiled = isTrue(options._compiled);
          var needNormalization = !isCompiled;
          this.data = data2;
          this.props = props3;
          this.children = children;
          this.parent = parent;
          this.listeners = data2.on || emptyObject;
          this.injections = resolveInject(options.inject, parent);
          this.slots = function() {
            if (!this$1.$slots) {
              normalizeScopedSlots(data2.scopedSlots, this$1.$slots = resolveSlots2(children, parent));
            }
            return this$1.$slots;
          };
          Object.defineProperty(this, "scopedSlots", {
            enumerable: true,
            get: function get2() {
              return normalizeScopedSlots(data2.scopedSlots, this.slots());
            }
          });
          if (isCompiled) {
            this.$options = options;
            this.$slots = this.slots();
            this.$scopedSlots = normalizeScopedSlots(data2.scopedSlots, this.$slots);
          }
          if (options._scopeId) {
            this._c = function(a, b, c, d) {
              var vnode = createElement3(contextVm, a, b, c, d, needNormalization);
              if (vnode && !Array.isArray(vnode)) {
                vnode.fnScopeId = options._scopeId;
                vnode.fnContext = parent;
              }
              return vnode;
            };
          } else {
            this._c = function(a, b, c, d) {
              return createElement3(contextVm, a, b, c, d, needNormalization);
            };
          }
        }
        installRenderHelpers(FunctionalRenderContext.prototype);
        function createFunctionalComponent(Ctor, propsData, data2, contextVm, children) {
          var options = Ctor.options;
          var props3 = {};
          var propOptions = options.props;
          if (isDef(propOptions)) {
            for (var key in propOptions) {
              props3[key] = validateProp(key, propOptions, propsData || emptyObject);
            }
          } else {
            if (isDef(data2.attrs)) {
              mergeProps(props3, data2.attrs);
            }
            if (isDef(data2.props)) {
              mergeProps(props3, data2.props);
            }
          }
          var renderContext = new FunctionalRenderContext(data2, props3, children, contextVm, Ctor);
          var vnode = options.render.call(null, renderContext._c, renderContext);
          if (vnode instanceof VNode) {
            return cloneAndMarkFunctionalResult(vnode, data2, renderContext.parent, options, renderContext);
          } else if (Array.isArray(vnode)) {
            var vnodes = normalizeChildren(vnode) || [];
            var res = new Array(vnodes.length);
            for (var i = 0; i < vnodes.length; i++) {
              res[i] = cloneAndMarkFunctionalResult(vnodes[i], data2, renderContext.parent, options, renderContext);
            }
            return res;
          }
        }
        function cloneAndMarkFunctionalResult(vnode, data2, contextVm, options, renderContext) {
          var clone = cloneVNode(vnode);
          clone.fnContext = contextVm;
          clone.fnOptions = options;
          {
            (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
          }
          if (data2.slot) {
            (clone.data || (clone.data = {})).slot = data2.slot;
          }
          return clone;
        }
        function mergeProps(to, from) {
          for (var key in from) {
            to[camelize(key)] = from[key];
          }
        }
        var componentVNodeHooks = {
          init: function init(vnode, hydrating) {
            if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
              var mountedNode = vnode;
              componentVNodeHooks.prepatch(mountedNode, mountedNode);
            } else {
              var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
              child.$mount(hydrating ? vnode.elm : void 0, hydrating);
            }
          },
          prepatch: function prepatch(oldVnode, vnode) {
            var options = vnode.componentOptions;
            var child = vnode.componentInstance = oldVnode.componentInstance;
            updateChildComponent(child, options.propsData, options.listeners, vnode, options.children);
          },
          insert: function insert(vnode) {
            var context = vnode.context;
            var componentInstance = vnode.componentInstance;
            if (!componentInstance._isMounted) {
              componentInstance._isMounted = true;
              callHook(componentInstance, "mounted");
            }
            if (vnode.data.keepAlive) {
              if (context._isMounted) {
                queueActivatedComponent(componentInstance);
              } else {
                activateChildComponent(componentInstance, true);
              }
            }
          },
          destroy: function destroy(vnode) {
            var componentInstance = vnode.componentInstance;
            if (!componentInstance._isDestroyed) {
              if (!vnode.data.keepAlive) {
                componentInstance.$destroy();
              } else {
                deactivateChildComponent(componentInstance, true);
              }
            }
          }
        };
        var hooksToMerge = Object.keys(componentVNodeHooks);
        function createComponent(Ctor, data2, context, children, tag) {
          if (isUndef2(Ctor)) {
            return;
          }
          var baseCtor = context.$options._base;
          if (isObject2(Ctor)) {
            Ctor = baseCtor.extend(Ctor);
          }
          if (typeof Ctor !== "function") {
            {
              warn2("Invalid Component definition: " + String(Ctor), context);
            }
            return;
          }
          var asyncFactory;
          if (isUndef2(Ctor.cid)) {
            asyncFactory = Ctor;
            Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
            if (Ctor === void 0) {
              return createAsyncPlaceholder(asyncFactory, data2, context, children, tag);
            }
          }
          data2 = data2 || {};
          resolveConstructorOptions(Ctor);
          if (isDef(data2.model)) {
            transformModel(Ctor.options, data2);
          }
          var propsData = extractPropsFromVNodeData(data2, Ctor, tag);
          if (isTrue(Ctor.options.functional)) {
            return createFunctionalComponent(Ctor, propsData, data2, context, children);
          }
          var listeners = data2.on;
          data2.on = data2.nativeOn;
          if (isTrue(Ctor.options.abstract)) {
            var slot = data2.slot;
            data2 = {};
            if (slot) {
              data2.slot = slot;
            }
          }
          installComponentHooks(data2);
          var name = Ctor.options.name || tag;
          var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ""), data2, void 0, void 0, void 0, context, { Ctor, propsData, listeners, tag, children }, asyncFactory);
          return vnode;
        }
        function createComponentInstanceForVnode(vnode, parent) {
          var options = {
            _isComponent: true,
            _parentVnode: vnode,
            parent
          };
          var inlineTemplate = vnode.data.inlineTemplate;
          if (isDef(inlineTemplate)) {
            options.render = inlineTemplate.render;
            options.staticRenderFns = inlineTemplate.staticRenderFns;
          }
          return new vnode.componentOptions.Ctor(options);
        }
        function installComponentHooks(data2) {
          var hooks2 = data2.hook || (data2.hook = {});
          for (var i = 0; i < hooksToMerge.length; i++) {
            var key = hooksToMerge[i];
            var existing = hooks2[key];
            var toMerge = componentVNodeHooks[key];
            if (existing !== toMerge && !(existing && existing._merged)) {
              hooks2[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
            }
          }
        }
        function mergeHook$1(f1, f2) {
          var merged = function(a, b) {
            f1(a, b);
            f2(a, b);
          };
          merged._merged = true;
          return merged;
        }
        function transformModel(options, data2) {
          var prop = options.model && options.model.prop || "value";
          var event = options.model && options.model.event || "input";
          (data2.attrs || (data2.attrs = {}))[prop] = data2.model.value;
          var on2 = data2.on || (data2.on = {});
          var existing = on2[event];
          var callback = data2.model.callback;
          if (isDef(existing)) {
            if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
              on2[event] = [callback].concat(existing);
            }
          } else {
            on2[event] = callback;
          }
        }
        var SIMPLE_NORMALIZE = 1;
        var ALWAYS_NORMALIZE = 2;
        function createElement3(context, tag, data2, children, normalizationType, alwaysNormalize) {
          if (Array.isArray(data2) || isPrimitive2(data2)) {
            normalizationType = children;
            children = data2;
            data2 = void 0;
          }
          if (isTrue(alwaysNormalize)) {
            normalizationType = ALWAYS_NORMALIZE;
          }
          return _createElement(context, tag, data2, children, normalizationType);
        }
        function _createElement(context, tag, data2, children, normalizationType) {
          if (isDef(data2) && isDef(data2.__ob__)) {
            warn2("Avoid using observed data object as vnode data: " + JSON.stringify(data2) + "\nAlways create fresh vnode data objects in each render!", context);
            return createEmptyVNode();
          }
          if (isDef(data2) && isDef(data2.is)) {
            tag = data2.is;
          }
          if (!tag) {
            return createEmptyVNode();
          }
          if (isDef(data2) && isDef(data2.key) && !isPrimitive2(data2.key)) {
            {
              warn2("Avoid using non-primitive value as key, use string/number value instead.", context);
            }
          }
          if (Array.isArray(children) && typeof children[0] === "function") {
            data2 = data2 || {};
            data2.scopedSlots = { default: children[0] };
            children.length = 0;
          }
          if (normalizationType === ALWAYS_NORMALIZE) {
            children = normalizeChildren(children);
          } else if (normalizationType === SIMPLE_NORMALIZE) {
            children = simpleNormalizeChildren(children);
          }
          var vnode, ns;
          if (typeof tag === "string") {
            var Ctor;
            ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
            if (config.isReservedTag(tag)) {
              if (isDef(data2) && isDef(data2.nativeOn) && data2.tag !== "component") {
                warn2("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">.", context);
              }
              vnode = new VNode(config.parsePlatformTagName(tag), data2, children, void 0, void 0, context);
            } else if ((!data2 || !data2.pre) && isDef(Ctor = resolveAsset(context.$options, "components", tag))) {
              vnode = createComponent(Ctor, data2, context, children, tag);
            } else {
              vnode = new VNode(tag, data2, children, void 0, void 0, context);
            }
          } else {
            vnode = createComponent(tag, data2, context, children);
          }
          if (Array.isArray(vnode)) {
            return vnode;
          } else if (isDef(vnode)) {
            if (isDef(ns)) {
              applyNS(vnode, ns);
            }
            if (isDef(data2)) {
              registerDeepBindings(data2);
            }
            return vnode;
          } else {
            return createEmptyVNode();
          }
        }
        function applyNS(vnode, ns, force) {
          vnode.ns = ns;
          if (vnode.tag === "foreignObject") {
            ns = void 0;
            force = true;
          }
          if (isDef(vnode.children)) {
            for (var i = 0, l = vnode.children.length; i < l; i++) {
              var child = vnode.children[i];
              if (isDef(child.tag) && (isUndef2(child.ns) || isTrue(force) && child.tag !== "svg")) {
                applyNS(child, ns, force);
              }
            }
          }
        }
        function registerDeepBindings(data2) {
          if (isObject2(data2.style)) {
            traverse2(data2.style);
          }
          if (isObject2(data2.class)) {
            traverse2(data2.class);
          }
        }
        function initRender(vm) {
          vm._vnode = null;
          vm._staticTrees = null;
          var options = vm.$options;
          var parentVnode = vm.$vnode = options._parentVnode;
          var renderContext = parentVnode && parentVnode.context;
          vm.$slots = resolveSlots2(options._renderChildren, renderContext);
          vm.$scopedSlots = emptyObject;
          vm._c = function(a, b, c, d) {
            return createElement3(vm, a, b, c, d, false);
          };
          vm.$createElement = function(a, b, c, d) {
            return createElement3(vm, a, b, c, d, true);
          };
          var parentData = parentVnode && parentVnode.data;
          {
            defineReactive$$1(vm, "$attrs", parentData && parentData.attrs || emptyObject, function() {
              !isUpdatingChildComponent && warn2("$attrs is readonly.", vm);
            }, true);
            defineReactive$$1(vm, "$listeners", options._parentListeners || emptyObject, function() {
              !isUpdatingChildComponent && warn2("$listeners is readonly.", vm);
            }, true);
          }
        }
        var currentRenderingInstance = null;
        function renderMixin(Vue5) {
          installRenderHelpers(Vue5.prototype);
          Vue5.prototype.$nextTick = function(fn) {
            return nextTick2(fn, this);
          };
          Vue5.prototype._render = function() {
            var vm = this;
            var ref3 = vm.$options;
            var render2 = ref3.render;
            var _parentVnode = ref3._parentVnode;
            if (_parentVnode) {
              vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
            }
            vm.$vnode = _parentVnode;
            var vnode;
            try {
              currentRenderingInstance = vm;
              vnode = render2.call(vm._renderProxy, vm.$createElement);
            } catch (e) {
              handleError(e, vm, "render");
              if (vm.$options.renderError) {
                try {
                  vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
                } catch (e2) {
                  handleError(e2, vm, "renderError");
                  vnode = vm._vnode;
                }
              } else {
                vnode = vm._vnode;
              }
            } finally {
              currentRenderingInstance = null;
            }
            if (Array.isArray(vnode) && vnode.length === 1) {
              vnode = vnode[0];
            }
            if (!(vnode instanceof VNode)) {
              if (Array.isArray(vnode)) {
                warn2("Multiple root nodes returned from render function. Render function should return a single root node.", vm);
              }
              vnode = createEmptyVNode();
            }
            vnode.parent = _parentVnode;
            return vnode;
          };
        }
        function ensureCtor(comp, base) {
          if (comp.__esModule || hasSymbol2 && comp[Symbol.toStringTag] === "Module") {
            comp = comp.default;
          }
          return isObject2(comp) ? base.extend(comp) : comp;
        }
        function createAsyncPlaceholder(factory, data2, context, children, tag) {
          var node = createEmptyVNode();
          node.asyncFactory = factory;
          node.asyncMeta = { data: data2, context, children, tag };
          return node;
        }
        function resolveAsyncComponent(factory, baseCtor) {
          if (isTrue(factory.error) && isDef(factory.errorComp)) {
            return factory.errorComp;
          }
          if (isDef(factory.resolved)) {
            return factory.resolved;
          }
          var owner = currentRenderingInstance;
          if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
            factory.owners.push(owner);
          }
          if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
            return factory.loadingComp;
          }
          if (owner && !isDef(factory.owners)) {
            var owners = factory.owners = [owner];
            var sync = true;
            var timerLoading = null;
            var timerTimeout = null;
            owner.$on("hook:destroyed", function() {
              return remove(owners, owner);
            });
            var forceRender = function(renderCompleted) {
              for (var i = 0, l = owners.length; i < l; i++) {
                owners[i].$forceUpdate();
              }
              if (renderCompleted) {
                owners.length = 0;
                if (timerLoading !== null) {
                  clearTimeout(timerLoading);
                  timerLoading = null;
                }
                if (timerTimeout !== null) {
                  clearTimeout(timerTimeout);
                  timerTimeout = null;
                }
              }
            };
            var resolve = once(function(res2) {
              factory.resolved = ensureCtor(res2, baseCtor);
              if (!sync) {
                forceRender(true);
              } else {
                owners.length = 0;
              }
            });
            var reject = once(function(reason) {
              warn2("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ""));
              if (isDef(factory.errorComp)) {
                factory.error = true;
                forceRender(true);
              }
            });
            var res = factory(resolve, reject);
            if (isObject2(res)) {
              if (isPromise(res)) {
                if (isUndef2(factory.resolved)) {
                  res.then(resolve, reject);
                }
              } else if (isPromise(res.component)) {
                res.component.then(resolve, reject);
                if (isDef(res.error)) {
                  factory.errorComp = ensureCtor(res.error, baseCtor);
                }
                if (isDef(res.loading)) {
                  factory.loadingComp = ensureCtor(res.loading, baseCtor);
                  if (res.delay === 0) {
                    factory.loading = true;
                  } else {
                    timerLoading = setTimeout(function() {
                      timerLoading = null;
                      if (isUndef2(factory.resolved) && isUndef2(factory.error)) {
                        factory.loading = true;
                        forceRender(false);
                      }
                    }, res.delay || 200);
                  }
                }
                if (isDef(res.timeout)) {
                  timerTimeout = setTimeout(function() {
                    timerTimeout = null;
                    if (isUndef2(factory.resolved)) {
                      reject("timeout (" + res.timeout + "ms)");
                    }
                  }, res.timeout);
                }
              }
            }
            sync = false;
            return factory.loading ? factory.loadingComp : factory.resolved;
          }
        }
        function getFirstComponentChild(children) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              var c = children[i];
              if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
                return c;
              }
            }
          }
        }
        function initEvents(vm) {
          vm._events = /* @__PURE__ */ Object.create(null);
          vm._hasHookEvent = false;
          var listeners = vm.$options._parentListeners;
          if (listeners) {
            updateComponentListeners(vm, listeners);
          }
        }
        var target;
        function add(event, fn) {
          target.$on(event, fn);
        }
        function remove$1(event, fn) {
          target.$off(event, fn);
        }
        function createOnceHandler(event, fn) {
          var _target = target;
          return function onceHandler() {
            var res = fn.apply(null, arguments);
            if (res !== null) {
              _target.$off(event, onceHandler);
            }
          };
        }
        function updateComponentListeners(vm, listeners, oldListeners) {
          target = vm;
          updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
          target = void 0;
        }
        function eventsMixin(Vue5) {
          var hookRE = /^hook:/;
          Vue5.prototype.$on = function(event, fn) {
            var vm = this;
            if (Array.isArray(event)) {
              for (var i = 0, l = event.length; i < l; i++) {
                vm.$on(event[i], fn);
              }
            } else {
              (vm._events[event] || (vm._events[event] = [])).push(fn);
              if (hookRE.test(event)) {
                vm._hasHookEvent = true;
              }
            }
            return vm;
          };
          Vue5.prototype.$once = function(event, fn) {
            var vm = this;
            function on2() {
              vm.$off(event, on2);
              fn.apply(vm, arguments);
            }
            on2.fn = fn;
            vm.$on(event, on2);
            return vm;
          };
          Vue5.prototype.$off = function(event, fn) {
            var vm = this;
            if (!arguments.length) {
              vm._events = /* @__PURE__ */ Object.create(null);
              return vm;
            }
            if (Array.isArray(event)) {
              for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
                vm.$off(event[i$1], fn);
              }
              return vm;
            }
            var cbs = vm._events[event];
            if (!cbs) {
              return vm;
            }
            if (!fn) {
              vm._events[event] = null;
              return vm;
            }
            var cb;
            var i = cbs.length;
            while (i--) {
              cb = cbs[i];
              if (cb === fn || cb.fn === fn) {
                cbs.splice(i, 1);
                break;
              }
            }
            return vm;
          };
          Vue5.prototype.$emit = function(event) {
            var vm = this;
            {
              var lowerCaseEvent = event.toLowerCase();
              if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
                tip('Event "' + lowerCaseEvent + '" is emitted in component ' + formatComponentName(vm) + ' but the handler is registered for "' + event + '". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "' + hyphenate(event) + '" instead of "' + event + '".');
              }
            }
            var cbs = vm._events[event];
            if (cbs) {
              cbs = cbs.length > 1 ? toArray(cbs) : cbs;
              var args = toArray(arguments, 1);
              var info = 'event handler for "' + event + '"';
              for (var i = 0, l = cbs.length; i < l; i++) {
                invokeWithErrorHandling(cbs[i], vm, args, vm, info);
              }
            }
            return vm;
          };
        }
        var activeInstance = null;
        var isUpdatingChildComponent = false;
        function setActiveInstance(vm) {
          var prevActiveInstance = activeInstance;
          activeInstance = vm;
          return function() {
            activeInstance = prevActiveInstance;
          };
        }
        function initLifecycle(vm) {
          var options = vm.$options;
          var parent = options.parent;
          if (parent && !options.abstract) {
            while (parent.$options.abstract && parent.$parent) {
              parent = parent.$parent;
            }
            parent.$children.push(vm);
          }
          vm.$parent = parent;
          vm.$root = parent ? parent.$root : vm;
          vm.$children = [];
          vm.$refs = {};
          vm._watcher = null;
          vm._inactive = null;
          vm._directInactive = false;
          vm._isMounted = false;
          vm._isDestroyed = false;
          vm._isBeingDestroyed = false;
        }
        function lifecycleMixin(Vue5) {
          Vue5.prototype._update = function(vnode, hydrating) {
            var vm = this;
            var prevEl = vm.$el;
            var prevVnode = vm._vnode;
            var restoreActiveInstance = setActiveInstance(vm);
            vm._vnode = vnode;
            if (!prevVnode) {
              vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false);
            } else {
              vm.$el = vm.__patch__(prevVnode, vnode);
            }
            restoreActiveInstance();
            if (prevEl) {
              prevEl.__vue__ = null;
            }
            if (vm.$el) {
              vm.$el.__vue__ = vm;
            }
            if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
              vm.$parent.$el = vm.$el;
            }
          };
          Vue5.prototype.$forceUpdate = function() {
            var vm = this;
            if (vm._watcher) {
              vm._watcher.update();
            }
          };
          Vue5.prototype.$destroy = function() {
            var vm = this;
            if (vm._isBeingDestroyed) {
              return;
            }
            callHook(vm, "beforeDestroy");
            vm._isBeingDestroyed = true;
            var parent = vm.$parent;
            if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
              remove(parent.$children, vm);
            }
            if (vm._watcher) {
              vm._watcher.teardown();
            }
            var i = vm._watchers.length;
            while (i--) {
              vm._watchers[i].teardown();
            }
            if (vm._data.__ob__) {
              vm._data.__ob__.vmCount--;
            }
            vm._isDestroyed = true;
            vm.__patch__(vm._vnode, null);
            callHook(vm, "destroyed");
            vm.$off();
            if (vm.$el) {
              vm.$el.__vue__ = null;
            }
            if (vm.$vnode) {
              vm.$vnode.parent = null;
            }
          };
        }
        function mountComponent(vm, el, hydrating) {
          vm.$el = el;
          if (!vm.$options.render) {
            vm.$options.render = createEmptyVNode;
            {
              if (vm.$options.template && vm.$options.template.charAt(0) !== "#" || vm.$options.el || el) {
                warn2("You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.", vm);
              } else {
                warn2("Failed to mount component: template or render function not defined.", vm);
              }
            }
          }
          callHook(vm, "beforeMount");
          var updateComponent;
          if (config.performance && mark) {
            updateComponent = function() {
              var name = vm._name;
              var id = vm._uid;
              var startTag = "vue-perf-start:" + id;
              var endTag2 = "vue-perf-end:" + id;
              mark(startTag);
              var vnode = vm._render();
              mark(endTag2);
              measure("vue " + name + " render", startTag, endTag2);
              mark(startTag);
              vm._update(vnode, hydrating);
              mark(endTag2);
              measure("vue " + name + " patch", startTag, endTag2);
            };
          } else {
            updateComponent = function() {
              vm._update(vm._render(), hydrating);
            };
          }
          new Watcher(vm, updateComponent, noop, {
            before: function before() {
              if (vm._isMounted && !vm._isDestroyed) {
                callHook(vm, "beforeUpdate");
              }
            }
          }, true);
          hydrating = false;
          if (vm.$vnode == null) {
            vm._isMounted = true;
            callHook(vm, "mounted");
          }
          return vm;
        }
        function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
          {
            isUpdatingChildComponent = true;
          }
          var newScopedSlots = parentVnode.data.scopedSlots;
          var oldScopedSlots = vm.$scopedSlots;
          var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key);
          var needsForceUpdate = !!(renderChildren || vm.$options._renderChildren || hasDynamicScopedSlot);
          vm.$options._parentVnode = parentVnode;
          vm.$vnode = parentVnode;
          if (vm._vnode) {
            vm._vnode.parent = parentVnode;
          }
          vm.$options._renderChildren = renderChildren;
          vm.$attrs = parentVnode.data.attrs || emptyObject;
          vm.$listeners = listeners || emptyObject;
          if (propsData && vm.$options.props) {
            toggleObserving(false);
            var props3 = vm._props;
            var propKeys = vm.$options._propKeys || [];
            for (var i = 0; i < propKeys.length; i++) {
              var key = propKeys[i];
              var propOptions = vm.$options.props;
              props3[key] = validateProp(key, propOptions, propsData, vm);
            }
            toggleObserving(true);
            vm.$options.propsData = propsData;
          }
          listeners = listeners || emptyObject;
          var oldListeners = vm.$options._parentListeners;
          vm.$options._parentListeners = listeners;
          updateComponentListeners(vm, listeners, oldListeners);
          if (needsForceUpdate) {
            vm.$slots = resolveSlots2(renderChildren, parentVnode.context);
            vm.$forceUpdate();
          }
          {
            isUpdatingChildComponent = false;
          }
        }
        function isInInactiveTree(vm) {
          while (vm && (vm = vm.$parent)) {
            if (vm._inactive) {
              return true;
            }
          }
          return false;
        }
        function activateChildComponent(vm, direct) {
          if (direct) {
            vm._directInactive = false;
            if (isInInactiveTree(vm)) {
              return;
            }
          } else if (vm._directInactive) {
            return;
          }
          if (vm._inactive || vm._inactive === null) {
            vm._inactive = false;
            for (var i = 0; i < vm.$children.length; i++) {
              activateChildComponent(vm.$children[i]);
            }
            callHook(vm, "activated");
          }
        }
        function deactivateChildComponent(vm, direct) {
          if (direct) {
            vm._directInactive = true;
            if (isInInactiveTree(vm)) {
              return;
            }
          }
          if (!vm._inactive) {
            vm._inactive = true;
            for (var i = 0; i < vm.$children.length; i++) {
              deactivateChildComponent(vm.$children[i]);
            }
            callHook(vm, "deactivated");
          }
        }
        function callHook(vm, hook) {
          pushTarget();
          var handlers = vm.$options[hook];
          var info = hook + " hook";
          if (handlers) {
            for (var i = 0, j = handlers.length; i < j; i++) {
              invokeWithErrorHandling(handlers[i], vm, null, vm, info);
            }
          }
          if (vm._hasHookEvent) {
            vm.$emit("hook:" + hook);
          }
          popTarget();
        }
        var MAX_UPDATE_COUNT = 100;
        var queue = [];
        var activatedChildren = [];
        var has = {};
        var circular = {};
        var waiting = false;
        var flushing = false;
        var index = 0;
        function resetSchedulerState() {
          index = queue.length = activatedChildren.length = 0;
          has = {};
          {
            circular = {};
          }
          waiting = flushing = false;
        }
        var currentFlushTimestamp = 0;
        var getNow = Date.now;
        if (inBrowser && !isIE) {
          var performance = window.performance;
          if (performance && typeof performance.now === "function" && getNow() > document.createEvent("Event").timeStamp) {
            getNow = function() {
              return performance.now();
            };
          }
        }
        function flushSchedulerQueue() {
          currentFlushTimestamp = getNow();
          flushing = true;
          var watcher, id;
          queue.sort(function(a, b) {
            return a.id - b.id;
          });
          for (index = 0; index < queue.length; index++) {
            watcher = queue[index];
            if (watcher.before) {
              watcher.before();
            }
            id = watcher.id;
            has[id] = null;
            watcher.run();
            if (has[id] != null) {
              circular[id] = (circular[id] || 0) + 1;
              if (circular[id] > MAX_UPDATE_COUNT) {
                warn2("You may have an infinite update loop " + (watcher.user ? 'in watcher with expression "' + watcher.expression + '"' : "in a component render function."), watcher.vm);
                break;
              }
            }
          }
          var activatedQueue = activatedChildren.slice();
          var updatedQueue = queue.slice();
          resetSchedulerState();
          callActivatedHooks(activatedQueue);
          callUpdatedHooks(updatedQueue);
          if (devtools && config.devtools) {
            devtools.emit("flush");
          }
        }
        function callUpdatedHooks(queue2) {
          var i = queue2.length;
          while (i--) {
            var watcher = queue2[i];
            var vm = watcher.vm;
            if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
              callHook(vm, "updated");
            }
          }
        }
        function queueActivatedComponent(vm) {
          vm._inactive = false;
          activatedChildren.push(vm);
        }
        function callActivatedHooks(queue2) {
          for (var i = 0; i < queue2.length; i++) {
            queue2[i]._inactive = true;
            activateChildComponent(queue2[i], true);
          }
        }
        function queueWatcher(watcher) {
          var id = watcher.id;
          if (has[id] == null) {
            has[id] = true;
            if (!flushing) {
              queue.push(watcher);
            } else {
              var i = queue.length - 1;
              while (i > index && queue[i].id > watcher.id) {
                i--;
              }
              queue.splice(i + 1, 0, watcher);
            }
            if (!waiting) {
              waiting = true;
              if (!config.async) {
                flushSchedulerQueue();
                return;
              }
              nextTick2(flushSchedulerQueue);
            }
          }
        }
        var uid$2 = 0;
        var Watcher = function Watcher2(vm, expOrFn, cb, options, isRenderWatcher) {
          this.vm = vm;
          if (isRenderWatcher) {
            vm._watcher = this;
          }
          vm._watchers.push(this);
          if (options) {
            this.deep = !!options.deep;
            this.user = !!options.user;
            this.lazy = !!options.lazy;
            this.sync = !!options.sync;
            this.before = options.before;
          } else {
            this.deep = this.user = this.lazy = this.sync = false;
          }
          this.cb = cb;
          this.id = ++uid$2;
          this.active = true;
          this.dirty = this.lazy;
          this.deps = [];
          this.newDeps = [];
          this.depIds = new _Set();
          this.newDepIds = new _Set();
          this.expression = expOrFn.toString();
          if (typeof expOrFn === "function") {
            this.getter = expOrFn;
          } else {
            this.getter = parsePath(expOrFn);
            if (!this.getter) {
              this.getter = noop;
              warn2('Failed watching path: "' + expOrFn + '" Watcher only accepts simple dot-delimited paths. For full control, use a function instead.', vm);
            }
          }
          this.value = this.lazy ? void 0 : this.get();
        };
        Watcher.prototype.get = function get2() {
          pushTarget(this);
          var value;
          var vm = this.vm;
          try {
            value = this.getter.call(vm, vm);
          } catch (e) {
            if (this.user) {
              handleError(e, vm, 'getter for watcher "' + this.expression + '"');
            } else {
              throw e;
            }
          } finally {
            if (this.deep) {
              traverse2(value);
            }
            popTarget();
            this.cleanupDeps();
          }
          return value;
        };
        Watcher.prototype.addDep = function addDep(dep) {
          var id = dep.id;
          if (!this.newDepIds.has(id)) {
            this.newDepIds.add(id);
            this.newDeps.push(dep);
            if (!this.depIds.has(id)) {
              dep.addSub(this);
            }
          }
        };
        Watcher.prototype.cleanupDeps = function cleanupDeps() {
          var i = this.deps.length;
          while (i--) {
            var dep = this.deps[i];
            if (!this.newDepIds.has(dep.id)) {
              dep.removeSub(this);
            }
          }
          var tmp = this.depIds;
          this.depIds = this.newDepIds;
          this.newDepIds = tmp;
          this.newDepIds.clear();
          tmp = this.deps;
          this.deps = this.newDeps;
          this.newDeps = tmp;
          this.newDeps.length = 0;
        };
        Watcher.prototype.update = function update() {
          if (this.lazy) {
            this.dirty = true;
          } else if (this.sync) {
            this.run();
          } else {
            queueWatcher(this);
          }
        };
        Watcher.prototype.run = function run() {
          if (this.active) {
            var value = this.get();
            if (value !== this.value || isObject2(value) || this.deep) {
              var oldValue = this.value;
              this.value = value;
              if (this.user) {
                var info = 'callback for watcher "' + this.expression + '"';
                invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
              } else {
                this.cb.call(this.vm, value, oldValue);
              }
            }
          }
        };
        Watcher.prototype.evaluate = function evaluate() {
          this.value = this.get();
          this.dirty = false;
        };
        Watcher.prototype.depend = function depend() {
          var i = this.deps.length;
          while (i--) {
            this.deps[i].depend();
          }
        };
        Watcher.prototype.teardown = function teardown() {
          if (this.active) {
            if (!this.vm._isBeingDestroyed) {
              remove(this.vm._watchers, this);
            }
            var i = this.deps.length;
            while (i--) {
              this.deps[i].removeSub(this);
            }
            this.active = false;
          }
        };
        var sharedPropertyDefinition = {
          enumerable: true,
          configurable: true,
          get: noop,
          set: noop
        };
        function proxy2(target2, sourceKey, key) {
          sharedPropertyDefinition.get = function proxyGetter() {
            return this[sourceKey][key];
          };
          sharedPropertyDefinition.set = function proxySetter(val) {
            this[sourceKey][key] = val;
          };
          Object.defineProperty(target2, key, sharedPropertyDefinition);
        }
        function initState(vm) {
          vm._watchers = [];
          var opts2 = vm.$options;
          if (opts2.props) {
            initProps(vm, opts2.props);
          }
          if (opts2.methods) {
            initMethods(vm, opts2.methods);
          }
          if (opts2.data) {
            initData(vm);
          } else {
            observe2(vm._data = {}, true);
          }
          if (opts2.computed) {
            initComputed(vm, opts2.computed);
          }
          if (opts2.watch && opts2.watch !== nativeWatch) {
            initWatch(vm, opts2.watch);
          }
        }
        function initProps(vm, propsOptions) {
          var propsData = vm.$options.propsData || {};
          var props3 = vm._props = {};
          var keys = vm.$options._propKeys = [];
          var isRoot = !vm.$parent;
          if (!isRoot) {
            toggleObserving(false);
          }
          var loop = function(key2) {
            keys.push(key2);
            var value = validateProp(key2, propsOptions, propsData, vm);
            {
              var hyphenatedKey = hyphenate(key2);
              if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
                warn2('"' + hyphenatedKey + '" is a reserved attribute and cannot be used as component prop.', vm);
              }
              defineReactive$$1(props3, key2, value, function() {
                if (!isRoot && !isUpdatingChildComponent) {
                  warn2(`Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: "` + key2 + '"', vm);
                }
              });
            }
            if (!(key2 in vm)) {
              proxy2(vm, "_props", key2);
            }
          };
          for (var key in propsOptions)
            loop(key);
          toggleObserving(true);
        }
        function initData(vm) {
          var data2 = vm.$options.data;
          data2 = vm._data = typeof data2 === "function" ? getData(data2, vm) : data2 || {};
          if (!isPlainObject2(data2)) {
            data2 = {};
            warn2("data functions should return an object:\nhttps://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function", vm);
          }
          var keys = Object.keys(data2);
          var props3 = vm.$options.props;
          var methods = vm.$options.methods;
          var i = keys.length;
          while (i--) {
            var key = keys[i];
            {
              if (methods && hasOwn2(methods, key)) {
                warn2('Method "' + key + '" has already been defined as a data property.', vm);
              }
            }
            if (props3 && hasOwn2(props3, key)) {
              warn2('The data property "' + key + '" is already declared as a prop. Use prop default value instead.', vm);
            } else if (!isReserved(key)) {
              proxy2(vm, "_data", key);
            }
          }
          observe2(data2, true);
        }
        function getData(data2, vm) {
          pushTarget();
          try {
            return data2.call(vm, vm);
          } catch (e) {
            handleError(e, vm, "data()");
            return {};
          } finally {
            popTarget();
          }
        }
        var computedWatcherOptions = { lazy: true };
        function initComputed(vm, computed2) {
          var watchers = vm._computedWatchers = /* @__PURE__ */ Object.create(null);
          var isSSR = isServerRendering();
          for (var key in computed2) {
            var userDef = computed2[key];
            var getter = typeof userDef === "function" ? userDef : userDef.get;
            if (getter == null) {
              warn2('Getter is missing for computed property "' + key + '".', vm);
            }
            if (!isSSR) {
              watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
            }
            if (!(key in vm)) {
              defineComputed(vm, key, userDef);
            } else {
              if (key in vm.$data) {
                warn2('The computed property "' + key + '" is already defined in data.', vm);
              } else if (vm.$options.props && key in vm.$options.props) {
                warn2('The computed property "' + key + '" is already defined as a prop.', vm);
              } else if (vm.$options.methods && key in vm.$options.methods) {
                warn2('The computed property "' + key + '" is already defined as a method.', vm);
              }
            }
          }
        }
        function defineComputed(target2, key, userDef) {
          var shouldCache = !isServerRendering();
          if (typeof userDef === "function") {
            sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
            sharedPropertyDefinition.set = noop;
          } else {
            sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
            sharedPropertyDefinition.set = userDef.set || noop;
          }
          if (sharedPropertyDefinition.set === noop) {
            sharedPropertyDefinition.set = function() {
              warn2('Computed property "' + key + '" was assigned to but it has no setter.', this);
            };
          }
          Object.defineProperty(target2, key, sharedPropertyDefinition);
        }
        function createComputedGetter(key) {
          return function computedGetter() {
            var watcher = this._computedWatchers && this._computedWatchers[key];
            if (watcher) {
              if (watcher.dirty) {
                watcher.evaluate();
              }
              if (Dep.target) {
                watcher.depend();
              }
              return watcher.value;
            }
          };
        }
        function createGetterInvoker(fn) {
          return function computedGetter() {
            return fn.call(this, this);
          };
        }
        function initMethods(vm, methods) {
          var props3 = vm.$options.props;
          for (var key in methods) {
            {
              if (typeof methods[key] !== "function") {
                warn2('Method "' + key + '" has type "' + typeof methods[key] + '" in the component definition. Did you reference the function correctly?', vm);
              }
              if (props3 && hasOwn2(props3, key)) {
                warn2('Method "' + key + '" has already been defined as a prop.', vm);
              }
              if (key in vm && isReserved(key)) {
                warn2('Method "' + key + '" conflicts with an existing Vue instance method. Avoid defining component methods that start with _ or $.');
              }
            }
            vm[key] = typeof methods[key] !== "function" ? noop : bind(methods[key], vm);
          }
        }
        function initWatch(vm, watch2) {
          for (var key in watch2) {
            var handler2 = watch2[key];
            if (Array.isArray(handler2)) {
              for (var i = 0; i < handler2.length; i++) {
                createWatcher2(vm, key, handler2[i]);
              }
            } else {
              createWatcher2(vm, key, handler2);
            }
          }
        }
        function createWatcher2(vm, expOrFn, handler2, options) {
          if (isPlainObject2(handler2)) {
            options = handler2;
            handler2 = handler2.handler;
          }
          if (typeof handler2 === "string") {
            handler2 = vm[handler2];
          }
          return vm.$watch(expOrFn, handler2, options);
        }
        function stateMixin(Vue5) {
          var dataDef = {};
          dataDef.get = function() {
            return this._data;
          };
          var propsDef = {};
          propsDef.get = function() {
            return this._props;
          };
          {
            dataDef.set = function() {
              warn2("Avoid replacing instance root $data. Use nested data properties instead.", this);
            };
            propsDef.set = function() {
              warn2("$props is readonly.", this);
            };
          }
          Object.defineProperty(Vue5.prototype, "$data", dataDef);
          Object.defineProperty(Vue5.prototype, "$props", propsDef);
          Vue5.prototype.$set = set3;
          Vue5.prototype.$delete = del2;
          Vue5.prototype.$watch = function(expOrFn, cb, options) {
            var vm = this;
            if (isPlainObject2(cb)) {
              return createWatcher2(vm, expOrFn, cb, options);
            }
            options = options || {};
            options.user = true;
            var watcher = new Watcher(vm, expOrFn, cb, options);
            if (options.immediate) {
              var info = 'callback for immediate watcher "' + watcher.expression + '"';
              pushTarget();
              invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
              popTarget();
            }
            return function unwatchFn() {
              watcher.teardown();
            };
          };
        }
        var uid$3 = 0;
        function initMixin(Vue5) {
          Vue5.prototype._init = function(options) {
            var vm = this;
            vm._uid = uid$3++;
            var startTag, endTag2;
            if (config.performance && mark) {
              startTag = "vue-perf-start:" + vm._uid;
              endTag2 = "vue-perf-end:" + vm._uid;
              mark(startTag);
            }
            vm._isVue = true;
            if (options && options._isComponent) {
              initInternalComponent(vm, options);
            } else {
              vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
            }
            {
              initProxy(vm);
            }
            vm._self = vm;
            initLifecycle(vm);
            initEvents(vm);
            initRender(vm);
            callHook(vm, "beforeCreate");
            initInjections(vm);
            initState(vm);
            initProvide(vm);
            callHook(vm, "created");
            if (config.performance && mark) {
              vm._name = formatComponentName(vm, false);
              mark(endTag2);
              measure("vue " + vm._name + " init", startTag, endTag2);
            }
            if (vm.$options.el) {
              vm.$mount(vm.$options.el);
            }
          };
        }
        function initInternalComponent(vm, options) {
          var opts2 = vm.$options = Object.create(vm.constructor.options);
          var parentVnode = options._parentVnode;
          opts2.parent = options.parent;
          opts2._parentVnode = parentVnode;
          var vnodeComponentOptions = parentVnode.componentOptions;
          opts2.propsData = vnodeComponentOptions.propsData;
          opts2._parentListeners = vnodeComponentOptions.listeners;
          opts2._renderChildren = vnodeComponentOptions.children;
          opts2._componentTag = vnodeComponentOptions.tag;
          if (options.render) {
            opts2.render = options.render;
            opts2.staticRenderFns = options.staticRenderFns;
          }
        }
        function resolveConstructorOptions(Ctor) {
          var options = Ctor.options;
          if (Ctor.super) {
            var superOptions = resolveConstructorOptions(Ctor.super);
            var cachedSuperOptions = Ctor.superOptions;
            if (superOptions !== cachedSuperOptions) {
              Ctor.superOptions = superOptions;
              var modifiedOptions = resolveModifiedOptions(Ctor);
              if (modifiedOptions) {
                extend(Ctor.extendOptions, modifiedOptions);
              }
              options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
              if (options.name) {
                options.components[options.name] = Ctor;
              }
            }
          }
          return options;
        }
        function resolveModifiedOptions(Ctor) {
          var modified;
          var latest = Ctor.options;
          var sealed = Ctor.sealedOptions;
          for (var key in latest) {
            if (latest[key] !== sealed[key]) {
              if (!modified) {
                modified = {};
              }
              modified[key] = latest[key];
            }
          }
          return modified;
        }
        function Vue4(options) {
          if (!(this instanceof Vue4)) {
            warn2("Vue is a constructor and should be called with the `new` keyword");
          }
          this._init(options);
        }
        initMixin(Vue4);
        stateMixin(Vue4);
        eventsMixin(Vue4);
        lifecycleMixin(Vue4);
        renderMixin(Vue4);
        function initUse(Vue5) {
          Vue5.use = function(plugin) {
            var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
            if (installedPlugins.indexOf(plugin) > -1) {
              return this;
            }
            var args = toArray(arguments, 1);
            args.unshift(this);
            if (typeof plugin.install === "function") {
              plugin.install.apply(plugin, args);
            } else if (typeof plugin === "function") {
              plugin.apply(null, args);
            }
            installedPlugins.push(plugin);
            return this;
          };
        }
        function initMixin$1(Vue5) {
          Vue5.mixin = function(mixin2) {
            this.options = mergeOptions(this.options, mixin2);
            return this;
          };
        }
        function initExtend(Vue5) {
          Vue5.cid = 0;
          var cid = 1;
          Vue5.extend = function(extendOptions) {
            extendOptions = extendOptions || {};
            var Super = this;
            var SuperId = Super.cid;
            var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
            if (cachedCtors[SuperId]) {
              return cachedCtors[SuperId];
            }
            var name = extendOptions.name || Super.options.name;
            if (name) {
              validateComponentName(name);
            }
            var Sub = function VueComponent(options) {
              this._init(options);
            };
            Sub.prototype = Object.create(Super.prototype);
            Sub.prototype.constructor = Sub;
            Sub.cid = cid++;
            Sub.options = mergeOptions(Super.options, extendOptions);
            Sub["super"] = Super;
            if (Sub.options.props) {
              initProps$1(Sub);
            }
            if (Sub.options.computed) {
              initComputed$1(Sub);
            }
            Sub.extend = Super.extend;
            Sub.mixin = Super.mixin;
            Sub.use = Super.use;
            ASSET_TYPES.forEach(function(type) {
              Sub[type] = Super[type];
            });
            if (name) {
              Sub.options.components[name] = Sub;
            }
            Sub.superOptions = Super.options;
            Sub.extendOptions = extendOptions;
            Sub.sealedOptions = extend({}, Sub.options);
            cachedCtors[SuperId] = Sub;
            return Sub;
          };
        }
        function initProps$1(Comp) {
          var props3 = Comp.options.props;
          for (var key in props3) {
            proxy2(Comp.prototype, "_props", key);
          }
        }
        function initComputed$1(Comp) {
          var computed2 = Comp.options.computed;
          for (var key in computed2) {
            defineComputed(Comp.prototype, key, computed2[key]);
          }
        }
        function initAssetRegisters(Vue5) {
          ASSET_TYPES.forEach(function(type) {
            Vue5[type] = function(id, definition) {
              if (!definition) {
                return this.options[type + "s"][id];
              } else {
                if (type === "component") {
                  validateComponentName(id);
                }
                if (type === "component" && isPlainObject2(definition)) {
                  definition.name = definition.name || id;
                  definition = this.options._base.extend(definition);
                }
                if (type === "directive" && typeof definition === "function") {
                  definition = { bind: definition, update: definition };
                }
                this.options[type + "s"][id] = definition;
                return definition;
              }
            };
          });
        }
        function getComponentName(opts2) {
          return opts2 && (opts2.Ctor.options.name || opts2.tag);
        }
        function matches(pattern, name) {
          if (Array.isArray(pattern)) {
            return pattern.indexOf(name) > -1;
          } else if (typeof pattern === "string") {
            return pattern.split(",").indexOf(name) > -1;
          } else if (isRegExp(pattern)) {
            return pattern.test(name);
          }
          return false;
        }
        function pruneCache(keepAliveInstance, filter) {
          var cache = keepAliveInstance.cache;
          var keys = keepAliveInstance.keys;
          var _vnode = keepAliveInstance._vnode;
          for (var key in cache) {
            var entry = cache[key];
            if (entry) {
              var name = entry.name;
              if (name && !filter(name)) {
                pruneCacheEntry(cache, key, keys, _vnode);
              }
            }
          }
        }
        function pruneCacheEntry(cache, key, keys, current) {
          var entry = cache[key];
          if (entry && (!current || entry.tag !== current.tag)) {
            entry.componentInstance.$destroy();
          }
          cache[key] = null;
          remove(keys, key);
        }
        var patternTypes = [String, RegExp, Array];
        var KeepAlive = {
          name: "keep-alive",
          abstract: true,
          props: {
            include: patternTypes,
            exclude: patternTypes,
            max: [String, Number]
          },
          methods: {
            cacheVNode: function cacheVNode() {
              var ref3 = this;
              var cache = ref3.cache;
              var keys = ref3.keys;
              var vnodeToCache = ref3.vnodeToCache;
              var keyToCache = ref3.keyToCache;
              if (vnodeToCache) {
                var tag = vnodeToCache.tag;
                var componentInstance = vnodeToCache.componentInstance;
                var componentOptions = vnodeToCache.componentOptions;
                cache[keyToCache] = {
                  name: getComponentName(componentOptions),
                  tag,
                  componentInstance
                };
                keys.push(keyToCache);
                if (this.max && keys.length > parseInt(this.max)) {
                  pruneCacheEntry(cache, keys[0], keys, this._vnode);
                }
                this.vnodeToCache = null;
              }
            }
          },
          created: function created() {
            this.cache = /* @__PURE__ */ Object.create(null);
            this.keys = [];
          },
          destroyed: function destroyed2() {
            for (var key in this.cache) {
              pruneCacheEntry(this.cache, key, this.keys);
            }
          },
          mounted: function mounted2() {
            var this$1 = this;
            this.cacheVNode();
            this.$watch("include", function(val) {
              pruneCache(this$1, function(name) {
                return matches(val, name);
              });
            });
            this.$watch("exclude", function(val) {
              pruneCache(this$1, function(name) {
                return !matches(val, name);
              });
            });
          },
          updated: function updated() {
            this.cacheVNode();
          },
          render: function render2() {
            var slot = this.$slots.default;
            var vnode = getFirstComponentChild(slot);
            var componentOptions = vnode && vnode.componentOptions;
            if (componentOptions) {
              var name = getComponentName(componentOptions);
              var ref3 = this;
              var include = ref3.include;
              var exclude = ref3.exclude;
              if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
                return vnode;
              }
              var ref$12 = this;
              var cache = ref$12.cache;
              var keys = ref$12.keys;
              var key = vnode.key == null ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : "") : vnode.key;
              if (cache[key]) {
                vnode.componentInstance = cache[key].componentInstance;
                remove(keys, key);
                keys.push(key);
              } else {
                this.vnodeToCache = vnode;
                this.keyToCache = key;
              }
              vnode.data.keepAlive = true;
            }
            return vnode || slot && slot[0];
          }
        };
        var builtInComponents = {
          KeepAlive
        };
        function initGlobalAPI(Vue5) {
          var configDef = {};
          configDef.get = function() {
            return config;
          };
          {
            configDef.set = function() {
              warn2("Do not replace the Vue.config object, set individual fields instead.");
            };
          }
          Object.defineProperty(Vue5, "config", configDef);
          Vue5.util = {
            warn: warn2,
            extend,
            mergeOptions,
            defineReactive: defineReactive$$1
          };
          Vue5.set = set3;
          Vue5.delete = del2;
          Vue5.nextTick = nextTick2;
          Vue5.observable = function(obj) {
            observe2(obj);
            return obj;
          };
          Vue5.options = /* @__PURE__ */ Object.create(null);
          ASSET_TYPES.forEach(function(type) {
            Vue5.options[type + "s"] = /* @__PURE__ */ Object.create(null);
          });
          Vue5.options._base = Vue5;
          extend(Vue5.options.components, builtInComponents);
          initUse(Vue5);
          initMixin$1(Vue5);
          initExtend(Vue5);
          initAssetRegisters(Vue5);
        }
        initGlobalAPI(Vue4);
        Object.defineProperty(Vue4.prototype, "$isServer", {
          get: isServerRendering
        });
        Object.defineProperty(Vue4.prototype, "$ssrContext", {
          get: function get2() {
            return this.$vnode && this.$vnode.ssrContext;
          }
        });
        Object.defineProperty(Vue4, "FunctionalRenderContext", {
          value: FunctionalRenderContext
        });
        Vue4.version = "2.6.14";
        var isReservedAttr = makeMap("style,class");
        var acceptValue = makeMap("input,textarea,option,select,progress");
        var mustUseProp = function(tag, type, attr) {
          return attr === "value" && acceptValue(tag) && type !== "button" || attr === "selected" && tag === "option" || attr === "checked" && tag === "input" || attr === "muted" && tag === "video";
        };
        var isEnumeratedAttr = makeMap("contenteditable,draggable,spellcheck");
        var isValidContentEditableValue = makeMap("events,caret,typing,plaintext-only");
        var convertEnumeratedValue = function(key, value) {
          return isFalsyAttrValue(value) || value === "false" ? "false" : key === "contenteditable" && isValidContentEditableValue(value) ? value : "true";
        };
        var isBooleanAttr = makeMap("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible");
        var xlinkNS = "http://www.w3.org/1999/xlink";
        var isXlink = function(name) {
          return name.charAt(5) === ":" && name.slice(0, 5) === "xlink";
        };
        var getXlinkProp = function(name) {
          return isXlink(name) ? name.slice(6, name.length) : "";
        };
        var isFalsyAttrValue = function(val) {
          return val == null || val === false;
        };
        function genClassForVnode(vnode) {
          var data2 = vnode.data;
          var parentNode2 = vnode;
          var childNode = vnode;
          while (isDef(childNode.componentInstance)) {
            childNode = childNode.componentInstance._vnode;
            if (childNode && childNode.data) {
              data2 = mergeClassData(childNode.data, data2);
            }
          }
          while (isDef(parentNode2 = parentNode2.parent)) {
            if (parentNode2 && parentNode2.data) {
              data2 = mergeClassData(data2, parentNode2.data);
            }
          }
          return renderClass(data2.staticClass, data2.class);
        }
        function mergeClassData(child, parent) {
          return {
            staticClass: concat(child.staticClass, parent.staticClass),
            class: isDef(child.class) ? [child.class, parent.class] : parent.class
          };
        }
        function renderClass(staticClass, dynamicClass) {
          if (isDef(staticClass) || isDef(dynamicClass)) {
            return concat(staticClass, stringifyClass(dynamicClass));
          }
          return "";
        }
        function concat(a, b) {
          return a ? b ? a + " " + b : a : b || "";
        }
        function stringifyClass(value) {
          if (Array.isArray(value)) {
            return stringifyArray(value);
          }
          if (isObject2(value)) {
            return stringifyObject(value);
          }
          if (typeof value === "string") {
            return value;
          }
          return "";
        }
        function stringifyArray(value) {
          var res = "";
          var stringified;
          for (var i = 0, l = value.length; i < l; i++) {
            if (isDef(stringified = stringifyClass(value[i])) && stringified !== "") {
              if (res) {
                res += " ";
              }
              res += stringified;
            }
          }
          return res;
        }
        function stringifyObject(value) {
          var res = "";
          for (var key in value) {
            if (value[key]) {
              if (res) {
                res += " ";
              }
              res += key;
            }
          }
          return res;
        }
        var namespaceMap = {
          svg: "http://www.w3.org/2000/svg",
          math: "http://www.w3.org/1998/Math/MathML"
        };
        var isHTMLTag = makeMap("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot");
        var isSVG = makeMap("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", true);
        var isPreTag = function(tag) {
          return tag === "pre";
        };
        var isReservedTag = function(tag) {
          return isHTMLTag(tag) || isSVG(tag);
        };
        function getTagNamespace(tag) {
          if (isSVG(tag)) {
            return "svg";
          }
          if (tag === "math") {
            return "math";
          }
        }
        var unknownElementCache = /* @__PURE__ */ Object.create(null);
        function isUnknownElement(tag) {
          if (!inBrowser) {
            return true;
          }
          if (isReservedTag(tag)) {
            return false;
          }
          tag = tag.toLowerCase();
          if (unknownElementCache[tag] != null) {
            return unknownElementCache[tag];
          }
          var el = document.createElement(tag);
          if (tag.indexOf("-") > -1) {
            return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
          } else {
            return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
          }
        }
        var isTextInputType = makeMap("text,number,password,search,email,tel,url");
        function query(el) {
          if (typeof el === "string") {
            var selected = document.querySelector(el);
            if (!selected) {
              warn2("Cannot find element: " + el);
              return document.createElement("div");
            }
            return selected;
          } else {
            return el;
          }
        }
        function createElement$1(tagName2, vnode) {
          var elm = document.createElement(tagName2);
          if (tagName2 !== "select") {
            return elm;
          }
          if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== void 0) {
            elm.setAttribute("multiple", "multiple");
          }
          return elm;
        }
        function createElementNS(namespace, tagName2) {
          return document.createElementNS(namespaceMap[namespace], tagName2);
        }
        function createTextNode(text2) {
          return document.createTextNode(text2);
        }
        function createComment(text2) {
          return document.createComment(text2);
        }
        function insertBefore(parentNode2, newNode, referenceNode) {
          parentNode2.insertBefore(newNode, referenceNode);
        }
        function removeChild(node, child) {
          node.removeChild(child);
        }
        function appendChild(node, child) {
          node.appendChild(child);
        }
        function parentNode(node) {
          return node.parentNode;
        }
        function nextSibling(node) {
          return node.nextSibling;
        }
        function tagName(node) {
          return node.tagName;
        }
        function setTextContent(node, text2) {
          node.textContent = text2;
        }
        function setStyleScope(node, scopeId) {
          node.setAttribute(scopeId, "");
        }
        var nodeOps = /* @__PURE__ */ Object.freeze({
          createElement: createElement$1,
          createElementNS,
          createTextNode,
          createComment,
          insertBefore,
          removeChild,
          appendChild,
          parentNode,
          nextSibling,
          tagName,
          setTextContent,
          setStyleScope
        });
        var ref2 = {
          create: function create(_, vnode) {
            registerRef(vnode);
          },
          update: function update(oldVnode, vnode) {
            if (oldVnode.data.ref !== vnode.data.ref) {
              registerRef(oldVnode, true);
              registerRef(vnode);
            }
          },
          destroy: function destroy(vnode) {
            registerRef(vnode, true);
          }
        };
        function registerRef(vnode, isRemoval) {
          var key = vnode.data.ref;
          if (!isDef(key)) {
            return;
          }
          var vm = vnode.context;
          var ref3 = vnode.componentInstance || vnode.elm;
          var refs = vm.$refs;
          if (isRemoval) {
            if (Array.isArray(refs[key])) {
              remove(refs[key], ref3);
            } else if (refs[key] === ref3) {
              refs[key] = void 0;
            }
          } else {
            if (vnode.data.refInFor) {
              if (!Array.isArray(refs[key])) {
                refs[key] = [ref3];
              } else if (refs[key].indexOf(ref3) < 0) {
                refs[key].push(ref3);
              }
            } else {
              refs[key] = ref3;
            }
          }
        }
        var emptyNode = new VNode("", {}, []);
        var hooks = ["create", "activate", "update", "remove", "destroy"];
        function sameVnode(a, b) {
          return a.key === b.key && a.asyncFactory === b.asyncFactory && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && isUndef2(b.asyncFactory.error));
        }
        function sameInputType(a, b) {
          if (a.tag !== "input") {
            return true;
          }
          var i;
          var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
          var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
          return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
        }
        function createKeyToOldIdx(children, beginIdx, endIdx) {
          var i, key;
          var map = {};
          for (i = beginIdx; i <= endIdx; ++i) {
            key = children[i].key;
            if (isDef(key)) {
              map[key] = i;
            }
          }
          return map;
        }
        function createPatchFunction(backend) {
          var i, j;
          var cbs = {};
          var modules2 = backend.modules;
          var nodeOps2 = backend.nodeOps;
          for (i = 0; i < hooks.length; ++i) {
            cbs[hooks[i]] = [];
            for (j = 0; j < modules2.length; ++j) {
              if (isDef(modules2[j][hooks[i]])) {
                cbs[hooks[i]].push(modules2[j][hooks[i]]);
              }
            }
          }
          function emptyNodeAt(elm) {
            return new VNode(nodeOps2.tagName(elm).toLowerCase(), {}, [], void 0, elm);
          }
          function createRmCb(childElm, listeners) {
            function remove$$1() {
              if (--remove$$1.listeners === 0) {
                removeNode(childElm);
              }
            }
            remove$$1.listeners = listeners;
            return remove$$1;
          }
          function removeNode(el) {
            var parent = nodeOps2.parentNode(el);
            if (isDef(parent)) {
              nodeOps2.removeChild(parent, el);
            }
          }
          function isUnknownElement$$1(vnode, inVPre) {
            return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function(ignore) {
              return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
            })) && config.isUnknownElement(vnode.tag);
          }
          var creatingElmInVPre = 0;
          function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index2) {
            if (isDef(vnode.elm) && isDef(ownerArray)) {
              vnode = ownerArray[index2] = cloneVNode(vnode);
            }
            vnode.isRootInsert = !nested;
            if (createComponent2(vnode, insertedVnodeQueue, parentElm, refElm)) {
              return;
            }
            var data2 = vnode.data;
            var children = vnode.children;
            var tag = vnode.tag;
            if (isDef(tag)) {
              {
                if (data2 && data2.pre) {
                  creatingElmInVPre++;
                }
                if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
                  warn2("Unknown custom element: <" + tag + '> - did you register the component correctly? For recursive components, make sure to provide the "name" option.', vnode.context);
                }
              }
              vnode.elm = vnode.ns ? nodeOps2.createElementNS(vnode.ns, tag) : nodeOps2.createElement(tag, vnode);
              setScope(vnode);
              {
                createChildren(vnode, children, insertedVnodeQueue);
                if (isDef(data2)) {
                  invokeCreateHooks(vnode, insertedVnodeQueue);
                }
                insert(parentElm, vnode.elm, refElm);
              }
              if (data2 && data2.pre) {
                creatingElmInVPre--;
              }
            } else if (isTrue(vnode.isComment)) {
              vnode.elm = nodeOps2.createComment(vnode.text);
              insert(parentElm, vnode.elm, refElm);
            } else {
              vnode.elm = nodeOps2.createTextNode(vnode.text);
              insert(parentElm, vnode.elm, refElm);
            }
          }
          function createComponent2(vnode, insertedVnodeQueue, parentElm, refElm) {
            var i2 = vnode.data;
            if (isDef(i2)) {
              var isReactivated = isDef(vnode.componentInstance) && i2.keepAlive;
              if (isDef(i2 = i2.hook) && isDef(i2 = i2.init)) {
                i2(vnode, false);
              }
              if (isDef(vnode.componentInstance)) {
                initComponent(vnode, insertedVnodeQueue);
                insert(parentElm, vnode.elm, refElm);
                if (isTrue(isReactivated)) {
                  reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
                }
                return true;
              }
            }
          }
          function initComponent(vnode, insertedVnodeQueue) {
            if (isDef(vnode.data.pendingInsert)) {
              insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
              vnode.data.pendingInsert = null;
            }
            vnode.elm = vnode.componentInstance.$el;
            if (isPatchable(vnode)) {
              invokeCreateHooks(vnode, insertedVnodeQueue);
              setScope(vnode);
            } else {
              registerRef(vnode);
              insertedVnodeQueue.push(vnode);
            }
          }
          function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
            var i2;
            var innerNode = vnode;
            while (innerNode.componentInstance) {
              innerNode = innerNode.componentInstance._vnode;
              if (isDef(i2 = innerNode.data) && isDef(i2 = i2.transition)) {
                for (i2 = 0; i2 < cbs.activate.length; ++i2) {
                  cbs.activate[i2](emptyNode, innerNode);
                }
                insertedVnodeQueue.push(innerNode);
                break;
              }
            }
            insert(parentElm, vnode.elm, refElm);
          }
          function insert(parent, elm, ref$$1) {
            if (isDef(parent)) {
              if (isDef(ref$$1)) {
                if (nodeOps2.parentNode(ref$$1) === parent) {
                  nodeOps2.insertBefore(parent, elm, ref$$1);
                }
              } else {
                nodeOps2.appendChild(parent, elm);
              }
            }
          }
          function createChildren(vnode, children, insertedVnodeQueue) {
            if (Array.isArray(children)) {
              {
                checkDuplicateKeys(children);
              }
              for (var i2 = 0; i2 < children.length; ++i2) {
                createElm(children[i2], insertedVnodeQueue, vnode.elm, null, true, children, i2);
              }
            } else if (isPrimitive2(vnode.text)) {
              nodeOps2.appendChild(vnode.elm, nodeOps2.createTextNode(String(vnode.text)));
            }
          }
          function isPatchable(vnode) {
            while (vnode.componentInstance) {
              vnode = vnode.componentInstance._vnode;
            }
            return isDef(vnode.tag);
          }
          function invokeCreateHooks(vnode, insertedVnodeQueue) {
            for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
              cbs.create[i$1](emptyNode, vnode);
            }
            i = vnode.data.hook;
            if (isDef(i)) {
              if (isDef(i.create)) {
                i.create(emptyNode, vnode);
              }
              if (isDef(i.insert)) {
                insertedVnodeQueue.push(vnode);
              }
            }
          }
          function setScope(vnode) {
            var i2;
            if (isDef(i2 = vnode.fnScopeId)) {
              nodeOps2.setStyleScope(vnode.elm, i2);
            } else {
              var ancestor = vnode;
              while (ancestor) {
                if (isDef(i2 = ancestor.context) && isDef(i2 = i2.$options._scopeId)) {
                  nodeOps2.setStyleScope(vnode.elm, i2);
                }
                ancestor = ancestor.parent;
              }
            }
            if (isDef(i2 = activeInstance) && i2 !== vnode.context && i2 !== vnode.fnContext && isDef(i2 = i2.$options._scopeId)) {
              nodeOps2.setStyleScope(vnode.elm, i2);
            }
          }
          function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
            for (; startIdx <= endIdx; ++startIdx) {
              createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
            }
          }
          function invokeDestroyHook(vnode) {
            var i2, j2;
            var data2 = vnode.data;
            if (isDef(data2)) {
              if (isDef(i2 = data2.hook) && isDef(i2 = i2.destroy)) {
                i2(vnode);
              }
              for (i2 = 0; i2 < cbs.destroy.length; ++i2) {
                cbs.destroy[i2](vnode);
              }
            }
            if (isDef(i2 = vnode.children)) {
              for (j2 = 0; j2 < vnode.children.length; ++j2) {
                invokeDestroyHook(vnode.children[j2]);
              }
            }
          }
          function removeVnodes(vnodes, startIdx, endIdx) {
            for (; startIdx <= endIdx; ++startIdx) {
              var ch = vnodes[startIdx];
              if (isDef(ch)) {
                if (isDef(ch.tag)) {
                  removeAndInvokeRemoveHook(ch);
                  invokeDestroyHook(ch);
                } else {
                  removeNode(ch.elm);
                }
              }
            }
          }
          function removeAndInvokeRemoveHook(vnode, rm) {
            if (isDef(rm) || isDef(vnode.data)) {
              var i2;
              var listeners = cbs.remove.length + 1;
              if (isDef(rm)) {
                rm.listeners += listeners;
              } else {
                rm = createRmCb(vnode.elm, listeners);
              }
              if (isDef(i2 = vnode.componentInstance) && isDef(i2 = i2._vnode) && isDef(i2.data)) {
                removeAndInvokeRemoveHook(i2, rm);
              }
              for (i2 = 0; i2 < cbs.remove.length; ++i2) {
                cbs.remove[i2](vnode, rm);
              }
              if (isDef(i2 = vnode.data.hook) && isDef(i2 = i2.remove)) {
                i2(vnode, rm);
              } else {
                rm();
              }
            } else {
              removeNode(vnode.elm);
            }
          }
          function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
            var oldStartIdx = 0;
            var newStartIdx = 0;
            var oldEndIdx = oldCh.length - 1;
            var oldStartVnode = oldCh[0];
            var oldEndVnode = oldCh[oldEndIdx];
            var newEndIdx = newCh.length - 1;
            var newStartVnode = newCh[0];
            var newEndVnode = newCh[newEndIdx];
            var oldKeyToIdx, idxInOld, vnodeToMove, refElm;
            var canMove = !removeOnly;
            {
              checkDuplicateKeys(newCh);
            }
            while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
              if (isUndef2(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx];
              } else if (isUndef2(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx];
              } else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
              } else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
              } else if (sameVnode(oldStartVnode, newEndVnode)) {
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                canMove && nodeOps2.insertBefore(parentElm, oldStartVnode.elm, nodeOps2.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
              } else if (sameVnode(oldEndVnode, newStartVnode)) {
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                canMove && nodeOps2.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
              } else {
                if (isUndef2(oldKeyToIdx)) {
                  oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
                if (isUndef2(idxInOld)) {
                  createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                } else {
                  vnodeToMove = oldCh[idxInOld];
                  if (sameVnode(vnodeToMove, newStartVnode)) {
                    patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                    oldCh[idxInOld] = void 0;
                    canMove && nodeOps2.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
                  } else {
                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                  }
                }
                newStartVnode = newCh[++newStartIdx];
              }
            }
            if (oldStartIdx > oldEndIdx) {
              refElm = isUndef2(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
              addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
            } else if (newStartIdx > newEndIdx) {
              removeVnodes(oldCh, oldStartIdx, oldEndIdx);
            }
          }
          function checkDuplicateKeys(children) {
            var seenKeys = {};
            for (var i2 = 0; i2 < children.length; i2++) {
              var vnode = children[i2];
              var key = vnode.key;
              if (isDef(key)) {
                if (seenKeys[key]) {
                  warn2("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
                } else {
                  seenKeys[key] = true;
                }
              }
            }
          }
          function findIdxInOld(node, oldCh, start, end) {
            for (var i2 = start; i2 < end; i2++) {
              var c = oldCh[i2];
              if (isDef(c) && sameVnode(node, c)) {
                return i2;
              }
            }
          }
          function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index2, removeOnly) {
            if (oldVnode === vnode) {
              return;
            }
            if (isDef(vnode.elm) && isDef(ownerArray)) {
              vnode = ownerArray[index2] = cloneVNode(vnode);
            }
            var elm = vnode.elm = oldVnode.elm;
            if (isTrue(oldVnode.isAsyncPlaceholder)) {
              if (isDef(vnode.asyncFactory.resolved)) {
                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
              } else {
                vnode.isAsyncPlaceholder = true;
              }
              return;
            }
            if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
              vnode.componentInstance = oldVnode.componentInstance;
              return;
            }
            var i2;
            var data2 = vnode.data;
            if (isDef(data2) && isDef(i2 = data2.hook) && isDef(i2 = i2.prepatch)) {
              i2(oldVnode, vnode);
            }
            var oldCh = oldVnode.children;
            var ch = vnode.children;
            if (isDef(data2) && isPatchable(vnode)) {
              for (i2 = 0; i2 < cbs.update.length; ++i2) {
                cbs.update[i2](oldVnode, vnode);
              }
              if (isDef(i2 = data2.hook) && isDef(i2 = i2.update)) {
                i2(oldVnode, vnode);
              }
            }
            if (isUndef2(vnode.text)) {
              if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch) {
                  updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
                }
              } else if (isDef(ch)) {
                {
                  checkDuplicateKeys(ch);
                }
                if (isDef(oldVnode.text)) {
                  nodeOps2.setTextContent(elm, "");
                }
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
              } else if (isDef(oldCh)) {
                removeVnodes(oldCh, 0, oldCh.length - 1);
              } else if (isDef(oldVnode.text)) {
                nodeOps2.setTextContent(elm, "");
              }
            } else if (oldVnode.text !== vnode.text) {
              nodeOps2.setTextContent(elm, vnode.text);
            }
            if (isDef(data2)) {
              if (isDef(i2 = data2.hook) && isDef(i2 = i2.postpatch)) {
                i2(oldVnode, vnode);
              }
            }
          }
          function invokeInsertHook(vnode, queue2, initial) {
            if (isTrue(initial) && isDef(vnode.parent)) {
              vnode.parent.data.pendingInsert = queue2;
            } else {
              for (var i2 = 0; i2 < queue2.length; ++i2) {
                queue2[i2].data.hook.insert(queue2[i2]);
              }
            }
          }
          var hydrationBailed = false;
          var isRenderedModule = makeMap("attrs,class,staticClass,staticStyle,key");
          function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
            var i2;
            var tag = vnode.tag;
            var data2 = vnode.data;
            var children = vnode.children;
            inVPre = inVPre || data2 && data2.pre;
            vnode.elm = elm;
            if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
              vnode.isAsyncPlaceholder = true;
              return true;
            }
            {
              if (!assertNodeMatch(elm, vnode, inVPre)) {
                return false;
              }
            }
            if (isDef(data2)) {
              if (isDef(i2 = data2.hook) && isDef(i2 = i2.init)) {
                i2(vnode, true);
              }
              if (isDef(i2 = vnode.componentInstance)) {
                initComponent(vnode, insertedVnodeQueue);
                return true;
              }
            }
            if (isDef(tag)) {
              if (isDef(children)) {
                if (!elm.hasChildNodes()) {
                  createChildren(vnode, children, insertedVnodeQueue);
                } else {
                  if (isDef(i2 = data2) && isDef(i2 = i2.domProps) && isDef(i2 = i2.innerHTML)) {
                    if (i2 !== elm.innerHTML) {
                      if (typeof console !== "undefined" && !hydrationBailed) {
                        hydrationBailed = true;
                        console.warn("Parent: ", elm);
                        console.warn("server innerHTML: ", i2);
                        console.warn("client innerHTML: ", elm.innerHTML);
                      }
                      return false;
                    }
                  } else {
                    var childrenMatch = true;
                    var childNode = elm.firstChild;
                    for (var i$1 = 0; i$1 < children.length; i$1++) {
                      if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                        childrenMatch = false;
                        break;
                      }
                      childNode = childNode.nextSibling;
                    }
                    if (!childrenMatch || childNode) {
                      if (typeof console !== "undefined" && !hydrationBailed) {
                        hydrationBailed = true;
                        console.warn("Parent: ", elm);
                        console.warn("Mismatching childNodes vs. VNodes: ", elm.childNodes, children);
                      }
                      return false;
                    }
                  }
                }
              }
              if (isDef(data2)) {
                var fullInvoke = false;
                for (var key in data2) {
                  if (!isRenderedModule(key)) {
                    fullInvoke = true;
                    invokeCreateHooks(vnode, insertedVnodeQueue);
                    break;
                  }
                }
                if (!fullInvoke && data2["class"]) {
                  traverse2(data2["class"]);
                }
              }
            } else if (elm.data !== vnode.text) {
              elm.data = vnode.text;
            }
            return true;
          }
          function assertNodeMatch(node, vnode, inVPre) {
            if (isDef(vnode.tag)) {
              return vnode.tag.indexOf("vue-component") === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
            } else {
              return node.nodeType === (vnode.isComment ? 8 : 3);
            }
          }
          return function patch2(oldVnode, vnode, hydrating, removeOnly) {
            if (isUndef2(vnode)) {
              if (isDef(oldVnode)) {
                invokeDestroyHook(oldVnode);
              }
              return;
            }
            var isInitialPatch = false;
            var insertedVnodeQueue = [];
            if (isUndef2(oldVnode)) {
              isInitialPatch = true;
              createElm(vnode, insertedVnodeQueue);
            } else {
              var isRealElement = isDef(oldVnode.nodeType);
              if (!isRealElement && sameVnode(oldVnode, vnode)) {
                patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
              } else {
                if (isRealElement) {
                  if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
                    oldVnode.removeAttribute(SSR_ATTR);
                    hydrating = true;
                  }
                  if (isTrue(hydrating)) {
                    if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                      invokeInsertHook(vnode, insertedVnodeQueue, true);
                      return oldVnode;
                    } else {
                      warn2("The client-side rendered virtual DOM tree is not matching server-rendered content. This is likely caused by incorrect HTML markup, for example nesting block-level elements inside <p>, or missing <tbody>. Bailing hydration and performing full client-side render.");
                    }
                  }
                  oldVnode = emptyNodeAt(oldVnode);
                }
                var oldElm = oldVnode.elm;
                var parentElm = nodeOps2.parentNode(oldElm);
                createElm(vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps2.nextSibling(oldElm));
                if (isDef(vnode.parent)) {
                  var ancestor = vnode.parent;
                  var patchable = isPatchable(vnode);
                  while (ancestor) {
                    for (var i2 = 0; i2 < cbs.destroy.length; ++i2) {
                      cbs.destroy[i2](ancestor);
                    }
                    ancestor.elm = vnode.elm;
                    if (patchable) {
                      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                        cbs.create[i$1](emptyNode, ancestor);
                      }
                      var insert2 = ancestor.data.hook.insert;
                      if (insert2.merged) {
                        for (var i$2 = 1; i$2 < insert2.fns.length; i$2++) {
                          insert2.fns[i$2]();
                        }
                      }
                    } else {
                      registerRef(ancestor);
                    }
                    ancestor = ancestor.parent;
                  }
                }
                if (isDef(parentElm)) {
                  removeVnodes([oldVnode], 0, 0);
                } else if (isDef(oldVnode.tag)) {
                  invokeDestroyHook(oldVnode);
                }
              }
            }
            invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
            return vnode.elm;
          };
        }
        var directives = {
          create: updateDirectives,
          update: updateDirectives,
          destroy: function unbindDirectives(vnode) {
            updateDirectives(vnode, emptyNode);
          }
        };
        function updateDirectives(oldVnode, vnode) {
          if (oldVnode.data.directives || vnode.data.directives) {
            _update(oldVnode, vnode);
          }
        }
        function _update(oldVnode, vnode) {
          var isCreate = oldVnode === emptyNode;
          var isDestroy = vnode === emptyNode;
          var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
          var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
          var dirsWithInsert = [];
          var dirsWithPostpatch = [];
          var key, oldDir, dir;
          for (key in newDirs) {
            oldDir = oldDirs[key];
            dir = newDirs[key];
            if (!oldDir) {
              callHook$1(dir, "bind", vnode, oldVnode);
              if (dir.def && dir.def.inserted) {
                dirsWithInsert.push(dir);
              }
            } else {
              dir.oldValue = oldDir.value;
              dir.oldArg = oldDir.arg;
              callHook$1(dir, "update", vnode, oldVnode);
              if (dir.def && dir.def.componentUpdated) {
                dirsWithPostpatch.push(dir);
              }
            }
          }
          if (dirsWithInsert.length) {
            var callInsert = function() {
              for (var i = 0; i < dirsWithInsert.length; i++) {
                callHook$1(dirsWithInsert[i], "inserted", vnode, oldVnode);
              }
            };
            if (isCreate) {
              mergeVNodeHook(vnode, "insert", callInsert);
            } else {
              callInsert();
            }
          }
          if (dirsWithPostpatch.length) {
            mergeVNodeHook(vnode, "postpatch", function() {
              for (var i = 0; i < dirsWithPostpatch.length; i++) {
                callHook$1(dirsWithPostpatch[i], "componentUpdated", vnode, oldVnode);
              }
            });
          }
          if (!isCreate) {
            for (key in oldDirs) {
              if (!newDirs[key]) {
                callHook$1(oldDirs[key], "unbind", oldVnode, oldVnode, isDestroy);
              }
            }
          }
        }
        var emptyModifiers = /* @__PURE__ */ Object.create(null);
        function normalizeDirectives$1(dirs, vm) {
          var res = /* @__PURE__ */ Object.create(null);
          if (!dirs) {
            return res;
          }
          var i, dir;
          for (i = 0; i < dirs.length; i++) {
            dir = dirs[i];
            if (!dir.modifiers) {
              dir.modifiers = emptyModifiers;
            }
            res[getRawDirName(dir)] = dir;
            dir.def = resolveAsset(vm.$options, "directives", dir.name, true);
          }
          return res;
        }
        function getRawDirName(dir) {
          return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join(".");
        }
        function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
          var fn = dir.def && dir.def[hook];
          if (fn) {
            try {
              fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
            } catch (e) {
              handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
            }
          }
        }
        var baseModules = [
          ref2,
          directives
        ];
        function updateAttrs(oldVnode, vnode) {
          var opts2 = vnode.componentOptions;
          if (isDef(opts2) && opts2.Ctor.options.inheritAttrs === false) {
            return;
          }
          if (isUndef2(oldVnode.data.attrs) && isUndef2(vnode.data.attrs)) {
            return;
          }
          var key, cur, old;
          var elm = vnode.elm;
          var oldAttrs = oldVnode.data.attrs || {};
          var attrs2 = vnode.data.attrs || {};
          if (isDef(attrs2.__ob__)) {
            attrs2 = vnode.data.attrs = extend({}, attrs2);
          }
          for (key in attrs2) {
            cur = attrs2[key];
            old = oldAttrs[key];
            if (old !== cur) {
              setAttr(elm, key, cur, vnode.data.pre);
            }
          }
          if ((isIE || isEdge) && attrs2.value !== oldAttrs.value) {
            setAttr(elm, "value", attrs2.value);
          }
          for (key in oldAttrs) {
            if (isUndef2(attrs2[key])) {
              if (isXlink(key)) {
                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
              } else if (!isEnumeratedAttr(key)) {
                elm.removeAttribute(key);
              }
            }
          }
        }
        function setAttr(el, key, value, isInPre) {
          if (isInPre || el.tagName.indexOf("-") > -1) {
            baseSetAttr(el, key, value);
          } else if (isBooleanAttr(key)) {
            if (isFalsyAttrValue(value)) {
              el.removeAttribute(key);
            } else {
              value = key === "allowfullscreen" && el.tagName === "EMBED" ? "true" : key;
              el.setAttribute(key, value);
            }
          } else if (isEnumeratedAttr(key)) {
            el.setAttribute(key, convertEnumeratedValue(key, value));
          } else if (isXlink(key)) {
            if (isFalsyAttrValue(value)) {
              el.removeAttributeNS(xlinkNS, getXlinkProp(key));
            } else {
              el.setAttributeNS(xlinkNS, key, value);
            }
          } else {
            baseSetAttr(el, key, value);
          }
        }
        function baseSetAttr(el, key, value) {
          if (isFalsyAttrValue(value)) {
            el.removeAttribute(key);
          } else {
            if (isIE && !isIE9 && el.tagName === "TEXTAREA" && key === "placeholder" && value !== "" && !el.__ieph) {
              var blocker = function(e) {
                e.stopImmediatePropagation();
                el.removeEventListener("input", blocker);
              };
              el.addEventListener("input", blocker);
              el.__ieph = true;
            }
            el.setAttribute(key, value);
          }
        }
        var attrs = {
          create: updateAttrs,
          update: updateAttrs
        };
        function updateClass(oldVnode, vnode) {
          var el = vnode.elm;
          var data2 = vnode.data;
          var oldData = oldVnode.data;
          if (isUndef2(data2.staticClass) && isUndef2(data2.class) && (isUndef2(oldData) || isUndef2(oldData.staticClass) && isUndef2(oldData.class))) {
            return;
          }
          var cls = genClassForVnode(vnode);
          var transitionClass = el._transitionClasses;
          if (isDef(transitionClass)) {
            cls = concat(cls, stringifyClass(transitionClass));
          }
          if (cls !== el._prevClass) {
            el.setAttribute("class", cls);
            el._prevClass = cls;
          }
        }
        var klass = {
          create: updateClass,
          update: updateClass
        };
        var validDivisionCharRE = /[\w).+\-_$\]]/;
        function parseFilters(exp) {
          var inSingle = false;
          var inDouble = false;
          var inTemplateString = false;
          var inRegex = false;
          var curly = 0;
          var square = 0;
          var paren = 0;
          var lastFilterIndex = 0;
          var c, prev, i, expression, filters;
          for (i = 0; i < exp.length; i++) {
            prev = c;
            c = exp.charCodeAt(i);
            if (inSingle) {
              if (c === 39 && prev !== 92) {
                inSingle = false;
              }
            } else if (inDouble) {
              if (c === 34 && prev !== 92) {
                inDouble = false;
              }
            } else if (inTemplateString) {
              if (c === 96 && prev !== 92) {
                inTemplateString = false;
              }
            } else if (inRegex) {
              if (c === 47 && prev !== 92) {
                inRegex = false;
              }
            } else if (c === 124 && exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
              if (expression === void 0) {
                lastFilterIndex = i + 1;
                expression = exp.slice(0, i).trim();
              } else {
                pushFilter();
              }
            } else {
              switch (c) {
                case 34:
                  inDouble = true;
                  break;
                case 39:
                  inSingle = true;
                  break;
                case 96:
                  inTemplateString = true;
                  break;
                case 40:
                  paren++;
                  break;
                case 41:
                  paren--;
                  break;
                case 91:
                  square++;
                  break;
                case 93:
                  square--;
                  break;
                case 123:
                  curly++;
                  break;
                case 125:
                  curly--;
                  break;
              }
              if (c === 47) {
                var j = i - 1;
                var p2 = void 0;
                for (; j >= 0; j--) {
                  p2 = exp.charAt(j);
                  if (p2 !== " ") {
                    break;
                  }
                }
                if (!p2 || !validDivisionCharRE.test(p2)) {
                  inRegex = true;
                }
              }
            }
          }
          if (expression === void 0) {
            expression = exp.slice(0, i).trim();
          } else if (lastFilterIndex !== 0) {
            pushFilter();
          }
          function pushFilter() {
            (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
            lastFilterIndex = i + 1;
          }
          if (filters) {
            for (i = 0; i < filters.length; i++) {
              expression = wrapFilter(expression, filters[i]);
            }
          }
          return expression;
        }
        function wrapFilter(exp, filter) {
          var i = filter.indexOf("(");
          if (i < 0) {
            return '_f("' + filter + '")(' + exp + ")";
          } else {
            var name = filter.slice(0, i);
            var args = filter.slice(i + 1);
            return '_f("' + name + '")(' + exp + (args !== ")" ? "," + args : args);
          }
        }
        function baseWarn(msg, range2) {
          console.error("[Vue compiler]: " + msg);
        }
        function pluckModuleFunction(modules2, key) {
          return modules2 ? modules2.map(function(m) {
            return m[key];
          }).filter(function(_) {
            return _;
          }) : [];
        }
        function addProp(el, name, value, range2, dynamic) {
          (el.props || (el.props = [])).push(rangeSetItem({ name, value, dynamic }, range2));
          el.plain = false;
        }
        function addAttr(el, name, value, range2, dynamic) {
          var attrs2 = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
          attrs2.push(rangeSetItem({ name, value, dynamic }, range2));
          el.plain = false;
        }
        function addRawAttr(el, name, value, range2) {
          el.attrsMap[name] = value;
          el.attrsList.push(rangeSetItem({ name, value }, range2));
        }
        function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range2) {
          (el.directives || (el.directives = [])).push(rangeSetItem({
            name,
            rawName,
            value,
            arg,
            isDynamicArg,
            modifiers
          }, range2));
          el.plain = false;
        }
        function prependModifierMarker(symbol, name, dynamic) {
          return dynamic ? "_p(" + name + ',"' + symbol + '")' : symbol + name;
        }
        function addHandler(el, name, value, modifiers, important, warn3, range2, dynamic) {
          modifiers = modifiers || emptyObject;
          if (warn3 && modifiers.prevent && modifiers.passive) {
            warn3("passive and prevent can't be used together. Passive handler can't prevent default event.", range2);
          }
          if (modifiers.right) {
            if (dynamic) {
              name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
            } else if (name === "click") {
              name = "contextmenu";
              delete modifiers.right;
            }
          } else if (modifiers.middle) {
            if (dynamic) {
              name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
            } else if (name === "click") {
              name = "mouseup";
            }
          }
          if (modifiers.capture) {
            delete modifiers.capture;
            name = prependModifierMarker("!", name, dynamic);
          }
          if (modifiers.once) {
            delete modifiers.once;
            name = prependModifierMarker("~", name, dynamic);
          }
          if (modifiers.passive) {
            delete modifiers.passive;
            name = prependModifierMarker("&", name, dynamic);
          }
          var events2;
          if (modifiers.native) {
            delete modifiers.native;
            events2 = el.nativeEvents || (el.nativeEvents = {});
          } else {
            events2 = el.events || (el.events = {});
          }
          var newHandler = rangeSetItem({ value: value.trim(), dynamic }, range2);
          if (modifiers !== emptyObject) {
            newHandler.modifiers = modifiers;
          }
          var handlers = events2[name];
          if (Array.isArray(handlers)) {
            important ? handlers.unshift(newHandler) : handlers.push(newHandler);
          } else if (handlers) {
            events2[name] = important ? [newHandler, handlers] : [handlers, newHandler];
          } else {
            events2[name] = newHandler;
          }
          el.plain = false;
        }
        function getRawBindingAttr(el, name) {
          return el.rawAttrsMap[":" + name] || el.rawAttrsMap["v-bind:" + name] || el.rawAttrsMap[name];
        }
        function getBindingAttr(el, name, getStatic) {
          var dynamicValue = getAndRemoveAttr(el, ":" + name) || getAndRemoveAttr(el, "v-bind:" + name);
          if (dynamicValue != null) {
            return parseFilters(dynamicValue);
          } else if (getStatic !== false) {
            var staticValue = getAndRemoveAttr(el, name);
            if (staticValue != null) {
              return JSON.stringify(staticValue);
            }
          }
        }
        function getAndRemoveAttr(el, name, removeFromMap) {
          var val;
          if ((val = el.attrsMap[name]) != null) {
            var list = el.attrsList;
            for (var i = 0, l = list.length; i < l; i++) {
              if (list[i].name === name) {
                list.splice(i, 1);
                break;
              }
            }
          }
          if (removeFromMap) {
            delete el.attrsMap[name];
          }
          return val;
        }
        function getAndRemoveAttrByRegex(el, name) {
          var list = el.attrsList;
          for (var i = 0, l = list.length; i < l; i++) {
            var attr = list[i];
            if (name.test(attr.name)) {
              list.splice(i, 1);
              return attr;
            }
          }
        }
        function rangeSetItem(item, range2) {
          if (range2) {
            if (range2.start != null) {
              item.start = range2.start;
            }
            if (range2.end != null) {
              item.end = range2.end;
            }
          }
          return item;
        }
        function genComponentModel(el, value, modifiers) {
          var ref3 = modifiers || {};
          var number = ref3.number;
          var trim = ref3.trim;
          var baseValueExpression = "$$v";
          var valueExpression = baseValueExpression;
          if (trim) {
            valueExpression = "(typeof " + baseValueExpression + " === 'string'? " + baseValueExpression + ".trim(): " + baseValueExpression + ")";
          }
          if (number) {
            valueExpression = "_n(" + valueExpression + ")";
          }
          var assignment = genAssignmentCode(value, valueExpression);
          el.model = {
            value: "(" + value + ")",
            expression: JSON.stringify(value),
            callback: "function (" + baseValueExpression + ") {" + assignment + "}"
          };
        }
        function genAssignmentCode(value, assignment) {
          var res = parseModel(value);
          if (res.key === null) {
            return value + "=" + assignment;
          } else {
            return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
          }
        }
        var len, str, chr, index$1, expressionPos, expressionEndPos;
        function parseModel(val) {
          val = val.trim();
          len = val.length;
          if (val.indexOf("[") < 0 || val.lastIndexOf("]") < len - 1) {
            index$1 = val.lastIndexOf(".");
            if (index$1 > -1) {
              return {
                exp: val.slice(0, index$1),
                key: '"' + val.slice(index$1 + 1) + '"'
              };
            } else {
              return {
                exp: val,
                key: null
              };
            }
          }
          str = val;
          index$1 = expressionPos = expressionEndPos = 0;
          while (!eof()) {
            chr = next();
            if (isStringStart(chr)) {
              parseString(chr);
            } else if (chr === 91) {
              parseBracket(chr);
            }
          }
          return {
            exp: val.slice(0, expressionPos),
            key: val.slice(expressionPos + 1, expressionEndPos)
          };
        }
        function next() {
          return str.charCodeAt(++index$1);
        }
        function eof() {
          return index$1 >= len;
        }
        function isStringStart(chr2) {
          return chr2 === 34 || chr2 === 39;
        }
        function parseBracket(chr2) {
          var inBracket = 1;
          expressionPos = index$1;
          while (!eof()) {
            chr2 = next();
            if (isStringStart(chr2)) {
              parseString(chr2);
              continue;
            }
            if (chr2 === 91) {
              inBracket++;
            }
            if (chr2 === 93) {
              inBracket--;
            }
            if (inBracket === 0) {
              expressionEndPos = index$1;
              break;
            }
          }
        }
        function parseString(chr2) {
          var stringQuote = chr2;
          while (!eof()) {
            chr2 = next();
            if (chr2 === stringQuote) {
              break;
            }
          }
        }
        var warn$12;
        var RANGE_TOKEN = "__r";
        var CHECKBOX_RADIO_TOKEN = "__c";
        function model(el, dir, _warn) {
          warn$12 = _warn;
          var value = dir.value;
          var modifiers = dir.modifiers;
          var tag = el.tag;
          var type = el.attrsMap.type;
          {
            if (tag === "input" && type === "file") {
              warn$12("<" + el.tag + ' v-model="' + value + '" type="file">:\nFile inputs are read only. Use a v-on:change listener instead.', el.rawAttrsMap["v-model"]);
            }
          }
          if (el.component) {
            genComponentModel(el, value, modifiers);
            return false;
          } else if (tag === "select") {
            genSelect(el, value, modifiers);
          } else if (tag === "input" && type === "checkbox") {
            genCheckboxModel(el, value, modifiers);
          } else if (tag === "input" && type === "radio") {
            genRadioModel(el, value, modifiers);
          } else if (tag === "input" || tag === "textarea") {
            genDefaultModel(el, value, modifiers);
          } else if (!config.isReservedTag(tag)) {
            genComponentModel(el, value, modifiers);
            return false;
          } else {
            warn$12("<" + el.tag + ' v-model="' + value + `">: v-model is not supported on this element type. If you are working with contenteditable, it's recommended to wrap a library dedicated for that purpose inside a custom component.`, el.rawAttrsMap["v-model"]);
          }
          return true;
        }
        function genCheckboxModel(el, value, modifiers) {
          var number = modifiers && modifiers.number;
          var valueBinding = getBindingAttr(el, "value") || "null";
          var trueValueBinding = getBindingAttr(el, "true-value") || "true";
          var falseValueBinding = getBindingAttr(el, "false-value") || "false";
          addProp(el, "checked", "Array.isArray(" + value + ")?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === "true" ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
          addHandler(el, "change", "var $$a=" + value + ",$$el=$event.target,$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");if(Array.isArray($$a)){var $$v=" + (number ? "_n(" + valueBinding + ")" : valueBinding) + ",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&(" + genAssignmentCode(value, "$$a.concat([$$v])") + ")}else{$$i>-1&&(" + genAssignmentCode(value, "$$a.slice(0,$$i).concat($$a.slice($$i+1))") + ")}}else{" + genAssignmentCode(value, "$$c") + "}", null, true);
        }
        function genRadioModel(el, value, modifiers) {
          var number = modifiers && modifiers.number;
          var valueBinding = getBindingAttr(el, "value") || "null";
          valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
          addProp(el, "checked", "_q(" + value + "," + valueBinding + ")");
          addHandler(el, "change", genAssignmentCode(value, valueBinding), null, true);
        }
        function genSelect(el, value, modifiers) {
          var number = modifiers && modifiers.number;
          var selectedVal = 'Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return ' + (number ? "_n(val)" : "val") + "})";
          var assignment = "$event.target.multiple ? $$selectedVal : $$selectedVal[0]";
          var code = "var $$selectedVal = " + selectedVal + ";";
          code = code + " " + genAssignmentCode(value, assignment);
          addHandler(el, "change", code, null, true);
        }
        function genDefaultModel(el, value, modifiers) {
          var type = el.attrsMap.type;
          {
            var value$1 = el.attrsMap["v-bind:value"] || el.attrsMap[":value"];
            var typeBinding = el.attrsMap["v-bind:type"] || el.attrsMap[":type"];
            if (value$1 && !typeBinding) {
              var binding = el.attrsMap["v-bind:value"] ? "v-bind:value" : ":value";
              warn$12(binding + '="' + value$1 + '" conflicts with v-model on the same element because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
            }
          }
          var ref3 = modifiers || {};
          var lazy = ref3.lazy;
          var number = ref3.number;
          var trim = ref3.trim;
          var needCompositionGuard = !lazy && type !== "range";
          var event = lazy ? "change" : type === "range" ? RANGE_TOKEN : "input";
          var valueExpression = "$event.target.value";
          if (trim) {
            valueExpression = "$event.target.value.trim()";
          }
          if (number) {
            valueExpression = "_n(" + valueExpression + ")";
          }
          var code = genAssignmentCode(value, valueExpression);
          if (needCompositionGuard) {
            code = "if($event.target.composing)return;" + code;
          }
          addProp(el, "value", "(" + value + ")");
          addHandler(el, event, code, null, true);
          if (trim || number) {
            addHandler(el, "blur", "$forceUpdate()");
          }
        }
        function normalizeEvents(on2) {
          if (isDef(on2[RANGE_TOKEN])) {
            var event = isIE ? "change" : "input";
            on2[event] = [].concat(on2[RANGE_TOKEN], on2[event] || []);
            delete on2[RANGE_TOKEN];
          }
          if (isDef(on2[CHECKBOX_RADIO_TOKEN])) {
            on2.change = [].concat(on2[CHECKBOX_RADIO_TOKEN], on2.change || []);
            delete on2[CHECKBOX_RADIO_TOKEN];
          }
        }
        var target$1;
        function createOnceHandler$1(event, handler2, capture) {
          var _target = target$1;
          return function onceHandler() {
            var res = handler2.apply(null, arguments);
            if (res !== null) {
              remove$2(event, onceHandler, capture, _target);
            }
          };
        }
        var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
        function add$1(name, handler2, capture, passive) {
          if (useMicrotaskFix) {
            var attachedTimestamp = currentFlushTimestamp;
            var original = handler2;
            handler2 = original._wrapper = function(e) {
              if (e.target === e.currentTarget || e.timeStamp >= attachedTimestamp || e.timeStamp <= 0 || e.target.ownerDocument !== document) {
                return original.apply(this, arguments);
              }
            };
          }
          target$1.addEventListener(name, handler2, supportsPassive ? { capture, passive } : capture);
        }
        function remove$2(name, handler2, capture, _target) {
          (_target || target$1).removeEventListener(name, handler2._wrapper || handler2, capture);
        }
        function updateDOMListeners(oldVnode, vnode) {
          if (isUndef2(oldVnode.data.on) && isUndef2(vnode.data.on)) {
            return;
          }
          var on2 = vnode.data.on || {};
          var oldOn = oldVnode.data.on || {};
          target$1 = vnode.elm;
          normalizeEvents(on2);
          updateListeners(on2, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
          target$1 = void 0;
        }
        var events = {
          create: updateDOMListeners,
          update: updateDOMListeners
        };
        var svgContainer;
        function updateDOMProps(oldVnode, vnode) {
          if (isUndef2(oldVnode.data.domProps) && isUndef2(vnode.data.domProps)) {
            return;
          }
          var key, cur;
          var elm = vnode.elm;
          var oldProps = oldVnode.data.domProps || {};
          var props3 = vnode.data.domProps || {};
          if (isDef(props3.__ob__)) {
            props3 = vnode.data.domProps = extend({}, props3);
          }
          for (key in oldProps) {
            if (!(key in props3)) {
              elm[key] = "";
            }
          }
          for (key in props3) {
            cur = props3[key];
            if (key === "textContent" || key === "innerHTML") {
              if (vnode.children) {
                vnode.children.length = 0;
              }
              if (cur === oldProps[key]) {
                continue;
              }
              if (elm.childNodes.length === 1) {
                elm.removeChild(elm.childNodes[0]);
              }
            }
            if (key === "value" && elm.tagName !== "PROGRESS") {
              elm._value = cur;
              var strCur = isUndef2(cur) ? "" : String(cur);
              if (shouldUpdateValue(elm, strCur)) {
                elm.value = strCur;
              }
            } else if (key === "innerHTML" && isSVG(elm.tagName) && isUndef2(elm.innerHTML)) {
              svgContainer = svgContainer || document.createElement("div");
              svgContainer.innerHTML = "<svg>" + cur + "</svg>";
              var svg = svgContainer.firstChild;
              while (elm.firstChild) {
                elm.removeChild(elm.firstChild);
              }
              while (svg.firstChild) {
                elm.appendChild(svg.firstChild);
              }
            } else if (cur !== oldProps[key]) {
              try {
                elm[key] = cur;
              } catch (e) {
              }
            }
          }
        }
        function shouldUpdateValue(elm, checkVal) {
          return !elm.composing && (elm.tagName === "OPTION" || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
        }
        function isNotInFocusAndDirty(elm, checkVal) {
          var notInFocus = true;
          try {
            notInFocus = document.activeElement !== elm;
          } catch (e) {
          }
          return notInFocus && elm.value !== checkVal;
        }
        function isDirtyWithModifiers(elm, newVal) {
          var value = elm.value;
          var modifiers = elm._vModifiers;
          if (isDef(modifiers)) {
            if (modifiers.number) {
              return toNumber(value) !== toNumber(newVal);
            }
            if (modifiers.trim) {
              return value.trim() !== newVal.trim();
            }
          }
          return value !== newVal;
        }
        var domProps = {
          create: updateDOMProps,
          update: updateDOMProps
        };
        var parseStyleText = cached(function(cssText) {
          var res = {};
          var listDelimiter = /;(?![^(]*\))/g;
          var propertyDelimiter = /:(.+)/;
          cssText.split(listDelimiter).forEach(function(item) {
            if (item) {
              var tmp = item.split(propertyDelimiter);
              tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
            }
          });
          return res;
        });
        function normalizeStyleData(data2) {
          var style2 = normalizeStyleBinding(data2.style);
          return data2.staticStyle ? extend(data2.staticStyle, style2) : style2;
        }
        function normalizeStyleBinding(bindingStyle) {
          if (Array.isArray(bindingStyle)) {
            return toObject(bindingStyle);
          }
          if (typeof bindingStyle === "string") {
            return parseStyleText(bindingStyle);
          }
          return bindingStyle;
        }
        function getStyle(vnode, checkChild) {
          var res = {};
          var styleData;
          if (checkChild) {
            var childNode = vnode;
            while (childNode.componentInstance) {
              childNode = childNode.componentInstance._vnode;
              if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
                extend(res, styleData);
              }
            }
          }
          if (styleData = normalizeStyleData(vnode.data)) {
            extend(res, styleData);
          }
          var parentNode2 = vnode;
          while (parentNode2 = parentNode2.parent) {
            if (parentNode2.data && (styleData = normalizeStyleData(parentNode2.data))) {
              extend(res, styleData);
            }
          }
          return res;
        }
        var cssVarRE = /^--/;
        var importantRE = /\s*!important$/;
        var setProp = function(el, name, val) {
          if (cssVarRE.test(name)) {
            el.style.setProperty(name, val);
          } else if (importantRE.test(val)) {
            el.style.setProperty(hyphenate(name), val.replace(importantRE, ""), "important");
          } else {
            var normalizedName = normalize(name);
            if (Array.isArray(val)) {
              for (var i = 0, len2 = val.length; i < len2; i++) {
                el.style[normalizedName] = val[i];
              }
            } else {
              el.style[normalizedName] = val;
            }
          }
        };
        var vendorNames = ["Webkit", "Moz", "ms"];
        var emptyStyle;
        var normalize = cached(function(prop) {
          emptyStyle = emptyStyle || document.createElement("div").style;
          prop = camelize(prop);
          if (prop !== "filter" && prop in emptyStyle) {
            return prop;
          }
          var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
          for (var i = 0; i < vendorNames.length; i++) {
            var name = vendorNames[i] + capName;
            if (name in emptyStyle) {
              return name;
            }
          }
        });
        function updateStyle(oldVnode, vnode) {
          var data2 = vnode.data;
          var oldData = oldVnode.data;
          if (isUndef2(data2.staticStyle) && isUndef2(data2.style) && isUndef2(oldData.staticStyle) && isUndef2(oldData.style)) {
            return;
          }
          var cur, name;
          var el = vnode.elm;
          var oldStaticStyle = oldData.staticStyle;
          var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
          var oldStyle = oldStaticStyle || oldStyleBinding;
          var style2 = normalizeStyleBinding(vnode.data.style) || {};
          vnode.data.normalizedStyle = isDef(style2.__ob__) ? extend({}, style2) : style2;
          var newStyle = getStyle(vnode, true);
          for (name in oldStyle) {
            if (isUndef2(newStyle[name])) {
              setProp(el, name, "");
            }
          }
          for (name in newStyle) {
            cur = newStyle[name];
            if (cur !== oldStyle[name]) {
              setProp(el, name, cur == null ? "" : cur);
            }
          }
        }
        var style = {
          create: updateStyle,
          update: updateStyle
        };
        var whitespaceRE = /\s+/;
        function addClass(el, cls) {
          if (!cls || !(cls = cls.trim())) {
            return;
          }
          if (el.classList) {
            if (cls.indexOf(" ") > -1) {
              cls.split(whitespaceRE).forEach(function(c) {
                return el.classList.add(c);
              });
            } else {
              el.classList.add(cls);
            }
          } else {
            var cur = " " + (el.getAttribute("class") || "") + " ";
            if (cur.indexOf(" " + cls + " ") < 0) {
              el.setAttribute("class", (cur + cls).trim());
            }
          }
        }
        function removeClass(el, cls) {
          if (!cls || !(cls = cls.trim())) {
            return;
          }
          if (el.classList) {
            if (cls.indexOf(" ") > -1) {
              cls.split(whitespaceRE).forEach(function(c) {
                return el.classList.remove(c);
              });
            } else {
              el.classList.remove(cls);
            }
            if (!el.classList.length) {
              el.removeAttribute("class");
            }
          } else {
            var cur = " " + (el.getAttribute("class") || "") + " ";
            var tar = " " + cls + " ";
            while (cur.indexOf(tar) >= 0) {
              cur = cur.replace(tar, " ");
            }
            cur = cur.trim();
            if (cur) {
              el.setAttribute("class", cur);
            } else {
              el.removeAttribute("class");
            }
          }
        }
        function resolveTransition(def$$1) {
          if (!def$$1) {
            return;
          }
          if (typeof def$$1 === "object") {
            var res = {};
            if (def$$1.css !== false) {
              extend(res, autoCssTransition(def$$1.name || "v"));
            }
            extend(res, def$$1);
            return res;
          } else if (typeof def$$1 === "string") {
            return autoCssTransition(def$$1);
          }
        }
        var autoCssTransition = cached(function(name) {
          return {
            enterClass: name + "-enter",
            enterToClass: name + "-enter-to",
            enterActiveClass: name + "-enter-active",
            leaveClass: name + "-leave",
            leaveToClass: name + "-leave-to",
            leaveActiveClass: name + "-leave-active"
          };
        });
        var hasTransition = inBrowser && !isIE9;
        var TRANSITION = "transition";
        var ANIMATION = "animation";
        var transitionProp = "transition";
        var transitionEndEvent = "transitionend";
        var animationProp = "animation";
        var animationEndEvent = "animationend";
        if (hasTransition) {
          if (window.ontransitionend === void 0 && window.onwebkittransitionend !== void 0) {
            transitionProp = "WebkitTransition";
            transitionEndEvent = "webkitTransitionEnd";
          }
          if (window.onanimationend === void 0 && window.onwebkitanimationend !== void 0) {
            animationProp = "WebkitAnimation";
            animationEndEvent = "webkitAnimationEnd";
          }
        }
        var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function(fn) {
          return fn();
        };
        function nextFrame(fn) {
          raf(function() {
            raf(fn);
          });
        }
        function addTransitionClass(el, cls) {
          var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
          if (transitionClasses.indexOf(cls) < 0) {
            transitionClasses.push(cls);
            addClass(el, cls);
          }
        }
        function removeTransitionClass(el, cls) {
          if (el._transitionClasses) {
            remove(el._transitionClasses, cls);
          }
          removeClass(el, cls);
        }
        function whenTransitionEnds(el, expectedType, cb) {
          var ref3 = getTransitionInfo(el, expectedType);
          var type = ref3.type;
          var timeout = ref3.timeout;
          var propCount = ref3.propCount;
          if (!type) {
            return cb();
          }
          var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
          var ended = 0;
          var end = function() {
            el.removeEventListener(event, onEnd);
            cb();
          };
          var onEnd = function(e) {
            if (e.target === el) {
              if (++ended >= propCount) {
                end();
              }
            }
          };
          setTimeout(function() {
            if (ended < propCount) {
              end();
            }
          }, timeout + 1);
          el.addEventListener(event, onEnd);
        }
        var transformRE = /\b(transform|all)(,|$)/;
        function getTransitionInfo(el, expectedType) {
          var styles = window.getComputedStyle(el);
          var transitionDelays = (styles[transitionProp + "Delay"] || "").split(", ");
          var transitionDurations = (styles[transitionProp + "Duration"] || "").split(", ");
          var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
          var animationDelays = (styles[animationProp + "Delay"] || "").split(", ");
          var animationDurations = (styles[animationProp + "Duration"] || "").split(", ");
          var animationTimeout = getTimeout(animationDelays, animationDurations);
          var type;
          var timeout = 0;
          var propCount = 0;
          if (expectedType === TRANSITION) {
            if (transitionTimeout > 0) {
              type = TRANSITION;
              timeout = transitionTimeout;
              propCount = transitionDurations.length;
            }
          } else if (expectedType === ANIMATION) {
            if (animationTimeout > 0) {
              type = ANIMATION;
              timeout = animationTimeout;
              propCount = animationDurations.length;
            }
          } else {
            timeout = Math.max(transitionTimeout, animationTimeout);
            type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
            propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
          }
          var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + "Property"]);
          return {
            type,
            timeout,
            propCount,
            hasTransform
          };
        }
        function getTimeout(delays, durations) {
          while (delays.length < durations.length) {
            delays = delays.concat(delays);
          }
          return Math.max.apply(null, durations.map(function(d, i) {
            return toMs(d) + toMs(delays[i]);
          }));
        }
        function toMs(s) {
          return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
        }
        function enter(vnode, toggleDisplay) {
          var el = vnode.elm;
          if (isDef(el._leaveCb)) {
            el._leaveCb.cancelled = true;
            el._leaveCb();
          }
          var data2 = resolveTransition(vnode.data.transition);
          if (isUndef2(data2)) {
            return;
          }
          if (isDef(el._enterCb) || el.nodeType !== 1) {
            return;
          }
          var css = data2.css;
          var type = data2.type;
          var enterClass = data2.enterClass;
          var enterToClass = data2.enterToClass;
          var enterActiveClass = data2.enterActiveClass;
          var appearClass = data2.appearClass;
          var appearToClass = data2.appearToClass;
          var appearActiveClass = data2.appearActiveClass;
          var beforeEnter = data2.beforeEnter;
          var enter2 = data2.enter;
          var afterEnter = data2.afterEnter;
          var enterCancelled = data2.enterCancelled;
          var beforeAppear = data2.beforeAppear;
          var appear = data2.appear;
          var afterAppear = data2.afterAppear;
          var appearCancelled = data2.appearCancelled;
          var duration = data2.duration;
          var context = activeInstance;
          var transitionNode = activeInstance.$vnode;
          while (transitionNode && transitionNode.parent) {
            context = transitionNode.context;
            transitionNode = transitionNode.parent;
          }
          var isAppear = !context._isMounted || !vnode.isRootInsert;
          if (isAppear && !appear && appear !== "") {
            return;
          }
          var startClass = isAppear && appearClass ? appearClass : enterClass;
          var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
          var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
          var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
          var enterHook = isAppear ? typeof appear === "function" ? appear : enter2 : enter2;
          var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
          var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
          var explicitEnterDuration = toNumber(isObject2(duration) ? duration.enter : duration);
          if (explicitEnterDuration != null) {
            checkDuration(explicitEnterDuration, "enter", vnode);
          }
          var expectsCSS = css !== false && !isIE9;
          var userWantsControl = getHookArgumentsLength(enterHook);
          var cb = el._enterCb = once(function() {
            if (expectsCSS) {
              removeTransitionClass(el, toClass);
              removeTransitionClass(el, activeClass);
            }
            if (cb.cancelled) {
              if (expectsCSS) {
                removeTransitionClass(el, startClass);
              }
              enterCancelledHook && enterCancelledHook(el);
            } else {
              afterEnterHook && afterEnterHook(el);
            }
            el._enterCb = null;
          });
          if (!vnode.data.show) {
            mergeVNodeHook(vnode, "insert", function() {
              var parent = el.parentNode;
              var pendingNode = parent && parent._pending && parent._pending[vnode.key];
              if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
                pendingNode.elm._leaveCb();
              }
              enterHook && enterHook(el, cb);
            });
          }
          beforeEnterHook && beforeEnterHook(el);
          if (expectsCSS) {
            addTransitionClass(el, startClass);
            addTransitionClass(el, activeClass);
            nextFrame(function() {
              removeTransitionClass(el, startClass);
              if (!cb.cancelled) {
                addTransitionClass(el, toClass);
                if (!userWantsControl) {
                  if (isValidDuration(explicitEnterDuration)) {
                    setTimeout(cb, explicitEnterDuration);
                  } else {
                    whenTransitionEnds(el, type, cb);
                  }
                }
              }
            });
          }
          if (vnode.data.show) {
            toggleDisplay && toggleDisplay();
            enterHook && enterHook(el, cb);
          }
          if (!expectsCSS && !userWantsControl) {
            cb();
          }
        }
        function leave(vnode, rm) {
          var el = vnode.elm;
          if (isDef(el._enterCb)) {
            el._enterCb.cancelled = true;
            el._enterCb();
          }
          var data2 = resolveTransition(vnode.data.transition);
          if (isUndef2(data2) || el.nodeType !== 1) {
            return rm();
          }
          if (isDef(el._leaveCb)) {
            return;
          }
          var css = data2.css;
          var type = data2.type;
          var leaveClass = data2.leaveClass;
          var leaveToClass = data2.leaveToClass;
          var leaveActiveClass = data2.leaveActiveClass;
          var beforeLeave = data2.beforeLeave;
          var leave2 = data2.leave;
          var afterLeave = data2.afterLeave;
          var leaveCancelled = data2.leaveCancelled;
          var delayLeave = data2.delayLeave;
          var duration = data2.duration;
          var expectsCSS = css !== false && !isIE9;
          var userWantsControl = getHookArgumentsLength(leave2);
          var explicitLeaveDuration = toNumber(isObject2(duration) ? duration.leave : duration);
          if (isDef(explicitLeaveDuration)) {
            checkDuration(explicitLeaveDuration, "leave", vnode);
          }
          var cb = el._leaveCb = once(function() {
            if (el.parentNode && el.parentNode._pending) {
              el.parentNode._pending[vnode.key] = null;
            }
            if (expectsCSS) {
              removeTransitionClass(el, leaveToClass);
              removeTransitionClass(el, leaveActiveClass);
            }
            if (cb.cancelled) {
              if (expectsCSS) {
                removeTransitionClass(el, leaveClass);
              }
              leaveCancelled && leaveCancelled(el);
            } else {
              rm();
              afterLeave && afterLeave(el);
            }
            el._leaveCb = null;
          });
          if (delayLeave) {
            delayLeave(performLeave);
          } else {
            performLeave();
          }
          function performLeave() {
            if (cb.cancelled) {
              return;
            }
            if (!vnode.data.show && el.parentNode) {
              (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
            }
            beforeLeave && beforeLeave(el);
            if (expectsCSS) {
              addTransitionClass(el, leaveClass);
              addTransitionClass(el, leaveActiveClass);
              nextFrame(function() {
                removeTransitionClass(el, leaveClass);
                if (!cb.cancelled) {
                  addTransitionClass(el, leaveToClass);
                  if (!userWantsControl) {
                    if (isValidDuration(explicitLeaveDuration)) {
                      setTimeout(cb, explicitLeaveDuration);
                    } else {
                      whenTransitionEnds(el, type, cb);
                    }
                  }
                }
              });
            }
            leave2 && leave2(el, cb);
            if (!expectsCSS && !userWantsControl) {
              cb();
            }
          }
        }
        function checkDuration(val, name, vnode) {
          if (typeof val !== "number") {
            warn2("<transition> explicit " + name + " duration is not a valid number - got " + JSON.stringify(val) + ".", vnode.context);
          } else if (isNaN(val)) {
            warn2("<transition> explicit " + name + " duration is NaN - the duration expression might be incorrect.", vnode.context);
          }
        }
        function isValidDuration(val) {
          return typeof val === "number" && !isNaN(val);
        }
        function getHookArgumentsLength(fn) {
          if (isUndef2(fn)) {
            return false;
          }
          var invokerFns = fn.fns;
          if (isDef(invokerFns)) {
            return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
          } else {
            return (fn._length || fn.length) > 1;
          }
        }
        function _enter(_, vnode) {
          if (vnode.data.show !== true) {
            enter(vnode);
          }
        }
        var transition = inBrowser ? {
          create: _enter,
          activate: _enter,
          remove: function remove$$1(vnode, rm) {
            if (vnode.data.show !== true) {
              leave(vnode, rm);
            } else {
              rm();
            }
          }
        } : {};
        var platformModules = [
          attrs,
          klass,
          events,
          domProps,
          style,
          transition
        ];
        var modules = platformModules.concat(baseModules);
        var patch = createPatchFunction({ nodeOps, modules });
        if (isIE9) {
          document.addEventListener("selectionchange", function() {
            var el = document.activeElement;
            if (el && el.vmodel) {
              trigger(el, "input");
            }
          });
        }
        var directive2 = {
          inserted: function inserted(el, binding, vnode, oldVnode) {
            if (vnode.tag === "select") {
              if (oldVnode.elm && !oldVnode.elm._vOptions) {
                mergeVNodeHook(vnode, "postpatch", function() {
                  directive2.componentUpdated(el, binding, vnode);
                });
              } else {
                setSelected(el, binding, vnode.context);
              }
              el._vOptions = [].map.call(el.options, getValue);
            } else if (vnode.tag === "textarea" || isTextInputType(el.type)) {
              el._vModifiers = binding.modifiers;
              if (!binding.modifiers.lazy) {
                el.addEventListener("compositionstart", onCompositionStart);
                el.addEventListener("compositionend", onCompositionEnd);
                el.addEventListener("change", onCompositionEnd);
                if (isIE9) {
                  el.vmodel = true;
                }
              }
            }
          },
          componentUpdated: function componentUpdated(el, binding, vnode) {
            if (vnode.tag === "select") {
              setSelected(el, binding, vnode.context);
              var prevOptions = el._vOptions;
              var curOptions = el._vOptions = [].map.call(el.options, getValue);
              if (curOptions.some(function(o, i) {
                return !looseEqual(o, prevOptions[i]);
              })) {
                var needReset = el.multiple ? binding.value.some(function(v) {
                  return hasNoMatchingOption(v, curOptions);
                }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
                if (needReset) {
                  trigger(el, "change");
                }
              }
            }
          }
        };
        function setSelected(el, binding, vm) {
          actuallySetSelected(el, binding, vm);
          if (isIE || isEdge) {
            setTimeout(function() {
              actuallySetSelected(el, binding, vm);
            }, 0);
          }
        }
        function actuallySetSelected(el, binding, vm) {
          var value = binding.value;
          var isMultiple = el.multiple;
          if (isMultiple && !Array.isArray(value)) {
            warn2('<select multiple v-model="' + binding.expression + '"> expects an Array value for its binding, but got ' + Object.prototype.toString.call(value).slice(8, -1), vm);
            return;
          }
          var selected, option;
          for (var i = 0, l = el.options.length; i < l; i++) {
            option = el.options[i];
            if (isMultiple) {
              selected = looseIndexOf(value, getValue(option)) > -1;
              if (option.selected !== selected) {
                option.selected = selected;
              }
            } else {
              if (looseEqual(getValue(option), value)) {
                if (el.selectedIndex !== i) {
                  el.selectedIndex = i;
                }
                return;
              }
            }
          }
          if (!isMultiple) {
            el.selectedIndex = -1;
          }
        }
        function hasNoMatchingOption(value, options) {
          return options.every(function(o) {
            return !looseEqual(o, value);
          });
        }
        function getValue(option) {
          return "_value" in option ? option._value : option.value;
        }
        function onCompositionStart(e) {
          e.target.composing = true;
        }
        function onCompositionEnd(e) {
          if (!e.target.composing) {
            return;
          }
          e.target.composing = false;
          trigger(e.target, "input");
        }
        function trigger(el, type) {
          var e = document.createEvent("HTMLEvents");
          e.initEvent(type, true, true);
          el.dispatchEvent(e);
        }
        function locateNode(vnode) {
          return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
        }
        var show = {
          bind: function bind2(el, ref3, vnode) {
            var value = ref3.value;
            vnode = locateNode(vnode);
            var transition$$1 = vnode.data && vnode.data.transition;
            var originalDisplay = el.__vOriginalDisplay = el.style.display === "none" ? "" : el.style.display;
            if (value && transition$$1) {
              vnode.data.show = true;
              enter(vnode, function() {
                el.style.display = originalDisplay;
              });
            } else {
              el.style.display = value ? originalDisplay : "none";
            }
          },
          update: function update(el, ref3, vnode) {
            var value = ref3.value;
            var oldValue = ref3.oldValue;
            if (!value === !oldValue) {
              return;
            }
            vnode = locateNode(vnode);
            var transition$$1 = vnode.data && vnode.data.transition;
            if (transition$$1) {
              vnode.data.show = true;
              if (value) {
                enter(vnode, function() {
                  el.style.display = el.__vOriginalDisplay;
                });
              } else {
                leave(vnode, function() {
                  el.style.display = "none";
                });
              }
            } else {
              el.style.display = value ? el.__vOriginalDisplay : "none";
            }
          },
          unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
            if (!isDestroy) {
              el.style.display = el.__vOriginalDisplay;
            }
          }
        };
        var platformDirectives = {
          model: directive2,
          show
        };
        var transitionProps = {
          name: String,
          appear: Boolean,
          css: Boolean,
          mode: String,
          type: String,
          enterClass: String,
          leaveClass: String,
          enterToClass: String,
          leaveToClass: String,
          enterActiveClass: String,
          leaveActiveClass: String,
          appearClass: String,
          appearActiveClass: String,
          appearToClass: String,
          duration: [Number, String, Object]
        };
        function getRealChild(vnode) {
          var compOptions = vnode && vnode.componentOptions;
          if (compOptions && compOptions.Ctor.options.abstract) {
            return getRealChild(getFirstComponentChild(compOptions.children));
          } else {
            return vnode;
          }
        }
        function extractTransitionData(comp) {
          var data2 = {};
          var options = comp.$options;
          for (var key in options.propsData) {
            data2[key] = comp[key];
          }
          var listeners = options._parentListeners;
          for (var key$1 in listeners) {
            data2[camelize(key$1)] = listeners[key$1];
          }
          return data2;
        }
        function placeholder(h, rawChild) {
          if (/\d-keep-alive$/.test(rawChild.tag)) {
            return h("keep-alive", {
              props: rawChild.componentOptions.propsData
            });
          }
        }
        function hasParentTransition(vnode) {
          while (vnode = vnode.parent) {
            if (vnode.data.transition) {
              return true;
            }
          }
        }
        function isSameChild(child, oldChild) {
          return oldChild.key === child.key && oldChild.tag === child.tag;
        }
        var isNotTextNode = function(c) {
          return c.tag || isAsyncPlaceholder(c);
        };
        var isVShowDirective = function(d) {
          return d.name === "show";
        };
        var Transition = {
          name: "transition",
          props: transitionProps,
          abstract: true,
          render: function render2(h) {
            var this$1 = this;
            var children = this.$slots.default;
            if (!children) {
              return;
            }
            children = children.filter(isNotTextNode);
            if (!children.length) {
              return;
            }
            if (children.length > 1) {
              warn2("<transition> can only be used on a single element. Use <transition-group> for lists.", this.$parent);
            }
            var mode = this.mode;
            if (mode && mode !== "in-out" && mode !== "out-in") {
              warn2("invalid <transition> mode: " + mode, this.$parent);
            }
            var rawChild = children[0];
            if (hasParentTransition(this.$vnode)) {
              return rawChild;
            }
            var child = getRealChild(rawChild);
            if (!child) {
              return rawChild;
            }
            if (this._leaving) {
              return placeholder(h, rawChild);
            }
            var id = "__transition-" + this._uid + "-";
            child.key = child.key == null ? child.isComment ? id + "comment" : id + child.tag : isPrimitive2(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
            var data2 = (child.data || (child.data = {})).transition = extractTransitionData(this);
            var oldRawChild = this._vnode;
            var oldChild = getRealChild(oldRawChild);
            if (child.data.directives && child.data.directives.some(isVShowDirective)) {
              child.data.show = true;
            }
            if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
              var oldData = oldChild.data.transition = extend({}, data2);
              if (mode === "out-in") {
                this._leaving = true;
                mergeVNodeHook(oldData, "afterLeave", function() {
                  this$1._leaving = false;
                  this$1.$forceUpdate();
                });
                return placeholder(h, rawChild);
              } else if (mode === "in-out") {
                if (isAsyncPlaceholder(child)) {
                  return oldRawChild;
                }
                var delayedLeave;
                var performLeave = function() {
                  delayedLeave();
                };
                mergeVNodeHook(data2, "afterEnter", performLeave);
                mergeVNodeHook(data2, "enterCancelled", performLeave);
                mergeVNodeHook(oldData, "delayLeave", function(leave2) {
                  delayedLeave = leave2;
                });
              }
            }
            return rawChild;
          }
        };
        var props2 = extend({
          tag: String,
          moveClass: String
        }, transitionProps);
        delete props2.mode;
        var TransitionGroup = {
          props: props2,
          beforeMount: function beforeMount() {
            var this$1 = this;
            var update = this._update;
            this._update = function(vnode, hydrating) {
              var restoreActiveInstance = setActiveInstance(this$1);
              this$1.__patch__(this$1._vnode, this$1.kept, false, true);
              this$1._vnode = this$1.kept;
              restoreActiveInstance();
              update.call(this$1, vnode, hydrating);
            };
          },
          render: function render2(h) {
            var tag = this.tag || this.$vnode.data.tag || "span";
            var map = /* @__PURE__ */ Object.create(null);
            var prevChildren = this.prevChildren = this.children;
            var rawChildren = this.$slots.default || [];
            var children = this.children = [];
            var transitionData = extractTransitionData(this);
            for (var i = 0; i < rawChildren.length; i++) {
              var c = rawChildren[i];
              if (c.tag) {
                if (c.key != null && String(c.key).indexOf("__vlist") !== 0) {
                  children.push(c);
                  map[c.key] = c;
                  (c.data || (c.data = {})).transition = transitionData;
                } else {
                  var opts2 = c.componentOptions;
                  var name = opts2 ? opts2.Ctor.options.name || opts2.tag || "" : c.tag;
                  warn2("<transition-group> children must be keyed: <" + name + ">");
                }
              }
            }
            if (prevChildren) {
              var kept = [];
              var removed = [];
              for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
                var c$1 = prevChildren[i$1];
                c$1.data.transition = transitionData;
                c$1.data.pos = c$1.elm.getBoundingClientRect();
                if (map[c$1.key]) {
                  kept.push(c$1);
                } else {
                  removed.push(c$1);
                }
              }
              this.kept = h(tag, null, kept);
              this.removed = removed;
            }
            return h(tag, null, children);
          },
          updated: function updated() {
            var children = this.prevChildren;
            var moveClass = this.moveClass || (this.name || "v") + "-move";
            if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
              return;
            }
            children.forEach(callPendingCbs);
            children.forEach(recordPosition);
            children.forEach(applyTranslation);
            this._reflow = document.body.offsetHeight;
            children.forEach(function(c) {
              if (c.data.moved) {
                var el = c.elm;
                var s = el.style;
                addTransitionClass(el, moveClass);
                s.transform = s.WebkitTransform = s.transitionDuration = "";
                el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
                  if (e && e.target !== el) {
                    return;
                  }
                  if (!e || /transform$/.test(e.propertyName)) {
                    el.removeEventListener(transitionEndEvent, cb);
                    el._moveCb = null;
                    removeTransitionClass(el, moveClass);
                  }
                });
              }
            });
          },
          methods: {
            hasMove: function hasMove(el, moveClass) {
              if (!hasTransition) {
                return false;
              }
              if (this._hasMove) {
                return this._hasMove;
              }
              var clone = el.cloneNode();
              if (el._transitionClasses) {
                el._transitionClasses.forEach(function(cls) {
                  removeClass(clone, cls);
                });
              }
              addClass(clone, moveClass);
              clone.style.display = "none";
              this.$el.appendChild(clone);
              var info = getTransitionInfo(clone);
              this.$el.removeChild(clone);
              return this._hasMove = info.hasTransform;
            }
          }
        };
        function callPendingCbs(c) {
          if (c.elm._moveCb) {
            c.elm._moveCb();
          }
          if (c.elm._enterCb) {
            c.elm._enterCb();
          }
        }
        function recordPosition(c) {
          c.data.newPos = c.elm.getBoundingClientRect();
        }
        function applyTranslation(c) {
          var oldPos = c.data.pos;
          var newPos = c.data.newPos;
          var dx = oldPos.left - newPos.left;
          var dy = oldPos.top - newPos.top;
          if (dx || dy) {
            c.data.moved = true;
            var s = c.elm.style;
            s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
            s.transitionDuration = "0s";
          }
        }
        var platformComponents = {
          Transition,
          TransitionGroup
        };
        Vue4.config.mustUseProp = mustUseProp;
        Vue4.config.isReservedTag = isReservedTag;
        Vue4.config.isReservedAttr = isReservedAttr;
        Vue4.config.getTagNamespace = getTagNamespace;
        Vue4.config.isUnknownElement = isUnknownElement;
        extend(Vue4.options.directives, platformDirectives);
        extend(Vue4.options.components, platformComponents);
        Vue4.prototype.__patch__ = inBrowser ? patch : noop;
        Vue4.prototype.$mount = function(el, hydrating) {
          el = el && inBrowser ? query(el) : void 0;
          return mountComponent(this, el, hydrating);
        };
        if (inBrowser) {
          setTimeout(function() {
            if (config.devtools) {
              if (devtools) {
                devtools.emit("init", Vue4);
              } else {
                console[console.info ? "info" : "log"]("Download the Vue Devtools extension for a better development experience:\nhttps://github.com/vuejs/vue-devtools");
              }
            }
            if (config.productionTip !== false && typeof console !== "undefined") {
              console[console.info ? "info" : "log"]("You are running Vue in development mode.\nMake sure to turn on production mode when deploying for production.\nSee more tips at https://vuejs.org/guide/deployment.html");
            }
          }, 0);
        }
        var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
        var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
        var buildRegex = cached(function(delimiters2) {
          var open = delimiters2[0].replace(regexEscapeRE, "\\$&");
          var close = delimiters2[1].replace(regexEscapeRE, "\\$&");
          return new RegExp(open + "((?:.|\\n)+?)" + close, "g");
        });
        function parseText(text2, delimiters2) {
          var tagRE = delimiters2 ? buildRegex(delimiters2) : defaultTagRE;
          if (!tagRE.test(text2)) {
            return;
          }
          var tokens = [];
          var rawTokens = [];
          var lastIndex = tagRE.lastIndex = 0;
          var match, index2, tokenValue;
          while (match = tagRE.exec(text2)) {
            index2 = match.index;
            if (index2 > lastIndex) {
              rawTokens.push(tokenValue = text2.slice(lastIndex, index2));
              tokens.push(JSON.stringify(tokenValue));
            }
            var exp = parseFilters(match[1].trim());
            tokens.push("_s(" + exp + ")");
            rawTokens.push({ "@binding": exp });
            lastIndex = index2 + match[0].length;
          }
          if (lastIndex < text2.length) {
            rawTokens.push(tokenValue = text2.slice(lastIndex));
            tokens.push(JSON.stringify(tokenValue));
          }
          return {
            expression: tokens.join("+"),
            tokens: rawTokens
          };
        }
        function transformNode(el, options) {
          var warn3 = options.warn || baseWarn;
          var staticClass = getAndRemoveAttr(el, "class");
          if (staticClass) {
            var res = parseText(staticClass, options.delimiters);
            if (res) {
              warn3('class="' + staticClass + '": Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead. For example, instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap["class"]);
            }
          }
          if (staticClass) {
            el.staticClass = JSON.stringify(staticClass);
          }
          var classBinding = getBindingAttr(el, "class", false);
          if (classBinding) {
            el.classBinding = classBinding;
          }
        }
        function genData(el) {
          var data2 = "";
          if (el.staticClass) {
            data2 += "staticClass:" + el.staticClass + ",";
          }
          if (el.classBinding) {
            data2 += "class:" + el.classBinding + ",";
          }
          return data2;
        }
        var klass$1 = {
          staticKeys: ["staticClass"],
          transformNode,
          genData
        };
        function transformNode$1(el, options) {
          var warn3 = options.warn || baseWarn;
          var staticStyle = getAndRemoveAttr(el, "style");
          if (staticStyle) {
            {
              var res = parseText(staticStyle, options.delimiters);
              if (res) {
                warn3('style="' + staticStyle + '": Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead. For example, instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap["style"]);
              }
            }
            el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
          }
          var styleBinding = getBindingAttr(el, "style", false);
          if (styleBinding) {
            el.styleBinding = styleBinding;
          }
        }
        function genData$1(el) {
          var data2 = "";
          if (el.staticStyle) {
            data2 += "staticStyle:" + el.staticStyle + ",";
          }
          if (el.styleBinding) {
            data2 += "style:(" + el.styleBinding + "),";
          }
          return data2;
        }
        var style$1 = {
          staticKeys: ["staticStyle"],
          transformNode: transformNode$1,
          genData: genData$1
        };
        var decoder;
        var he = {
          decode: function decode(html2) {
            decoder = decoder || document.createElement("div");
            decoder.innerHTML = html2;
            return decoder.textContent;
          }
        };
        var isUnaryTag = makeMap("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr");
        var canBeLeftOpenTag = makeMap("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source");
        var isNonPhrasingTag = makeMap("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track");
        var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
        var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
        var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeRegExp.source + "]*";
        var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
        var startTagOpen = new RegExp("^<" + qnameCapture);
        var startTagClose = /^\s*(\/?)>/;
        var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
        var doctype = /^<!DOCTYPE [^>]+>/i;
        var comment = /^<!\--/;
        var conditionalComment = /^<!\[/;
        var isPlainTextElement = makeMap("script,style,textarea", true);
        var reCache = {};
        var decodingMap = {
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&amp;": "&",
          "&#10;": "\n",
          "&#9;": "	",
          "&#39;": "'"
        };
        var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
        var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;
        var isIgnoreNewlineTag = makeMap("pre,textarea", true);
        var shouldIgnoreFirstNewline = function(tag, html2) {
          return tag && isIgnoreNewlineTag(tag) && html2[0] === "\n";
        };
        function decodeAttr(value, shouldDecodeNewlines2) {
          var re = shouldDecodeNewlines2 ? encodedAttrWithNewLines : encodedAttr;
          return value.replace(re, function(match) {
            return decodingMap[match];
          });
        }
        function parseHTML(html2, options) {
          var stack = [];
          var expectHTML = options.expectHTML;
          var isUnaryTag$$1 = options.isUnaryTag || no;
          var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
          var index2 = 0;
          var last, lastTag;
          while (html2) {
            last = html2;
            if (!lastTag || !isPlainTextElement(lastTag)) {
              var textEnd = html2.indexOf("<");
              if (textEnd === 0) {
                if (comment.test(html2)) {
                  var commentEnd = html2.indexOf("-->");
                  if (commentEnd >= 0) {
                    if (options.shouldKeepComment) {
                      options.comment(html2.substring(4, commentEnd), index2, index2 + commentEnd + 3);
                    }
                    advance(commentEnd + 3);
                    continue;
                  }
                }
                if (conditionalComment.test(html2)) {
                  var conditionalEnd = html2.indexOf("]>");
                  if (conditionalEnd >= 0) {
                    advance(conditionalEnd + 2);
                    continue;
                  }
                }
                var doctypeMatch = html2.match(doctype);
                if (doctypeMatch) {
                  advance(doctypeMatch[0].length);
                  continue;
                }
                var endTagMatch = html2.match(endTag);
                if (endTagMatch) {
                  var curIndex = index2;
                  advance(endTagMatch[0].length);
                  parseEndTag(endTagMatch[1], curIndex, index2);
                  continue;
                }
                var startTagMatch = parseStartTag();
                if (startTagMatch) {
                  handleStartTag(startTagMatch);
                  if (shouldIgnoreFirstNewline(startTagMatch.tagName, html2)) {
                    advance(1);
                  }
                  continue;
                }
              }
              var text2 = void 0, rest = void 0, next2 = void 0;
              if (textEnd >= 0) {
                rest = html2.slice(textEnd);
                while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
                  next2 = rest.indexOf("<", 1);
                  if (next2 < 0) {
                    break;
                  }
                  textEnd += next2;
                  rest = html2.slice(textEnd);
                }
                text2 = html2.substring(0, textEnd);
              }
              if (textEnd < 0) {
                text2 = html2;
              }
              if (text2) {
                advance(text2.length);
              }
              if (options.chars && text2) {
                options.chars(text2, index2 - text2.length, index2);
              }
            } else {
              var endTagLength = 0;
              var stackedTag = lastTag.toLowerCase();
              var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp("([\\s\\S]*?)(</" + stackedTag + "[^>]*>)", "i"));
              var rest$1 = html2.replace(reStackedTag, function(all, text3, endTag2) {
                endTagLength = endTag2.length;
                if (!isPlainTextElement(stackedTag) && stackedTag !== "noscript") {
                  text3 = text3.replace(/<!\--([\s\S]*?)-->/g, "$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1");
                }
                if (shouldIgnoreFirstNewline(stackedTag, text3)) {
                  text3 = text3.slice(1);
                }
                if (options.chars) {
                  options.chars(text3);
                }
                return "";
              });
              index2 += html2.length - rest$1.length;
              html2 = rest$1;
              parseEndTag(stackedTag, index2 - endTagLength, index2);
            }
            if (html2 === last) {
              options.chars && options.chars(html2);
              if (!stack.length && options.warn) {
                options.warn('Mal-formatted tag at end of template: "' + html2 + '"', { start: index2 + html2.length });
              }
              break;
            }
          }
          parseEndTag();
          function advance(n) {
            index2 += n;
            html2 = html2.substring(n);
          }
          function parseStartTag() {
            var start = html2.match(startTagOpen);
            if (start) {
              var match = {
                tagName: start[1],
                attrs: [],
                start: index2
              };
              advance(start[0].length);
              var end, attr;
              while (!(end = html2.match(startTagClose)) && (attr = html2.match(dynamicArgAttribute) || html2.match(attribute))) {
                attr.start = index2;
                advance(attr[0].length);
                attr.end = index2;
                match.attrs.push(attr);
              }
              if (end) {
                match.unarySlash = end[1];
                advance(end[0].length);
                match.end = index2;
                return match;
              }
            }
          }
          function handleStartTag(match) {
            var tagName2 = match.tagName;
            var unarySlash = match.unarySlash;
            if (expectHTML) {
              if (lastTag === "p" && isNonPhrasingTag(tagName2)) {
                parseEndTag(lastTag);
              }
              if (canBeLeftOpenTag$$1(tagName2) && lastTag === tagName2) {
                parseEndTag(tagName2);
              }
            }
            var unary = isUnaryTag$$1(tagName2) || !!unarySlash;
            var l = match.attrs.length;
            var attrs2 = new Array(l);
            for (var i = 0; i < l; i++) {
              var args = match.attrs[i];
              var value = args[3] || args[4] || args[5] || "";
              var shouldDecodeNewlines2 = tagName2 === "a" && args[1] === "href" ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
              attrs2[i] = {
                name: args[1],
                value: decodeAttr(value, shouldDecodeNewlines2)
              };
              if (options.outputSourceRange) {
                attrs2[i].start = args.start + args[0].match(/^\s*/).length;
                attrs2[i].end = args.end;
              }
            }
            if (!unary) {
              stack.push({ tag: tagName2, lowerCasedTag: tagName2.toLowerCase(), attrs: attrs2, start: match.start, end: match.end });
              lastTag = tagName2;
            }
            if (options.start) {
              options.start(tagName2, attrs2, unary, match.start, match.end);
            }
          }
          function parseEndTag(tagName2, start, end) {
            var pos, lowerCasedTagName;
            if (start == null) {
              start = index2;
            }
            if (end == null) {
              end = index2;
            }
            if (tagName2) {
              lowerCasedTagName = tagName2.toLowerCase();
              for (pos = stack.length - 1; pos >= 0; pos--) {
                if (stack[pos].lowerCasedTag === lowerCasedTagName) {
                  break;
                }
              }
            } else {
              pos = 0;
            }
            if (pos >= 0) {
              for (var i = stack.length - 1; i >= pos; i--) {
                if (i > pos || !tagName2 && options.warn) {
                  options.warn("tag <" + stack[i].tag + "> has no matching end tag.", { start: stack[i].start, end: stack[i].end });
                }
                if (options.end) {
                  options.end(stack[i].tag, start, end);
                }
              }
              stack.length = pos;
              lastTag = pos && stack[pos - 1].tag;
            } else if (lowerCasedTagName === "br") {
              if (options.start) {
                options.start(tagName2, [], true, start, end);
              }
            } else if (lowerCasedTagName === "p") {
              if (options.start) {
                options.start(tagName2, [], false, start, end);
              }
              if (options.end) {
                options.end(tagName2, start, end);
              }
            }
          }
        }
        var onRE = /^@|^v-on:/;
        var dirRE = /^v-|^@|^:|^#/;
        var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
        var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
        var stripParensRE = /^\(|\)$/g;
        var dynamicArgRE = /^\[.*\]$/;
        var argRE = /:(.*)$/;
        var bindRE = /^:|^\.|^v-bind:/;
        var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;
        var slotRE = /^v-slot(:|$)|^#/;
        var lineBreakRE = /[\r\n]/;
        var whitespaceRE$1 = /[ \f\t\r\n]+/g;
        var invalidAttributeRE = /[\s"'<>\/=]/;
        var decodeHTMLCached = cached(he.decode);
        var emptySlotScopeToken = "_empty_";
        var warn$2;
        var delimiters;
        var transforms;
        var preTransforms;
        var postTransforms;
        var platformIsPreTag;
        var platformMustUseProp;
        var platformGetTagNamespace;
        var maybeComponent;
        function createASTElement(tag, attrs2, parent) {
          return {
            type: 1,
            tag,
            attrsList: attrs2,
            attrsMap: makeAttrsMap(attrs2),
            rawAttrsMap: {},
            parent,
            children: []
          };
        }
        function parse3(template, options) {
          warn$2 = options.warn || baseWarn;
          platformIsPreTag = options.isPreTag || no;
          platformMustUseProp = options.mustUseProp || no;
          platformGetTagNamespace = options.getTagNamespace || no;
          var isReservedTag2 = options.isReservedTag || no;
          maybeComponent = function(el) {
            return !!(el.component || el.attrsMap[":is"] || el.attrsMap["v-bind:is"] || !(el.attrsMap.is ? isReservedTag2(el.attrsMap.is) : isReservedTag2(el.tag)));
          };
          transforms = pluckModuleFunction(options.modules, "transformNode");
          preTransforms = pluckModuleFunction(options.modules, "preTransformNode");
          postTransforms = pluckModuleFunction(options.modules, "postTransformNode");
          delimiters = options.delimiters;
          var stack = [];
          var preserveWhitespace = options.preserveWhitespace !== false;
          var whitespaceOption = options.whitespace;
          var root;
          var currentParent;
          var inVPre = false;
          var inPre = false;
          var warned = false;
          function warnOnce(msg, range2) {
            if (!warned) {
              warned = true;
              warn$2(msg, range2);
            }
          }
          function closeElement(element) {
            trimEndingWhitespace(element);
            if (!inVPre && !element.processed) {
              element = processElement(element, options);
            }
            if (!stack.length && element !== root) {
              if (root.if && (element.elseif || element.else)) {
                {
                  checkRootConstraints(element);
                }
                addIfCondition(root, {
                  exp: element.elseif,
                  block: element
                });
              } else {
                warnOnce("Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.", { start: element.start });
              }
            }
            if (currentParent && !element.forbidden) {
              if (element.elseif || element.else) {
                processIfConditions(element, currentParent);
              } else {
                if (element.slotScope) {
                  var name = element.slotTarget || '"default"';
                  (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
                }
                currentParent.children.push(element);
                element.parent = currentParent;
              }
            }
            element.children = element.children.filter(function(c) {
              return !c.slotScope;
            });
            trimEndingWhitespace(element);
            if (element.pre) {
              inVPre = false;
            }
            if (platformIsPreTag(element.tag)) {
              inPre = false;
            }
            for (var i = 0; i < postTransforms.length; i++) {
              postTransforms[i](element, options);
            }
          }
          function trimEndingWhitespace(el) {
            if (!inPre) {
              var lastNode;
              while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === " ") {
                el.children.pop();
              }
            }
          }
          function checkRootConstraints(el) {
            if (el.tag === "slot" || el.tag === "template") {
              warnOnce("Cannot use <" + el.tag + "> as component root element because it may contain multiple nodes.", { start: el.start });
            }
            if (el.attrsMap.hasOwnProperty("v-for")) {
              warnOnce("Cannot use v-for on stateful component root element because it renders multiple elements.", el.rawAttrsMap["v-for"]);
            }
          }
          parseHTML(template, {
            warn: warn$2,
            expectHTML: options.expectHTML,
            isUnaryTag: options.isUnaryTag,
            canBeLeftOpenTag: options.canBeLeftOpenTag,
            shouldDecodeNewlines: options.shouldDecodeNewlines,
            shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
            shouldKeepComment: options.comments,
            outputSourceRange: options.outputSourceRange,
            start: function start(tag, attrs2, unary, start$1, end) {
              var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);
              if (isIE && ns === "svg") {
                attrs2 = guardIESVGBug(attrs2);
              }
              var element = createASTElement(tag, attrs2, currentParent);
              if (ns) {
                element.ns = ns;
              }
              {
                if (options.outputSourceRange) {
                  element.start = start$1;
                  element.end = end;
                  element.rawAttrsMap = element.attrsList.reduce(function(cumulated, attr) {
                    cumulated[attr.name] = attr;
                    return cumulated;
                  }, {});
                }
                attrs2.forEach(function(attr) {
                  if (invalidAttributeRE.test(attr.name)) {
                    warn$2("Invalid dynamic argument expression: attribute names cannot contain spaces, quotes, <, >, / or =.", {
                      start: attr.start + attr.name.indexOf("["),
                      end: attr.start + attr.name.length
                    });
                  }
                });
              }
              if (isForbiddenTag(element) && !isServerRendering()) {
                element.forbidden = true;
                warn$2("Templates should only be responsible for mapping the state to the UI. Avoid placing tags with side-effects in your templates, such as <" + tag + ">, as they will not be parsed.", { start: element.start });
              }
              for (var i = 0; i < preTransforms.length; i++) {
                element = preTransforms[i](element, options) || element;
              }
              if (!inVPre) {
                processPre(element);
                if (element.pre) {
                  inVPre = true;
                }
              }
              if (platformIsPreTag(element.tag)) {
                inPre = true;
              }
              if (inVPre) {
                processRawAttrs(element);
              } else if (!element.processed) {
                processFor(element);
                processIf(element);
                processOnce(element);
              }
              if (!root) {
                root = element;
                {
                  checkRootConstraints(root);
                }
              }
              if (!unary) {
                currentParent = element;
                stack.push(element);
              } else {
                closeElement(element);
              }
            },
            end: function end(tag, start, end$1) {
              var element = stack[stack.length - 1];
              stack.length -= 1;
              currentParent = stack[stack.length - 1];
              if (options.outputSourceRange) {
                element.end = end$1;
              }
              closeElement(element);
            },
            chars: function chars(text2, start, end) {
              if (!currentParent) {
                {
                  if (text2 === template) {
                    warnOnce("Component template requires a root element, rather than just text.", { start });
                  } else if (text2 = text2.trim()) {
                    warnOnce('text "' + text2 + '" outside root element will be ignored.', { start });
                  }
                }
                return;
              }
              if (isIE && currentParent.tag === "textarea" && currentParent.attrsMap.placeholder === text2) {
                return;
              }
              var children = currentParent.children;
              if (inPre || text2.trim()) {
                text2 = isTextTag(currentParent) ? text2 : decodeHTMLCached(text2);
              } else if (!children.length) {
                text2 = "";
              } else if (whitespaceOption) {
                if (whitespaceOption === "condense") {
                  text2 = lineBreakRE.test(text2) ? "" : " ";
                } else {
                  text2 = " ";
                }
              } else {
                text2 = preserveWhitespace ? " " : "";
              }
              if (text2) {
                if (!inPre && whitespaceOption === "condense") {
                  text2 = text2.replace(whitespaceRE$1, " ");
                }
                var res;
                var child;
                if (!inVPre && text2 !== " " && (res = parseText(text2, delimiters))) {
                  child = {
                    type: 2,
                    expression: res.expression,
                    tokens: res.tokens,
                    text: text2
                  };
                } else if (text2 !== " " || !children.length || children[children.length - 1].text !== " ") {
                  child = {
                    type: 3,
                    text: text2
                  };
                }
                if (child) {
                  if (options.outputSourceRange) {
                    child.start = start;
                    child.end = end;
                  }
                  children.push(child);
                }
              }
            },
            comment: function comment2(text2, start, end) {
              if (currentParent) {
                var child = {
                  type: 3,
                  text: text2,
                  isComment: true
                };
                if (options.outputSourceRange) {
                  child.start = start;
                  child.end = end;
                }
                currentParent.children.push(child);
              }
            }
          });
          return root;
        }
        function processPre(el) {
          if (getAndRemoveAttr(el, "v-pre") != null) {
            el.pre = true;
          }
        }
        function processRawAttrs(el) {
          var list = el.attrsList;
          var len2 = list.length;
          if (len2) {
            var attrs2 = el.attrs = new Array(len2);
            for (var i = 0; i < len2; i++) {
              attrs2[i] = {
                name: list[i].name,
                value: JSON.stringify(list[i].value)
              };
              if (list[i].start != null) {
                attrs2[i].start = list[i].start;
                attrs2[i].end = list[i].end;
              }
            }
          } else if (!el.pre) {
            el.plain = true;
          }
        }
        function processElement(element, options) {
          processKey(element);
          element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;
          processRef(element);
          processSlotContent(element);
          processSlotOutlet(element);
          processComponent(element);
          for (var i = 0; i < transforms.length; i++) {
            element = transforms[i](element, options) || element;
          }
          processAttrs(element);
          return element;
        }
        function processKey(el) {
          var exp = getBindingAttr(el, "key");
          if (exp) {
            {
              if (el.tag === "template") {
                warn$2("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, "key"));
              }
              if (el.for) {
                var iterator = el.iterator2 || el.iterator1;
                var parent = el.parent;
                if (iterator && iterator === exp && parent && parent.tag === "transition-group") {
                  warn$2("Do not use v-for index as key on <transition-group> children, this is the same as not using keys.", getRawBindingAttr(el, "key"), true);
                }
              }
            }
            el.key = exp;
          }
        }
        function processRef(el) {
          var ref3 = getBindingAttr(el, "ref");
          if (ref3) {
            el.ref = ref3;
            el.refInFor = checkInFor(el);
          }
        }
        function processFor(el) {
          var exp;
          if (exp = getAndRemoveAttr(el, "v-for")) {
            var res = parseFor(exp);
            if (res) {
              extend(el, res);
            } else {
              warn$2("Invalid v-for expression: " + exp, el.rawAttrsMap["v-for"]);
            }
          }
        }
        function parseFor(exp) {
          var inMatch = exp.match(forAliasRE);
          if (!inMatch) {
            return;
          }
          var res = {};
          res.for = inMatch[2].trim();
          var alias = inMatch[1].trim().replace(stripParensRE, "");
          var iteratorMatch = alias.match(forIteratorRE);
          if (iteratorMatch) {
            res.alias = alias.replace(forIteratorRE, "").trim();
            res.iterator1 = iteratorMatch[1].trim();
            if (iteratorMatch[2]) {
              res.iterator2 = iteratorMatch[2].trim();
            }
          } else {
            res.alias = alias;
          }
          return res;
        }
        function processIf(el) {
          var exp = getAndRemoveAttr(el, "v-if");
          if (exp) {
            el.if = exp;
            addIfCondition(el, {
              exp,
              block: el
            });
          } else {
            if (getAndRemoveAttr(el, "v-else") != null) {
              el.else = true;
            }
            var elseif = getAndRemoveAttr(el, "v-else-if");
            if (elseif) {
              el.elseif = elseif;
            }
          }
        }
        function processIfConditions(el, parent) {
          var prev = findPrevElement(parent.children);
          if (prev && prev.if) {
            addIfCondition(prev, {
              exp: el.elseif,
              block: el
            });
          } else {
            warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : "else") + " used on element <" + el.tag + "> without corresponding v-if.", el.rawAttrsMap[el.elseif ? "v-else-if" : "v-else"]);
          }
        }
        function findPrevElement(children) {
          var i = children.length;
          while (i--) {
            if (children[i].type === 1) {
              return children[i];
            } else {
              if (children[i].text !== " ") {
                warn$2('text "' + children[i].text.trim() + '" between v-if and v-else(-if) will be ignored.', children[i]);
              }
              children.pop();
            }
          }
        }
        function addIfCondition(el, condition) {
          if (!el.ifConditions) {
            el.ifConditions = [];
          }
          el.ifConditions.push(condition);
        }
        function processOnce(el) {
          var once$$1 = getAndRemoveAttr(el, "v-once");
          if (once$$1 != null) {
            el.once = true;
          }
        }
        function processSlotContent(el) {
          var slotScope;
          if (el.tag === "template") {
            slotScope = getAndRemoveAttr(el, "scope");
            if (slotScope) {
              warn$2('the "scope" attribute for scoped slots have been deprecated and replaced by "slot-scope" since 2.5. The new "slot-scope" attribute can also be used on plain elements in addition to <template> to denote scoped slots.', el.rawAttrsMap["scope"], true);
            }
            el.slotScope = slotScope || getAndRemoveAttr(el, "slot-scope");
          } else if (slotScope = getAndRemoveAttr(el, "slot-scope")) {
            if (el.attrsMap["v-for"]) {
              warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> (v-for takes higher priority). Use a wrapper <template> for the scoped slot to make it clearer.", el.rawAttrsMap["slot-scope"], true);
            }
            el.slotScope = slotScope;
          }
          var slotTarget = getBindingAttr(el, "slot");
          if (slotTarget) {
            el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
            el.slotTargetDynamic = !!(el.attrsMap[":slot"] || el.attrsMap["v-bind:slot"]);
            if (el.tag !== "template" && !el.slotScope) {
              addAttr(el, "slot", slotTarget, getRawBindingAttr(el, "slot"));
            }
          }
          {
            if (el.tag === "template") {
              var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
              if (slotBinding) {
                {
                  if (el.slotTarget || el.slotScope) {
                    warn$2("Unexpected mixed usage of different slot syntaxes.", el);
                  }
                  if (el.parent && !maybeComponent(el.parent)) {
                    warn$2("<template v-slot> can only appear at the root level inside the receiving component", el);
                  }
                }
                var ref3 = getSlotName(slotBinding);
                var name = ref3.name;
                var dynamic = ref3.dynamic;
                el.slotTarget = name;
                el.slotTargetDynamic = dynamic;
                el.slotScope = slotBinding.value || emptySlotScopeToken;
              }
            } else {
              var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
              if (slotBinding$1) {
                {
                  if (!maybeComponent(el)) {
                    warn$2("v-slot can only be used on components or <template>.", slotBinding$1);
                  }
                  if (el.slotScope || el.slotTarget) {
                    warn$2("Unexpected mixed usage of different slot syntaxes.", el);
                  }
                  if (el.scopedSlots) {
                    warn$2("To avoid scope ambiguity, the default slot should also use <template> syntax when there are other named slots.", slotBinding$1);
                  }
                }
                var slots = el.scopedSlots || (el.scopedSlots = {});
                var ref$12 = getSlotName(slotBinding$1);
                var name$1 = ref$12.name;
                var dynamic$1 = ref$12.dynamic;
                var slotContainer = slots[name$1] = createASTElement("template", [], el);
                slotContainer.slotTarget = name$1;
                slotContainer.slotTargetDynamic = dynamic$1;
                slotContainer.children = el.children.filter(function(c) {
                  if (!c.slotScope) {
                    c.parent = slotContainer;
                    return true;
                  }
                });
                slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;
                el.children = [];
                el.plain = false;
              }
            }
          }
        }
        function getSlotName(binding) {
          var name = binding.name.replace(slotRE, "");
          if (!name) {
            if (binding.name[0] !== "#") {
              name = "default";
            } else {
              warn$2("v-slot shorthand syntax requires a slot name.", binding);
            }
          }
          return dynamicArgRE.test(name) ? { name: name.slice(1, -1), dynamic: true } : { name: '"' + name + '"', dynamic: false };
        }
        function processSlotOutlet(el) {
          if (el.tag === "slot") {
            el.slotName = getBindingAttr(el, "name");
            if (el.key) {
              warn$2("`key` does not work on <slot> because slots are abstract outlets and can possibly expand into multiple elements. Use the key on a wrapping element instead.", getRawBindingAttr(el, "key"));
            }
          }
        }
        function processComponent(el) {
          var binding;
          if (binding = getBindingAttr(el, "is")) {
            el.component = binding;
          }
          if (getAndRemoveAttr(el, "inline-template") != null) {
            el.inlineTemplate = true;
          }
        }
        function processAttrs(el) {
          var list = el.attrsList;
          var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
          for (i = 0, l = list.length; i < l; i++) {
            name = rawName = list[i].name;
            value = list[i].value;
            if (dirRE.test(name)) {
              el.hasBindings = true;
              modifiers = parseModifiers(name.replace(dirRE, ""));
              if (modifiers) {
                name = name.replace(modifierRE, "");
              }
              if (bindRE.test(name)) {
                name = name.replace(bindRE, "");
                value = parseFilters(value);
                isDynamic = dynamicArgRE.test(name);
                if (isDynamic) {
                  name = name.slice(1, -1);
                }
                if (value.trim().length === 0) {
                  warn$2('The value for a v-bind expression cannot be empty. Found in "v-bind:' + name + '"');
                }
                if (modifiers) {
                  if (modifiers.prop && !isDynamic) {
                    name = camelize(name);
                    if (name === "innerHtml") {
                      name = "innerHTML";
                    }
                  }
                  if (modifiers.camel && !isDynamic) {
                    name = camelize(name);
                  }
                  if (modifiers.sync) {
                    syncGen = genAssignmentCode(value, "$event");
                    if (!isDynamic) {
                      addHandler(el, "update:" + camelize(name), syncGen, null, false, warn$2, list[i]);
                      if (hyphenate(name) !== camelize(name)) {
                        addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn$2, list[i]);
                      }
                    } else {
                      addHandler(el, '"update:"+(' + name + ")", syncGen, null, false, warn$2, list[i], true);
                    }
                  }
                }
                if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
                  addProp(el, name, value, list[i], isDynamic);
                } else {
                  addAttr(el, name, value, list[i], isDynamic);
                }
              } else if (onRE.test(name)) {
                name = name.replace(onRE, "");
                isDynamic = dynamicArgRE.test(name);
                if (isDynamic) {
                  name = name.slice(1, -1);
                }
                addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
              } else {
                name = name.replace(dirRE, "");
                var argMatch = name.match(argRE);
                var arg = argMatch && argMatch[1];
                isDynamic = false;
                if (arg) {
                  name = name.slice(0, -(arg.length + 1));
                  if (dynamicArgRE.test(arg)) {
                    arg = arg.slice(1, -1);
                    isDynamic = true;
                  }
                }
                addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
                if (name === "model") {
                  checkForAliasModel(el, value);
                }
              }
            } else {
              {
                var res = parseText(value, delimiters);
                if (res) {
                  warn$2(name + '="' + value + '": Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead. For example, instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
                }
              }
              addAttr(el, name, JSON.stringify(value), list[i]);
              if (!el.component && name === "muted" && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
                addProp(el, name, "true", list[i]);
              }
            }
          }
        }
        function checkInFor(el) {
          var parent = el;
          while (parent) {
            if (parent.for !== void 0) {
              return true;
            }
            parent = parent.parent;
          }
          return false;
        }
        function parseModifiers(name) {
          var match = name.match(modifierRE);
          if (match) {
            var ret = {};
            match.forEach(function(m) {
              ret[m.slice(1)] = true;
            });
            return ret;
          }
        }
        function makeAttrsMap(attrs2) {
          var map = {};
          for (var i = 0, l = attrs2.length; i < l; i++) {
            if (map[attrs2[i].name] && !isIE && !isEdge) {
              warn$2("duplicate attribute: " + attrs2[i].name, attrs2[i]);
            }
            map[attrs2[i].name] = attrs2[i].value;
          }
          return map;
        }
        function isTextTag(el) {
          return el.tag === "script" || el.tag === "style";
        }
        function isForbiddenTag(el) {
          return el.tag === "style" || el.tag === "script" && (!el.attrsMap.type || el.attrsMap.type === "text/javascript");
        }
        var ieNSBug = /^xmlns:NS\d+/;
        var ieNSPrefix = /^NS\d+:/;
        function guardIESVGBug(attrs2) {
          var res = [];
          for (var i = 0; i < attrs2.length; i++) {
            var attr = attrs2[i];
            if (!ieNSBug.test(attr.name)) {
              attr.name = attr.name.replace(ieNSPrefix, "");
              res.push(attr);
            }
          }
          return res;
        }
        function checkForAliasModel(el, value) {
          var _el = el;
          while (_el) {
            if (_el.for && _el.alias === value) {
              warn$2("<" + el.tag + ' v-model="' + value + '">: You are binding v-model directly to a v-for iteration alias. This will not be able to modify the v-for source array because writing to the alias is like modifying a function local variable. Consider using an array of objects and use v-model on an object property instead.', el.rawAttrsMap["v-model"]);
            }
            _el = _el.parent;
          }
        }
        function preTransformNode(el, options) {
          if (el.tag === "input") {
            var map = el.attrsMap;
            if (!map["v-model"]) {
              return;
            }
            var typeBinding;
            if (map[":type"] || map["v-bind:type"]) {
              typeBinding = getBindingAttr(el, "type");
            }
            if (!map.type && !typeBinding && map["v-bind"]) {
              typeBinding = "(" + map["v-bind"] + ").type";
            }
            if (typeBinding) {
              var ifCondition = getAndRemoveAttr(el, "v-if", true);
              var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
              var hasElse = getAndRemoveAttr(el, "v-else", true) != null;
              var elseIfCondition = getAndRemoveAttr(el, "v-else-if", true);
              var branch0 = cloneASTElement(el);
              processFor(branch0);
              addRawAttr(branch0, "type", "checkbox");
              processElement(branch0, options);
              branch0.processed = true;
              branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
              addIfCondition(branch0, {
                exp: branch0.if,
                block: branch0
              });
              var branch1 = cloneASTElement(el);
              getAndRemoveAttr(branch1, "v-for", true);
              addRawAttr(branch1, "type", "radio");
              processElement(branch1, options);
              addIfCondition(branch0, {
                exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
                block: branch1
              });
              var branch2 = cloneASTElement(el);
              getAndRemoveAttr(branch2, "v-for", true);
              addRawAttr(branch2, ":type", typeBinding);
              processElement(branch2, options);
              addIfCondition(branch0, {
                exp: ifCondition,
                block: branch2
              });
              if (hasElse) {
                branch0.else = true;
              } else if (elseIfCondition) {
                branch0.elseif = elseIfCondition;
              }
              return branch0;
            }
          }
        }
        function cloneASTElement(el) {
          return createASTElement(el.tag, el.attrsList.slice(), el.parent);
        }
        var model$1 = {
          preTransformNode
        };
        var modules$1 = [
          klass$1,
          style$1,
          model$1
        ];
        function text(el, dir) {
          if (dir.value) {
            addProp(el, "textContent", "_s(" + dir.value + ")", dir);
          }
        }
        function html(el, dir) {
          if (dir.value) {
            addProp(el, "innerHTML", "_s(" + dir.value + ")", dir);
          }
        }
        var directives$1 = {
          model,
          text,
          html
        };
        var baseOptions = {
          expectHTML: true,
          modules: modules$1,
          directives: directives$1,
          isPreTag,
          isUnaryTag,
          mustUseProp,
          canBeLeftOpenTag,
          isReservedTag,
          getTagNamespace,
          staticKeys: genStaticKeys(modules$1)
        };
        var isStaticKey;
        var isPlatformReservedTag;
        var genStaticKeysCached = cached(genStaticKeys$1);
        function optimize(root, options) {
          if (!root) {
            return;
          }
          isStaticKey = genStaticKeysCached(options.staticKeys || "");
          isPlatformReservedTag = options.isReservedTag || no;
          markStatic$1(root);
          markStaticRoots(root, false);
        }
        function genStaticKeys$1(keys) {
          return makeMap("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap" + (keys ? "," + keys : ""));
        }
        function markStatic$1(node) {
          node.static = isStatic(node);
          if (node.type === 1) {
            if (!isPlatformReservedTag(node.tag) && node.tag !== "slot" && node.attrsMap["inline-template"] == null) {
              return;
            }
            for (var i = 0, l = node.children.length; i < l; i++) {
              var child = node.children[i];
              markStatic$1(child);
              if (!child.static) {
                node.static = false;
              }
            }
            if (node.ifConditions) {
              for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
                var block = node.ifConditions[i$1].block;
                markStatic$1(block);
                if (!block.static) {
                  node.static = false;
                }
              }
            }
          }
        }
        function markStaticRoots(node, isInFor) {
          if (node.type === 1) {
            if (node.static || node.once) {
              node.staticInFor = isInFor;
            }
            if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
              node.staticRoot = true;
              return;
            } else {
              node.staticRoot = false;
            }
            if (node.children) {
              for (var i = 0, l = node.children.length; i < l; i++) {
                markStaticRoots(node.children[i], isInFor || !!node.for);
              }
            }
            if (node.ifConditions) {
              for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
                markStaticRoots(node.ifConditions[i$1].block, isInFor);
              }
            }
          }
        }
        function isStatic(node) {
          if (node.type === 2) {
            return false;
          }
          if (node.type === 3) {
            return true;
          }
          return !!(node.pre || !node.hasBindings && !node.if && !node.for && !isBuiltInTag(node.tag) && isPlatformReservedTag(node.tag) && !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
        }
        function isDirectChildOfTemplateFor(node) {
          while (node.parent) {
            node = node.parent;
            if (node.tag !== "template") {
              return false;
            }
            if (node.for) {
              return true;
            }
          }
          return false;
        }
        var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
        var fnInvokeRE = /\([^)]*?\);*$/;
        var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;
        var keyCodes = {
          esc: 27,
          tab: 9,
          enter: 13,
          space: 32,
          up: 38,
          left: 37,
          right: 39,
          down: 40,
          "delete": [8, 46]
        };
        var keyNames = {
          esc: ["Esc", "Escape"],
          tab: "Tab",
          enter: "Enter",
          space: [" ", "Spacebar"],
          up: ["Up", "ArrowUp"],
          left: ["Left", "ArrowLeft"],
          right: ["Right", "ArrowRight"],
          down: ["Down", "ArrowDown"],
          "delete": ["Backspace", "Delete", "Del"]
        };
        var genGuard = function(condition) {
          return "if(" + condition + ")return null;";
        };
        var modifierCode = {
          stop: "$event.stopPropagation();",
          prevent: "$event.preventDefault();",
          self: genGuard("$event.target !== $event.currentTarget"),
          ctrl: genGuard("!$event.ctrlKey"),
          shift: genGuard("!$event.shiftKey"),
          alt: genGuard("!$event.altKey"),
          meta: genGuard("!$event.metaKey"),
          left: genGuard("'button' in $event && $event.button !== 0"),
          middle: genGuard("'button' in $event && $event.button !== 1"),
          right: genGuard("'button' in $event && $event.button !== 2")
        };
        function genHandlers(events2, isNative3) {
          var prefix = isNative3 ? "nativeOn:" : "on:";
          var staticHandlers = "";
          var dynamicHandlers = "";
          for (var name in events2) {
            var handlerCode = genHandler(events2[name]);
            if (events2[name] && events2[name].dynamic) {
              dynamicHandlers += name + "," + handlerCode + ",";
            } else {
              staticHandlers += '"' + name + '":' + handlerCode + ",";
            }
          }
          staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";
          if (dynamicHandlers) {
            return prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])";
          } else {
            return prefix + staticHandlers;
          }
        }
        function genHandler(handler2) {
          if (!handler2) {
            return "function(){}";
          }
          if (Array.isArray(handler2)) {
            return "[" + handler2.map(function(handler3) {
              return genHandler(handler3);
            }).join(",") + "]";
          }
          var isMethodPath = simplePathRE.test(handler2.value);
          var isFunctionExpression = fnExpRE.test(handler2.value);
          var isFunctionInvocation = simplePathRE.test(handler2.value.replace(fnInvokeRE, ""));
          if (!handler2.modifiers) {
            if (isMethodPath || isFunctionExpression) {
              return handler2.value;
            }
            return "function($event){" + (isFunctionInvocation ? "return " + handler2.value : handler2.value) + "}";
          } else {
            var code = "";
            var genModifierCode = "";
            var keys = [];
            for (var key in handler2.modifiers) {
              if (modifierCode[key]) {
                genModifierCode += modifierCode[key];
                if (keyCodes[key]) {
                  keys.push(key);
                }
              } else if (key === "exact") {
                var modifiers = handler2.modifiers;
                genModifierCode += genGuard(["ctrl", "shift", "alt", "meta"].filter(function(keyModifier) {
                  return !modifiers[keyModifier];
                }).map(function(keyModifier) {
                  return "$event." + keyModifier + "Key";
                }).join("||"));
              } else {
                keys.push(key);
              }
            }
            if (keys.length) {
              code += genKeyFilter(keys);
            }
            if (genModifierCode) {
              code += genModifierCode;
            }
            var handlerCode = isMethodPath ? "return " + handler2.value + ".apply(null, arguments)" : isFunctionExpression ? "return (" + handler2.value + ").apply(null, arguments)" : isFunctionInvocation ? "return " + handler2.value : handler2.value;
            return "function($event){" + code + handlerCode + "}";
          }
        }
        function genKeyFilter(keys) {
          return "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join("&&") + ")return null;";
        }
        function genFilterCode(key) {
          var keyVal = parseInt(key, 10);
          if (keyVal) {
            return "$event.keyCode!==" + keyVal;
          }
          var keyCode = keyCodes[key];
          var keyName = keyNames[key];
          return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + ",$event.key," + JSON.stringify(keyName) + ")";
        }
        function on(el, dir) {
          if (dir.modifiers) {
            warn2("v-on without argument does not support modifiers.");
          }
          el.wrapListeners = function(code) {
            return "_g(" + code + "," + dir.value + ")";
          };
        }
        function bind$1(el, dir) {
          el.wrapData = function(code) {
            return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? "true" : "false") + (dir.modifiers && dir.modifiers.sync ? ",true" : "") + ")";
          };
        }
        var baseDirectives = {
          on,
          bind: bind$1,
          cloak: noop
        };
        var CodegenState = function CodegenState2(options) {
          this.options = options;
          this.warn = options.warn || baseWarn;
          this.transforms = pluckModuleFunction(options.modules, "transformCode");
          this.dataGenFns = pluckModuleFunction(options.modules, "genData");
          this.directives = extend(extend({}, baseDirectives), options.directives);
          var isReservedTag2 = options.isReservedTag || no;
          this.maybeComponent = function(el) {
            return !!el.component || !isReservedTag2(el.tag);
          };
          this.onceId = 0;
          this.staticRenderFns = [];
          this.pre = false;
        };
        function generate(ast, options) {
          var state = new CodegenState(options);
          var code = ast ? ast.tag === "script" ? "null" : genElement(ast, state) : '_c("div")';
          return {
            render: "with(this){return " + code + "}",
            staticRenderFns: state.staticRenderFns
          };
        }
        function genElement(el, state) {
          if (el.parent) {
            el.pre = el.pre || el.parent.pre;
          }
          if (el.staticRoot && !el.staticProcessed) {
            return genStatic(el, state);
          } else if (el.once && !el.onceProcessed) {
            return genOnce(el, state);
          } else if (el.for && !el.forProcessed) {
            return genFor(el, state);
          } else if (el.if && !el.ifProcessed) {
            return genIf(el, state);
          } else if (el.tag === "template" && !el.slotTarget && !state.pre) {
            return genChildren(el, state) || "void 0";
          } else if (el.tag === "slot") {
            return genSlot(el, state);
          } else {
            var code;
            if (el.component) {
              code = genComponent(el.component, el, state);
            } else {
              var data2;
              if (!el.plain || el.pre && state.maybeComponent(el)) {
                data2 = genData$2(el, state);
              }
              var children = el.inlineTemplate ? null : genChildren(el, state, true);
              code = "_c('" + el.tag + "'" + (data2 ? "," + data2 : "") + (children ? "," + children : "") + ")";
            }
            for (var i = 0; i < state.transforms.length; i++) {
              code = state.transforms[i](el, code);
            }
            return code;
          }
        }
        function genStatic(el, state) {
          el.staticProcessed = true;
          var originalPreState = state.pre;
          if (el.pre) {
            state.pre = el.pre;
          }
          state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
          state.pre = originalPreState;
          return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ",true" : "") + ")";
        }
        function genOnce(el, state) {
          el.onceProcessed = true;
          if (el.if && !el.ifProcessed) {
            return genIf(el, state);
          } else if (el.staticInFor) {
            var key = "";
            var parent = el.parent;
            while (parent) {
              if (parent.for) {
                key = parent.key;
                break;
              }
              parent = parent.parent;
            }
            if (!key) {
              state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap["v-once"]);
              return genElement(el, state);
            }
            return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
          } else {
            return genStatic(el, state);
          }
        }
        function genIf(el, state, altGen, altEmpty) {
          el.ifProcessed = true;
          return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
        }
        function genIfConditions(conditions, state, altGen, altEmpty) {
          if (!conditions.length) {
            return altEmpty || "_e()";
          }
          var condition = conditions.shift();
          if (condition.exp) {
            return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
          } else {
            return "" + genTernaryExp(condition.block);
          }
          function genTernaryExp(el) {
            return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
          }
        }
        function genFor(el, state, altGen, altHelper) {
          var exp = el.for;
          var alias = el.alias;
          var iterator1 = el.iterator1 ? "," + el.iterator1 : "";
          var iterator2 = el.iterator2 ? "," + el.iterator2 : "";
          if (state.maybeComponent(el) && el.tag !== "slot" && el.tag !== "template" && !el.key) {
            state.warn("<" + el.tag + ' v-for="' + alias + " in " + exp + '">: component lists rendered with v-for should have explicit keys. See https://vuejs.org/guide/list.html#key for more info.', el.rawAttrsMap["v-for"], true);
          }
          el.forProcessed = true;
          return (altHelper || "_l") + "((" + exp + "),function(" + alias + iterator1 + iterator2 + "){return " + (altGen || genElement)(el, state) + "})";
        }
        function genData$2(el, state) {
          var data2 = "{";
          var dirs = genDirectives(el, state);
          if (dirs) {
            data2 += dirs + ",";
          }
          if (el.key) {
            data2 += "key:" + el.key + ",";
          }
          if (el.ref) {
            data2 += "ref:" + el.ref + ",";
          }
          if (el.refInFor) {
            data2 += "refInFor:true,";
          }
          if (el.pre) {
            data2 += "pre:true,";
          }
          if (el.component) {
            data2 += 'tag:"' + el.tag + '",';
          }
          for (var i = 0; i < state.dataGenFns.length; i++) {
            data2 += state.dataGenFns[i](el);
          }
          if (el.attrs) {
            data2 += "attrs:" + genProps(el.attrs) + ",";
          }
          if (el.props) {
            data2 += "domProps:" + genProps(el.props) + ",";
          }
          if (el.events) {
            data2 += genHandlers(el.events, false) + ",";
          }
          if (el.nativeEvents) {
            data2 += genHandlers(el.nativeEvents, true) + ",";
          }
          if (el.slotTarget && !el.slotScope) {
            data2 += "slot:" + el.slotTarget + ",";
          }
          if (el.scopedSlots) {
            data2 += genScopedSlots(el, el.scopedSlots, state) + ",";
          }
          if (el.model) {
            data2 += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
          }
          if (el.inlineTemplate) {
            var inlineTemplate = genInlineTemplate(el, state);
            if (inlineTemplate) {
              data2 += inlineTemplate + ",";
            }
          }
          data2 = data2.replace(/,$/, "") + "}";
          if (el.dynamicAttrs) {
            data2 = "_b(" + data2 + ',"' + el.tag + '",' + genProps(el.dynamicAttrs) + ")";
          }
          if (el.wrapData) {
            data2 = el.wrapData(data2);
          }
          if (el.wrapListeners) {
            data2 = el.wrapListeners(data2);
          }
          return data2;
        }
        function genDirectives(el, state) {
          var dirs = el.directives;
          if (!dirs) {
            return;
          }
          var res = "directives:[";
          var hasRuntime = false;
          var i, l, dir, needRuntime;
          for (i = 0, l = dirs.length; i < l; i++) {
            dir = dirs[i];
            needRuntime = true;
            var gen = state.directives[dir.name];
            if (gen) {
              needRuntime = !!gen(el, dir, state.warn);
            }
            if (needRuntime) {
              hasRuntime = true;
              res += '{name:"' + dir.name + '",rawName:"' + dir.rawName + '"' + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : "") + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : '"' + dir.arg + '"') : "") + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : "") + "},";
            }
          }
          if (hasRuntime) {
            return res.slice(0, -1) + "]";
          }
        }
        function genInlineTemplate(el, state) {
          var ast = el.children[0];
          if (el.children.length !== 1 || ast.type !== 1) {
            state.warn("Inline-template components must have exactly one child element.", { start: el.start });
          }
          if (ast && ast.type === 1) {
            var inlineRenderFns = generate(ast, state.options);
            return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function(code) {
              return "function(){" + code + "}";
            }).join(",") + "]}";
          }
        }
        function genScopedSlots(el, slots, state) {
          var needsForceUpdate = el.for || Object.keys(slots).some(function(key) {
            var slot = slots[key];
            return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot);
          });
          var needsKey = !!el.if;
          if (!needsForceUpdate) {
            var parent = el.parent;
            while (parent) {
              if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent.for) {
                needsForceUpdate = true;
                break;
              }
              if (parent.if) {
                needsKey = true;
              }
              parent = parent.parent;
            }
          }
          var generatedSlots = Object.keys(slots).map(function(key) {
            return genScopedSlot(slots[key], state);
          }).join(",");
          return "scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? ",null,false," + hash(generatedSlots) : "") + ")";
        }
        function hash(str2) {
          var hash2 = 5381;
          var i = str2.length;
          while (i) {
            hash2 = hash2 * 33 ^ str2.charCodeAt(--i);
          }
          return hash2 >>> 0;
        }
        function containsSlotChild(el) {
          if (el.type === 1) {
            if (el.tag === "slot") {
              return true;
            }
            return el.children.some(containsSlotChild);
          }
          return false;
        }
        function genScopedSlot(el, state) {
          var isLegacySyntax = el.attrsMap["slot-scope"];
          if (el.if && !el.ifProcessed && !isLegacySyntax) {
            return genIf(el, state, genScopedSlot, "null");
          }
          if (el.for && !el.forProcessed) {
            return genFor(el, state, genScopedSlot);
          }
          var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
          var fn = "function(" + slotScope + "){return " + (el.tag === "template" ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || "undefined") + ":undefined" : genChildren(el, state) || "undefined" : genElement(el, state)) + "}";
          var reverseProxy = slotScope ? "" : ",proxy:true";
          return "{key:" + (el.slotTarget || '"default"') + ",fn:" + fn + reverseProxy + "}";
        }
        function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
          var children = el.children;
          if (children.length) {
            var el$1 = children[0];
            if (children.length === 1 && el$1.for && el$1.tag !== "template" && el$1.tag !== "slot") {
              var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
              return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
            }
            var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
            var gen = altGenNode || genNode;
            return "[" + children.map(function(c) {
              return gen(c, state);
            }).join(",") + "]" + (normalizationType$1 ? "," + normalizationType$1 : "");
          }
        }
        function getNormalizationType(children, maybeComponent2) {
          var res = 0;
          for (var i = 0; i < children.length; i++) {
            var el = children[i];
            if (el.type !== 1) {
              continue;
            }
            if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function(c) {
              return needsNormalization(c.block);
            })) {
              res = 2;
              break;
            }
            if (maybeComponent2(el) || el.ifConditions && el.ifConditions.some(function(c) {
              return maybeComponent2(c.block);
            })) {
              res = 1;
            }
          }
          return res;
        }
        function needsNormalization(el) {
          return el.for !== void 0 || el.tag === "template" || el.tag === "slot";
        }
        function genNode(node, state) {
          if (node.type === 1) {
            return genElement(node, state);
          } else if (node.type === 3 && node.isComment) {
            return genComment(node);
          } else {
            return genText(node);
          }
        }
        function genText(text2) {
          return "_v(" + (text2.type === 2 ? text2.expression : transformSpecialNewlines(JSON.stringify(text2.text))) + ")";
        }
        function genComment(comment2) {
          return "_e(" + JSON.stringify(comment2.text) + ")";
        }
        function genSlot(el, state) {
          var slotName = el.slotName || '"default"';
          var children = genChildren(el, state);
          var res = "_t(" + slotName + (children ? ",function(){return " + children + "}" : "");
          var attrs2 = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function(attr) {
            return {
              name: camelize(attr.name),
              value: attr.value,
              dynamic: attr.dynamic
            };
          })) : null;
          var bind$$1 = el.attrsMap["v-bind"];
          if ((attrs2 || bind$$1) && !children) {
            res += ",null";
          }
          if (attrs2) {
            res += "," + attrs2;
          }
          if (bind$$1) {
            res += (attrs2 ? "" : ",null") + "," + bind$$1;
          }
          return res + ")";
        }
        function genComponent(componentName, el, state) {
          var children = el.inlineTemplate ? null : genChildren(el, state, true);
          return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : "") + ")";
        }
        function genProps(props3) {
          var staticProps = "";
          var dynamicProps = "";
          for (var i = 0; i < props3.length; i++) {
            var prop = props3[i];
            var value = transformSpecialNewlines(prop.value);
            if (prop.dynamic) {
              dynamicProps += prop.name + "," + value + ",";
            } else {
              staticProps += '"' + prop.name + '":' + value + ",";
            }
          }
          staticProps = "{" + staticProps.slice(0, -1) + "}";
          if (dynamicProps) {
            return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
          } else {
            return staticProps;
          }
        }
        function transformSpecialNewlines(text2) {
          return text2.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
        }
        var prohibitedKeywordRE = new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b") + "\\b");
        var unaryOperatorsRE = new RegExp("\\b" + "delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b") + "\\s*\\([^\\)]*\\)");
        var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
        function detectErrors(ast, warn3) {
          if (ast) {
            checkNode(ast, warn3);
          }
        }
        function checkNode(node, warn3) {
          if (node.type === 1) {
            for (var name in node.attrsMap) {
              if (dirRE.test(name)) {
                var value = node.attrsMap[name];
                if (value) {
                  var range2 = node.rawAttrsMap[name];
                  if (name === "v-for") {
                    checkFor(node, 'v-for="' + value + '"', warn3, range2);
                  } else if (name === "v-slot" || name[0] === "#") {
                    checkFunctionParameterExpression(value, name + '="' + value + '"', warn3, range2);
                  } else if (onRE.test(name)) {
                    checkEvent(value, name + '="' + value + '"', warn3, range2);
                  } else {
                    checkExpression(value, name + '="' + value + '"', warn3, range2);
                  }
                }
              }
            }
            if (node.children) {
              for (var i = 0; i < node.children.length; i++) {
                checkNode(node.children[i], warn3);
              }
            }
          } else if (node.type === 2) {
            checkExpression(node.expression, node.text, warn3, node);
          }
        }
        function checkEvent(exp, text2, warn3, range2) {
          var stripped = exp.replace(stripStringRE, "");
          var keywordMatch = stripped.match(unaryOperatorsRE);
          if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== "$") {
            warn3('avoid using JavaScript unary operator as property name: "' + keywordMatch[0] + '" in expression ' + text2.trim(), range2);
          }
          checkExpression(exp, text2, warn3, range2);
        }
        function checkFor(node, text2, warn3, range2) {
          checkExpression(node.for || "", text2, warn3, range2);
          checkIdentifier(node.alias, "v-for alias", text2, warn3, range2);
          checkIdentifier(node.iterator1, "v-for iterator", text2, warn3, range2);
          checkIdentifier(node.iterator2, "v-for iterator", text2, warn3, range2);
        }
        function checkIdentifier(ident, type, text2, warn3, range2) {
          if (typeof ident === "string") {
            try {
              new Function("var " + ident + "=_");
            } catch (e) {
              warn3("invalid " + type + ' "' + ident + '" in expression: ' + text2.trim(), range2);
            }
          }
        }
        function checkExpression(exp, text2, warn3, range2) {
          try {
            new Function("return " + exp);
          } catch (e) {
            var keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
            if (keywordMatch) {
              warn3('avoid using JavaScript keyword as property name: "' + keywordMatch[0] + '"\n  Raw expression: ' + text2.trim(), range2);
            } else {
              warn3("invalid expression: " + e.message + " in\n\n    " + exp + "\n\n  Raw expression: " + text2.trim() + "\n", range2);
            }
          }
        }
        function checkFunctionParameterExpression(exp, text2, warn3, range2) {
          try {
            new Function(exp, "");
          } catch (e) {
            warn3("invalid function parameter expression: " + e.message + " in\n\n    " + exp + "\n\n  Raw expression: " + text2.trim() + "\n", range2);
          }
        }
        var range = 2;
        function generateCodeFrame(source, start, end) {
          if (start === void 0)
            start = 0;
          if (end === void 0)
            end = source.length;
          var lines = source.split(/\r?\n/);
          var count = 0;
          var res = [];
          for (var i = 0; i < lines.length; i++) {
            count += lines[i].length + 1;
            if (count >= start) {
              for (var j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length) {
                  continue;
                }
                res.push("" + (j + 1) + repeat$1(" ", 3 - String(j + 1).length) + "|  " + lines[j]);
                var lineLength = lines[j].length;
                if (j === i) {
                  var pad = start - (count - lineLength) + 1;
                  var length = end > count ? lineLength - pad : end - start;
                  res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
                } else if (j > i) {
                  if (end > count) {
                    var length$1 = Math.min(end - count, lineLength);
                    res.push("   |  " + repeat$1("^", length$1));
                  }
                  count += lineLength + 1;
                }
              }
              break;
            }
          }
          return res.join("\n");
        }
        function repeat$1(str2, n) {
          var result = "";
          if (n > 0) {
            while (true) {
              if (n & 1) {
                result += str2;
              }
              n >>>= 1;
              if (n <= 0) {
                break;
              }
              str2 += str2;
            }
          }
          return result;
        }
        function createFunction(code, errors) {
          try {
            return new Function(code);
          } catch (err) {
            errors.push({ err, code });
            return noop;
          }
        }
        function createCompileToFunctionFn(compile2) {
          var cache = /* @__PURE__ */ Object.create(null);
          return function compileToFunctions2(template, options, vm) {
            options = extend({}, options);
            var warn$$1 = options.warn || warn2;
            delete options.warn;
            {
              try {
                new Function("return 1");
              } catch (e) {
                if (e.toString().match(/unsafe-eval|CSP/)) {
                  warn$$1("It seems you are using the standalone build of Vue.js in an environment with Content Security Policy that prohibits unsafe-eval. The template compiler cannot work in this environment. Consider relaxing the policy to allow unsafe-eval or pre-compiling your templates into render functions.");
                }
              }
            }
            var key = options.delimiters ? String(options.delimiters) + template : template;
            if (cache[key]) {
              return cache[key];
            }
            var compiled = compile2(template, options);
            {
              if (compiled.errors && compiled.errors.length) {
                if (options.outputSourceRange) {
                  compiled.errors.forEach(function(e) {
                    warn$$1("Error compiling template:\n\n" + e.msg + "\n\n" + generateCodeFrame(template, e.start, e.end), vm);
                  });
                } else {
                  warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function(e) {
                    return "- " + e;
                  }).join("\n") + "\n", vm);
                }
              }
              if (compiled.tips && compiled.tips.length) {
                if (options.outputSourceRange) {
                  compiled.tips.forEach(function(e) {
                    return tip(e.msg, vm);
                  });
                } else {
                  compiled.tips.forEach(function(msg) {
                    return tip(msg, vm);
                  });
                }
              }
            }
            var res = {};
            var fnGenErrors = [];
            res.render = createFunction(compiled.render, fnGenErrors);
            res.staticRenderFns = compiled.staticRenderFns.map(function(code) {
              return createFunction(code, fnGenErrors);
            });
            {
              if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
                warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function(ref3) {
                  var err = ref3.err;
                  var code = ref3.code;
                  return err.toString() + " in\n\n" + code + "\n";
                }).join("\n"), vm);
              }
            }
            return cache[key] = res;
          };
        }
        function createCompilerCreator(baseCompile) {
          return function createCompiler2(baseOptions2) {
            function compile2(template, options) {
              var finalOptions = Object.create(baseOptions2);
              var errors = [];
              var tips = [];
              var warn3 = function(msg, range2, tip2) {
                (tip2 ? tips : errors).push(msg);
              };
              if (options) {
                if (options.outputSourceRange) {
                  var leadingSpaceLength = template.match(/^\s*/)[0].length;
                  warn3 = function(msg, range2, tip2) {
                    var data2 = { msg };
                    if (range2) {
                      if (range2.start != null) {
                        data2.start = range2.start + leadingSpaceLength;
                      }
                      if (range2.end != null) {
                        data2.end = range2.end + leadingSpaceLength;
                      }
                    }
                    (tip2 ? tips : errors).push(data2);
                  };
                }
                if (options.modules) {
                  finalOptions.modules = (baseOptions2.modules || []).concat(options.modules);
                }
                if (options.directives) {
                  finalOptions.directives = extend(Object.create(baseOptions2.directives || null), options.directives);
                }
                for (var key in options) {
                  if (key !== "modules" && key !== "directives") {
                    finalOptions[key] = options[key];
                  }
                }
              }
              finalOptions.warn = warn3;
              var compiled = baseCompile(template.trim(), finalOptions);
              {
                detectErrors(compiled.ast, warn3);
              }
              compiled.errors = errors;
              compiled.tips = tips;
              return compiled;
            }
            return {
              compile: compile2,
              compileToFunctions: createCompileToFunctionFn(compile2)
            };
          };
        }
        var createCompiler = createCompilerCreator(function baseCompile(template, options) {
          var ast = parse3(template.trim(), options);
          if (options.optimize !== false) {
            optimize(ast, options);
          }
          var code = generate(ast, options);
          return {
            ast,
            render: code.render,
            staticRenderFns: code.staticRenderFns
          };
        });
        var ref$1 = createCompiler(baseOptions);
        var compile = ref$1.compile;
        var compileToFunctions = ref$1.compileToFunctions;
        var div;
        function getShouldDecode(href) {
          div = div || document.createElement("div");
          div.innerHTML = href ? '<a href="\n"/>' : '<div a="\n"/>';
          return div.innerHTML.indexOf("&#10;") > 0;
        }
        var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
        var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;
        var idToTemplate = cached(function(id) {
          var el = query(id);
          return el && el.innerHTML;
        });
        var mount = Vue4.prototype.$mount;
        Vue4.prototype.$mount = function(el, hydrating) {
          el = el && query(el);
          if (el === document.body || el === document.documentElement) {
            warn2("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
            return this;
          }
          var options = this.$options;
          if (!options.render) {
            var template = options.template;
            if (template) {
              if (typeof template === "string") {
                if (template.charAt(0) === "#") {
                  template = idToTemplate(template);
                  if (!template) {
                    warn2("Template element not found or is empty: " + options.template, this);
                  }
                }
              } else if (template.nodeType) {
                template = template.innerHTML;
              } else {
                {
                  warn2("invalid template option:" + template, this);
                }
                return this;
              }
            } else if (el) {
              template = getOuterHTML(el);
            }
            if (template) {
              if (config.performance && mark) {
                mark("compile");
              }
              var ref3 = compileToFunctions(template, {
                outputSourceRange: true,
                shouldDecodeNewlines,
                shouldDecodeNewlinesForHref,
                delimiters: options.delimiters,
                comments: options.comments
              }, this);
              var render2 = ref3.render;
              var staticRenderFns = ref3.staticRenderFns;
              options.render = render2;
              options.staticRenderFns = staticRenderFns;
              if (config.performance && mark) {
                mark("compile end");
                measure("vue " + this._name + " compile", "compile", "compile end");
              }
            }
          }
          return mount.call(this, el, hydrating);
        };
        function getOuterHTML(el) {
          if (el.outerHTML) {
            return el.outerHTML;
          } else {
            var container = document.createElement("div");
            container.appendChild(el.cloneNode(true));
            return container.innerHTML;
          }
        }
        Vue4.compile = compileToFunctions;
        return Vue4;
      });
    }
  });

  // node_modules/vue-sweetalert2/dist/vue-sweetalert.umd.js
  var require_vue_sweetalert_umd = __commonJS({
    "node_modules/vue-sweetalert2/dist/vue-sweetalert.umd.js"(exports, module) {
      !function(t, e) {
        typeof exports == "object" && typeof module != "undefined" ? module.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self).vueSweetalert = e();
      }(exports, function() {
        "use strict";
        var t = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {}, e = { exports: {} };
        e.exports = function() {
          const t2 = Object.freeze({ cancel: "cancel", backdrop: "backdrop", close: "close", esc: "esc", timer: "timer" }), e2 = (t3) => {
            const e3 = [];
            for (let n3 = 0; n3 < t3.length; n3++)
              e3.indexOf(t3[n3]) === -1 && e3.push(t3[n3]);
            return e3;
          }, n2 = (t3) => t3.charAt(0).toUpperCase() + t3.slice(1), o = (t3) => Array.prototype.slice.call(t3), i = (t3) => {
          }, s = (t3) => {
          }, a = [], r = (t3) => {
            a.includes(t3) || (a.push(t3), i(t3));
          }, c = (t3, e3) => {
            r('"'.concat(t3, '" is deprecated and will be removed in the next major release. Please use "').concat(e3, '" instead.'));
          }, l = (t3) => typeof t3 == "function" ? t3() : t3, u = (t3) => t3 && typeof t3.toPromise == "function", d = (t3) => u(t3) ? t3.toPromise() : Promise.resolve(t3), p = (t3) => t3 && Promise.resolve(t3) === t3, m = (t3) => typeof t3 == "object" && t3.jquery, g = (t3) => t3 instanceof Element || m(t3), h = (t3) => {
            const e3 = {};
            return typeof t3[0] != "object" || g(t3[0]) ? ["title", "html", "icon"].forEach((n3, o2) => {
              const i2 = t3[o2];
              typeof i2 == "string" || g(i2) ? e3[n3] = i2 : i2 !== void 0 && s("Unexpected type of ".concat(n3, '! Expected "string" or "Element", got ').concat(typeof i2));
            }) : Object.assign(e3, t3[0]), e3;
          }, f = "swal2-", b = (t3) => {
            const e3 = {};
            for (const n3 in t3)
              e3[t3[n3]] = f + t3[n3];
            return e3;
          }, y = b(["container", "shown", "height-auto", "iosfix", "popup", "modal", "no-backdrop", "no-transition", "toast", "toast-shown", "show", "hide", "close", "title", "html-container", "actions", "confirm", "deny", "cancel", "default-outline", "footer", "icon", "icon-content", "image", "input", "file", "range", "select", "radio", "checkbox", "label", "textarea", "inputerror", "input-label", "validation-message", "progress-steps", "active-progress-step", "progress-step", "progress-step-line", "loader", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen", "rtl", "timer-progress-bar", "timer-progress-bar-container", "scrollbar-measure", "icon-success", "icon-warning", "icon-info", "icon-question", "icon-error"]), w = b(["success", "warning", "info", "question", "error"]), v = () => document.body.querySelector(".".concat(y.container)), C = (t3) => {
            const e3 = v();
            return e3 ? e3.querySelector(t3) : null;
          }, k = (t3) => C(".".concat(t3)), A = () => k(y.popup), B = () => k(y.icon), x = () => k(y.title), P = () => k(y["html-container"]), E = () => k(y.image), S = () => k(y["progress-steps"]), T = () => k(y["validation-message"]), O = () => C(".".concat(y.actions, " .").concat(y.confirm)), L = () => C(".".concat(y.actions, " .").concat(y.deny)), j = () => k(y["input-label"]), M = () => C(".".concat(y.loader)), D = () => C(".".concat(y.actions, " .").concat(y.cancel)), I = () => k(y.actions), H = () => k(y.footer), q = () => k(y["timer-progress-bar"]), V = () => k(y.close), N = '\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex="0"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n', U = () => {
            const t3 = o(A().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')).sort((t4, e3) => (t4 = parseInt(t4.getAttribute("tabindex"))) > (e3 = parseInt(e3.getAttribute("tabindex"))) ? 1 : t4 < e3 ? -1 : 0), n3 = o(A().querySelectorAll(N)).filter((t4) => t4.getAttribute("tabindex") !== "-1");
            return e2(t3.concat(n3)).filter((t4) => at(t4));
          }, F = () => !R() && !document.body.classList.contains(y["no-backdrop"]), R = () => document.body.classList.contains(y["toast-shown"]), z = () => A().hasAttribute("data-loading"), W = { previousBodyPadding: null }, _ = (t3, e3) => {
            if (t3.textContent = "", e3) {
              const n3 = new DOMParser().parseFromString(e3, "text/html");
              o(n3.querySelector("head").childNodes).forEach((e4) => {
                t3.appendChild(e4);
              }), o(n3.querySelector("body").childNodes).forEach((e4) => {
                t3.appendChild(e4);
              });
            }
          }, K = (t3, e3) => {
            if (!e3)
              return false;
            const n3 = e3.split(/\s+/);
            for (let o2 = 0; o2 < n3.length; o2++)
              if (!t3.classList.contains(n3[o2]))
                return false;
            return true;
          }, Y = (t3, e3) => {
            o(t3.classList).forEach((n3) => {
              Object.values(y).includes(n3) || Object.values(w).includes(n3) || Object.values(e3.showClass).includes(n3) || t3.classList.remove(n3);
            });
          }, $2 = (t3, e3, n3) => {
            if (Y(t3, e3), e3.customClass && e3.customClass[n3]) {
              if (typeof e3.customClass[n3] != "string" && !e3.customClass[n3].forEach)
                return i("Invalid type of customClass.".concat(n3, '! Expected string or iterable object, got "').concat(typeof e3.customClass[n3], '"'));
              G(t3, e3.customClass[n3]);
            }
          }, Z = (t3, e3) => {
            if (!e3)
              return null;
            switch (e3) {
              case "select":
              case "textarea":
              case "file":
                return tt(t3, y[e3]);
              case "checkbox":
                return t3.querySelector(".".concat(y.checkbox, " input"));
              case "radio":
                return t3.querySelector(".".concat(y.radio, " input:checked")) || t3.querySelector(".".concat(y.radio, " input:first-child"));
              case "range":
                return t3.querySelector(".".concat(y.range, " input"));
              default:
                return tt(t3, y.input);
            }
          }, J = (t3) => {
            if (t3.focus(), t3.type !== "file") {
              const e3 = t3.value;
              t3.value = "", t3.value = e3;
            }
          }, X = (t3, e3, n3) => {
            t3 && e3 && (typeof e3 == "string" && (e3 = e3.split(/\s+/).filter(Boolean)), e3.forEach((e4) => {
              t3.forEach ? t3.forEach((t4) => {
                n3 ? t4.classList.add(e4) : t4.classList.remove(e4);
              }) : n3 ? t3.classList.add(e4) : t3.classList.remove(e4);
            }));
          }, G = (t3, e3) => {
            X(t3, e3, true);
          }, Q = (t3, e3) => {
            X(t3, e3, false);
          }, tt = (t3, e3) => {
            for (let n3 = 0; n3 < t3.childNodes.length; n3++)
              if (K(t3.childNodes[n3], e3))
                return t3.childNodes[n3];
          }, et = (t3, e3, n3) => {
            n3 === "".concat(parseInt(n3)) && (n3 = parseInt(n3)), n3 || parseInt(n3) === 0 ? t3.style[e3] = typeof n3 == "number" ? "".concat(n3, "px") : n3 : t3.style.removeProperty(e3);
          }, nt = (t3, e3 = "flex") => {
            t3.style.display = e3;
          }, ot = (t3) => {
            t3.style.display = "none";
          }, it = (t3, e3, n3, o2) => {
            const i2 = t3.querySelector(e3);
            i2 && (i2.style[n3] = o2);
          }, st = (t3, e3, n3) => {
            e3 ? nt(t3, n3) : ot(t3);
          }, at = (t3) => !(!t3 || !(t3.offsetWidth || t3.offsetHeight || t3.getClientRects().length)), rt = () => !at(O()) && !at(L()) && !at(D()), ct = (t3) => !!(t3.scrollHeight > t3.clientHeight), lt = (t3) => {
            const e3 = window.getComputedStyle(t3), n3 = parseFloat(e3.getPropertyValue("animation-duration") || "0"), o2 = parseFloat(e3.getPropertyValue("transition-duration") || "0");
            return n3 > 0 || o2 > 0;
          }, ut = (t3, e3 = false) => {
            const n3 = q();
            at(n3) && (e3 && (n3.style.transition = "none", n3.style.width = "100%"), setTimeout(() => {
              n3.style.transition = "width ".concat(t3 / 1e3, "s linear"), n3.style.width = "0%";
            }, 10));
          }, dt = () => {
            const t3 = q(), e3 = parseInt(window.getComputedStyle(t3).width);
            t3.style.removeProperty("transition"), t3.style.width = "100%";
            const n3 = parseInt(window.getComputedStyle(t3).width), o2 = parseInt(e3 / n3 * 100);
            t3.style.removeProperty("transition"), t3.style.width = "".concat(o2, "%");
          }, pt = () => typeof window == "undefined" || typeof document == "undefined", mt = '\n <div aria-labelledby="'.concat(y.title, '" aria-describedby="').concat(y["html-container"], '" class="').concat(y.popup, '" tabindex="-1">\n   <button type="button" class="').concat(y.close, '"></button>\n   <ul class="').concat(y["progress-steps"], '"></ul>\n   <div class="').concat(y.icon, '"></div>\n   <img class="').concat(y.image, '" />\n   <h2 class="').concat(y.title, '" id="').concat(y.title, '"></h2>\n   <div class="').concat(y["html-container"], '" id="').concat(y["html-container"], '"></div>\n   <input class="').concat(y.input, '" />\n   <input type="file" class="').concat(y.file, '" />\n   <div class="').concat(y.range, '">\n     <input type="range" />\n     <output></output>\n   </div>\n   <select class="').concat(y.select, '"></select>\n   <div class="').concat(y.radio, '"></div>\n   <label for="').concat(y.checkbox, '" class="').concat(y.checkbox, '">\n     <input type="checkbox" />\n     <span class="').concat(y.label, '"></span>\n   </label>\n   <textarea class="').concat(y.textarea, '"></textarea>\n   <div class="').concat(y["validation-message"], '" id="').concat(y["validation-message"], '"></div>\n   <div class="').concat(y.actions, '">\n     <div class="').concat(y.loader, '"></div>\n     <button type="button" class="').concat(y.confirm, '"></button>\n     <button type="button" class="').concat(y.deny, '"></button>\n     <button type="button" class="').concat(y.cancel, '"></button>\n   </div>\n   <div class="').concat(y.footer, '"></div>\n   <div class="').concat(y["timer-progress-bar-container"], '">\n     <div class="').concat(y["timer-progress-bar"], '"></div>\n   </div>\n </div>\n').replace(/(^|\n)\s*/g, ""), gt = () => {
            const t3 = v();
            return !!t3 && (t3.remove(), Q([document.documentElement, document.body], [y["no-backdrop"], y["toast-shown"], y["has-column"]]), true);
          }, ht = () => {
            Io.isVisible() && Io.resetValidationMessage();
          }, ft = () => {
            const t3 = A(), e3 = tt(t3, y.input), n3 = tt(t3, y.file), o2 = t3.querySelector(".".concat(y.range, " input")), i2 = t3.querySelector(".".concat(y.range, " output")), s2 = tt(t3, y.select), a2 = t3.querySelector(".".concat(y.checkbox, " input")), r2 = tt(t3, y.textarea);
            e3.oninput = ht, n3.onchange = ht, s2.onchange = ht, a2.onchange = ht, r2.oninput = ht, o2.oninput = () => {
              ht(), i2.value = o2.value;
            }, o2.onchange = () => {
              ht(), o2.nextSibling.value = o2.value;
            };
          }, bt = (t3) => typeof t3 == "string" ? document.querySelector(t3) : t3, yt = (t3) => {
            const e3 = A();
            e3.setAttribute("role", t3.toast ? "alert" : "dialog"), e3.setAttribute("aria-live", t3.toast ? "polite" : "assertive"), t3.toast || e3.setAttribute("aria-modal", "true");
          }, wt = (t3) => {
            window.getComputedStyle(t3).direction === "rtl" && G(v(), y.rtl);
          }, vt = (t3) => {
            const e3 = gt();
            if (pt())
              return void s("SweetAlert2 requires document to initialize");
            const n3 = document.createElement("div");
            n3.className = y.container, e3 && G(n3, y["no-transition"]), _(n3, mt);
            const o2 = bt(t3.target);
            o2.appendChild(n3), yt(t3), wt(o2), ft();
          }, Ct = (t3, e3) => {
            t3 instanceof HTMLElement ? e3.appendChild(t3) : typeof t3 == "object" ? kt(t3, e3) : t3 && _(e3, t3);
          }, kt = (t3, e3) => {
            t3.jquery ? At(e3, t3) : _(e3, t3.toString());
          }, At = (t3, e3) => {
            if (t3.textContent = "", 0 in e3)
              for (let n3 = 0; n3 in e3; n3++)
                t3.appendChild(e3[n3].cloneNode(true));
            else
              t3.appendChild(e3.cloneNode(true));
          }, Bt = (() => {
            if (pt())
              return false;
            const t3 = document.createElement("div"), e3 = { WebkitAnimation: "webkitAnimationEnd", OAnimation: "oAnimationEnd oanimationend", animation: "animationend" };
            for (const n3 in e3)
              if (Object.prototype.hasOwnProperty.call(e3, n3) && t3.style[n3] !== void 0)
                return e3[n3];
            return false;
          })(), xt = () => {
            const t3 = document.createElement("div");
            t3.className = y["scrollbar-measure"], document.body.appendChild(t3);
            const e3 = t3.getBoundingClientRect().width - t3.clientWidth;
            return document.body.removeChild(t3), e3;
          }, Pt = (t3, e3) => {
            const n3 = I(), o2 = M(), i2 = O(), s2 = L(), a2 = D();
            e3.showConfirmButton || e3.showDenyButton || e3.showCancelButton || ot(n3), $2(n3, e3, "actions"), St(i2, "confirm", e3), St(s2, "deny", e3), St(a2, "cancel", e3), Et(i2, s2, a2, e3), e3.reverseButtons && (n3.insertBefore(a2, o2), n3.insertBefore(s2, o2), n3.insertBefore(i2, o2)), _(o2, e3.loaderHtml), $2(o2, e3, "loader");
          };
          function Et(t3, e3, n3, o2) {
            if (!o2.buttonsStyling)
              return Q([t3, e3, n3], y.styled);
            G([t3, e3, n3], y.styled), o2.confirmButtonColor && (t3.style.backgroundColor = o2.confirmButtonColor, G(t3, y["default-outline"])), o2.denyButtonColor && (e3.style.backgroundColor = o2.denyButtonColor, G(e3, y["default-outline"])), o2.cancelButtonColor && (n3.style.backgroundColor = o2.cancelButtonColor, G(n3, y["default-outline"]));
          }
          function St(t3, e3, o2) {
            st(t3, o2["show".concat(n2(e3), "Button")], "inline-block"), _(t3, o2["".concat(e3, "ButtonText")]), t3.setAttribute("aria-label", o2["".concat(e3, "ButtonAriaLabel")]), t3.className = y[e3], $2(t3, o2, "".concat(e3, "Button")), G(t3, o2["".concat(e3, "ButtonClass")]);
          }
          function Tt(t3, e3) {
            typeof e3 == "string" ? t3.style.background = e3 : e3 || G([document.documentElement, document.body], y["no-backdrop"]);
          }
          function Ot(t3, e3) {
            e3 in y ? G(t3, y[e3]) : (i('The "position" parameter is not valid, defaulting to "center"'), G(t3, y.center));
          }
          function Lt(t3, e3) {
            if (e3 && typeof e3 == "string") {
              const n3 = "grow-".concat(e3);
              n3 in y && G(t3, y[n3]);
            }
          }
          const jt = (t3, e3) => {
            const n3 = v();
            n3 && (Tt(n3, e3.backdrop), Ot(n3, e3.position), Lt(n3, e3.grow), $2(n3, e3, "container"));
          };
          var Mt = { promise: /* @__PURE__ */ new WeakMap(), innerParams: /* @__PURE__ */ new WeakMap(), domCache: /* @__PURE__ */ new WeakMap() };
          const Dt = ["input", "file", "range", "select", "radio", "checkbox", "textarea"], It = (t3, e3) => {
            const n3 = A(), o2 = Mt.innerParams.get(t3), i2 = !o2 || e3.input !== o2.input;
            Dt.forEach((t4) => {
              const o3 = y[t4], s2 = tt(n3, o3);
              Vt(t4, e3.inputAttributes), s2.className = o3, i2 && ot(s2);
            }), e3.input && (i2 && Ht(e3), Nt(e3));
          }, Ht = (t3) => {
            if (!zt[t3.input])
              return s('Unexpected type of input! Expected "text", "email", "password", "number", "tel", "select", "radio", "checkbox", "textarea", "file" or "url", got "'.concat(t3.input, '"'));
            const e3 = Rt(t3.input), n3 = zt[t3.input](e3, t3);
            nt(n3), setTimeout(() => {
              J(n3);
            });
          }, qt = (t3) => {
            for (let e3 = 0; e3 < t3.attributes.length; e3++) {
              const n3 = t3.attributes[e3].name;
              ["type", "value", "style"].includes(n3) || t3.removeAttribute(n3);
            }
          }, Vt = (t3, e3) => {
            const n3 = Z(A(), t3);
            if (n3) {
              qt(n3);
              for (const t4 in e3)
                n3.setAttribute(t4, e3[t4]);
            }
          }, Nt = (t3) => {
            const e3 = Rt(t3.input);
            t3.customClass && G(e3, t3.customClass.input);
          }, Ut = (t3, e3) => {
            t3.placeholder && !e3.inputPlaceholder || (t3.placeholder = e3.inputPlaceholder);
          }, Ft = (t3, e3, n3) => {
            if (n3.inputLabel) {
              t3.id = y.input;
              const o2 = document.createElement("label"), i2 = y["input-label"];
              o2.setAttribute("for", t3.id), o2.className = i2, G(o2, n3.customClass.inputLabel), o2.innerText = n3.inputLabel, e3.insertAdjacentElement("beforebegin", o2);
            }
          }, Rt = (t3) => {
            const e3 = y[t3] ? y[t3] : y.input;
            return tt(A(), e3);
          }, zt = {};
          zt.text = zt.email = zt.password = zt.number = zt.tel = zt.url = (t3, e3) => (typeof e3.inputValue == "string" || typeof e3.inputValue == "number" ? t3.value = e3.inputValue : p(e3.inputValue) || i('Unexpected type of inputValue! Expected "string", "number" or "Promise", got "'.concat(typeof e3.inputValue, '"')), Ft(t3, t3, e3), Ut(t3, e3), t3.type = e3.input, t3), zt.file = (t3, e3) => (Ft(t3, t3, e3), Ut(t3, e3), t3), zt.range = (t3, e3) => {
            const n3 = t3.querySelector("input"), o2 = t3.querySelector("output");
            return n3.value = e3.inputValue, n3.type = e3.input, o2.value = e3.inputValue, Ft(n3, t3, e3), t3;
          }, zt.select = (t3, e3) => {
            if (t3.textContent = "", e3.inputPlaceholder) {
              const n3 = document.createElement("option");
              _(n3, e3.inputPlaceholder), n3.value = "", n3.disabled = true, n3.selected = true, t3.appendChild(n3);
            }
            return Ft(t3, t3, e3), t3;
          }, zt.radio = (t3) => (t3.textContent = "", t3), zt.checkbox = (t3, e3) => {
            const n3 = Z(A(), "checkbox");
            n3.value = 1, n3.id = y.checkbox, n3.checked = Boolean(e3.inputValue);
            const o2 = t3.querySelector("span");
            return _(o2, e3.inputPlaceholder), t3;
          }, zt.textarea = (t3, e3) => {
            t3.value = e3.inputValue, Ut(t3, e3), Ft(t3, t3, e3);
            const n3 = (t4) => parseInt(window.getComputedStyle(t4).marginLeft) + parseInt(window.getComputedStyle(t4).marginRight);
            if ("MutationObserver" in window) {
              const e4 = parseInt(window.getComputedStyle(A()).width);
              new MutationObserver(() => {
                const o2 = t3.offsetWidth + n3(t3);
                A().style.width = o2 > e4 ? "".concat(o2, "px") : null;
              }).observe(t3, { attributes: true, attributeFilter: ["style"] });
            }
            return t3;
          };
          const Wt = (t3, e3) => {
            const n3 = P();
            $2(n3, e3, "htmlContainer"), e3.html ? (Ct(e3.html, n3), nt(n3, "block")) : e3.text ? (n3.textContent = e3.text, nt(n3, "block")) : ot(n3), It(t3, e3);
          }, _t = (t3, e3) => {
            const n3 = H();
            st(n3, e3.footer), e3.footer && Ct(e3.footer, n3), $2(n3, e3, "footer");
          }, Kt = (t3, e3) => {
            const n3 = V();
            _(n3, e3.closeButtonHtml), $2(n3, e3, "closeButton"), st(n3, e3.showCloseButton), n3.setAttribute("aria-label", e3.closeButtonAriaLabel);
          }, Yt = (t3, e3) => {
            const n3 = Mt.innerParams.get(t3), o2 = B();
            return n3 && e3.icon === n3.icon ? (Jt(o2, e3), void $t(o2, e3)) : e3.icon || e3.iconHtml ? e3.icon && Object.keys(w).indexOf(e3.icon) === -1 ? (s('Unknown icon! Expected "success", "error", "warning", "info" or "question", got "'.concat(e3.icon, '"')), ot(o2)) : (nt(o2), Jt(o2, e3), $t(o2, e3), void G(o2, e3.showClass.icon)) : ot(o2);
          }, $t = (t3, e3) => {
            for (const n3 in w)
              e3.icon !== n3 && Q(t3, w[n3]);
            G(t3, w[e3.icon]), Xt(t3, e3), Zt(), $2(t3, e3, "icon");
          }, Zt = () => {
            const t3 = A(), e3 = window.getComputedStyle(t3).getPropertyValue("background-color"), n3 = t3.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
            for (let o2 = 0; o2 < n3.length; o2++)
              n3[o2].style.backgroundColor = e3;
          }, Jt = (t3, e3) => {
            t3.textContent = "", e3.iconHtml ? _(t3, Gt(e3.iconHtml)) : e3.icon === "success" ? _(t3, '\n      <div class="swal2-success-circular-line-left"></div>\n      <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>\n      <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>\n      <div class="swal2-success-circular-line-right"></div>\n    ') : e3.icon === "error" ? _(t3, '\n      <span class="swal2-x-mark">\n        <span class="swal2-x-mark-line-left"></span>\n        <span class="swal2-x-mark-line-right"></span>\n      </span>\n    ') : _(t3, Gt({ question: "?", warning: "!", info: "i" }[e3.icon]));
          }, Xt = (t3, e3) => {
            if (e3.iconColor) {
              t3.style.color = e3.iconColor, t3.style.borderColor = e3.iconColor;
              for (const n3 of [".swal2-success-line-tip", ".swal2-success-line-long", ".swal2-x-mark-line-left", ".swal2-x-mark-line-right"])
                it(t3, n3, "backgroundColor", e3.iconColor);
              it(t3, ".swal2-success-ring", "borderColor", e3.iconColor);
            }
          }, Gt = (t3) => '<div class="'.concat(y["icon-content"], '">').concat(t3, "</div>"), Qt = (t3, e3) => {
            const n3 = E();
            if (!e3.imageUrl)
              return ot(n3);
            nt(n3, ""), n3.setAttribute("src", e3.imageUrl), n3.setAttribute("alt", e3.imageAlt), et(n3, "width", e3.imageWidth), et(n3, "height", e3.imageHeight), n3.className = y.image, $2(n3, e3, "image");
          }, te = (t3) => {
            const e3 = document.createElement("li");
            return G(e3, y["progress-step"]), _(e3, t3), e3;
          }, ee = (t3) => {
            const e3 = document.createElement("li");
            return G(e3, y["progress-step-line"]), t3.progressStepsDistance && (e3.style.width = t3.progressStepsDistance), e3;
          }, ne = (t3, e3) => {
            const n3 = S();
            if (!e3.progressSteps || e3.progressSteps.length === 0)
              return ot(n3);
            nt(n3), n3.textContent = "", e3.currentProgressStep >= e3.progressSteps.length && i("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"), e3.progressSteps.forEach((t4, o2) => {
              const i2 = te(t4);
              if (n3.appendChild(i2), o2 === e3.currentProgressStep && G(i2, y["active-progress-step"]), o2 !== e3.progressSteps.length - 1) {
                const t5 = ee(e3);
                n3.appendChild(t5);
              }
            });
          }, oe = (t3, e3) => {
            const n3 = x();
            st(n3, e3.title || e3.titleText, "block"), e3.title && Ct(e3.title, n3), e3.titleText && (n3.innerText = e3.titleText), $2(n3, e3, "title");
          }, ie = (t3, e3) => {
            const n3 = v(), o2 = A();
            e3.toast ? (et(n3, "width", e3.width), o2.style.width = "100%", o2.insertBefore(M(), B())) : et(o2, "width", e3.width), et(o2, "padding", e3.padding), e3.background && (o2.style.background = e3.background), ot(T()), se(o2, e3);
          }, se = (t3, e3) => {
            t3.className = "".concat(y.popup, " ").concat(at(t3) ? e3.showClass.popup : ""), e3.toast ? (G([document.documentElement, document.body], y["toast-shown"]), G(t3, y.toast)) : G(t3, y.modal), $2(t3, e3, "popup"), typeof e3.customClass == "string" && G(t3, e3.customClass), e3.icon && G(t3, y["icon-".concat(e3.icon)]);
          }, ae = (t3, e3) => {
            ie(t3, e3), jt(t3, e3), ne(t3, e3), Yt(t3, e3), Qt(t3, e3), oe(t3, e3), Kt(t3, e3), Wt(t3, e3), Pt(t3, e3), _t(t3, e3), typeof e3.didRender == "function" && e3.didRender(A());
          }, re = () => at(A()), ce = () => O() && O().click(), le = () => L() && L().click(), ue = () => D() && D().click();
          function de(...t3) {
            return new this(...t3);
          }
          function pe(t3) {
            class e3 extends this {
              _main(e4, n3) {
                return super._main(e4, Object.assign({}, t3, n3));
              }
            }
            return e3;
          }
          const me = (t3) => {
            let e3 = A();
            e3 || Io.fire(), e3 = A();
            const n3 = M();
            R() ? ot(B()) : ge(e3, t3), nt(n3), e3.setAttribute("data-loading", true), e3.setAttribute("aria-busy", true), e3.focus();
          }, ge = (t3, e3) => {
            const n3 = I(), o2 = M();
            !e3 && at(O()) && (e3 = O()), nt(n3), e3 && (ot(e3), o2.setAttribute("data-button-to-replace", e3.className)), o2.parentNode.insertBefore(o2, e3), G([t3, n3], y.loading);
          }, he = 100, fe = {}, be = () => {
            fe.previousActiveElement && fe.previousActiveElement.focus ? (fe.previousActiveElement.focus(), fe.previousActiveElement = null) : document.body && document.body.focus();
          }, ye = (t3) => new Promise((e3) => {
            if (!t3)
              return e3();
            const n3 = window.scrollX, o2 = window.scrollY;
            fe.restoreFocusTimeout = setTimeout(() => {
              be(), e3();
            }, he), window.scrollTo(n3, o2);
          }), we = () => fe.timeout && fe.timeout.getTimerLeft(), ve = () => {
            if (fe.timeout)
              return dt(), fe.timeout.stop();
          }, Ce = () => {
            if (fe.timeout) {
              const t3 = fe.timeout.start();
              return ut(t3), t3;
            }
          }, ke = () => {
            const t3 = fe.timeout;
            return t3 && (t3.running ? ve() : Ce());
          }, Ae = (t3) => {
            if (fe.timeout) {
              const e3 = fe.timeout.increase(t3);
              return ut(e3, true), e3;
            }
          }, Be = () => fe.timeout && fe.timeout.isRunning();
          let xe = false;
          const Pe = {};
          function Ee(t3 = "data-swal-template") {
            Pe[t3] = this, xe || (document.body.addEventListener("click", Se), xe = true);
          }
          const Se = (t3) => {
            for (let e3 = t3.target; e3 && e3 !== document; e3 = e3.parentNode)
              for (const t4 in Pe) {
                const n3 = e3.getAttribute(t4);
                if (n3)
                  return void Pe[t4].fire({ template: n3 });
              }
          }, Te = { title: "", titleText: "", text: "", html: "", footer: "", icon: void 0, iconColor: void 0, iconHtml: void 0, template: void 0, toast: false, showClass: { popup: "swal2-show", backdrop: "swal2-backdrop-show", icon: "swal2-icon-show" }, hideClass: { popup: "swal2-hide", backdrop: "swal2-backdrop-hide", icon: "swal2-icon-hide" }, customClass: {}, target: "body", backdrop: true, heightAuto: true, allowOutsideClick: true, allowEscapeKey: true, allowEnterKey: true, stopKeydownPropagation: true, keydownListenerCapture: false, showConfirmButton: true, showDenyButton: false, showCancelButton: false, preConfirm: void 0, preDeny: void 0, confirmButtonText: "OK", confirmButtonAriaLabel: "", confirmButtonColor: void 0, denyButtonText: "No", denyButtonAriaLabel: "", denyButtonColor: void 0, cancelButtonText: "Cancel", cancelButtonAriaLabel: "", cancelButtonColor: void 0, buttonsStyling: true, reverseButtons: false, focusConfirm: true, focusDeny: false, focusCancel: false, returnFocus: true, showCloseButton: false, closeButtonHtml: "&times;", closeButtonAriaLabel: "Close this dialog", loaderHtml: "", showLoaderOnConfirm: false, showLoaderOnDeny: false, imageUrl: void 0, imageWidth: void 0, imageHeight: void 0, imageAlt: "", timer: void 0, timerProgressBar: false, width: void 0, padding: void 0, background: void 0, input: void 0, inputPlaceholder: "", inputLabel: "", inputValue: "", inputOptions: {}, inputAutoTrim: true, inputAttributes: {}, inputValidator: void 0, returnInputValueOnDeny: false, validationMessage: void 0, grow: false, position: "center", progressSteps: [], currentProgressStep: void 0, progressStepsDistance: void 0, willOpen: void 0, didOpen: void 0, didRender: void 0, willClose: void 0, didClose: void 0, didDestroy: void 0, scrollbarPadding: true }, Oe = ["allowEscapeKey", "allowOutsideClick", "background", "buttonsStyling", "cancelButtonAriaLabel", "cancelButtonColor", "cancelButtonText", "closeButtonAriaLabel", "closeButtonHtml", "confirmButtonAriaLabel", "confirmButtonColor", "confirmButtonText", "currentProgressStep", "customClass", "denyButtonAriaLabel", "denyButtonColor", "denyButtonText", "didClose", "didDestroy", "footer", "hideClass", "html", "icon", "iconColor", "iconHtml", "imageAlt", "imageHeight", "imageUrl", "imageWidth", "progressSteps", "returnFocus", "reverseButtons", "showCancelButton", "showCloseButton", "showConfirmButton", "showDenyButton", "text", "title", "titleText", "willClose"], Le = {}, je = ["allowOutsideClick", "allowEnterKey", "backdrop", "focusConfirm", "focusDeny", "focusCancel", "returnFocus", "heightAuto", "keydownListenerCapture"], Me = (t3) => Object.prototype.hasOwnProperty.call(Te, t3), De = (t3) => Oe.indexOf(t3) !== -1, Ie = (t3) => Le[t3], He = (t3) => {
            Me(t3) || i('Unknown parameter "'.concat(t3, '"'));
          }, qe = (t3) => {
            je.includes(t3) && i('The parameter "'.concat(t3, '" is incompatible with toasts'));
          }, Ve = (t3) => {
            Ie(t3) && c(t3, Ie(t3));
          }, Ne = (t3) => {
            !t3.backdrop && t3.allowOutsideClick && i('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
            for (const e3 in t3)
              He(e3), t3.toast && qe(e3), Ve(e3);
          };
          var Ue = Object.freeze({ isValidParameter: Me, isUpdatableParameter: De, isDeprecatedParameter: Ie, argsToParams: h, isVisible: re, clickConfirm: ce, clickDeny: le, clickCancel: ue, getContainer: v, getPopup: A, getTitle: x, getHtmlContainer: P, getImage: E, getIcon: B, getInputLabel: j, getCloseButton: V, getActions: I, getConfirmButton: O, getDenyButton: L, getCancelButton: D, getLoader: M, getFooter: H, getTimerProgressBar: q, getFocusableElements: U, getValidationMessage: T, isLoading: z, fire: de, mixin: pe, showLoading: me, enableLoading: me, getTimerLeft: we, stopTimer: ve, resumeTimer: Ce, toggleTimer: ke, increaseTimer: Ae, isTimerRunning: Be, bindClickHandler: Ee });
          function Fe() {
            const t3 = Mt.innerParams.get(this);
            if (!t3)
              return;
            const e3 = Mt.domCache.get(this);
            ot(e3.loader), R() ? t3.icon && nt(B()) : Re(e3), Q([e3.popup, e3.actions], y.loading), e3.popup.removeAttribute("aria-busy"), e3.popup.removeAttribute("data-loading"), e3.confirmButton.disabled = false, e3.denyButton.disabled = false, e3.cancelButton.disabled = false;
          }
          const Re = (t3) => {
            const e3 = t3.popup.getElementsByClassName(t3.loader.getAttribute("data-button-to-replace"));
            e3.length ? nt(e3[0], "inline-block") : rt() && ot(t3.actions);
          };
          function ze(t3) {
            const e3 = Mt.innerParams.get(t3 || this), n3 = Mt.domCache.get(t3 || this);
            return n3 ? Z(n3.popup, e3.input) : null;
          }
          const We = () => {
            W.previousBodyPadding === null && document.body.scrollHeight > window.innerHeight && (W.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right")), document.body.style.paddingRight = "".concat(W.previousBodyPadding + xt(), "px"));
          }, _e = () => {
            W.previousBodyPadding !== null && (document.body.style.paddingRight = "".concat(W.previousBodyPadding, "px"), W.previousBodyPadding = null);
          }, Ke = () => {
            if ((/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && !K(document.body, y.iosfix)) {
              const t3 = document.body.scrollTop;
              document.body.style.top = "".concat(-1 * t3, "px"), G(document.body, y.iosfix), $e(), Ye();
            }
          }, Ye = () => {
            if (!navigator.userAgent.match(/(CriOS|FxiOS|EdgiOS|YaBrowser|UCBrowser)/i)) {
              const t3 = 44;
              A().scrollHeight > window.innerHeight - t3 && (v().style.paddingBottom = "".concat(t3, "px"));
            }
          }, $e = () => {
            const t3 = v();
            let e3;
            t3.ontouchstart = (t4) => {
              e3 = Ze(t4);
            }, t3.ontouchmove = (t4) => {
              e3 && (t4.preventDefault(), t4.stopPropagation());
            };
          }, Ze = (t3) => {
            const e3 = t3.target, n3 = v();
            return !(Je(t3) || Xe(t3) || e3 !== n3 && (ct(n3) || e3.tagName === "INPUT" || e3.tagName === "TEXTAREA" || ct(P()) && P().contains(e3)));
          }, Je = (t3) => t3.touches && t3.touches.length && t3.touches[0].touchType === "stylus", Xe = (t3) => t3.touches && t3.touches.length > 1, Ge = () => {
            if (K(document.body, y.iosfix)) {
              const t3 = parseInt(document.body.style.top, 10);
              Q(document.body, y.iosfix), document.body.style.top = "", document.body.scrollTop = -1 * t3;
            }
          }, Qe = () => {
            o(document.body.children).forEach((t3) => {
              t3 === v() || t3.contains(v()) || (t3.hasAttribute("aria-hidden") && t3.setAttribute("data-previous-aria-hidden", t3.getAttribute("aria-hidden")), t3.setAttribute("aria-hidden", "true"));
            });
          }, tn = () => {
            o(document.body.children).forEach((t3) => {
              t3.hasAttribute("data-previous-aria-hidden") ? (t3.setAttribute("aria-hidden", t3.getAttribute("data-previous-aria-hidden")), t3.removeAttribute("data-previous-aria-hidden")) : t3.removeAttribute("aria-hidden");
            });
          };
          var en = { swalPromiseResolve: /* @__PURE__ */ new WeakMap() };
          function nn(t3, e3, n3, o2) {
            R() ? ln(t3, o2) : (ye(n3).then(() => ln(t3, o2)), fe.keydownTarget.removeEventListener("keydown", fe.keydownHandler, { capture: fe.keydownListenerCapture }), fe.keydownHandlerAdded = false), /^((?!chrome|android).)*safari/i.test(navigator.userAgent) ? (e3.setAttribute("style", "display:none !important"), e3.removeAttribute("class"), e3.innerHTML = "") : e3.remove(), F() && (_e(), Ge(), tn()), on();
          }
          function on() {
            Q([document.documentElement, document.body], [y.shown, y["height-auto"], y["no-backdrop"], y["toast-shown"]]);
          }
          function sn(t3) {
            const e3 = A();
            if (!e3)
              return;
            t3 = an(t3);
            const n3 = Mt.innerParams.get(this);
            if (!n3 || K(e3, n3.hideClass.popup))
              return;
            const o2 = en.swalPromiseResolve.get(this);
            Q(e3, n3.showClass.popup), G(e3, n3.hideClass.popup);
            const i2 = v();
            Q(i2, n3.showClass.backdrop), G(i2, n3.hideClass.backdrop), rn(this, e3, n3), o2(t3);
          }
          const an = (t3) => t3 === void 0 ? { isConfirmed: false, isDenied: false, isDismissed: true } : Object.assign({ isConfirmed: false, isDenied: false, isDismissed: false }, t3), rn = (t3, e3, n3) => {
            const o2 = v(), i2 = Bt && lt(e3);
            typeof n3.willClose == "function" && n3.willClose(e3), i2 ? cn(t3, e3, o2, n3.returnFocus, n3.didClose) : nn(t3, o2, n3.returnFocus, n3.didClose);
          }, cn = (t3, e3, n3, o2, i2) => {
            fe.swalCloseEventFinishedCallback = nn.bind(null, t3, n3, o2, i2), e3.addEventListener(Bt, function(t4) {
              t4.target === e3 && (fe.swalCloseEventFinishedCallback(), delete fe.swalCloseEventFinishedCallback);
            });
          }, ln = (t3, e3) => {
            setTimeout(() => {
              typeof e3 == "function" && e3.bind(t3.params)(), t3._destroy();
            });
          };
          function un(t3, e3, n3) {
            const o2 = Mt.domCache.get(t3);
            e3.forEach((t4) => {
              o2[t4].disabled = n3;
            });
          }
          function dn(t3, e3) {
            if (!t3)
              return false;
            if (t3.type === "radio") {
              const n3 = t3.parentNode.parentNode.querySelectorAll("input");
              for (let t4 = 0; t4 < n3.length; t4++)
                n3[t4].disabled = e3;
            } else
              t3.disabled = e3;
          }
          function pn() {
            un(this, ["confirmButton", "denyButton", "cancelButton"], false);
          }
          function mn() {
            un(this, ["confirmButton", "denyButton", "cancelButton"], true);
          }
          function gn() {
            return dn(this.getInput(), false);
          }
          function hn() {
            return dn(this.getInput(), true);
          }
          function fn(t3) {
            const e3 = Mt.domCache.get(this), n3 = Mt.innerParams.get(this);
            _(e3.validationMessage, t3), e3.validationMessage.className = y["validation-message"], n3.customClass && n3.customClass.validationMessage && G(e3.validationMessage, n3.customClass.validationMessage), nt(e3.validationMessage);
            const o2 = this.getInput();
            o2 && (o2.setAttribute("aria-invalid", true), o2.setAttribute("aria-describedby", y["validation-message"]), J(o2), G(o2, y.inputerror));
          }
          function bn() {
            const t3 = Mt.domCache.get(this);
            t3.validationMessage && ot(t3.validationMessage);
            const e3 = this.getInput();
            e3 && (e3.removeAttribute("aria-invalid"), e3.removeAttribute("aria-describedby"), Q(e3, y.inputerror));
          }
          function yn() {
            return Mt.domCache.get(this).progressSteps;
          }
          class wn {
            constructor(t3, e3) {
              this.callback = t3, this.remaining = e3, this.running = false, this.start();
            }
            start() {
              return this.running || (this.running = true, this.started = new Date(), this.id = setTimeout(this.callback, this.remaining)), this.remaining;
            }
            stop() {
              return this.running && (this.running = false, clearTimeout(this.id), this.remaining -= new Date() - this.started), this.remaining;
            }
            increase(t3) {
              const e3 = this.running;
              return e3 && this.stop(), this.remaining += t3, e3 && this.start(), this.remaining;
            }
            getTimerLeft() {
              return this.running && (this.stop(), this.start()), this.remaining;
            }
            isRunning() {
              return this.running;
            }
          }
          var vn = { email: (t3, e3) => /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(t3) ? Promise.resolve() : Promise.resolve(e3 || "Invalid email address"), url: (t3, e3) => /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(t3) ? Promise.resolve() : Promise.resolve(e3 || "Invalid URL") };
          function Cn(t3) {
            t3.inputValidator || Object.keys(vn).forEach((e3) => {
              t3.input === e3 && (t3.inputValidator = vn[e3]);
            });
          }
          function kn(t3) {
            (!t3.target || typeof t3.target == "string" && !document.querySelector(t3.target) || typeof t3.target != "string" && !t3.target.appendChild) && (i('Target parameter is not valid, defaulting to "body"'), t3.target = "body");
          }
          function An(t3) {
            Cn(t3), t3.showLoaderOnConfirm && !t3.preConfirm && i("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request"), kn(t3), typeof t3.title == "string" && (t3.title = t3.title.split("\n").join("<br />")), vt(t3);
          }
          const Bn = ["swal-title", "swal-html", "swal-footer"], xn = (t3) => {
            const e3 = typeof t3.template == "string" ? document.querySelector(t3.template) : t3.template;
            if (!e3)
              return {};
            const n3 = e3.content;
            return jn(n3), Object.assign(Pn(n3), En(n3), Sn(n3), Tn(n3), On(n3), Ln(n3, Bn));
          }, Pn = (t3) => {
            const e3 = {};
            return o(t3.querySelectorAll("swal-param")).forEach((t4) => {
              Mn(t4, ["name", "value"]);
              const n3 = t4.getAttribute("name");
              let o2 = t4.getAttribute("value");
              typeof Te[n3] == "boolean" && o2 === "false" && (o2 = false), typeof Te[n3] == "object" && (o2 = JSON.parse(o2)), e3[n3] = o2;
            }), e3;
          }, En = (t3) => {
            const e3 = {};
            return o(t3.querySelectorAll("swal-button")).forEach((t4) => {
              Mn(t4, ["type", "color", "aria-label"]);
              const o2 = t4.getAttribute("type");
              e3["".concat(o2, "ButtonText")] = t4.innerHTML, e3["show".concat(n2(o2), "Button")] = true, t4.hasAttribute("color") && (e3["".concat(o2, "ButtonColor")] = t4.getAttribute("color")), t4.hasAttribute("aria-label") && (e3["".concat(o2, "ButtonAriaLabel")] = t4.getAttribute("aria-label"));
            }), e3;
          }, Sn = (t3) => {
            const e3 = {}, n3 = t3.querySelector("swal-image");
            return n3 && (Mn(n3, ["src", "width", "height", "alt"]), n3.hasAttribute("src") && (e3.imageUrl = n3.getAttribute("src")), n3.hasAttribute("width") && (e3.imageWidth = n3.getAttribute("width")), n3.hasAttribute("height") && (e3.imageHeight = n3.getAttribute("height")), n3.hasAttribute("alt") && (e3.imageAlt = n3.getAttribute("alt"))), e3;
          }, Tn = (t3) => {
            const e3 = {}, n3 = t3.querySelector("swal-icon");
            return n3 && (Mn(n3, ["type", "color"]), n3.hasAttribute("type") && (e3.icon = n3.getAttribute("type")), n3.hasAttribute("color") && (e3.iconColor = n3.getAttribute("color")), e3.iconHtml = n3.innerHTML), e3;
          }, On = (t3) => {
            const e3 = {}, n3 = t3.querySelector("swal-input");
            n3 && (Mn(n3, ["type", "label", "placeholder", "value"]), e3.input = n3.getAttribute("type") || "text", n3.hasAttribute("label") && (e3.inputLabel = n3.getAttribute("label")), n3.hasAttribute("placeholder") && (e3.inputPlaceholder = n3.getAttribute("placeholder")), n3.hasAttribute("value") && (e3.inputValue = n3.getAttribute("value")));
            const i2 = t3.querySelectorAll("swal-input-option");
            return i2.length && (e3.inputOptions = {}, o(i2).forEach((t4) => {
              Mn(t4, ["value"]);
              const n4 = t4.getAttribute("value"), o2 = t4.innerHTML;
              e3.inputOptions[n4] = o2;
            })), e3;
          }, Ln = (t3, e3) => {
            const n3 = {};
            for (const o2 in e3) {
              const i2 = e3[o2], s2 = t3.querySelector(i2);
              s2 && (Mn(s2, []), n3[i2.replace(/^swal-/, "")] = s2.innerHTML.trim());
            }
            return n3;
          }, jn = (t3) => {
            const e3 = Bn.concat(["swal-param", "swal-button", "swal-image", "swal-icon", "swal-input", "swal-input-option"]);
            o(t3.children).forEach((t4) => {
              const n3 = t4.tagName.toLowerCase();
              e3.indexOf(n3) === -1 && i("Unrecognized element <".concat(n3, ">"));
            });
          }, Mn = (t3, e3) => {
            o(t3.attributes).forEach((n3) => {
              e3.indexOf(n3.name) === -1 && i(['Unrecognized attribute "'.concat(n3.name, '" on <').concat(t3.tagName.toLowerCase(), ">."), "".concat(e3.length ? "Allowed attributes are: ".concat(e3.join(", ")) : "To set the value, use HTML within the element.")]);
            });
          }, Dn = 10, In = (t3) => {
            const e3 = v(), n3 = A();
            typeof t3.willOpen == "function" && t3.willOpen(n3);
            const o2 = window.getComputedStyle(document.body).overflowY;
            Nn(e3, n3, t3), setTimeout(() => {
              qn(e3, n3);
            }, Dn), F() && (Vn(e3, t3.scrollbarPadding, o2), Qe()), R() || fe.previousActiveElement || (fe.previousActiveElement = document.activeElement), typeof t3.didOpen == "function" && setTimeout(() => t3.didOpen(n3)), Q(e3, y["no-transition"]);
          }, Hn = (t3) => {
            const e3 = A();
            if (t3.target !== e3)
              return;
            const n3 = v();
            e3.removeEventListener(Bt, Hn), n3.style.overflowY = "auto";
          }, qn = (t3, e3) => {
            Bt && lt(e3) ? (t3.style.overflowY = "hidden", e3.addEventListener(Bt, Hn)) : t3.style.overflowY = "auto";
          }, Vn = (t3, e3, n3) => {
            Ke(), e3 && n3 !== "hidden" && We(), setTimeout(() => {
              t3.scrollTop = 0;
            });
          }, Nn = (t3, e3, n3) => {
            G(t3, n3.showClass.backdrop), e3.style.setProperty("opacity", "0", "important"), nt(e3, "grid"), setTimeout(() => {
              G(e3, n3.showClass.popup), e3.style.removeProperty("opacity");
            }, Dn), G([document.documentElement, document.body], y.shown), n3.heightAuto && n3.backdrop && !n3.toast && G([document.documentElement, document.body], y["height-auto"]);
          }, Un = (t3, e3) => {
            e3.input === "select" || e3.input === "radio" ? _n(t3, e3) : ["text", "email", "number", "tel", "textarea"].includes(e3.input) && (u(e3.inputValue) || p(e3.inputValue)) && (me(O()), Kn(t3, e3));
          }, Fn = (t3, e3) => {
            const n3 = t3.getInput();
            if (!n3)
              return null;
            switch (e3.input) {
              case "checkbox":
                return Rn(n3);
              case "radio":
                return zn(n3);
              case "file":
                return Wn(n3);
              default:
                return e3.inputAutoTrim ? n3.value.trim() : n3.value;
            }
          }, Rn = (t3) => t3.checked ? 1 : 0, zn = (t3) => t3.checked ? t3.value : null, Wn = (t3) => t3.files.length ? t3.getAttribute("multiple") !== null ? t3.files : t3.files[0] : null, _n = (t3, e3) => {
            const n3 = A(), o2 = (t4) => Yn[e3.input](n3, $n(t4), e3);
            u(e3.inputOptions) || p(e3.inputOptions) ? (me(O()), d(e3.inputOptions).then((e4) => {
              t3.hideLoading(), o2(e4);
            })) : typeof e3.inputOptions == "object" ? o2(e3.inputOptions) : s("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(typeof e3.inputOptions));
          }, Kn = (t3, e3) => {
            const n3 = t3.getInput();
            ot(n3), d(e3.inputValue).then((o2) => {
              n3.value = e3.input === "number" ? parseFloat(o2) || 0 : "".concat(o2), nt(n3), n3.focus(), t3.hideLoading();
            }).catch((e4) => {
              s("Error in inputValue promise: ".concat(e4)), n3.value = "", nt(n3), n3.focus(), t3.hideLoading();
            });
          }, Yn = { select: (t3, e3, n3) => {
            const o2 = tt(t3, y.select), i2 = (t4, e4, o3) => {
              const i3 = document.createElement("option");
              i3.value = o3, _(i3, e4), i3.selected = Zn(o3, n3.inputValue), t4.appendChild(i3);
            };
            e3.forEach((t4) => {
              const e4 = t4[0], n4 = t4[1];
              if (Array.isArray(n4)) {
                const t5 = document.createElement("optgroup");
                t5.label = e4, t5.disabled = false, o2.appendChild(t5), n4.forEach((e5) => i2(t5, e5[1], e5[0]));
              } else
                i2(o2, n4, e4);
            }), o2.focus();
          }, radio: (t3, e3, n3) => {
            const o2 = tt(t3, y.radio);
            e3.forEach((t4) => {
              const e4 = t4[0], i3 = t4[1], s2 = document.createElement("input"), a2 = document.createElement("label");
              s2.type = "radio", s2.name = y.radio, s2.value = e4, Zn(e4, n3.inputValue) && (s2.checked = true);
              const r2 = document.createElement("span");
              _(r2, i3), r2.className = y.label, a2.appendChild(s2), a2.appendChild(r2), o2.appendChild(a2);
            });
            const i2 = o2.querySelectorAll("input");
            i2.length && i2[0].focus();
          } }, $n = (t3) => {
            const e3 = [];
            return typeof Map != "undefined" && t3 instanceof Map ? t3.forEach((t4, n3) => {
              let o2 = t4;
              typeof o2 == "object" && (o2 = $n(o2)), e3.push([n3, o2]);
            }) : Object.keys(t3).forEach((n3) => {
              let o2 = t3[n3];
              typeof o2 == "object" && (o2 = $n(o2)), e3.push([n3, o2]);
            }), e3;
          }, Zn = (t3, e3) => e3 && e3.toString() === t3.toString(), Jn = (t3, e3) => {
            t3.disableButtons(), e3.input ? Qn(t3, e3, "confirm") : oo(t3, e3, true);
          }, Xn = (t3, e3) => {
            t3.disableButtons(), e3.returnInputValueOnDeny ? Qn(t3, e3, "deny") : eo(t3, e3, false);
          }, Gn = (e3, n3) => {
            e3.disableButtons(), n3(t2.cancel);
          }, Qn = (t3, e3, n3) => {
            const o2 = Fn(t3, e3);
            e3.inputValidator ? to(t3, e3, o2, n3) : t3.getInput().checkValidity() ? n3 === "deny" ? eo(t3, e3, o2) : oo(t3, e3, o2) : (t3.enableButtons(), t3.showValidationMessage(e3.validationMessage));
          }, to = (t3, e3, n3, o2) => {
            t3.disableInput(), Promise.resolve().then(() => d(e3.inputValidator(n3, e3.validationMessage))).then((i2) => {
              t3.enableButtons(), t3.enableInput(), i2 ? t3.showValidationMessage(i2) : o2 === "deny" ? eo(t3, e3, n3) : oo(t3, e3, n3);
            });
          }, eo = (t3, e3, n3) => {
            e3.showLoaderOnDeny && me(L()), e3.preDeny ? Promise.resolve().then(() => d(e3.preDeny(n3, e3.validationMessage))).then((e4) => {
              e4 === false ? t3.hideLoading() : t3.closePopup({ isDenied: true, value: e4 === void 0 ? n3 : e4 });
            }) : t3.closePopup({ isDenied: true, value: n3 });
          }, no = (t3, e3) => {
            t3.closePopup({ isConfirmed: true, value: e3 });
          }, oo = (t3, e3, n3) => {
            e3.showLoaderOnConfirm && me(), e3.preConfirm ? (t3.resetValidationMessage(), Promise.resolve().then(() => d(e3.preConfirm(n3, e3.validationMessage))).then((e4) => {
              at(T()) || e4 === false ? t3.hideLoading() : no(t3, e4 === void 0 ? n3 : e4);
            })) : no(t3, n3);
          }, io = (t3, e3, n3, o2) => {
            e3.keydownTarget && e3.keydownHandlerAdded && (e3.keydownTarget.removeEventListener("keydown", e3.keydownHandler, { capture: e3.keydownListenerCapture }), e3.keydownHandlerAdded = false), n3.toast || (e3.keydownHandler = (e4) => co(t3, e4, o2), e3.keydownTarget = n3.keydownListenerCapture ? window : A(), e3.keydownListenerCapture = n3.keydownListenerCapture, e3.keydownTarget.addEventListener("keydown", e3.keydownHandler, { capture: e3.keydownListenerCapture }), e3.keydownHandlerAdded = true);
          }, so = (t3, e3, n3) => {
            const o2 = U();
            if (o2.length)
              return (e3 += n3) === o2.length ? e3 = 0 : e3 === -1 && (e3 = o2.length - 1), o2[e3].focus();
            A().focus();
          }, ao = ["ArrowRight", "ArrowDown"], ro = ["ArrowLeft", "ArrowUp"], co = (t3, e3, n3) => {
            const o2 = Mt.innerParams.get(t3);
            o2 && (o2.stopKeydownPropagation && e3.stopPropagation(), e3.key === "Enter" ? lo(t3, e3, o2) : e3.key === "Tab" ? uo(e3, o2) : [...ao, ...ro].includes(e3.key) ? po(e3.key) : e3.key === "Escape" && mo(e3, o2, n3));
          }, lo = (t3, e3, n3) => {
            if (!e3.isComposing && e3.target && t3.getInput() && e3.target.outerHTML === t3.getInput().outerHTML) {
              if (["textarea", "file"].includes(n3.input))
                return;
              ce(), e3.preventDefault();
            }
          }, uo = (t3, e3) => {
            const n3 = t3.target, o2 = U();
            let i2 = -1;
            for (let s2 = 0; s2 < o2.length; s2++)
              if (n3 === o2[s2]) {
                i2 = s2;
                break;
              }
            t3.shiftKey ? so(e3, i2, -1) : so(e3, i2, 1), t3.stopPropagation(), t3.preventDefault();
          }, po = (t3) => {
            if (![O(), L(), D()].includes(document.activeElement))
              return;
            const e3 = ao.includes(t3) ? "nextElementSibling" : "previousElementSibling", n3 = document.activeElement[e3];
            n3 && n3.focus();
          }, mo = (e3, n3, o2) => {
            l(n3.allowEscapeKey) && (e3.preventDefault(), o2(t2.esc));
          }, go = (t3, e3, n3) => {
            Mt.innerParams.get(t3).toast ? ho(t3, e3, n3) : (bo(e3), yo(e3), wo(t3, e3, n3));
          }, ho = (e3, n3, o2) => {
            n3.popup.onclick = () => {
              const n4 = Mt.innerParams.get(e3);
              n4.showConfirmButton || n4.showDenyButton || n4.showCancelButton || n4.showCloseButton || n4.timer || n4.input || o2(t2.close);
            };
          };
          let fo = false;
          const bo = (t3) => {
            t3.popup.onmousedown = () => {
              t3.container.onmouseup = function(e3) {
                t3.container.onmouseup = void 0, e3.target === t3.container && (fo = true);
              };
            };
          }, yo = (t3) => {
            t3.container.onmousedown = () => {
              t3.popup.onmouseup = function(e3) {
                t3.popup.onmouseup = void 0, (e3.target === t3.popup || t3.popup.contains(e3.target)) && (fo = true);
              };
            };
          }, wo = (e3, n3, o2) => {
            n3.container.onclick = (i2) => {
              const s2 = Mt.innerParams.get(e3);
              fo ? fo = false : i2.target === n3.container && l(s2.allowOutsideClick) && o2(t2.backdrop);
            };
          };
          function vo(t3, e3 = {}) {
            Ne(Object.assign({}, e3, t3)), fe.currentInstance && fe.currentInstance._destroy(), fe.currentInstance = this;
            const n3 = Co(t3, e3);
            An(n3), Object.freeze(n3), fe.timeout && (fe.timeout.stop(), delete fe.timeout), clearTimeout(fe.restoreFocusTimeout);
            const o2 = Ao(this);
            return ae(this, n3), Mt.innerParams.set(this, n3), ko(this, o2, n3);
          }
          const Co = (t3, e3) => {
            const n3 = xn(t3), o2 = Object.assign({}, Te, e3, n3, t3);
            return o2.showClass = Object.assign({}, Te.showClass, o2.showClass), o2.hideClass = Object.assign({}, Te.hideClass, o2.hideClass), o2;
          }, ko = (e3, n3, o2) => new Promise((i2) => {
            const s2 = (t3) => {
              e3.closePopup({ isDismissed: true, dismiss: t3 });
            };
            en.swalPromiseResolve.set(e3, i2), n3.confirmButton.onclick = () => Jn(e3, o2), n3.denyButton.onclick = () => Xn(e3, o2), n3.cancelButton.onclick = () => Gn(e3, s2), n3.closeButton.onclick = () => s2(t2.close), go(e3, n3, s2), io(e3, fe, o2, s2), Un(e3, o2), In(o2), Bo(fe, o2, s2), xo(n3, o2), setTimeout(() => {
              n3.container.scrollTop = 0;
            });
          }), Ao = (t3) => {
            const e3 = { popup: A(), container: v(), actions: I(), confirmButton: O(), denyButton: L(), cancelButton: D(), loader: M(), closeButton: V(), validationMessage: T(), progressSteps: S() };
            return Mt.domCache.set(t3, e3), e3;
          }, Bo = (t3, e3, n3) => {
            const o2 = q();
            ot(o2), e3.timer && (t3.timeout = new wn(() => {
              n3("timer"), delete t3.timeout;
            }, e3.timer), e3.timerProgressBar && (nt(o2), setTimeout(() => {
              t3.timeout && t3.timeout.running && ut(e3.timer);
            })));
          }, xo = (t3, e3) => {
            if (!e3.toast)
              return l(e3.allowEnterKey) ? void (Po(t3, e3) || so(e3, -1, 1)) : Eo();
          }, Po = (t3, e3) => e3.focusDeny && at(t3.denyButton) ? (t3.denyButton.focus(), true) : e3.focusCancel && at(t3.cancelButton) ? (t3.cancelButton.focus(), true) : !(!e3.focusConfirm || !at(t3.confirmButton) || (t3.confirmButton.focus(), 0)), Eo = () => {
            document.activeElement && typeof document.activeElement.blur == "function" && document.activeElement.blur();
          };
          function So(t3) {
            const e3 = A(), n3 = Mt.innerParams.get(this);
            if (!e3 || K(e3, n3.hideClass.popup))
              return i("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.");
            const o2 = {};
            Object.keys(t3).forEach((e4) => {
              Io.isUpdatableParameter(e4) ? o2[e4] = t3[e4] : i('Invalid parameter to update: "'.concat(e4, '". Updatable params are listed here: https://github.com/sweetalert2/sweetalert2/blob/master/src/utils/params.js\n\nIf you think this parameter should be updatable, request it here: https://github.com/sweetalert2/sweetalert2/issues/new?template=02_feature_request.md'));
            });
            const s2 = Object.assign({}, n3, o2);
            ae(this, s2), Mt.innerParams.set(this, s2), Object.defineProperties(this, { params: { value: Object.assign({}, this.params, t3), writable: false, enumerable: true } });
          }
          function To() {
            const t3 = Mt.domCache.get(this), e3 = Mt.innerParams.get(this);
            e3 && (t3.popup && fe.swalCloseEventFinishedCallback && (fe.swalCloseEventFinishedCallback(), delete fe.swalCloseEventFinishedCallback), fe.deferDisposalTimer && (clearTimeout(fe.deferDisposalTimer), delete fe.deferDisposalTimer), typeof e3.didDestroy == "function" && e3.didDestroy(), Oo(this));
          }
          const Oo = (t3) => {
            delete t3.params, delete fe.keydownHandler, delete fe.keydownTarget, Lo(Mt), Lo(en);
          }, Lo = (t3) => {
            for (const e3 in t3)
              t3[e3] = /* @__PURE__ */ new WeakMap();
          };
          var jo = Object.freeze({ hideLoading: Fe, disableLoading: Fe, getInput: ze, close: sn, closePopup: sn, closeModal: sn, closeToast: sn, enableButtons: pn, disableButtons: mn, enableInput: gn, disableInput: hn, showValidationMessage: fn, resetValidationMessage: bn, getProgressSteps: yn, _main: vo, update: So, _destroy: To });
          let Mo;
          class Do {
            constructor(...t3) {
              if (typeof window == "undefined")
                return;
              Mo = this;
              const e3 = Object.freeze(this.constructor.argsToParams(t3));
              Object.defineProperties(this, { params: { value: e3, writable: false, enumerable: true, configurable: true } });
              const n3 = this._main(this.params);
              Mt.promise.set(this, n3);
            }
            then(t3) {
              return Mt.promise.get(this).then(t3);
            }
            finally(t3) {
              return Mt.promise.get(this).finally(t3);
            }
          }
          Object.assign(Do.prototype, jo), Object.assign(Do, Ue), Object.keys(jo).forEach((t3) => {
            Do[t3] = function(...e3) {
              if (Mo)
                return Mo[t3](...e3);
            };
          }), Do.DismissReason = t2, Do.version = "11.0.18";
          const Io = Do;
          return Io.default = Io, Io;
        }(), t !== void 0 && t.Sweetalert2 && (t.swal = t.sweetAlert = t.Swal = t.SweetAlert = t.Sweetalert2);
        var n = e.exports;
        return class {
          static install(t2, e2 = {}) {
            var o;
            const i = n.mixin(e2), s = function(...t3) {
              return i.fire.call(i, ...t3);
            };
            Object.assign(s, n), Object.keys(n).filter((t3) => typeof n[t3] == "function").forEach((t3) => {
              s[t3] = i[t3].bind(i);
            }), ((o = t2.config) == null ? void 0 : o.globalProperties) && !t2.config.globalProperties.$swal ? (t2.config.globalProperties.$swal = s, t2.provide("$swal", s)) : Object.prototype.hasOwnProperty.call(t2, "$swal") || (t2.prototype.$swal = s, t2.swal = s);
          }
        };
      });
    }
  });

  // node_modules/vue-select/dist/vue-select.js
  var require_vue_select = __commonJS({
    "node_modules/vue-select/dist/vue-select.js"(exports, module) {
      !function(t, e) {
        typeof exports == "object" && typeof module == "object" ? module.exports = e() : typeof define == "function" && define.amd ? define([], e) : typeof exports == "object" ? exports.VueSelect = e() : t.VueSelect = e();
      }(typeof self != "undefined" ? self : exports, function() {
        return (() => {
          var t = { 646: (t2) => {
            t2.exports = function(t3) {
              if (Array.isArray(t3)) {
                for (var e2 = 0, n2 = new Array(t3.length); e2 < t3.length; e2++)
                  n2[e2] = t3[e2];
                return n2;
              }
            };
          }, 713: (t2) => {
            t2.exports = function(t3, e2, n2) {
              return e2 in t3 ? Object.defineProperty(t3, e2, { value: n2, enumerable: true, configurable: true, writable: true }) : t3[e2] = n2, t3;
            };
          }, 860: (t2) => {
            t2.exports = function(t3) {
              if (Symbol.iterator in Object(t3) || Object.prototype.toString.call(t3) === "[object Arguments]")
                return Array.from(t3);
            };
          }, 206: (t2) => {
            t2.exports = function() {
              throw new TypeError("Invalid attempt to spread non-iterable instance");
            };
          }, 319: (t2, e2, n2) => {
            var o2 = n2(646), i = n2(860), s = n2(206);
            t2.exports = function(t3) {
              return o2(t3) || i(t3) || s();
            };
          }, 8: (t2) => {
            function e2(n2) {
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? t2.exports = e2 = function(t3) {
                return typeof t3;
              } : t2.exports = e2 = function(t3) {
                return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
              }, e2(n2);
            }
            t2.exports = e2;
          } }, e = {};
          function n(o2) {
            var i = e[o2];
            if (i !== void 0)
              return i.exports;
            var s = e[o2] = { exports: {} };
            return t[o2](s, s.exports, n), s.exports;
          }
          n.n = (t2) => {
            var e2 = t2 && t2.__esModule ? () => t2.default : () => t2;
            return n.d(e2, { a: e2 }), e2;
          }, n.d = (t2, e2) => {
            for (var o2 in e2)
              n.o(e2, o2) && !n.o(t2, o2) && Object.defineProperty(t2, o2, { enumerable: true, get: e2[o2] });
          }, n.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), n.r = (t2) => {
            typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
          };
          var o = {};
          return (() => {
            "use strict";
            n.r(o), n.d(o, { VueSelect: () => m, default: () => O, mixins: () => _ });
            var t2 = n(319), e2 = n.n(t2), i = n(8), s = n.n(i), r = n(713), a = n.n(r);
            const l = { props: { autoscroll: { type: Boolean, default: true } }, watch: { typeAheadPointer: function() {
              this.autoscroll && this.maybeAdjustScroll();
            }, open: function(t3) {
              var e3 = this;
              this.autoscroll && t3 && this.$nextTick(function() {
                return e3.maybeAdjustScroll();
              });
            } }, methods: { maybeAdjustScroll: function() {
              var t3, e3 = ((t3 = this.$refs.dropdownMenu) === null || t3 === void 0 ? void 0 : t3.children[this.typeAheadPointer]) || false;
              if (e3) {
                var n2 = this.getDropdownViewport(), o2 = e3.getBoundingClientRect(), i2 = o2.top, s2 = o2.bottom, r2 = o2.height;
                if (i2 < n2.top)
                  return this.$refs.dropdownMenu.scrollTop = e3.offsetTop;
                if (s2 > n2.bottom)
                  return this.$refs.dropdownMenu.scrollTop = e3.offsetTop - (n2.height - r2);
              }
            }, getDropdownViewport: function() {
              return this.$refs.dropdownMenu ? this.$refs.dropdownMenu.getBoundingClientRect() : { height: 0, top: 0, bottom: 0 };
            } } }, c = { data: function() {
              return { typeAheadPointer: -1 };
            }, watch: { filteredOptions: function() {
              for (var t3 = 0; t3 < this.filteredOptions.length; t3++)
                if (this.selectable(this.filteredOptions[t3])) {
                  this.typeAheadPointer = t3;
                  break;
                }
            }, open: function(t3) {
              t3 && this.typeAheadToLastSelected();
            }, selectedValue: function() {
              this.open && this.typeAheadToLastSelected();
            } }, methods: { typeAheadUp: function() {
              for (var t3 = this.typeAheadPointer - 1; t3 >= 0; t3--)
                if (this.selectable(this.filteredOptions[t3])) {
                  this.typeAheadPointer = t3;
                  break;
                }
            }, typeAheadDown: function() {
              for (var t3 = this.typeAheadPointer + 1; t3 < this.filteredOptions.length; t3++)
                if (this.selectable(this.filteredOptions[t3])) {
                  this.typeAheadPointer = t3;
                  break;
                }
            }, typeAheadSelect: function() {
              var t3 = this.filteredOptions[this.typeAheadPointer];
              t3 && this.selectable(t3) && this.select(t3);
            }, typeAheadToLastSelected: function() {
              this.typeAheadPointer = this.selectedValue.length !== 0 ? this.filteredOptions.indexOf(this.selectedValue[this.selectedValue.length - 1]) : -1;
            } } }, u = { props: { loading: { type: Boolean, default: false } }, data: function() {
              return { mutableLoading: false };
            }, watch: { search: function() {
              this.$emit("search", this.search, this.toggleLoading);
            }, loading: function(t3) {
              this.mutableLoading = t3;
            } }, methods: { toggleLoading: function() {
              var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
              return this.mutableLoading = t3 == null ? !this.mutableLoading : t3;
            } } };
            function p(t3, e3, n2, o2, i2, s2, r2, a2) {
              var l2, c2 = typeof t3 == "function" ? t3.options : t3;
              if (e3 && (c2.render = e3, c2.staticRenderFns = n2, c2._compiled = true), o2 && (c2.functional = true), s2 && (c2._scopeId = "data-v-" + s2), r2 ? (l2 = function(t4) {
                (t4 = t4 || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) || typeof __VUE_SSR_CONTEXT__ == "undefined" || (t4 = __VUE_SSR_CONTEXT__), i2 && i2.call(this, t4), t4 && t4._registeredComponents && t4._registeredComponents.add(r2);
              }, c2._ssrRegister = l2) : i2 && (l2 = a2 ? function() {
                i2.call(this, (c2.functional ? this.parent : this).$root.$options.shadowRoot);
              } : i2), l2)
                if (c2.functional) {
                  c2._injectStyles = l2;
                  var u2 = c2.render;
                  c2.render = function(t4, e4) {
                    return l2.call(e4), u2(t4, e4);
                  };
                } else {
                  var p2 = c2.beforeCreate;
                  c2.beforeCreate = p2 ? [].concat(p2, l2) : [l2];
                }
              return { exports: t3, options: c2 };
            }
            const h = { Deselect: p({}, function() {
              var t3 = this.$createElement, e3 = this._self._c || t3;
              return e3("svg", { attrs: { xmlns: "http://www.w3.org/2000/svg", width: "10", height: "10" } }, [e3("path", { attrs: { d: "M6.895455 5l2.842897-2.842898c.348864-.348863.348864-.914488 0-1.263636L9.106534.261648c-.348864-.348864-.914489-.348864-1.263636 0L5 3.104545 2.157102.261648c-.348863-.348864-.914488-.348864-1.263636 0L.261648.893466c-.348864.348864-.348864.914489 0 1.263636L3.104545 5 .261648 7.842898c-.348864.348863-.348864.914488 0 1.263636l.631818.631818c.348864.348864.914773.348864 1.263636 0L5 6.895455l2.842898 2.842897c.348863.348864.914772.348864 1.263636 0l.631818-.631818c.348864-.348864.348864-.914489 0-1.263636L6.895455 5z" } })]);
            }, [], false, null, null, null).exports, OpenIndicator: p({}, function() {
              var t3 = this.$createElement, e3 = this._self._c || t3;
              return e3("svg", { attrs: { xmlns: "http://www.w3.org/2000/svg", width: "14", height: "10" } }, [e3("path", { attrs: { d: "M9.211364 7.59931l4.48338-4.867229c.407008-.441854.407008-1.158247 0-1.60046l-.73712-.80023c-.407008-.441854-1.066904-.441854-1.474243 0L7 5.198617 2.51662.33139c-.407008-.441853-1.066904-.441853-1.474243 0l-.737121.80023c-.407008.441854-.407008 1.158248 0 1.600461l4.48338 4.867228L7 10l2.211364-2.40069z" } })]);
            }, [], false, null, null, null).exports }, d = { inserted: function(t3, e3, n2) {
              var o2 = n2.context;
              if (o2.appendToBody) {
                var i2 = o2.$refs.toggle.getBoundingClientRect(), s2 = i2.height, r2 = i2.top, a2 = i2.left, l2 = i2.width, c2 = window.scrollX || window.pageXOffset, u2 = window.scrollY || window.pageYOffset;
                t3.unbindPosition = o2.calculatePosition(t3, o2, { width: l2 + "px", left: c2 + a2 + "px", top: u2 + r2 + s2 + "px" }), document.body.appendChild(t3);
              }
            }, unbind: function(t3, e3, n2) {
              n2.context.appendToBody && (t3.unbindPosition && typeof t3.unbindPosition == "function" && t3.unbindPosition(), t3.parentNode && t3.parentNode.removeChild(t3));
            } };
            const f = function(t3) {
              var e3 = {};
              return Object.keys(t3).sort().forEach(function(n2) {
                e3[n2] = t3[n2];
              }), JSON.stringify(e3);
            };
            var y = 0;
            const b = function() {
              return ++y;
            };
            function g(t3, e3) {
              var n2 = Object.keys(t3);
              if (Object.getOwnPropertySymbols) {
                var o2 = Object.getOwnPropertySymbols(t3);
                e3 && (o2 = o2.filter(function(e4) {
                  return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
                })), n2.push.apply(n2, o2);
              }
              return n2;
            }
            function v(t3) {
              for (var e3 = 1; e3 < arguments.length; e3++) {
                var n2 = arguments[e3] != null ? arguments[e3] : {};
                e3 % 2 ? g(Object(n2), true).forEach(function(e4) {
                  a()(t3, e4, n2[e4]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(n2)) : g(Object(n2)).forEach(function(e4) {
                  Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(n2, e4));
                });
              }
              return t3;
            }
            const m = p({ components: v({}, h), directives: { appendToBody: d }, mixins: [l, c, u], props: { value: {}, components: { type: Object, default: function() {
              return {};
            } }, options: { type: Array, default: function() {
              return [];
            } }, disabled: { type: Boolean, default: false }, clearable: { type: Boolean, default: true }, deselectFromDropdown: { type: Boolean, default: false }, searchable: { type: Boolean, default: true }, multiple: { type: Boolean, default: false }, placeholder: { type: String, default: "" }, transition: { type: String, default: "vs__fade" }, clearSearchOnSelect: { type: Boolean, default: true }, closeOnSelect: { type: Boolean, default: true }, label: { type: String, default: "label" }, autocomplete: { type: String, default: "off" }, reduce: { type: Function, default: function(t3) {
              return t3;
            } }, selectable: { type: Function, default: function(t3) {
              return true;
            } }, getOptionLabel: { type: Function, default: function(t3) {
              return s()(t3) === "object" ? t3.hasOwnProperty(this.label) ? t3[this.label] : console.warn('[vue-select warn]: Label key "option.'.concat(this.label, '" does not') + " exist in options object ".concat(JSON.stringify(t3), ".\n") + "https://vue-select.org/api/props.html#getoptionlabel") : t3;
            } }, getOptionKey: { type: Function, default: function(t3) {
              if (s()(t3) !== "object")
                return t3;
              try {
                return t3.hasOwnProperty("id") ? t3.id : f(t3);
              } catch (e3) {
                return console.warn("[vue-select warn]: Could not stringify this option to generate unique key. Please provide'getOptionKey' prop to return a unique key for each option.\nhttps://vue-select.org/api/props.html#getoptionkey", t3, e3);
              }
            } }, onTab: { type: Function, default: function() {
              this.selectOnTab && !this.isComposing && this.typeAheadSelect();
            } }, taggable: { type: Boolean, default: false }, tabindex: { type: Number, default: null }, pushTags: { type: Boolean, default: false }, filterable: { type: Boolean, default: true }, filterBy: { type: Function, default: function(t3, e3, n2) {
              return (e3 || "").toLocaleLowerCase().indexOf(n2.toLocaleLowerCase()) > -1;
            } }, filter: { type: Function, default: function(t3, e3) {
              var n2 = this;
              return t3.filter(function(t4) {
                var o2 = n2.getOptionLabel(t4);
                return typeof o2 == "number" && (o2 = o2.toString()), n2.filterBy(t4, o2, e3);
              });
            } }, createOption: { type: Function, default: function(t3) {
              return s()(this.optionList[0]) === "object" ? a()({}, this.label, t3) : t3;
            } }, resetOnOptionsChange: { default: false, validator: function(t3) {
              return ["function", "boolean"].includes(s()(t3));
            } }, clearSearchOnBlur: { type: Function, default: function(t3) {
              var e3 = t3.clearSearchOnSelect, n2 = t3.multiple;
              return e3 && !n2;
            } }, noDrop: { type: Boolean, default: false }, inputId: { type: String }, dir: { type: String, default: "auto" }, selectOnTab: { type: Boolean, default: false }, selectOnKeyCodes: { type: Array, default: function() {
              return [13];
            } }, searchInputQuerySelector: { type: String, default: "[type=search]" }, mapKeydown: { type: Function, default: function(t3, e3) {
              return t3;
            } }, appendToBody: { type: Boolean, default: false }, calculatePosition: { type: Function, default: function(t3, e3, n2) {
              var o2 = n2.width, i2 = n2.top, s2 = n2.left;
              t3.style.top = i2, t3.style.left = s2, t3.style.width = o2;
            } }, dropdownShouldOpen: { type: Function, default: function(t3) {
              var e3 = t3.noDrop, n2 = t3.open, o2 = t3.mutableLoading;
              return !e3 && (n2 && !o2);
            } }, uid: { type: [String, Number], default: function() {
              return b();
            } } }, data: function() {
              return { search: "", open: false, isComposing: false, pushedTags: [], _value: [] };
            }, computed: { isTrackingValues: function() {
              return this.value === void 0 || this.$options.propsData.hasOwnProperty("reduce");
            }, selectedValue: function() {
              var t3 = this.value;
              return this.isTrackingValues && (t3 = this.$data._value), t3 != null && t3 !== "" ? [].concat(t3) : [];
            }, optionList: function() {
              return this.options.concat(this.pushTags ? this.pushedTags : []);
            }, searchEl: function() {
              return this.$scopedSlots.search ? this.$refs.selectedOptions.querySelector(this.searchInputQuerySelector) : this.$refs.search;
            }, scope: function() {
              var t3 = this, e3 = { search: this.search, loading: this.loading, searching: this.searching, filteredOptions: this.filteredOptions };
              return { search: { attributes: v({ disabled: this.disabled, placeholder: this.searchPlaceholder, tabindex: this.tabindex, readonly: !this.searchable, id: this.inputId, "aria-autocomplete": "list", "aria-labelledby": "vs".concat(this.uid, "__combobox"), "aria-controls": "vs".concat(this.uid, "__listbox"), ref: "search", type: "search", autocomplete: this.autocomplete, value: this.search }, this.dropdownOpen && this.filteredOptions[this.typeAheadPointer] ? { "aria-activedescendant": "vs".concat(this.uid, "__option-").concat(this.typeAheadPointer) } : {}), events: { compositionstart: function() {
                return t3.isComposing = true;
              }, compositionend: function() {
                return t3.isComposing = false;
              }, keydown: this.onSearchKeyDown, blur: this.onSearchBlur, focus: this.onSearchFocus, input: function(e4) {
                return t3.search = e4.target.value;
              } } }, spinner: { loading: this.mutableLoading }, noOptions: { search: this.search, loading: this.mutableLoading, searching: this.searching }, openIndicator: { attributes: { ref: "openIndicator", role: "presentation", class: "vs__open-indicator" } }, listHeader: e3, listFooter: e3, header: v({}, e3, { deselect: this.deselect }), footer: v({}, e3, { deselect: this.deselect }) };
            }, childComponents: function() {
              return v({}, h, {}, this.components);
            }, stateClasses: function() {
              return { "vs--open": this.dropdownOpen, "vs--single": !this.multiple, "vs--multiple": this.multiple, "vs--searching": this.searching && !this.noDrop, "vs--searchable": this.searchable && !this.noDrop, "vs--unsearchable": !this.searchable, "vs--loading": this.mutableLoading, "vs--disabled": this.disabled };
            }, searching: function() {
              return !!this.search;
            }, dropdownOpen: function() {
              return this.dropdownShouldOpen(this);
            }, searchPlaceholder: function() {
              return this.isValueEmpty && this.placeholder ? this.placeholder : void 0;
            }, filteredOptions: function() {
              var t3 = [].concat(this.optionList);
              if (!this.filterable && !this.taggable)
                return t3;
              var e3 = this.search.length ? this.filter(t3, this.search, this) : t3;
              if (this.taggable && this.search.length) {
                var n2 = this.createOption(this.search);
                this.optionExists(n2) || e3.unshift(n2);
              }
              return e3;
            }, isValueEmpty: function() {
              return this.selectedValue.length === 0;
            }, showClearButton: function() {
              return !this.multiple && this.clearable && !this.open && !this.isValueEmpty;
            } }, watch: { options: function(t3, e3) {
              var n2 = this;
              !this.taggable && (typeof n2.resetOnOptionsChange == "function" ? n2.resetOnOptionsChange(t3, e3, n2.selectedValue) : n2.resetOnOptionsChange) && this.clearSelection(), this.value && this.isTrackingValues && this.setInternalValueFromOptions(this.value);
            }, value: { immediate: true, handler: function(t3) {
              this.isTrackingValues && this.setInternalValueFromOptions(t3);
            } }, multiple: function() {
              this.clearSelection();
            }, open: function(t3) {
              this.$emit(t3 ? "open" : "close");
            } }, created: function() {
              this.mutableLoading = this.loading, this.$on("option:created", this.pushTag);
            }, methods: { setInternalValueFromOptions: function(t3) {
              var e3 = this;
              Array.isArray(t3) ? this.$data._value = t3.map(function(t4) {
                return e3.findOptionFromReducedValue(t4);
              }) : this.$data._value = this.findOptionFromReducedValue(t3);
            }, select: function(t3) {
              this.$emit("option:selecting", t3), this.isOptionSelected(t3) ? this.deselectFromDropdown && (this.clearable || this.multiple && this.selectedValue.length > 1) && this.deselect(t3) : (this.taggable && !this.optionExists(t3) && this.$emit("option:created", t3), this.multiple && (t3 = this.selectedValue.concat(t3)), this.updateValue(t3), this.$emit("option:selected", t3)), this.onAfterSelect(t3);
            }, deselect: function(t3) {
              var e3 = this;
              this.$emit("option:deselecting", t3), this.updateValue(this.selectedValue.filter(function(n2) {
                return !e3.optionComparator(n2, t3);
              })), this.$emit("option:deselected", t3);
            }, clearSelection: function() {
              this.updateValue(this.multiple ? [] : null);
            }, onAfterSelect: function(t3) {
              this.closeOnSelect && (this.open = !this.open, this.searchEl.blur()), this.clearSearchOnSelect && (this.search = "");
            }, updateValue: function(t3) {
              var e3 = this;
              this.value === void 0 && (this.$data._value = t3), t3 !== null && (t3 = Array.isArray(t3) ? t3.map(function(t4) {
                return e3.reduce(t4);
              }) : this.reduce(t3)), this.$emit("input", t3);
            }, toggleDropdown: function(t3) {
              var n2 = t3.target !== this.searchEl;
              n2 && t3.preventDefault();
              var o2 = [].concat(e2()(this.$refs.deselectButtons || []), e2()([this.$refs.clearButton]));
              this.searchEl === void 0 || o2.filter(Boolean).some(function(e3) {
                return e3.contains(t3.target) || e3 === t3.target;
              }) ? t3.preventDefault() : this.open && n2 ? this.searchEl.blur() : this.disabled || (this.open = true, this.searchEl.focus());
            }, isOptionSelected: function(t3) {
              var e3 = this;
              return this.selectedValue.some(function(n2) {
                return e3.optionComparator(n2, t3);
              });
            }, isOptionDeselectable: function(t3) {
              return this.isOptionSelected(t3) && this.deselectFromDropdown;
            }, optionComparator: function(t3, e3) {
              return this.getOptionKey(t3) === this.getOptionKey(e3);
            }, findOptionFromReducedValue: function(t3) {
              var n2 = this, o2 = [].concat(e2()(this.options), e2()(this.pushedTags)).filter(function(e3) {
                return JSON.stringify(n2.reduce(e3)) === JSON.stringify(t3);
              });
              return o2.length === 1 ? o2[0] : o2.find(function(t4) {
                return n2.optionComparator(t4, n2.$data._value);
              }) || t3;
            }, closeSearchOptions: function() {
              this.open = false, this.$emit("search:blur");
            }, maybeDeleteValue: function() {
              if (!this.searchEl.value.length && this.selectedValue && this.selectedValue.length && this.clearable) {
                var t3 = null;
                this.multiple && (t3 = e2()(this.selectedValue.slice(0, this.selectedValue.length - 1))), this.updateValue(t3);
              }
            }, optionExists: function(t3) {
              var e3 = this;
              return this.optionList.some(function(n2) {
                return e3.optionComparator(n2, t3);
              });
            }, normalizeOptionForSlot: function(t3) {
              return s()(t3) === "object" ? t3 : a()({}, this.label, t3);
            }, pushTag: function(t3) {
              this.pushedTags.push(t3);
            }, onEscape: function() {
              this.search.length ? this.search = "" : this.searchEl.blur();
            }, onSearchBlur: function() {
              if (!this.mousedown || this.searching) {
                var t3 = this.clearSearchOnSelect, e3 = this.multiple;
                return this.clearSearchOnBlur({ clearSearchOnSelect: t3, multiple: e3 }) && (this.search = ""), void this.closeSearchOptions();
              }
              this.mousedown = false, this.search.length !== 0 || this.options.length !== 0 || this.closeSearchOptions();
            }, onSearchFocus: function() {
              this.open = true, this.$emit("search:focus");
            }, onMousedown: function() {
              this.mousedown = true;
            }, onMouseUp: function() {
              this.mousedown = false;
            }, onSearchKeyDown: function(t3) {
              var e3 = this, n2 = function(t4) {
                return t4.preventDefault(), !e3.isComposing && e3.typeAheadSelect();
              }, o2 = { 8: function(t4) {
                return e3.maybeDeleteValue();
              }, 9: function(t4) {
                return e3.onTab();
              }, 27: function(t4) {
                return e3.onEscape();
              }, 38: function(t4) {
                return t4.preventDefault(), e3.typeAheadUp();
              }, 40: function(t4) {
                return t4.preventDefault(), e3.typeAheadDown();
              } };
              this.selectOnKeyCodes.forEach(function(t4) {
                return o2[t4] = n2;
              });
              var i2 = this.mapKeydown(o2, this);
              if (typeof i2[t3.keyCode] == "function")
                return i2[t3.keyCode](t3);
            } } }, function() {
              var t3 = this, e3 = t3.$createElement, n2 = t3._self._c || e3;
              return n2("div", { staticClass: "v-select", class: t3.stateClasses, attrs: { dir: t3.dir } }, [t3._t("header", null, null, t3.scope.header), t3._v(" "), n2("div", { ref: "toggle", staticClass: "vs__dropdown-toggle", attrs: { id: "vs" + t3.uid + "__combobox", role: "combobox", "aria-expanded": t3.dropdownOpen.toString(), "aria-owns": "vs" + t3.uid + "__listbox", "aria-label": "Search for option" }, on: { mousedown: function(e4) {
                return t3.toggleDropdown(e4);
              } } }, [n2("div", { ref: "selectedOptions", staticClass: "vs__selected-options" }, [t3._l(t3.selectedValue, function(e4) {
                return t3._t("selected-option-container", [n2("span", { key: t3.getOptionKey(e4), staticClass: "vs__selected" }, [t3._t("selected-option", [t3._v("\n            " + t3._s(t3.getOptionLabel(e4)) + "\n          ")], null, t3.normalizeOptionForSlot(e4)), t3._v(" "), t3.multiple ? n2("button", { ref: "deselectButtons", refInFor: true, staticClass: "vs__deselect", attrs: { disabled: t3.disabled, type: "button", title: "Deselect " + t3.getOptionLabel(e4), "aria-label": "Deselect " + t3.getOptionLabel(e4) }, on: { click: function(n3) {
                  return t3.deselect(e4);
                } } }, [n2(t3.childComponents.Deselect, { tag: "component" })], 1) : t3._e()], 2)], { option: t3.normalizeOptionForSlot(e4), deselect: t3.deselect, multiple: t3.multiple, disabled: t3.disabled });
              }), t3._v(" "), t3._t("search", [n2("input", t3._g(t3._b({ staticClass: "vs__search" }, "input", t3.scope.search.attributes, false), t3.scope.search.events))], null, t3.scope.search)], 2), t3._v(" "), n2("div", { ref: "actions", staticClass: "vs__actions" }, [n2("button", { directives: [{ name: "show", rawName: "v-show", value: t3.showClearButton, expression: "showClearButton" }], ref: "clearButton", staticClass: "vs__clear", attrs: { disabled: t3.disabled, type: "button", title: "Clear Selected", "aria-label": "Clear Selected" }, on: { click: t3.clearSelection } }, [n2(t3.childComponents.Deselect, { tag: "component" })], 1), t3._v(" "), t3._t("open-indicator", [t3.noDrop ? t3._e() : n2(t3.childComponents.OpenIndicator, t3._b({ tag: "component" }, "component", t3.scope.openIndicator.attributes, false))], null, t3.scope.openIndicator), t3._v(" "), t3._t("spinner", [n2("div", { directives: [{ name: "show", rawName: "v-show", value: t3.mutableLoading, expression: "mutableLoading" }], staticClass: "vs__spinner" }, [t3._v("Loading...")])], null, t3.scope.spinner)], 2)]), t3._v(" "), n2("transition", { attrs: { name: t3.transition } }, [t3.dropdownOpen ? n2("ul", { directives: [{ name: "append-to-body", rawName: "v-append-to-body" }], key: "vs" + t3.uid + "__listbox", ref: "dropdownMenu", staticClass: "vs__dropdown-menu", attrs: { id: "vs" + t3.uid + "__listbox", role: "listbox", tabindex: "-1" }, on: { mousedown: function(e4) {
                return e4.preventDefault(), t3.onMousedown(e4);
              }, mouseup: t3.onMouseUp } }, [t3._t("list-header", null, null, t3.scope.listHeader), t3._v(" "), t3._l(t3.filteredOptions, function(e4, o2) {
                return n2("li", { key: t3.getOptionKey(e4), staticClass: "vs__dropdown-option", class: { "vs__dropdown-option--deselect": t3.isOptionDeselectable(e4) && o2 === t3.typeAheadPointer, "vs__dropdown-option--selected": t3.isOptionSelected(e4), "vs__dropdown-option--highlight": o2 === t3.typeAheadPointer, "vs__dropdown-option--disabled": !t3.selectable(e4) }, attrs: { id: "vs" + t3.uid + "__option-" + o2, role: "option", "aria-selected": o2 === t3.typeAheadPointer || null }, on: { mouseover: function(n3) {
                  t3.selectable(e4) && (t3.typeAheadPointer = o2);
                }, click: function(n3) {
                  n3.preventDefault(), n3.stopPropagation(), t3.selectable(e4) && t3.select(e4);
                } } }, [t3._t("option", [t3._v("\n          " + t3._s(t3.getOptionLabel(e4)) + "\n        ")], null, t3.normalizeOptionForSlot(e4))], 2);
              }), t3._v(" "), t3.filteredOptions.length === 0 ? n2("li", { staticClass: "vs__no-options" }, [t3._t("no-options", [t3._v("\n          Sorry, no matching options.\n        ")], null, t3.scope.noOptions)], 2) : t3._e(), t3._v(" "), t3._t("list-footer", null, null, t3.scope.listFooter)], 2) : n2("ul", { staticStyle: { display: "none", visibility: "hidden" }, attrs: { id: "vs" + t3.uid + "__listbox", role: "listbox" } })]), t3._v(" "), t3._t("footer", null, null, t3.scope.footer)], 2);
            }, [], false, null, null, null).exports, _ = { ajax: u, pointer: c, pointerScroll: l }, O = m;
          })(), o;
        })();
      });
    }
  });

  // node_modules/axios/lib/helpers/bind.js
  var require_bind = __commonJS({
    "node_modules/axios/lib/helpers/bind.js"(exports, module) {
      "use strict";
      module.exports = function bind(fn, thisArg) {
        return function wrap() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          return fn.apply(thisArg, args);
        };
      };
    }
  });

  // node_modules/axios/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/axios/lib/utils.js"(exports, module) {
      "use strict";
      var bind = require_bind();
      var toString2 = Object.prototype.toString;
      function isArray2(val) {
        return Array.isArray(val);
      }
      function isUndefined(val) {
        return typeof val === "undefined";
      }
      function isBuffer(val) {
        return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
      }
      function isArrayBuffer(val) {
        return toString2.call(val) === "[object ArrayBuffer]";
      }
      function isFormData(val) {
        return toString2.call(val) === "[object FormData]";
      }
      function isArrayBufferView(val) {
        var result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && isArrayBuffer(val.buffer);
        }
        return result;
      }
      function isString2(val) {
        return typeof val === "string";
      }
      function isNumber(val) {
        return typeof val === "number";
      }
      function isObject2(val) {
        return val !== null && typeof val === "object";
      }
      function isPlainObject2(val) {
        if (toString2.call(val) !== "[object Object]") {
          return false;
        }
        var prototype = Object.getPrototypeOf(val);
        return prototype === null || prototype === Object.prototype;
      }
      function isDate(val) {
        return toString2.call(val) === "[object Date]";
      }
      function isFile(val) {
        return toString2.call(val) === "[object File]";
      }
      function isBlob(val) {
        return toString2.call(val) === "[object Blob]";
      }
      function isFunction2(val) {
        return toString2.call(val) === "[object Function]";
      }
      function isStream(val) {
        return isObject2(val) && isFunction2(val.pipe);
      }
      function isURLSearchParams(val) {
        return toString2.call(val) === "[object URLSearchParams]";
      }
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function isStandardBrowserEnv() {
        if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
          return false;
        }
        return typeof window !== "undefined" && typeof document !== "undefined";
      }
      function forEach(obj, fn) {
        if (obj === null || typeof obj === "undefined") {
          return;
        }
        if (typeof obj !== "object") {
          obj = [obj];
        }
        if (isArray2(obj)) {
          for (var i = 0, l = obj.length; i < l; i++) {
            fn.call(null, obj[i], i, obj);
          }
        } else {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              fn.call(null, obj[key], key, obj);
            }
          }
        }
      }
      function merge() {
        var result = {};
        function assignValue(val, key) {
          if (isPlainObject2(result[key]) && isPlainObject2(val)) {
            result[key] = merge(result[key], val);
          } else if (isPlainObject2(val)) {
            result[key] = merge({}, val);
          } else if (isArray2(val)) {
            result[key] = val.slice();
          } else {
            result[key] = val;
          }
        }
        for (var i = 0, l = arguments.length; i < l; i++) {
          forEach(arguments[i], assignValue);
        }
        return result;
      }
      function extend(a, b, thisArg) {
        forEach(b, function assignValue(val, key) {
          if (thisArg && typeof val === "function") {
            a[key] = bind(val, thisArg);
          } else {
            a[key] = val;
          }
        });
        return a;
      }
      function stripBOM(content) {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      }
      module.exports = {
        isArray: isArray2,
        isArrayBuffer,
        isBuffer,
        isFormData,
        isArrayBufferView,
        isString: isString2,
        isNumber,
        isObject: isObject2,
        isPlainObject: isPlainObject2,
        isUndefined,
        isDate,
        isFile,
        isBlob,
        isFunction: isFunction2,
        isStream,
        isURLSearchParams,
        isStandardBrowserEnv,
        forEach,
        merge,
        extend,
        trim,
        stripBOM
      };
    }
  });

  // node_modules/axios/lib/helpers/buildURL.js
  var require_buildURL = __commonJS({
    "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      function encode(val) {
        return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      module.exports = function buildURL(url, params, paramsSerializer) {
        if (!params) {
          return url;
        }
        var serializedParams;
        if (paramsSerializer) {
          serializedParams = paramsSerializer(params);
        } else if (utils.isURLSearchParams(params)) {
          serializedParams = params.toString();
        } else {
          var parts = [];
          utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === "undefined") {
              return;
            }
            if (utils.isArray(val)) {
              key = key + "[]";
            } else {
              val = [val];
            }
            utils.forEach(val, function parseValue(v) {
              if (utils.isDate(v)) {
                v = v.toISOString();
              } else if (utils.isObject(v)) {
                v = JSON.stringify(v);
              }
              parts.push(encode(key) + "=" + encode(v));
            });
          });
          serializedParams = parts.join("&");
        }
        if (serializedParams) {
          var hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }
          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url;
      };
    }
  });

  // node_modules/axios/lib/core/InterceptorManager.js
  var require_InterceptorManager = __commonJS({
    "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      function InterceptorManager() {
        this.handlers = [];
      }
      InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      };
      InterceptorManager.prototype.eject = function eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      };
      InterceptorManager.prototype.forEach = function forEach(fn) {
        utils.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      };
      module.exports = InterceptorManager;
    }
  });

  // node_modules/axios/lib/helpers/normalizeHeaderName.js
  var require_normalizeHeaderName = __commonJS({
    "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = function normalizeHeaderName(headers, normalizedName) {
        utils.forEach(headers, function processHeader(value, name) {
          if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name];
          }
        });
      };
    }
  });

  // node_modules/axios/lib/core/enhanceError.js
  var require_enhanceError = __commonJS({
    "node_modules/axios/lib/core/enhanceError.js"(exports, module) {
      "use strict";
      module.exports = function enhanceError(error, config, code, request, response) {
        error.config = config;
        if (code) {
          error.code = code;
        }
        error.request = request;
        error.response = response;
        error.isAxiosError = true;
        error.toJSON = function toJSON() {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: this.config,
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
          };
        };
        return error;
      };
    }
  });

  // node_modules/axios/lib/core/createError.js
  var require_createError = __commonJS({
    "node_modules/axios/lib/core/createError.js"(exports, module) {
      "use strict";
      var enhanceError = require_enhanceError();
      module.exports = function createError(message, config, code, request, response) {
        var error = new Error(message);
        return enhanceError(error, config, code, request, response);
      };
    }
  });

  // node_modules/axios/lib/core/settle.js
  var require_settle = __commonJS({
    "node_modules/axios/lib/core/settle.js"(exports, module) {
      "use strict";
      var createError = require_createError();
      module.exports = function settle(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
        }
      };
    }
  });

  // node_modules/axios/lib/helpers/cookies.js
  var require_cookies = __commonJS({
    "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }() : function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }();
    }
  });

  // node_modules/axios/lib/helpers/isAbsoluteURL.js
  var require_isAbsoluteURL = __commonJS({
    "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
      "use strict";
      module.exports = function isAbsoluteURL(url) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
      };
    }
  });

  // node_modules/axios/lib/helpers/combineURLs.js
  var require_combineURLs = __commonJS({
    "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
      "use strict";
      module.exports = function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      };
    }
  });

  // node_modules/axios/lib/core/buildFullPath.js
  var require_buildFullPath = __commonJS({
    "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
      "use strict";
      var isAbsoluteURL = require_isAbsoluteURL();
      var combineURLs = require_combineURLs();
      module.exports = function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      };
    }
  });

  // node_modules/axios/lib/helpers/parseHeaders.js
  var require_parseHeaders = __commonJS({
    "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var ignoreDuplicateOf = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ];
      module.exports = function parseHeaders(headers) {
        var parsed = {};
        var key;
        var val;
        var i;
        if (!headers) {
          return parsed;
        }
        utils.forEach(headers.split("\n"), function parser(line) {
          i = line.indexOf(":");
          key = utils.trim(line.substr(0, i)).toLowerCase();
          val = utils.trim(line.substr(i + 1));
          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });
        return parsed;
      };
    }
  });

  // node_modules/axios/lib/helpers/isURLSameOrigin.js
  var require_isURLSameOrigin = __commonJS({
    "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }() : function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }();
    }
  });

  // node_modules/axios/lib/cancel/Cancel.js
  var require_Cancel = __commonJS({
    "node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
      "use strict";
      function Cancel(message) {
        this.message = message;
      }
      Cancel.prototype.toString = function toString2() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      };
      Cancel.prototype.__CANCEL__ = true;
      module.exports = Cancel;
    }
  });

  // node_modules/axios/lib/adapters/xhr.js
  var require_xhr = __commonJS({
    "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var settle = require_settle();
      var cookies = require_cookies();
      var buildURL = require_buildURL();
      var buildFullPath = require_buildFullPath();
      var parseHeaders = require_parseHeaders();
      var isURLSameOrigin = require_isURLSameOrigin();
      var createError = require_createError();
      var defaults = require_defaults();
      var Cancel = require_Cancel();
      module.exports = function xhrAdapter(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config.data;
          var requestHeaders = config.headers;
          var responseType = config.responseType;
          var onCanceled;
          function done() {
            if (config.cancelToken) {
              config.cancelToken.unsubscribe(onCanceled);
            }
            if (config.signal) {
              config.signal.removeEventListener("abort", onCanceled);
            }
          }
          if (utils.isFormData(requestData)) {
            delete requestHeaders["Content-Type"];
          }
          var request = new XMLHttpRequest();
          if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
          }
          var fullPath = buildFullPath(config.baseURL, config.url);
          request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
          request.timeout = config.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config,
              request
            };
            settle(function _resolve(value) {
              resolve(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(createError("Request aborted", config, "ECONNABORTED", request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(createError("Network Error", config, null, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            var transitional = config.transitional || defaults.transitional;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(createError(timeoutErrorMessage, config, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request));
            request = null;
          };
          if (utils.isStandardBrowserEnv()) {
            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
            if (xsrfValue) {
              requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
          }
          if ("setRequestHeader" in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                delete requestHeaders[key];
              } else {
                request.setRequestHeader(key, val);
              }
            });
          }
          if (!utils.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config.responseType;
          }
          if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", config.onDownloadProgress);
          }
          if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config.onUploadProgress);
          }
          if (config.cancelToken || config.signal) {
            onCanceled = function(cancel) {
              if (!request) {
                return;
              }
              reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
              request.abort();
              request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) {
              config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
            }
          }
          if (!requestData) {
            requestData = null;
          }
          request.send(requestData);
        });
      };
    }
  });

  // node_modules/axios/lib/defaults.js
  var require_defaults = __commonJS({
    "node_modules/axios/lib/defaults.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var normalizeHeaderName = require_normalizeHeaderName();
      var enhanceError = require_enhanceError();
      var DEFAULT_CONTENT_TYPE = {
        "Content-Type": "application/x-www-form-urlencoded"
      };
      function setContentTypeIfUnset(headers, value) {
        if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
          headers["Content-Type"] = value;
        }
      }
      function getDefaultAdapter() {
        var adapter;
        if (typeof XMLHttpRequest !== "undefined") {
          adapter = require_xhr();
        } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
          adapter = require_xhr();
        }
        return adapter;
      }
      function stringifySafely(rawValue, parser, encoder) {
        if (utils.isString(rawValue)) {
          try {
            (parser || JSON.parse)(rawValue);
            return utils.trim(rawValue);
          } catch (e) {
            if (e.name !== "SyntaxError") {
              throw e;
            }
          }
        }
        return (encoder || JSON.stringify)(rawValue);
      }
      var defaults = {
        transitional: {
          silentJSONParsing: true,
          forcedJSONParsing: true,
          clarifyTimeoutError: false
        },
        adapter: getDefaultAdapter(),
        transformRequest: [function transformRequest(data2, headers) {
          normalizeHeaderName(headers, "Accept");
          normalizeHeaderName(headers, "Content-Type");
          if (utils.isFormData(data2) || utils.isArrayBuffer(data2) || utils.isBuffer(data2) || utils.isStream(data2) || utils.isFile(data2) || utils.isBlob(data2)) {
            return data2;
          }
          if (utils.isArrayBufferView(data2)) {
            return data2.buffer;
          }
          if (utils.isURLSearchParams(data2)) {
            setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
            return data2.toString();
          }
          if (utils.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
            setContentTypeIfUnset(headers, "application/json");
            return stringifySafely(data2);
          }
          return data2;
        }],
        transformResponse: [function transformResponse(data2) {
          var transitional = this.transitional || defaults.transitional;
          var silentJSONParsing = transitional && transitional.silentJSONParsing;
          var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
          var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
          if (strictJSONParsing || forcedJSONParsing && utils.isString(data2) && data2.length) {
            try {
              return JSON.parse(data2);
            } catch (e) {
              if (strictJSONParsing) {
                if (e.name === "SyntaxError") {
                  throw enhanceError(e, this, "E_JSON_PARSE");
                }
                throw e;
              }
            }
          }
          return data2;
        }],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        },
        headers: {
          common: {
            "Accept": "application/json, text/plain, */*"
          }
        }
      };
      utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
        defaults.headers[method] = {};
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
      });
      module.exports = defaults;
    }
  });

  // node_modules/axios/lib/core/transformData.js
  var require_transformData = __commonJS({
    "node_modules/axios/lib/core/transformData.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var defaults = require_defaults();
      module.exports = function transformData(data2, headers, fns) {
        var context = this || defaults;
        utils.forEach(fns, function transform(fn) {
          data2 = fn.call(context, data2, headers);
        });
        return data2;
      };
    }
  });

  // node_modules/axios/lib/cancel/isCancel.js
  var require_isCancel = __commonJS({
    "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
      "use strict";
      module.exports = function isCancel(value) {
        return !!(value && value.__CANCEL__);
      };
    }
  });

  // node_modules/axios/lib/core/dispatchRequest.js
  var require_dispatchRequest = __commonJS({
    "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var transformData = require_transformData();
      var isCancel = require_isCancel();
      var defaults = require_defaults();
      var Cancel = require_Cancel();
      function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
          config.cancelToken.throwIfRequested();
        }
        if (config.signal && config.signal.aborted) {
          throw new Cancel("canceled");
        }
      }
      module.exports = function dispatchRequest(config) {
        throwIfCancellationRequested(config);
        config.headers = config.headers || {};
        config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
        config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
        utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
          delete config.headers[method];
        });
        var adapter = config.adapter || defaults.adapter;
        return adapter(config).then(function onAdapterResolution(response) {
          throwIfCancellationRequested(config);
          response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            if (reason && reason.response) {
              reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
            }
          }
          return Promise.reject(reason);
        });
      };
    }
  });

  // node_modules/axios/lib/core/mergeConfig.js
  var require_mergeConfig = __commonJS({
    "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = function mergeConfig(config1, config2) {
        config2 = config2 || {};
        var config = {};
        function getMergedValue(target, source) {
          if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
            return utils.merge(target, source);
          } else if (utils.isPlainObject(source)) {
            return utils.merge({}, source);
          } else if (utils.isArray(source)) {
            return source.slice();
          }
          return source;
        }
        function mergeDeepProperties(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function valueFromConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(void 0, config2[prop]);
          }
        }
        function defaultToConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(void 0, config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function mergeDirectKeys(prop) {
          if (prop in config2) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (prop in config1) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        var mergeMap = {
          "url": valueFromConfig2,
          "method": valueFromConfig2,
          "data": valueFromConfig2,
          "baseURL": defaultToConfig2,
          "transformRequest": defaultToConfig2,
          "transformResponse": defaultToConfig2,
          "paramsSerializer": defaultToConfig2,
          "timeout": defaultToConfig2,
          "timeoutMessage": defaultToConfig2,
          "withCredentials": defaultToConfig2,
          "adapter": defaultToConfig2,
          "responseType": defaultToConfig2,
          "xsrfCookieName": defaultToConfig2,
          "xsrfHeaderName": defaultToConfig2,
          "onUploadProgress": defaultToConfig2,
          "onDownloadProgress": defaultToConfig2,
          "decompress": defaultToConfig2,
          "maxContentLength": defaultToConfig2,
          "maxBodyLength": defaultToConfig2,
          "transport": defaultToConfig2,
          "httpAgent": defaultToConfig2,
          "httpsAgent": defaultToConfig2,
          "cancelToken": defaultToConfig2,
          "socketPath": defaultToConfig2,
          "responseEncoding": defaultToConfig2,
          "validateStatus": mergeDirectKeys
        };
        utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
          var merge = mergeMap[prop] || mergeDeepProperties;
          var configValue = merge(prop);
          utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
        });
        return config;
      };
    }
  });

  // node_modules/axios/lib/env/data.js
  var require_data = __commonJS({
    "node_modules/axios/lib/env/data.js"(exports, module) {
      module.exports = {
        "version": "0.26.0"
      };
    }
  });

  // node_modules/axios/lib/helpers/validator.js
  var require_validator = __commonJS({
    "node_modules/axios/lib/helpers/validator.js"(exports, module) {
      "use strict";
      var VERSION = require_data().version;
      var validators = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
        validators[type] = function validator2(thing) {
          return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
        };
      });
      var deprecatedWarnings = {};
      validators.transitional = function transitional(validator2, version2, message) {
        function formatMessage(opt, desc) {
          return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
        }
        return function(value, opt, opts) {
          if (validator2 === false) {
            throw new Error(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")));
          }
          if (version2 && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
          }
          return validator2 ? validator2(value, opt, opts) : true;
        };
      };
      function assertOptions(options, schema, allowUnknown) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        var keys = Object.keys(options);
        var i = keys.length;
        while (i-- > 0) {
          var opt = keys[i];
          var validator2 = schema[opt];
          if (validator2) {
            var value = options[opt];
            var result = value === void 0 || validator2(value, opt, options);
            if (result !== true) {
              throw new TypeError("option " + opt + " must be " + result);
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw Error("Unknown option " + opt);
          }
        }
      }
      module.exports = {
        assertOptions,
        validators
      };
    }
  });

  // node_modules/axios/lib/core/Axios.js
  var require_Axios = __commonJS({
    "node_modules/axios/lib/core/Axios.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var buildURL = require_buildURL();
      var InterceptorManager = require_InterceptorManager();
      var dispatchRequest = require_dispatchRequest();
      var mergeConfig = require_mergeConfig();
      var validator2 = require_validator();
      var validators = validator2.validators;
      function Axios(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      Axios.prototype.request = function request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        if (config.method) {
          config.method = config.method.toLowerCase();
        } else if (this.defaults.method) {
          config.method = this.defaults.method.toLowerCase();
        } else {
          config.method = "get";
        }
        var transitional = config.transitional;
        if (transitional !== void 0) {
          validator2.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        var requestInterceptorChain = [];
        var synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        var responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        var promise;
        if (!synchronousRequestInterceptors) {
          var chain = [dispatchRequest, void 0];
          Array.prototype.unshift.apply(chain, requestInterceptorChain);
          chain = chain.concat(responseInterceptorChain);
          promise = Promise.resolve(config);
          while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
          }
          return promise;
        }
        var newConfig = config;
        while (requestInterceptorChain.length) {
          var onFulfilled = requestInterceptorChain.shift();
          var onRejected = requestInterceptorChain.shift();
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected(error);
            break;
          }
        }
        try {
          promise = dispatchRequest(newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        while (responseInterceptorChain.length) {
          promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
        }
        return promise;
      };
      Axios.prototype.getUri = function getUri(config) {
        config = mergeConfig(this.defaults, config);
        return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
      };
      utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
        Axios.prototype[method] = function(url, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            url,
            data: (config || {}).data
          }));
        };
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        Axios.prototype[method] = function(url, data2, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            url,
            data: data2
          }));
        };
      });
      module.exports = Axios;
    }
  });

  // node_modules/axios/lib/cancel/CancelToken.js
  var require_CancelToken = __commonJS({
    "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
      "use strict";
      var Cancel = require_Cancel();
      function CancelToken(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        var token = this;
        this.promise.then(function(cancel) {
          if (!token._listeners)
            return;
          var i;
          var l = token._listeners.length;
          for (i = 0; i < l; i++) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = function(onfulfilled) {
          var _resolve;
          var promise = new Promise(function(resolve) {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message) {
          if (token.reason) {
            return;
          }
          token.reason = new Cancel(message);
          resolvePromise(token.reason);
        });
      }
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };
      CancelToken.prototype.subscribe = function subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      };
      CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        var index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      };
      CancelToken.source = function source() {
        var cancel;
        var token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      };
      module.exports = CancelToken;
    }
  });

  // node_modules/axios/lib/helpers/spread.js
  var require_spread = __commonJS({
    "node_modules/axios/lib/helpers/spread.js"(exports, module) {
      "use strict";
      module.exports = function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };
    }
  });

  // node_modules/axios/lib/helpers/isAxiosError.js
  var require_isAxiosError = __commonJS({
    "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = function isAxiosError(payload) {
        return utils.isObject(payload) && payload.isAxiosError === true;
      };
    }
  });

  // node_modules/axios/lib/axios.js
  var require_axios = __commonJS({
    "node_modules/axios/lib/axios.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var bind = require_bind();
      var Axios = require_Axios();
      var mergeConfig = require_mergeConfig();
      var defaults = require_defaults();
      function createInstance(defaultConfig) {
        var context = new Axios(defaultConfig);
        var instance = bind(Axios.prototype.request, context);
        utils.extend(instance, Axios.prototype, context);
        utils.extend(instance, context);
        instance.create = function create(instanceConfig) {
          return createInstance(mergeConfig(defaultConfig, instanceConfig));
        };
        return instance;
      }
      var axios2 = createInstance(defaults);
      axios2.Axios = Axios;
      axios2.Cancel = require_Cancel();
      axios2.CancelToken = require_CancelToken();
      axios2.isCancel = require_isCancel();
      axios2.VERSION = require_data().version;
      axios2.all = function all(promises) {
        return Promise.all(promises);
      };
      axios2.spread = require_spread();
      axios2.isAxiosError = require_isAxiosError();
      module.exports = axios2;
      module.exports.default = axios2;
    }
  });

  // node_modules/axios/index.js
  var require_axios2 = __commonJS({
    "node_modules/axios/index.js"(exports, module) {
      module.exports = require_axios();
    }
  });

  // node_modules/moment/moment.js
  var require_moment = __commonJS({
    "node_modules/moment/moment.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
      })(exports, function() {
        "use strict";
        var hookCallback;
        function hooks() {
          return hookCallback.apply(null, arguments);
        }
        function setHookCallback(callback) {
          hookCallback = callback;
        }
        function isArray2(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
        }
        function isObject2(input) {
          return input != null && Object.prototype.toString.call(input) === "[object Object]";
        }
        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k;
            for (k in obj) {
              if (hasOwnProp(obj, k)) {
                return false;
              }
            }
            return true;
          }
        }
        function isUndefined(input) {
          return input === void 0;
        }
        function isNumber(input) {
          return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
        }
        function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
        }
        function map(arr, fn) {
          var res = [], i;
          for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
          }
          return res;
        }
        function extend(a, b) {
          for (var i in b) {
            if (hasOwnProp(b, i)) {
              a[i] = b[i];
            }
          }
          if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
          }
          if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
          }
          return a;
        }
        function createUTC(input, format4, locale2, strict) {
          return createLocalOrUTC(input, format4, locale2, strict, true).utc();
        }
        function defaultParsingFlags() {
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }
        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }
          return m._pf;
        }
        var some;
        if (Array.prototype.some) {
          some = Array.prototype.some;
        } else {
          some = function(fun) {
            var t = Object(this), len = t.length >>> 0, i;
            for (i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                return true;
              }
            }
            return false;
          };
        }
        function isValid(m) {
          if (m._isValid == null) {
            var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
              return i != null;
            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
              m._isValid = isNowValid;
            } else {
              return isNowValid;
            }
          }
          return m._isValid;
        }
        function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
            extend(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }
          return m;
        }
        var momentProperties = hooks.momentProperties = [], updateInProgress = false;
        function copyConfig(to2, from2) {
          var i, prop, val;
          if (!isUndefined(from2._isAMomentObject)) {
            to2._isAMomentObject = from2._isAMomentObject;
          }
          if (!isUndefined(from2._i)) {
            to2._i = from2._i;
          }
          if (!isUndefined(from2._f)) {
            to2._f = from2._f;
          }
          if (!isUndefined(from2._l)) {
            to2._l = from2._l;
          }
          if (!isUndefined(from2._strict)) {
            to2._strict = from2._strict;
          }
          if (!isUndefined(from2._tzm)) {
            to2._tzm = from2._tzm;
          }
          if (!isUndefined(from2._isUTC)) {
            to2._isUTC = from2._isUTC;
          }
          if (!isUndefined(from2._offset)) {
            to2._offset = from2._offset;
          }
          if (!isUndefined(from2._pf)) {
            to2._pf = getParsingFlags(from2);
          }
          if (!isUndefined(from2._locale)) {
            to2._locale = from2._locale;
          }
          if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
              prop = momentProperties[i];
              val = from2[prop];
              if (!isUndefined(val)) {
                to2[prop] = val;
              }
            }
          }
          return to2;
        }
        function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
            this._d = new Date(NaN);
          }
          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }
        function isMoment(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }
        function warn2(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
          }
        }
        function deprecate(msg, fn) {
          var firstTime = true;
          return extend(function() {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
              var args = [], arg, i, key;
              for (i = 0; i < arguments.length; i++) {
                arg = "";
                if (typeof arguments[i] === "object") {
                  arg += "\n[" + i + "] ";
                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ": " + arguments[0][key] + ", ";
                    }
                  }
                  arg = arg.slice(0, -2);
                } else {
                  arg = arguments[i];
                }
                args.push(arg);
              }
              warn2(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
              firstTime = false;
            }
            return fn.apply(this, arguments);
          }, fn);
        }
        var deprecations = {};
        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
            warn2(msg);
            deprecations[name] = true;
          }
        }
        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;
        function isFunction2(input) {
          return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
        }
        function set3(config) {
          var prop, i;
          for (i in config) {
            if (hasOwnProp(config, i)) {
              prop = config[i];
              if (isFunction2(prop)) {
                this[i] = prop;
              } else {
                this["_" + i] = prop;
              }
            }
          }
          this._config = config;
          this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
        }
        function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig), prop;
          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }
          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
              res[prop] = extend({}, res[prop]);
            }
          }
          return res;
        }
        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }
        var keys;
        if (Object.keys) {
          keys = Object.keys;
        } else {
          keys = function(obj) {
            var i, res = [];
            for (i in obj) {
              if (hasOwnProp(obj, i)) {
                res.push(i);
              }
            }
            return res;
          };
        }
        var defaultCalendar = {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        };
        function calendar(key, mom, now2) {
          var output = this._calendar[key] || this._calendar["sameElse"];
          return isFunction2(output) ? output.call(mom, now2) : output;
        }
        function zeroFill(number, targetLength, forceSign) {
          var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
          return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }
        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
        function addFormatToken(token2, padded, ordinal2, callback) {
          var func = callback;
          if (typeof callback === "string") {
            func = function() {
              return this[callback]();
            };
          }
          if (token2) {
            formatTokenFunctions[token2] = func;
          }
          if (padded) {
            formatTokenFunctions[padded[0]] = function() {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }
          if (ordinal2) {
            formatTokenFunctions[ordinal2] = function() {
              return this.localeData().ordinal(func.apply(this, arguments), token2);
            };
          }
        }
        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
          }
          return input.replace(/\\/g, "");
        }
        function makeFormatFunction(format4) {
          var array = format4.match(formattingTokens), i, length;
          for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
              array[i] = formatTokenFunctions[array[i]];
            } else {
              array[i] = removeFormattingTokens(array[i]);
            }
          }
          return function(mom) {
            var output = "", i2;
            for (i2 = 0; i2 < length; i2++) {
              output += isFunction2(array[i2]) ? array[i2].call(mom, format4) : array[i2];
            }
            return output;
          };
        }
        function formatMoment(m, format4) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }
          format4 = expandFormat(format4, m.localeData());
          formatFunctions[format4] = formatFunctions[format4] || makeFormatFunction(format4);
          return formatFunctions[format4](m);
        }
        function expandFormat(format4, locale2) {
          var i = 5;
          function replaceLongDateFormatTokens(input) {
            return locale2.longDateFormat(input) || input;
          }
          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format4)) {
            format4 = format4.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
          }
          return format4;
        }
        var defaultLongDateFormat = {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A"
        };
        function longDateFormat(key) {
          var format4 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
          if (format4 || !formatUpper) {
            return format4;
          }
          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
            if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
              return tok.slice(1);
            }
            return tok;
          }).join("");
          return this._longDateFormat[key];
        }
        var defaultInvalidDate = "Invalid date";
        function invalidDate() {
          return this._invalidDate;
        }
        var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
        function ordinal(number) {
          return this._ordinal.replace("%d", number);
        }
        var defaultRelativeTime = {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          w: "a week",
          ww: "%d weeks",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        };
        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction2(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }
        function pastFuture(diff2, output) {
          var format4 = this._relativeTime[diff2 > 0 ? "future" : "past"];
          return isFunction2(format4) ? format4(output) : format4.replace(/%s/i, output);
        }
        var aliases = {};
        function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
        }
        function normalizeUnits(units) {
          return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
        }
        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {}, normalizedProp, prop;
          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }
          return normalizedInput;
        }
        var priorities = {};
        function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
        }
        function getPrioritizedUnits(unitsObj) {
          var units = [], u;
          for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
              units.push({ unit: u, priority: priorities[u] });
            }
          }
          units.sort(function(a, b) {
            return a.priority - b.priority;
          });
          return units;
        }
        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        function absFloor(number) {
          if (number < 0) {
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }
        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion, value = 0;
          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }
          return value;
        }
        function makeGetSet(unit, keepTime) {
          return function(value) {
            if (value != null) {
              set$12(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get2(this, unit);
            }
          };
        }
        function get2(mom, unit) {
          return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
        }
        function set$12(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
            if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
              value = toInt(value);
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
            } else {
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
            }
          }
        }
        function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction2(this[units])) {
            return this[units]();
          }
          return this;
        }
        function stringSet(units, value) {
          if (typeof units === "object") {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units), i;
            for (i = 0; i < prioritized.length; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
            }
          } else {
            units = normalizeUnits(units);
            if (isFunction2(this[units])) {
              return this[units](value);
            }
          }
          return this;
        }
        var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
        regexes = {};
        function addRegexToken(token2, regex, strictRegex) {
          regexes[token2] = isFunction2(regex) ? regex : function(isStrict, localeData2) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }
        function getParseRegexForToken(token2, config) {
          if (!hasOwnProp(regexes, token2)) {
            return new RegExp(unescapeFormat(token2));
          }
          return regexes[token2](config._strict, config._locale);
        }
        function unescapeFormat(s) {
          return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }));
        }
        function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        var tokens = {};
        function addParseToken(token2, callback) {
          var i, func = callback;
          if (typeof token2 === "string") {
            token2 = [token2];
          }
          if (isNumber(callback)) {
            func = function(input, array) {
              array[callback] = toInt(input);
            };
          }
          for (i = 0; i < token2.length; i++) {
            tokens[token2[i]] = func;
          }
        }
        function addWeekParseToken(token2, callback) {
          addParseToken(token2, function(input, array, config, token3) {
            config._w = config._w || {};
            callback(input, config._w, config, token3);
          });
        }
        function addTimeToArrayFromToken(token2, input, config) {
          if (input != null && hasOwnProp(tokens, token2)) {
            tokens[token2](input, config._a, config, token2);
          }
        }
        var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
        function mod(n, x) {
          return (n % x + x) % x;
        }
        var indexOf;
        if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
        } else {
          indexOf = function(o) {
            var i;
            for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                return i;
              }
            }
            return -1;
          };
        }
        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        }
        addFormatToken("M", ["MM", 2], "Mo", function() {
          return this.month() + 1;
        });
        addFormatToken("MMM", 0, 0, function(format4) {
          return this.localeData().monthsShort(this, format4);
        });
        addFormatToken("MMMM", 0, 0, function(format4) {
          return this.localeData().months(this, format4);
        });
        addUnitAlias("month", "M");
        addUnitPriority("month", 8);
        addRegexToken("M", match1to2);
        addRegexToken("MM", match1to2, match2);
        addRegexToken("MMM", function(isStrict, locale2) {
          return locale2.monthsShortRegex(isStrict);
        });
        addRegexToken("MMMM", function(isStrict, locale2) {
          return locale2.monthsRegex(isStrict);
        });
        addParseToken(["M", "MM"], function(input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
          var month = config._locale.monthsParse(input, token2, config._strict);
          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        });
        var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
        function localeMonths(m, format4) {
          if (!m) {
            return isArray2(this._months) ? this._months : this._months["standalone"];
          }
          return isArray2(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format4) ? "format" : "standalone"][m.month()];
        }
        function localeMonthsShort(m, format4) {
          if (!m) {
            return isArray2(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
          }
          return isArray2(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format4) ? "format" : "standalone"][m.month()];
        }
        function handleStrictParse(monthName, format4, strict) {
          var i, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
              mom = createUTC([2e3, i]);
              this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format4 === "MMM") {
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format4 === "MMM") {
              ii = indexOf.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeMonthsParse(monthName, format4, strict) {
          var i, mom, regex;
          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format4, strict);
          }
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }
          for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
              this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
            }
            if (!strict && !this._monthsParse[i]) {
              regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
              this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format4 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
              return i;
            } else if (strict && format4 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
              return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
            }
          }
        }
        function setMonth(mom, value) {
          var dayOfMonth;
          if (!mom.isValid()) {
            return mom;
          }
          if (typeof value === "string") {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value);
              if (!isNumber(value)) {
                return mom;
              }
            }
          }
          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
          return mom;
        }
        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get2(this, "Month");
          }
        }
        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }
        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsShortRegex")) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }
        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsRegex")) {
              this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }
        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
          for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            shortPieces.push(this.monthsShort(mom, ""));
            longPieces.push(this.months(mom, ""));
            mixedPieces.push(this.months(mom, ""));
            mixedPieces.push(this.monthsShort(mom, ""));
          }
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
          }
          this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
          this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
        }
        addFormatToken("Y", 0, 0, function() {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : "+" + y;
        });
        addFormatToken(0, ["YY", 2], 0, function() {
          return this.year() % 100;
        });
        addFormatToken(0, ["YYYY", 4], 0, "year");
        addFormatToken(0, ["YYYYY", 5], 0, "year");
        addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
        addUnitAlias("year", "y");
        addUnitPriority("year", 1);
        addRegexToken("Y", matchSigned);
        addRegexToken("YY", match1to2, match2);
        addRegexToken("YYYY", match1to4, match4);
        addRegexToken("YYYYY", match1to6, match6);
        addRegexToken("YYYYYY", match1to6, match6);
        addParseToken(["YYYYY", "YYYYYY"], YEAR);
        addParseToken("YYYY", function(input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken("YY", function(input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken("Y", function(input, array) {
          array[YEAR] = parseInt(input, 10);
        });
        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }
        hooks.parseTwoDigitYear = function(input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
        };
        var getSetYear = makeGetSet("FullYear", true);
        function getIsLeapYear() {
          return isLeapYear(this.year());
        }
        function createDate(y, m, d, h, M, s, ms) {
          var date;
          if (y < 100 && y >= 0) {
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
            }
          } else {
            date = new Date(y, m, d, h, M, s, ms);
          }
          return date;
        }
        function createUTCDate(y) {
          var date, args;
          if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }
          return date;
        }
        function firstWeekOffset(year, dow, doy) {
          var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        }
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }
          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }
        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }
          return {
            week: resWeek,
            year: resYear
          };
        }
        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }
        addFormatToken("w", ["ww", 2], "wo", "week");
        addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
        addUnitAlias("week", "w");
        addUnitAlias("isoWeek", "W");
        addUnitPriority("week", 5);
        addUnitPriority("isoWeek", 5);
        addRegexToken("w", match1to2);
        addRegexToken("ww", match1to2, match2);
        addRegexToken("W", match1to2);
        addRegexToken("WW", match1to2, match2);
        addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        });
        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
        var defaultLocaleWeek = {
          dow: 0,
          doy: 6
        };
        function localeFirstDayOfWeek() {
          return this._week.dow;
        }
        function localeFirstDayOfYear() {
          return this._week.doy;
        }
        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        addFormatToken("d", 0, "do", "day");
        addFormatToken("dd", 0, 0, function(format4) {
          return this.localeData().weekdaysMin(this, format4);
        });
        addFormatToken("ddd", 0, 0, function(format4) {
          return this.localeData().weekdaysShort(this, format4);
        });
        addFormatToken("dddd", 0, 0, function(format4) {
          return this.localeData().weekdays(this, format4);
        });
        addFormatToken("e", 0, 0, "weekday");
        addFormatToken("E", 0, 0, "isoWeekday");
        addUnitAlias("day", "d");
        addUnitAlias("weekday", "e");
        addUnitAlias("isoWeekday", "E");
        addUnitPriority("day", 11);
        addUnitPriority("weekday", 11);
        addUnitPriority("isoWeekday", 11);
        addRegexToken("d", match1to2);
        addRegexToken("e", match1to2);
        addRegexToken("E", match1to2);
        addRegexToken("dd", function(isStrict, locale2) {
          return locale2.weekdaysMinRegex(isStrict);
        });
        addRegexToken("ddd", function(isStrict, locale2) {
          return locale2.weekdaysShortRegex(isStrict);
        });
        addRegexToken("dddd", function(isStrict, locale2) {
          return locale2.weekdaysRegex(isStrict);
        });
        addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
          var weekday = config._locale.weekdaysParse(input, token2, config._strict);
          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
          week[token2] = toInt(input);
        });
        function parseWeekday(input, locale2) {
          if (typeof input !== "string") {
            return input;
          }
          if (!isNaN(input)) {
            return parseInt(input, 10);
          }
          input = locale2.weekdaysParse(input);
          if (typeof input === "number") {
            return input;
          }
          return null;
        }
        function parseIsoWeekday(input, locale2) {
          if (typeof input === "string") {
            return locale2.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
        }
        function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
        }
        var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
        function localeWeekdays(m, format4) {
          var weekdays = isArray2(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format4) ? "format" : "standalone"];
          return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
        }
        function localeWeekdaysShort(m) {
          return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }
        function localeWeekdaysMin(m) {
          return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }
        function handleStrictParse$1(weekdayName, format4, strict) {
          var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
              mom = createUTC([2e3, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format4 === "dddd") {
              ii = indexOf.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format4 === "ddd") {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format4 === "dddd") {
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format4 === "ddd") {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeWeekdaysParse(weekdayName, format4, strict) {
          var i, mom, regex;
          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format4, strict);
          }
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }
          for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
              this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
              this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
            }
            if (!this._weekdaysParse[i]) {
              regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
              this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format4 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format4 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format4 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
            }
          }
        }
        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
          } else {
            return day;
          }
        }
        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, "d");
        }
        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }
        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }
        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysShortRegex")) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }
        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysMinRegex")) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }
        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
          for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ""));
            shortp = regexEscape(this.weekdaysShort(mom, ""));
            longp = regexEscape(this.weekdays(mom, ""));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          }
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
          this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
          this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
        }
        function hFormat() {
          return this.hours() % 12 || 12;
        }
        function kFormat() {
          return this.hours() || 24;
        }
        addFormatToken("H", ["HH", 2], 0, "hour");
        addFormatToken("h", ["hh", 2], 0, hFormat);
        addFormatToken("k", ["kk", 2], 0, kFormat);
        addFormatToken("hmm", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken("hmmss", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken("Hmm", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken("Hmmss", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        function meridiem(token2, lowercase) {
          addFormatToken(token2, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
          });
        }
        meridiem("a", true);
        meridiem("A", false);
        addUnitAlias("hour", "h");
        addUnitPriority("hour", 13);
        function matchMeridiem(isStrict, locale2) {
          return locale2._meridiemParse;
        }
        addRegexToken("a", matchMeridiem);
        addRegexToken("A", matchMeridiem);
        addRegexToken("H", match1to2);
        addRegexToken("h", match1to2);
        addRegexToken("k", match1to2);
        addRegexToken("HH", match1to2, match2);
        addRegexToken("hh", match1to2, match2);
        addRegexToken("kk", match1to2, match2);
        addRegexToken("hmm", match3to4);
        addRegexToken("hmmss", match5to6);
        addRegexToken("Hmm", match3to4);
        addRegexToken("Hmmss", match5to6);
        addParseToken(["H", "HH"], HOUR);
        addParseToken(["k", "kk"], function(input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(["a", "A"], function(input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(["h", "hh"], function(input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("Hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken("Hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        });
        function localeIsPM(input) {
          return (input + "").toLowerCase().charAt(0) === "p";
        }
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
        function localeMeridiem(hours2, minutes2, isLower) {
          if (hours2 > 11) {
            return isLower ? "pm" : "PM";
          } else {
            return isLower ? "am" : "AM";
          }
        }
        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        };
        var locales = {}, localeFamilies = {}, globalLocale;
        function commonPrefix(arr1, arr2) {
          var i, minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
              return i;
            }
          }
          return minl;
        }
        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace("_", "-") : key;
        }
        function chooseLocale(names) {
          var i = 0, j, next, locale2, split;
          while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
              locale2 = loadLocale(split.slice(0, j).join("-"));
              if (locale2) {
                return locale2;
              }
              if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                break;
              }
              j--;
            }
            i++;
          }
          return globalLocale;
        }
        function loadLocale(name) {
          var oldLocale = null, aliasedRequire;
          if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = __require;
              aliasedRequire("./locale/" + name);
              getSetGlobalLocale(oldLocale);
            } catch (e) {
              locales[name] = null;
            }
          }
          return locales[name];
        }
        function getSetGlobalLocale(key, values) {
          var data2;
          if (key) {
            if (isUndefined(values)) {
              data2 = getLocale(key);
            } else {
              data2 = defineLocale(key, values);
            }
            if (data2) {
              globalLocale = data2;
            } else {
              if (typeof console !== "undefined" && console.warn) {
                console.warn("Locale " + key + " not found. Did you forget to load it?");
              }
            }
          }
          return globalLocale._abbr;
        }
        function defineLocale(name, config) {
          if (config !== null) {
            var locale2, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
              deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
              parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
              } else {
                locale2 = loadLocale(config.parentLocale);
                if (locale2 != null) {
                  parentConfig = locale2._config;
                } else {
                  if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                  }
                  localeFamilies[config.parentLocale].push({
                    name,
                    config
                  });
                  return null;
                }
              }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function(x) {
                defineLocale(x.name, x.config);
              });
            }
            getSetGlobalLocale(name);
            return locales[name];
          } else {
            delete locales[name];
            return null;
          }
        }
        function updateLocale(name, config) {
          if (config != null) {
            var locale2, tmpLocale, parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
              locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              if (tmpLocale == null) {
                config.abbr = name;
              }
              locale2 = new Locale(config);
              locale2.parentLocale = locales[name];
              locales[name] = locale2;
            }
            getSetGlobalLocale(name);
          } else {
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }
          return locales[name];
        }
        function getLocale(key) {
          var locale2;
          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }
          if (!key) {
            return globalLocale;
          }
          if (!isArray2(key)) {
            locale2 = loadLocale(key);
            if (locale2) {
              return locale2;
            }
            key = [key];
          }
          return chooseLocale(key);
        }
        function listLocales() {
          return keys(locales);
        }
        function checkOverflow(m) {
          var overflow, a = m._a;
          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
          }
          return m;
        }
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
          ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
          ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
          ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
          ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
          ["YYYY-DDD", /\d{4}-\d{3}/],
          ["YYYY-MM", /\d{4}-\d\d/, false],
          ["YYYYYYMMDD", /[+-]\d{10}/],
          ["YYYYMMDD", /\d{8}/],
          ["GGGG[W]WWE", /\d{4}W\d{3}/],
          ["GGGG[W]WW", /\d{4}W\d{2}/, false],
          ["YYYYDDD", /\d{7}/],
          ["YYYYMM", /\d{6}/, false],
          ["YYYY", /\d{4}/, false]
        ], isoTimes = [
          ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
          ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
          ["HH:mm:ss", /\d\d:\d\d:\d\d/],
          ["HH:mm", /\d\d:\d\d/],
          ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
          ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
          ["HHmmss", /\d\d\d\d\d\d/],
          ["HHmm", /\d\d\d\d/],
          ["HH", /\d\d/]
        ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60
        };
        function configFromISO(config) {
          var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;
          if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
              if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
              }
            }
            if (dateFormat == null) {
              config._isValid = false;
              return;
            }
            if (match[3]) {
              for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                  timeFormat = (match[2] || " ") + isoTimes[i][0];
                  break;
                }
              }
              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }
            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }
            if (match[4]) {
              if (tzRegex.exec(match[4])) {
                tzFormat = "Z";
              } else {
                config._isValid = false;
                return;
              }
            }
            config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        }
        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
          ];
          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }
          return result;
        }
        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
            return 2e3 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }
          return year;
        }
        function preprocessRFC2822(s) {
          return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }
        function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
            }
          }
          return true;
        }
        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            return 0;
          } else {
            var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
          }
        }
        function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
          if (match) {
            parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
              return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        }
        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
          }
          configFromISO(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          configFromRFC2822(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          if (config._strict) {
            config._isValid = false;
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
          config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
        });
        function defaults(a, b, c) {
          if (a != null) {
            return a;
          }
          if (b != null) {
            return b;
          }
          return c;
        }
        function currentDateArray(config) {
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
            return [
              nowValue.getUTCFullYear(),
              nowValue.getUTCMonth(),
              nowValue.getUTCDate()
            ];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }
        function configFromArray(config) {
          var i, date, input = [], currentDate, expectedWeekday, yearToUse;
          if (config._d) {
            return;
          }
          currentDate = currentDateArray(config);
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          }
          if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          }
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
          }
          for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
          }
          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }
          config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }
          if (config._nextDay) {
            config._a[HOUR] = 24;
          }
          if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
          }
        }
        function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              weekday = dow;
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        }
        hooks.ISO_8601 = function() {
        };
        hooks.RFC_2822 = function() {
        };
        function configFromStringAndFormat(config) {
          if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
          }
          if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;
          var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era;
          tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
          for (i = 0; i < tokens2.length; i++) {
            token2 = tokens2[i];
            parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }
              string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
              totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token2]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token2);
              }
              addTimeToArrayFromToken(token2, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token2);
            }
          }
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
          }
          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = void 0;
          }
          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
          era = getParsingFlags(config).era;
          if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }
          configFromArray(config);
          checkOverflow(config);
        }
        function meridiemFixWrap(locale2, hour, meridiem2) {
          var isPm;
          if (meridiem2 == null) {
            return hour;
          }
          if (locale2.meridiemHour != null) {
            return locale2.meridiemHour(hour, meridiem2);
          } else if (locale2.isPM != null) {
            isPm = locale2.isPM(meridiem2);
            if (isPm && hour < 12) {
              hour += 12;
            }
            if (!isPm && hour === 12) {
              hour = 0;
            }
            return hour;
          } else {
            return hour;
          }
        }
        function configFromStringAndArray(config) {
          var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false;
          if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
          }
          for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
              validFormatFound = true;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }
          extend(config, bestMoment || tempConfig);
        }
        function configFromObject(config) {
          if (config._d) {
            return;
          }
          var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
          config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function(obj) {
            return obj && parseInt(obj, 10);
          });
          configFromArray(config);
        }
        function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = void 0;
          }
          return res;
        }
        function prepareConfig(config) {
          var input = config._i, format4 = config._f;
          config._locale = config._locale || getLocale(config._l);
          if (input === null || format4 === void 0 && input === "") {
            return createInvalid({ nullInput: true });
          }
          if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
          }
          if (isMoment(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
            config._d = input;
          } else if (isArray2(format4)) {
            configFromStringAndArray(config);
          } else if (format4) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }
          if (!isValid(config)) {
            config._d = null;
          }
          return config;
        }
        function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
            config._d = new Date(hooks.now());
          } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === "string") {
            configFromString(config);
          } else if (isArray2(input)) {
            config._a = map(input.slice(0), function(obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject2(input)) {
            configFromObject(config);
          } else if (isNumber(input)) {
            config._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        function createLocalOrUTC(input, format4, locale2, strict, isUTC) {
          var c = {};
          if (format4 === true || format4 === false) {
            strict = format4;
            format4 = void 0;
          }
          if (locale2 === true || locale2 === false) {
            strict = locale2;
            locale2 = void 0;
          }
          if (isObject2(input) && isObjectEmpty(input) || isArray2(input) && input.length === 0) {
            input = void 0;
          }
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale2;
          c._i = input;
          c._f = format4;
          c._strict = strict;
          return createFromConfig(c);
        }
        function createLocal(input, format4, locale2, strict) {
          return createLocalOrUTC(input, format4, locale2, strict, false);
        }
        var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        });
        function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray2(moments[0])) {
            moments = moments[0];
          }
          if (!moments.length) {
            return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
              res = moments[i];
            }
          }
          return res;
        }
        function min() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isBefore", args);
        }
        function max() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isAfter", args);
        }
        var now = function() {
          return Date.now ? Date.now() : +new Date();
        };
        var ordering = [
          "year",
          "quarter",
          "month",
          "week",
          "day",
          "hour",
          "minute",
          "second",
          "millisecond"
        ];
        function isDurationValid(m) {
          var key, unitHasDecimal = false, i;
          for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }
          for (i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
              if (unitHasDecimal) {
                return false;
              }
              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
              }
            }
          }
          return true;
        }
        function isValid$1() {
          return this._isValid;
        }
        function createInvalid$1() {
          return createDuration(NaN);
        }
        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput);
          this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
          this._days = +days2 + weeks2 * 7;
          this._months = +months2 + quarters * 3 + years2 * 12;
          this._data = {};
          this._locale = getLocale();
          this._bubble();
        }
        function isDuration(obj) {
          return obj instanceof Duration;
        }
        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        }
        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
          for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
              diffs++;
            }
          }
          return diffs + lengthDiff;
        }
        function offset(token2, separator) {
          addFormatToken(token2, 0, 0, function() {
            var offset2 = this.utcOffset(), sign2 = "+";
            if (offset2 < 0) {
              offset2 = -offset2;
              sign2 = "-";
            }
            return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
          });
        }
        offset("Z", ":");
        offset("ZZ", "");
        addRegexToken("Z", matchShortOffset);
        addRegexToken("ZZ", matchShortOffset);
        addParseToken(["Z", "ZZ"], function(input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        });
        var chunkOffset = /([\+\-]|\d\d)/gi;
        function offsetFromString(matcher, string) {
          var matches = (string || "").match(matcher), chunk, parts, minutes2;
          if (matches === null) {
            return null;
          }
          chunk = matches[matches.length - 1] || [];
          parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
          minutes2 = +(parts[1] * 60) + toInt(parts[2]);
          return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
        }
        function cloneWithOffset(input, model) {
          var res, diff2;
          if (model._isUTC) {
            res = model.clone();
            diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff2);
            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }
        function getDateOffset(m) {
          return -Math.round(m._d.getTimezoneOffset());
        }
        hooks.updateOffset = function() {
        };
        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset2 = this._offset || 0, localAdjust;
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            if (typeof input === "string") {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.add(localAdjust, "m");
            }
            if (offset2 !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset2, "m"), 1, false);
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
            return this;
          } else {
            return this._isUTC ? offset2 : getDateOffset(this);
          }
        }
        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== "string") {
              input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }
        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }
        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.subtract(getDateOffset(this), "m");
            }
          }
          return this;
        }
        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === "string") {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }
          return this;
        }
        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }
        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }
        function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
          }
          var c = {}, other;
          copyConfig(c, this);
          c = prepareConfig(c);
          if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }
          return this._isDSTShifted;
        }
        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }
        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }
        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function createDuration(input, key) {
          var duration = input, match = null, sign2, ret, diffRes;
          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match = aspNetRegex.exec(input)) {
            sign2 = match[1] === "-" ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match[DATE]) * sign2,
              h: toInt(match[HOUR]) * sign2,
              m: toInt(match[MINUTE]) * sign2,
              s: toInt(match[SECOND]) * sign2,
              ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            };
          } else if (match = isoRegex.exec(input)) {
            sign2 = match[1] === "-" ? -1 : 1;
            duration = {
              y: parseIso(match[2], sign2),
              M: parseIso(match[3], sign2),
              w: parseIso(match[4], sign2),
              d: parseIso(match[5], sign2),
              h: parseIso(match[6], sign2),
              m: parseIso(match[7], sign2),
              s: parseIso(match[8], sign2)
            };
          } else if (duration == null) {
            duration = {};
          } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }
          ret = new Duration(duration);
          if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
          }
          if (isDuration(input) && hasOwnProp(input, "_isValid")) {
            ret._isValid = input._isValid;
          }
          return ret;
        }
        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;
        function parseIso(inp, sign2) {
          var res = inp && parseFloat(inp.replace(",", "."));
          return (isNaN(res) ? 0 : res) * sign2;
        }
        function positiveMomentsDifference(base, other) {
          var res = {};
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
          }
          res.milliseconds = +other - +base.clone().add(res.months, "M");
          return res;
        }
        function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
          }
          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }
          return res;
        }
        function createAdder(direction, name) {
          return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
              deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
              tmp = val;
              val = period;
              period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }
        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
          if (!mom.isValid()) {
            return;
          }
          updateOffset = updateOffset == null ? true : updateOffset;
          if (months2) {
            setMonth(mom, get2(mom, "Month") + months2 * isAdding);
          }
          if (days2) {
            set$12(mom, "Date", get2(mom, "Date") + days2 * isAdding);
          }
          if (milliseconds2) {
            mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
          }
          if (updateOffset) {
            hooks.updateOffset(mom, days2 || months2);
          }
        }
        var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
        function isString2(input) {
          return typeof input === "string" || input instanceof String;
        }
        function isMomentInput(input) {
          return isMoment(input) || isDate(input) || isString2(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
        }
        function isMomentInputObject(input) {
          var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "years",
            "year",
            "y",
            "months",
            "month",
            "M",
            "days",
            "day",
            "d",
            "dates",
            "date",
            "D",
            "hours",
            "hour",
            "h",
            "minutes",
            "minute",
            "m",
            "seconds",
            "second",
            "s",
            "milliseconds",
            "millisecond",
            "ms"
          ], i, property;
          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function isNumberOrStringArray(input) {
          var arrayTest = isArray2(input), dataTypeTest = false;
          if (arrayTest) {
            dataTypeTest = input.filter(function(item) {
              return !isNumber(item) && isString2(input);
            }).length === 0;
          }
          return arrayTest && dataTypeTest;
        }
        function isCalendarSpec(input) {
          var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "sameDay",
            "nextDay",
            "lastDay",
            "nextWeek",
            "lastWeek",
            "sameElse"
          ], i, property;
          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function getCalendarFormat(myMoment, now2) {
          var diff2 = myMoment.diff(now2, "days", true);
          return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
        }
        function calendar$1(time, formats) {
          if (arguments.length === 1) {
            if (!arguments[0]) {
              time = void 0;
              formats = void 0;
            } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = void 0;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = void 0;
            }
          }
          var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format4 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction2(formats[format4]) ? formats[format4].call(this, now2) : formats[format4]);
          return this.format(output || this.localeData().calendar(format4, this, createLocal(now2)));
        }
        function clone() {
          return new Moment(this);
        }
        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }
        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }
        function isBetween(from2, to2, units, inclusivity) {
          var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }
          inclusivity = inclusivity || "()";
          return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }
        function isSame2(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input), inputMs;
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }
        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }
        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }
        function diff(input, units, asFloat) {
          var that, zoneDelta, output;
          if (!this.isValid()) {
            return NaN;
          }
          that = cloneWithOffset(input, this);
          if (!that.isValid()) {
            return NaN;
          }
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);
          switch (units) {
            case "year":
              output = monthDiff(this, that) / 12;
              break;
            case "month":
              output = monthDiff(this, that);
              break;
            case "quarter":
              output = monthDiff(this, that) / 3;
              break;
            case "second":
              output = (this - that) / 1e3;
              break;
            case "minute":
              output = (this - that) / 6e4;
              break;
            case "hour":
              output = (this - that) / 36e5;
              break;
            case "day":
              output = (this - that - zoneDelta) / 864e5;
              break;
            case "week":
              output = (this - that - zoneDelta) / 6048e5;
              break;
            default:
              output = this - that;
          }
          return asFloat ? output : absFloor(output);
        }
        function monthDiff(a, b) {
          if (a.date() < b.date()) {
            return -monthDiff(b, a);
          }
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
          }
          return -(wholeMonthDiff + adjust) || 0;
        }
        hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
        hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
        function toString2() {
          return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        }
        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }
          var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
          }
          if (isFunction2(Date.prototype.toISOString)) {
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
            }
          }
          return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
        }
        function inspect() {
          if (!this.isValid()) {
            return "moment.invalid(/* " + this._i + " */)";
          }
          var func = "moment", zone = "", prefix, year, datetime, suffix;
          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
            zone = "Z";
          }
          prefix = "[" + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
          datetime = "-MM-DD[T]HH:mm:ss.SSS";
          suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }
        function format3(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }
        function from(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }
        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        }
        function locale(key) {
          var newLocaleData;
          if (key === void 0) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        }
        var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        });
        function localeData() {
          return this._locale;
        }
        var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }
        function localStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return new Date(y, m, d).valueOf();
          }
        }
        function utcStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y, m, d);
          }
        }
        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year(), 0, 1);
              break;
            case "quarter":
              time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
              break;
            case "month":
              time = startOfDate(this.year(), this.month(), 1);
              break;
            case "week":
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
              break;
            case "isoWeek":
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date());
              break;
            case "hour":
              time = this._d.valueOf();
              time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
              break;
            case "minute":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
            case "second":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
            case "quarter":
              time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
              break;
            case "month":
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
            case "week":
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
              break;
            case "isoWeek":
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case "hour":
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
              break;
            case "minute":
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
            case "second":
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 6e4;
        }
        function unix() {
          return Math.floor(this.valueOf() / 1e3);
        }
        function toDate() {
          return new Date(this.valueOf());
        }
        function toArray() {
          var m = this;
          return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond()
          ];
        }
        function toObject() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }
        function toJSON() {
          return this.isValid() ? this.toISOString() : null;
        }
        function isValid$2() {
          return isValid(this);
        }
        function parsingFlags() {
          return extend({}, getParsingFlags(this));
        }
        function invalidAt() {
          return getParsingFlags(this).overflow;
        }
        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }
        addFormatToken("N", 0, 0, "eraAbbr");
        addFormatToken("NN", 0, 0, "eraAbbr");
        addFormatToken("NNN", 0, 0, "eraAbbr");
        addFormatToken("NNNN", 0, 0, "eraName");
        addFormatToken("NNNNN", 0, 0, "eraNarrow");
        addFormatToken("y", ["y", 1], "yo", "eraYear");
        addFormatToken("y", ["yy", 2], 0, "eraYear");
        addFormatToken("y", ["yyy", 3], 0, "eraYear");
        addFormatToken("y", ["yyyy", 4], 0, "eraYear");
        addRegexToken("N", matchEraAbbr);
        addRegexToken("NN", matchEraAbbr);
        addRegexToken("NNN", matchEraAbbr);
        addRegexToken("NNNN", matchEraName);
        addRegexToken("NNNNN", matchEraNarrow);
        addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        });
        addRegexToken("y", matchUnsigned);
        addRegexToken("yy", matchUnsigned);
        addRegexToken("yyy", matchUnsigned);
        addRegexToken("yyyy", matchUnsigned);
        addRegexToken("yo", matchEraYearOrdinal);
        addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
        addParseToken(["yo"], function(input, array, config, token2) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
          }
          if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
            array[YEAR] = parseInt(input, 10);
          }
        });
        function localeEras(m, format4) {
          var i, l, date, eras = this._eras || getLocale("en")._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
              case "string":
                date = hooks(eras[i].since).startOf("day");
                eras[i].since = date.valueOf();
                break;
            }
            switch (typeof eras[i].until) {
              case "undefined":
                eras[i].until = Infinity;
                break;
              case "string":
                date = hooks(eras[i].until).startOf("day").valueOf();
                eras[i].until = date.valueOf();
                break;
            }
          }
          return eras;
        }
        function localeErasParse(eraName, format4, strict) {
          var i, l, eras = this.eras(), name, abbr, narrow;
          eraName = eraName.toUpperCase();
          for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
              switch (format4) {
                case "N":
                case "NN":
                case "NNN":
                  if (abbr === eraName) {
                    return eras[i];
                  }
                  break;
                case "NNNN":
                  if (name === eraName) {
                    return eras[i];
                  }
                  break;
                case "NNNNN":
                  if (narrow === eraName) {
                    return eras[i];
                  }
                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i];
            }
          }
        }
        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? 1 : -1;
          if (year === void 0) {
            return hooks(era.since).year();
          } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
          }
        }
        function getEraName() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].name;
            }
          }
          return "";
        }
        function getEraNarrow() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].narrow;
            }
          }
          return "";
        }
        function getEraAbbr() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].abbr;
            }
          }
          return "";
        }
        function getEraYear() {
          var i, l, dir, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? 1 : -1;
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
              return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
          }
          return this.year();
        }
        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNameRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
        }
        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, "_erasAbbrRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }
        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNarrowRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }
        function matchEraAbbr(isStrict, locale2) {
          return locale2.erasAbbrRegex(isStrict);
        }
        function matchEraName(isStrict, locale2) {
          return locale2.erasNameRegex(isStrict);
        }
        function matchEraNarrow(isStrict, locale2) {
          return locale2.erasNarrowRegex(isStrict);
        }
        function matchEraYearOrdinal(isStrict, locale2) {
          return locale2._eraYearOrdinalRegex || matchUnsigned;
        }
        function computeErasParse() {
          var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));
            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
          }
          this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
          this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
          this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
        }
        addFormatToken(0, ["gg", 2], 0, function() {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ["GG", 2], 0, function() {
          return this.isoWeekYear() % 100;
        });
        function addWeekYearFormatToken(token2, getter) {
          addFormatToken(0, [token2, token2.length], 0, getter);
        }
        addWeekYearFormatToken("gggg", "weekYear");
        addWeekYearFormatToken("ggggg", "weekYear");
        addWeekYearFormatToken("GGGG", "isoWeekYear");
        addWeekYearFormatToken("GGGGG", "isoWeekYear");
        addUnitAlias("weekYear", "gg");
        addUnitAlias("isoWeekYear", "GG");
        addUnitPriority("weekYear", 1);
        addUnitPriority("isoWeekYear", 1);
        addRegexToken("G", matchSigned);
        addRegexToken("g", matchSigned);
        addRegexToken("GG", match1to2, match2);
        addRegexToken("gg", match1to2, match2);
        addRegexToken("GGGG", match1to4, match4);
        addRegexToken("gggg", match1to4, match4);
        addRegexToken("GGGGG", match1to6, match6);
        addRegexToken("ggggg", match1to6, match6);
        addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        });
        addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
          week[token2] = hooks.parseTwoDigitYear(input);
        });
        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
        }
        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
        }
        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }
        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }
        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }
        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
              week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }
        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        }
        addFormatToken("Q", 0, "Qo", "quarter");
        addUnitAlias("quarter", "Q");
        addUnitPriority("quarter", 7);
        addRegexToken("Q", match1);
        addParseToken("Q", function(input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        });
        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }
        addFormatToken("D", ["DD", 2], "Do", "date");
        addUnitAlias("date", "D");
        addUnitPriority("date", 9);
        addRegexToken("D", match1to2);
        addRegexToken("DD", match1to2, match2);
        addRegexToken("Do", function(isStrict, locale2) {
          return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(["D", "DD"], DATE);
        addParseToken("Do", function(input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
        });
        var getSetDayOfMonth = makeGetSet("Date", true);
        addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
        addUnitAlias("dayOfYear", "DDD");
        addUnitPriority("dayOfYear", 4);
        addRegexToken("DDD", match1to3);
        addRegexToken("DDDD", match3);
        addParseToken(["DDD", "DDDD"], function(input, array, config) {
          config._dayOfYear = toInt(input);
        });
        function getSetDayOfYear(input) {
          var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        }
        addFormatToken("m", ["mm", 2], 0, "minute");
        addUnitAlias("minute", "m");
        addUnitPriority("minute", 14);
        addRegexToken("m", match1to2);
        addRegexToken("mm", match1to2, match2);
        addParseToken(["m", "mm"], MINUTE);
        var getSetMinute = makeGetSet("Minutes", false);
        addFormatToken("s", ["ss", 2], 0, "second");
        addUnitAlias("second", "s");
        addUnitPriority("second", 15);
        addRegexToken("s", match1to2);
        addRegexToken("ss", match1to2, match2);
        addParseToken(["s", "ss"], SECOND);
        var getSetSecond = makeGetSet("Seconds", false);
        addFormatToken("S", 0, 0, function() {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ["SS", 2], 0, function() {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ["SSS", 3], 0, "millisecond");
        addFormatToken(0, ["SSSS", 4], 0, function() {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ["SSSSS", 5], 0, function() {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ["SSSSSS", 6], 0, function() {
          return this.millisecond() * 1e3;
        });
        addFormatToken(0, ["SSSSSSS", 7], 0, function() {
          return this.millisecond() * 1e4;
        });
        addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
          return this.millisecond() * 1e5;
        });
        addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
          return this.millisecond() * 1e6;
        });
        addUnitAlias("millisecond", "ms");
        addUnitPriority("millisecond", 16);
        addRegexToken("S", match1to3, match1);
        addRegexToken("SS", match1to3, match2);
        addRegexToken("SSS", match1to3, match3);
        var token, getSetMillisecond;
        for (token = "SSSS"; token.length <= 9; token += "S") {
          addRegexToken(token, matchUnsigned);
        }
        function parseMs(input, array) {
          array[MILLISECOND] = toInt(("0." + input) * 1e3);
        }
        for (token = "S"; token.length <= 9; token += "S") {
          addParseToken(token, parseMs);
        }
        getSetMillisecond = makeGetSet("Milliseconds", false);
        addFormatToken("z", 0, 0, "zoneAbbr");
        addFormatToken("zz", 0, 0, "zoneName");
        function getZoneAbbr() {
          return this._isUTC ? "UTC" : "";
        }
        function getZoneName() {
          return this._isUTC ? "Coordinated Universal Time" : "";
        }
        var proto = Moment.prototype;
        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format3;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame2;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== "undefined" && Symbol.for != null) {
          proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">";
          };
        }
        proto.toJSON = toJSON;
        proto.toString = toString2;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
        proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
        proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
        proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
        proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
        function createUnix(input) {
          return createLocal(input * 1e3);
        }
        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }
        function preParsePostFormat(string) {
          return string;
        }
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set3;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;
        function get$1(format4, index, field, setter) {
          var locale2 = getLocale(), utc = createUTC().set(setter, index);
          return locale2[field](utc, format4);
        }
        function listMonthsImpl(format4, index, field) {
          if (isNumber(format4)) {
            index = format4;
            format4 = void 0;
          }
          format4 = format4 || "";
          if (index != null) {
            return get$1(format4, index, field, "month");
          }
          var i, out = [];
          for (i = 0; i < 12; i++) {
            out[i] = get$1(format4, i, field, "month");
          }
          return out;
        }
        function listWeekdaysImpl(localeSorted, format4, index, field) {
          if (typeof localeSorted === "boolean") {
            if (isNumber(format4)) {
              index = format4;
              format4 = void 0;
            }
            format4 = format4 || "";
          } else {
            format4 = localeSorted;
            index = format4;
            localeSorted = false;
            if (isNumber(format4)) {
              index = format4;
              format4 = void 0;
            }
            format4 = format4 || "";
          }
          var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
          if (index != null) {
            return get$1(format4, (index + shift) % 7, field, "day");
          }
          for (i = 0; i < 7; i++) {
            out[i] = get$1(format4, (i + shift) % 7, field, "day");
          }
          return out;
        }
        function listMonths(format4, index) {
          return listMonthsImpl(format4, index, "months");
        }
        function listMonthsShort(format4, index) {
          return listMonthsImpl(format4, index, "monthsShort");
        }
        function listWeekdays(localeSorted, format4, index) {
          return listWeekdaysImpl(localeSorted, format4, index, "weekdays");
        }
        function listWeekdaysShort(localeSorted, format4, index) {
          return listWeekdaysImpl(localeSorted, format4, index, "weekdaysShort");
        }
        function listWeekdaysMin(localeSorted, format4, index) {
          return listWeekdaysImpl(localeSorted, format4, index, "weekdaysMin");
        }
        getSetGlobalLocale("en", {
          eras: [
            {
              since: "0001-01-01",
              until: Infinity,
              offset: 1,
              name: "Anno Domini",
              narrow: "AD",
              abbr: "AD"
            },
            {
              since: "0000-12-31",
              until: -Infinity,
              offset: 1,
              name: "Before Christ",
              narrow: "BC",
              abbr: "BC"
            }
          ],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
          }
        });
        hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
        hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
        var mathAbs = Math.abs;
        function abs() {
          var data2 = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data2.milliseconds = mathAbs(data2.milliseconds);
          data2.seconds = mathAbs(data2.seconds);
          data2.minutes = mathAbs(data2.minutes);
          data2.hours = mathAbs(data2.hours);
          data2.months = mathAbs(data2.months);
          data2.years = mathAbs(data2.years);
          return this;
        }
        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        }
        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        }
        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }
        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }
        function bubble() {
          var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data2 = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
          if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
            milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
            days2 = 0;
            months2 = 0;
          }
          data2.milliseconds = milliseconds2 % 1e3;
          seconds2 = absFloor(milliseconds2 / 1e3);
          data2.seconds = seconds2 % 60;
          minutes2 = absFloor(seconds2 / 60);
          data2.minutes = minutes2 % 60;
          hours2 = absFloor(minutes2 / 60);
          data2.hours = hours2 % 24;
          days2 += absFloor(hours2 / 24);
          monthsFromDays = absFloor(daysToMonths(days2));
          months2 += monthsFromDays;
          days2 -= absCeil(monthsToDays(monthsFromDays));
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          data2.days = days2;
          data2.months = months2;
          data2.years = years2;
          return this;
        }
        function daysToMonths(days2) {
          return days2 * 4800 / 146097;
        }
        function monthsToDays(months2) {
          return months2 * 146097 / 4800;
        }
        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }
          var days2, months2, milliseconds2 = this._milliseconds;
          units = normalizeUnits(units);
          if (units === "month" || units === "quarter" || units === "year") {
            days2 = this._days + milliseconds2 / 864e5;
            months2 = this._months + daysToMonths(days2);
            switch (units) {
              case "month":
                return months2;
              case "quarter":
                return months2 / 3;
              case "year":
                return months2 / 12;
            }
          } else {
            days2 = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case "week":
                return days2 / 7 + milliseconds2 / 6048e5;
              case "day":
                return days2 + milliseconds2 / 864e5;
              case "hour":
                return days2 * 24 + milliseconds2 / 36e5;
              case "minute":
                return days2 * 1440 + milliseconds2 / 6e4;
              case "second":
                return days2 * 86400 + milliseconds2 / 1e3;
              case "millisecond":
                return Math.floor(days2 * 864e5) + milliseconds2;
              default:
                throw new Error("Unknown unit " + units);
            }
          }
        }
        function valueOf$1() {
          if (!this.isValid()) {
            return NaN;
          }
          return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        }
        function makeAs(alias) {
          return function() {
            return this.as(alias);
          };
        }
        var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
        function clone$1() {
          return createDuration(this);
        }
        function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + "s"]() : NaN;
        }
        function makeGetter(name) {
          return function() {
            return this.isValid() ? this._data[name] : NaN;
          };
        }
        var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
        function weeks() {
          return absFloor(this.days() / 7);
        }
        var round = Math.round, thresholds = {
          ss: 44,
          s: 45,
          m: 45,
          h: 22,
          d: 26,
          w: null,
          M: 11
        };
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
          return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }
        function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
          var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
          if (thresholds2.w != null) {
            a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
          }
          a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale2;
          return substituteTimeAgo.apply(null, a);
        }
        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === void 0) {
            return round;
          }
          if (typeof roundingFunction === "function") {
            round = roundingFunction;
            return true;
          }
          return false;
        }
        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === void 0) {
            return false;
          }
          if (limit === void 0) {
            return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === "s") {
            thresholds.ss = limit - 1;
          }
          return true;
        }
        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var withSuffix = false, th = thresholds, locale2, output;
          if (typeof argWithSuffix === "object") {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }
          if (typeof argWithSuffix === "boolean") {
            withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === "object") {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }
          locale2 = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale2);
          if (withSuffix) {
            output = locale2.pastFuture(+this, output);
          }
          return locale2.postformat(output);
        }
        var abs$1 = Math.abs;
        function sign(x) {
          return (x > 0) - (x < 0) || +x;
        }
        function toISOString$1() {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
          if (!total) {
            return "P0D";
          }
          minutes2 = absFloor(seconds2 / 60);
          hours2 = absFloor(minutes2 / 60);
          seconds2 %= 60;
          minutes2 %= 60;
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
          totalSign = total < 0 ? "-" : "";
          ymSign = sign(this._months) !== sign(total) ? "-" : "";
          daysSign = sign(this._days) !== sign(total) ? "-" : "";
          hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
          return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
        }
        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
        proto$2.lang = lang;
        addFormatToken("X", 0, 0, "unix");
        addFormatToken("x", 0, 0, "valueOf");
        addRegexToken("x", matchSigned);
        addRegexToken("X", matchTimestamp);
        addParseToken("X", function(input, array, config) {
          config._d = new Date(parseFloat(input) * 1e3);
        });
        addParseToken("x", function(input, array, config) {
          config._d = new Date(toInt(input));
        });
        hooks.version = "2.29.1";
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;
        hooks.HTML5_FMT = {
          DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
          DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
          DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
          DATE: "YYYY-MM-DD",
          TIME: "HH:mm",
          TIME_SECONDS: "HH:mm:ss",
          TIME_MS: "HH:mm:ss.SSS",
          WEEK: "GGGG-[W]WW",
          MONTH: "YYYY-MM"
        };
        return hooks;
      });
    }
  });

  // node_modules/numeral/numeral.js
  var require_numeral = __commonJS({
    "node_modules/numeral/numeral.js"(exports, module) {
      (function(global2, factory) {
        if (typeof define === "function" && define.amd) {
          define(factory);
        } else if (typeof module === "object" && module.exports) {
          module.exports = factory();
        } else {
          global2.numeral = factory();
        }
      })(exports, function() {
        var numeral2, _, VERSION = "2.0.6", formats = {}, locales = {}, defaults = {
          currentLocale: "en",
          zeroFormat: null,
          nullFormat: null,
          defaultFormat: "0,0",
          scalePercentBy100: true
        }, options = {
          currentLocale: defaults.currentLocale,
          zeroFormat: defaults.zeroFormat,
          nullFormat: defaults.nullFormat,
          defaultFormat: defaults.defaultFormat,
          scalePercentBy100: defaults.scalePercentBy100
        };
        function Numeral(input, number) {
          this._input = input;
          this._value = number;
        }
        numeral2 = function(input) {
          var value, kind, unformatFunction, regexp;
          if (numeral2.isNumeral(input)) {
            value = input.value();
          } else if (input === 0 || typeof input === "undefined") {
            value = 0;
          } else if (input === null || _.isNaN(input)) {
            value = null;
          } else if (typeof input === "string") {
            if (options.zeroFormat && input === options.zeroFormat) {
              value = 0;
            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, "").length) {
              value = null;
            } else {
              for (kind in formats) {
                regexp = typeof formats[kind].regexps.unformat === "function" ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;
                if (regexp && input.match(regexp)) {
                  unformatFunction = formats[kind].unformat;
                  break;
                }
              }
              unformatFunction = unformatFunction || numeral2._.stringToNumber;
              value = unformatFunction(input);
            }
          } else {
            value = Number(input) || null;
          }
          return new Numeral(input, value);
        };
        numeral2.version = VERSION;
        numeral2.isNumeral = function(obj) {
          return obj instanceof Numeral;
        };
        numeral2._ = _ = {
          numberToFormat: function(value, format3, roundingFunction) {
            var locale = locales[numeral2.options.currentLocale], negP = false, optDec = false, leadingCount = 0, abbr = "", trillion = 1e12, billion = 1e9, million = 1e6, thousand = 1e3, decimal = "", neg = false, abbrForce, abs, min, max, power, int, precision, signed, thousands, output;
            value = value || 0;
            abs = Math.abs(value);
            if (numeral2._.includes(format3, "(")) {
              negP = true;
              format3 = format3.replace(/[\(|\)]/g, "");
            } else if (numeral2._.includes(format3, "+") || numeral2._.includes(format3, "-")) {
              signed = numeral2._.includes(format3, "+") ? format3.indexOf("+") : value < 0 ? format3.indexOf("-") : -1;
              format3 = format3.replace(/[\+|\-]/g, "");
            }
            if (numeral2._.includes(format3, "a")) {
              abbrForce = format3.match(/a(k|m|b|t)?/);
              abbrForce = abbrForce ? abbrForce[1] : false;
              if (numeral2._.includes(format3, " a")) {
                abbr = " ";
              }
              format3 = format3.replace(new RegExp(abbr + "a[kmbt]?"), "");
              if (abs >= trillion && !abbrForce || abbrForce === "t") {
                abbr += locale.abbreviations.trillion;
                value = value / trillion;
              } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === "b") {
                abbr += locale.abbreviations.billion;
                value = value / billion;
              } else if (abs < billion && abs >= million && !abbrForce || abbrForce === "m") {
                abbr += locale.abbreviations.million;
                value = value / million;
              } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === "k") {
                abbr += locale.abbreviations.thousand;
                value = value / thousand;
              }
            }
            if (numeral2._.includes(format3, "[.]")) {
              optDec = true;
              format3 = format3.replace("[.]", ".");
            }
            int = value.toString().split(".")[0];
            precision = format3.split(".")[1];
            thousands = format3.indexOf(",");
            leadingCount = (format3.split(".")[0].split(",")[0].match(/0/g) || []).length;
            if (precision) {
              if (numeral2._.includes(precision, "[")) {
                precision = precision.replace("]", "");
                precision = precision.split("[");
                decimal = numeral2._.toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
              } else {
                decimal = numeral2._.toFixed(value, precision.length, roundingFunction);
              }
              int = decimal.split(".")[0];
              if (numeral2._.includes(decimal, ".")) {
                decimal = locale.delimiters.decimal + decimal.split(".")[1];
              } else {
                decimal = "";
              }
              if (optDec && Number(decimal.slice(1)) === 0) {
                decimal = "";
              }
            } else {
              int = numeral2._.toFixed(value, 0, roundingFunction);
            }
            if (abbr && !abbrForce && Number(int) >= 1e3 && abbr !== locale.abbreviations.trillion) {
              int = String(Number(int) / 1e3);
              switch (abbr) {
                case locale.abbreviations.thousand:
                  abbr = locale.abbreviations.million;
                  break;
                case locale.abbreviations.million:
                  abbr = locale.abbreviations.billion;
                  break;
                case locale.abbreviations.billion:
                  abbr = locale.abbreviations.trillion;
                  break;
              }
            }
            if (numeral2._.includes(int, "-")) {
              int = int.slice(1);
              neg = true;
            }
            if (int.length < leadingCount) {
              for (var i = leadingCount - int.length; i > 0; i--) {
                int = "0" + int;
              }
            }
            if (thousands > -1) {
              int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1" + locale.delimiters.thousands);
            }
            if (format3.indexOf(".") === 0) {
              int = "";
            }
            output = int + decimal + (abbr ? abbr : "");
            if (negP) {
              output = (negP && neg ? "(" : "") + output + (negP && neg ? ")" : "");
            } else {
              if (signed >= 0) {
                output = signed === 0 ? (neg ? "-" : "+") + output : output + (neg ? "-" : "+");
              } else if (neg) {
                output = "-" + output;
              }
            }
            return output;
          },
          stringToNumber: function(string) {
            var locale = locales[options.currentLocale], stringOriginal = string, abbreviations = {
              thousand: 3,
              million: 6,
              billion: 9,
              trillion: 12
            }, abbreviation, value, i, regexp;
            if (options.zeroFormat && string === options.zeroFormat) {
              value = 0;
            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, "").length) {
              value = null;
            } else {
              value = 1;
              if (locale.delimiters.decimal !== ".") {
                string = string.replace(/\./g, "").replace(locale.delimiters.decimal, ".");
              }
              for (abbreviation in abbreviations) {
                regexp = new RegExp("[^a-zA-Z]" + locale.abbreviations[abbreviation] + "(?:\\)|(\\" + locale.currency.symbol + ")?(?:\\))?)?$");
                if (stringOriginal.match(regexp)) {
                  value *= Math.pow(10, abbreviations[abbreviation]);
                  break;
                }
              }
              value *= (string.split("-").length + Math.min(string.split("(").length - 1, string.split(")").length - 1)) % 2 ? 1 : -1;
              string = string.replace(/[^0-9\.]+/g, "");
              value *= Number(string);
            }
            return value;
          },
          isNaN: function(value) {
            return typeof value === "number" && isNaN(value);
          },
          includes: function(string, search) {
            return string.indexOf(search) !== -1;
          },
          insert: function(string, subString, start) {
            return string.slice(0, start) + subString + string.slice(start);
          },
          reduce: function(array, callback) {
            if (this === null) {
              throw new TypeError("Array.prototype.reduce called on null or undefined");
            }
            if (typeof callback !== "function") {
              throw new TypeError(callback + " is not a function");
            }
            var t = Object(array), len = t.length >>> 0, k = 0, value;
            if (arguments.length === 3) {
              value = arguments[2];
            } else {
              while (k < len && !(k in t)) {
                k++;
              }
              if (k >= len) {
                throw new TypeError("Reduce of empty array with no initial value");
              }
              value = t[k++];
            }
            for (; k < len; k++) {
              if (k in t) {
                value = callback(value, t[k], k, t);
              }
            }
            return value;
          },
          multiplier: function(x) {
            var parts = x.toString().split(".");
            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
          },
          correctionFactor: function() {
            var args = Array.prototype.slice.call(arguments);
            return args.reduce(function(accum, next) {
              var mn = _.multiplier(next);
              return accum > mn ? accum : mn;
            }, 1);
          },
          toFixed: function(value, maxDecimals, roundingFunction, optionals) {
            var splitValue = value.toString().split("."), minDecimals = maxDecimals - (optionals || 0), boundedPrecision, optionalsRegExp, power, output;
            if (splitValue.length === 2) {
              boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
            } else {
              boundedPrecision = minDecimals;
            }
            power = Math.pow(10, boundedPrecision);
            output = (roundingFunction(value + "e+" + boundedPrecision) / power).toFixed(boundedPrecision);
            if (optionals > maxDecimals - boundedPrecision) {
              optionalsRegExp = new RegExp("\\.?0{1," + (optionals - (maxDecimals - boundedPrecision)) + "}$");
              output = output.replace(optionalsRegExp, "");
            }
            return output;
          }
        };
        numeral2.options = options;
        numeral2.formats = formats;
        numeral2.locales = locales;
        numeral2.locale = function(key) {
          if (key) {
            options.currentLocale = key.toLowerCase();
          }
          return options.currentLocale;
        };
        numeral2.localeData = function(key) {
          if (!key) {
            return locales[options.currentLocale];
          }
          key = key.toLowerCase();
          if (!locales[key]) {
            throw new Error("Unknown locale : " + key);
          }
          return locales[key];
        };
        numeral2.reset = function() {
          for (var property in defaults) {
            options[property] = defaults[property];
          }
        };
        numeral2.zeroFormat = function(format3) {
          options.zeroFormat = typeof format3 === "string" ? format3 : null;
        };
        numeral2.nullFormat = function(format3) {
          options.nullFormat = typeof format3 === "string" ? format3 : null;
        };
        numeral2.defaultFormat = function(format3) {
          options.defaultFormat = typeof format3 === "string" ? format3 : "0.0";
        };
        numeral2.register = function(type, name, format3) {
          name = name.toLowerCase();
          if (this[type + "s"][name]) {
            throw new TypeError(name + " " + type + " already registered.");
          }
          this[type + "s"][name] = format3;
          return format3;
        };
        numeral2.validate = function(val, culture) {
          var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, localeData, temp;
          if (typeof val !== "string") {
            val += "";
            if (console.warn) {
              console.warn("Numeral.js: Value is not string. It has been co-erced to: ", val);
            }
          }
          val = val.trim();
          if (!!val.match(/^\d+$/)) {
            return true;
          }
          if (val === "") {
            return false;
          }
          try {
            localeData = numeral2.localeData(culture);
          } catch (e) {
            localeData = numeral2.localeData(numeral2.locale());
          }
          _currSymbol = localeData.currency.symbol;
          _abbrObj = localeData.abbreviations;
          _decimalSep = localeData.delimiters.decimal;
          if (localeData.delimiters.thousands === ".") {
            _thousandSep = "\\.";
          } else {
            _thousandSep = localeData.delimiters.thousands;
          }
          temp = val.match(/^[^\d]+/);
          if (temp !== null) {
            val = val.substr(1);
            if (temp[0] !== _currSymbol) {
              return false;
            }
          }
          temp = val.match(/[^\d]+$/);
          if (temp !== null) {
            val = val.slice(0, -1);
            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
              return false;
            }
          }
          _thousandRegEx = new RegExp(_thousandSep + "{2}");
          if (!val.match(/[^\d.,]/g)) {
            _valArray = val.split(_decimalSep);
            if (_valArray.length > 2) {
              return false;
            } else {
              if (_valArray.length < 2) {
                return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx);
              } else {
                if (_valArray[0].length === 1) {
                  return !!_valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
                } else {
                  return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
                }
              }
            }
          }
          return false;
        };
        numeral2.fn = Numeral.prototype = {
          clone: function() {
            return numeral2(this);
          },
          format: function(inputString, roundingFunction) {
            var value = this._value, format3 = inputString || options.defaultFormat, kind, output, formatFunction;
            roundingFunction = roundingFunction || Math.round;
            if (value === 0 && options.zeroFormat !== null) {
              output = options.zeroFormat;
            } else if (value === null && options.nullFormat !== null) {
              output = options.nullFormat;
            } else {
              for (kind in formats) {
                if (format3.match(formats[kind].regexps.format)) {
                  formatFunction = formats[kind].format;
                  break;
                }
              }
              formatFunction = formatFunction || numeral2._.numberToFormat;
              output = formatFunction(value, format3, roundingFunction);
            }
            return output;
          },
          value: function() {
            return this._value;
          },
          input: function() {
            return this._input;
          },
          set: function(value) {
            this._value = Number(value);
            return this;
          },
          add: function(value) {
            var corrFactor = _.correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
              return accum + Math.round(corrFactor * curr);
            }
            this._value = _.reduce([this._value, value], cback, 0) / corrFactor;
            return this;
          },
          subtract: function(value) {
            var corrFactor = _.correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
              return accum - Math.round(corrFactor * curr);
            }
            this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;
            return this;
          },
          multiply: function(value) {
            function cback(accum, curr, currI, O) {
              var corrFactor = _.correctionFactor(accum, curr);
              return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
            }
            this._value = _.reduce([this._value, value], cback, 1);
            return this;
          },
          divide: function(value) {
            function cback(accum, curr, currI, O) {
              var corrFactor = _.correctionFactor(accum, curr);
              return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
            }
            this._value = _.reduce([this._value, value], cback);
            return this;
          },
          difference: function(value) {
            return Math.abs(numeral2(this._value).subtract(value).value());
          }
        };
        numeral2.register("locale", "en", {
          delimiters: {
            thousands: ",",
            decimal: "."
          },
          abbreviations: {
            thousand: "k",
            million: "m",
            billion: "b",
            trillion: "t"
          },
          ordinal: function(number) {
            var b = number % 10;
            return ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          },
          currency: {
            symbol: "$"
          }
        });
        (function() {
          numeral2.register("format", "bps", {
            regexps: {
              format: /(BPS)/,
              unformat: /(BPS)/
            },
            format: function(value, format3, roundingFunction) {
              var space = numeral2._.includes(format3, " BPS") ? " " : "", output;
              value = value * 1e4;
              format3 = format3.replace(/\s?BPS/, "");
              output = numeral2._.numberToFormat(value, format3, roundingFunction);
              if (numeral2._.includes(output, ")")) {
                output = output.split("");
                output.splice(-1, 0, space + "BPS");
                output = output.join("");
              } else {
                output = output + space + "BPS";
              }
              return output;
            },
            unformat: function(string) {
              return +(numeral2._.stringToNumber(string) * 1e-4).toFixed(15);
            }
          });
        })();
        (function() {
          var decimal = {
            base: 1e3,
            suffixes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
          }, binary = {
            base: 1024,
            suffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
          };
          var allSuffixes = decimal.suffixes.concat(binary.suffixes.filter(function(item) {
            return decimal.suffixes.indexOf(item) < 0;
          }));
          var unformatRegex = allSuffixes.join("|");
          unformatRegex = "(" + unformatRegex.replace("B", "B(?!PS)") + ")";
          numeral2.register("format", "bytes", {
            regexps: {
              format: /([0\s]i?b)/,
              unformat: new RegExp(unformatRegex)
            },
            format: function(value, format3, roundingFunction) {
              var output, bytes = numeral2._.includes(format3, "ib") ? binary : decimal, suffix = numeral2._.includes(format3, " b") || numeral2._.includes(format3, " ib") ? " " : "", power, min, max;
              format3 = format3.replace(/\s?i?b/, "");
              for (power = 0; power <= bytes.suffixes.length; power++) {
                min = Math.pow(bytes.base, power);
                max = Math.pow(bytes.base, power + 1);
                if (value === null || value === 0 || value >= min && value < max) {
                  suffix += bytes.suffixes[power];
                  if (min > 0) {
                    value = value / min;
                  }
                  break;
                }
              }
              output = numeral2._.numberToFormat(value, format3, roundingFunction);
              return output + suffix;
            },
            unformat: function(string) {
              var value = numeral2._.stringToNumber(string), power, bytesMultiplier;
              if (value) {
                for (power = decimal.suffixes.length - 1; power >= 0; power--) {
                  if (numeral2._.includes(string, decimal.suffixes[power])) {
                    bytesMultiplier = Math.pow(decimal.base, power);
                    break;
                  }
                  if (numeral2._.includes(string, binary.suffixes[power])) {
                    bytesMultiplier = Math.pow(binary.base, power);
                    break;
                  }
                }
                value *= bytesMultiplier || 1;
              }
              return value;
            }
          });
        })();
        (function() {
          numeral2.register("format", "currency", {
            regexps: {
              format: /(\$)/
            },
            format: function(value, format3, roundingFunction) {
              var locale = numeral2.locales[numeral2.options.currentLocale], symbols = {
                before: format3.match(/^([\+|\-|\(|\s|\$]*)/)[0],
                after: format3.match(/([\+|\-|\)|\s|\$]*)$/)[0]
              }, output, symbol, i;
              format3 = format3.replace(/\s?\$\s?/, "");
              output = numeral2._.numberToFormat(value, format3, roundingFunction);
              if (value >= 0) {
                symbols.before = symbols.before.replace(/[\-\(]/, "");
                symbols.after = symbols.after.replace(/[\-\)]/, "");
              } else if (value < 0 && (!numeral2._.includes(symbols.before, "-") && !numeral2._.includes(symbols.before, "("))) {
                symbols.before = "-" + symbols.before;
              }
              for (i = 0; i < symbols.before.length; i++) {
                symbol = symbols.before[i];
                switch (symbol) {
                  case "$":
                    output = numeral2._.insert(output, locale.currency.symbol, i);
                    break;
                  case " ":
                    output = numeral2._.insert(output, " ", i + locale.currency.symbol.length - 1);
                    break;
                }
              }
              for (i = symbols.after.length - 1; i >= 0; i--) {
                symbol = symbols.after[i];
                switch (symbol) {
                  case "$":
                    output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral2._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));
                    break;
                  case " ":
                    output = i === symbols.after.length - 1 ? output + " " : numeral2._.insert(output, " ", -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));
                    break;
                }
              }
              return output;
            }
          });
        })();
        (function() {
          numeral2.register("format", "exponential", {
            regexps: {
              format: /(e\+|e-)/,
              unformat: /(e\+|e-)/
            },
            format: function(value, format3, roundingFunction) {
              var output, exponential = typeof value === "number" && !numeral2._.isNaN(value) ? value.toExponential() : "0e+0", parts = exponential.split("e");
              format3 = format3.replace(/e[\+|\-]{1}0/, "");
              output = numeral2._.numberToFormat(Number(parts[0]), format3, roundingFunction);
              return output + "e" + parts[1];
            },
            unformat: function(string) {
              var parts = numeral2._.includes(string, "e+") ? string.split("e+") : string.split("e-"), value = Number(parts[0]), power = Number(parts[1]);
              power = numeral2._.includes(string, "e-") ? power *= -1 : power;
              function cback(accum, curr, currI, O) {
                var corrFactor = numeral2._.correctionFactor(accum, curr), num = accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);
                return num;
              }
              return numeral2._.reduce([value, Math.pow(10, power)], cback, 1);
            }
          });
        })();
        (function() {
          numeral2.register("format", "ordinal", {
            regexps: {
              format: /(o)/
            },
            format: function(value, format3, roundingFunction) {
              var locale = numeral2.locales[numeral2.options.currentLocale], output, ordinal = numeral2._.includes(format3, " o") ? " " : "";
              format3 = format3.replace(/\s?o/, "");
              ordinal += locale.ordinal(value);
              output = numeral2._.numberToFormat(value, format3, roundingFunction);
              return output + ordinal;
            }
          });
        })();
        (function() {
          numeral2.register("format", "percentage", {
            regexps: {
              format: /(%)/,
              unformat: /(%)/
            },
            format: function(value, format3, roundingFunction) {
              var space = numeral2._.includes(format3, " %") ? " " : "", output;
              if (numeral2.options.scalePercentBy100) {
                value = value * 100;
              }
              format3 = format3.replace(/\s?\%/, "");
              output = numeral2._.numberToFormat(value, format3, roundingFunction);
              if (numeral2._.includes(output, ")")) {
                output = output.split("");
                output.splice(-1, 0, space + "%");
                output = output.join("");
              } else {
                output = output + space + "%";
              }
              return output;
            },
            unformat: function(string) {
              var number = numeral2._.stringToNumber(string);
              if (numeral2.options.scalePercentBy100) {
                return number * 0.01;
              }
              return number;
            }
          });
        })();
        (function() {
          numeral2.register("format", "time", {
            regexps: {
              format: /(:)/,
              unformat: /(:)/
            },
            format: function(value, format3, roundingFunction) {
              var hours = Math.floor(value / 60 / 60), minutes = Math.floor((value - hours * 60 * 60) / 60), seconds = Math.round(value - hours * 60 * 60 - minutes * 60);
              return hours + ":" + (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
            },
            unformat: function(string) {
              var timeArray = string.split(":"), seconds = 0;
              if (timeArray.length === 3) {
                seconds = seconds + Number(timeArray[0]) * 60 * 60;
                seconds = seconds + Number(timeArray[1]) * 60;
                seconds = seconds + Number(timeArray[2]);
              } else if (timeArray.length === 2) {
                seconds = seconds + Number(timeArray[0]) * 60;
                seconds = seconds + Number(timeArray[1]);
              }
              return Number(seconds);
            }
          });
        })();
        return numeral2;
      });
    }
  });

  // resource/js/components/login/Login.vue
  var Login_exports = {};
  __export(Login_exports, {
    default: () => Login_default
  });
  function __vue_normalize__(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\login\\Login.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var __vue_script__2, __vue_render__2, __vue_staticRenderFns__2, __vue_inject_styles__2, __vue_scope_id__2, __vue_module_identifier__2, __vue_is_functional_template__2, __vue_component__, Login_default;
  var init_Login = __esm({
    "resource/js/components/login/Login.vue"() {
      __vue_script__2 = {
        name: "login-form",
        props: ["csrf"],
        data() {
          return {
            username: "",
            password: "",
            loginError: false
          };
        },
        methods: {
          login() {
            axios({
              method: "post",
              url: "/api/login",
              data: {
                csrf_token: this.csrf,
                username: this.username,
                password: this.password
              }
            }).then((response) => {
              const { data: { status, response: data2 } } = response;
              if (status) {
                this.setCookie("session", this.csrf, 365);
                location.href = "/";
              } else {
                this.loginError = true;
              }
            });
          },
          setCookie(name, value, days) {
            let expires = "";
            if (days) {
              const date = new Date();
              date.setTime(date.getTime() + days * 24 * 60 * 60 * 1e3);
              expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/";
          }
        },
        computed: {
          isInvalid() {
            if (this.loginError == true) {
              return "is-invalid";
            } else {
              return "";
            }
          }
        }
      };
      __vue_render__2 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", [
          _c("p", { staticClass: "login-box-msg" }, [_vm._v("Sign in to Dashboard")]),
          _vm._v(" "),
          _vm.loginError ? _c("div", { staticClass: "alert alert-danger", attrs: { role: "alert" } }, [_vm._v("\n        Incorrect user or password\n    ")]) : _vm._e(),
          _vm._v(" "),
          _c("form", {
            attrs: { method: "post" },
            on: {
              submit: function($event) {
                $event.preventDefault();
                return _vm.login.apply(null, arguments);
              }
            }
          }, [
            _c("input", {
              attrs: { type: "hidden", name: "csrf_token" },
              domProps: { value: _vm.csrf }
            }),
            _vm._v(" "),
            _c("div", { staticClass: "input-group mb-3" }, [
              _c("input", {
                directives: [
                  {
                    name: "model",
                    rawName: "v-model",
                    value: _vm.username,
                    expression: "username"
                  }
                ],
                staticClass: "form-control",
                class: _vm.isInvalid,
                attrs: { type: "text", placeholder: "Username", name: "username" },
                domProps: { value: _vm.username },
                on: {
                  input: function($event) {
                    if ($event.target.composing) {
                      return;
                    }
                    _vm.username = $event.target.value;
                  }
                }
              }),
              _vm._v(" "),
              _vm._m(0)
            ]),
            _vm._v(" "),
            _c("div", { staticClass: "input-group mb-3" }, [
              _c("input", {
                directives: [
                  {
                    name: "model",
                    rawName: "v-model",
                    value: _vm.password,
                    expression: "password"
                  }
                ],
                staticClass: "form-control",
                class: _vm.isInvalid,
                attrs: {
                  type: "password",
                  placeholder: "Password",
                  name: "password"
                },
                domProps: { value: _vm.password },
                on: {
                  input: function($event) {
                    if ($event.target.composing) {
                      return;
                    }
                    _vm.password = $event.target.value;
                  }
                }
              }),
              _vm._v(" "),
              _vm._m(1)
            ]),
            _vm._v(" "),
            _vm._m(2)
          ])
        ]);
      };
      __vue_staticRenderFns__2 = [
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("div", { staticClass: "input-group-append" }, [
            _c("div", { staticClass: "input-group-text" }, [
              _c("span", { staticClass: "fas fa-envelope" })
            ])
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("div", { staticClass: "input-group-append" }, [
            _c("div", { staticClass: "input-group-text" }, [
              _c("span", { staticClass: "fas fa-lock" })
            ])
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("div", { staticClass: "row" }, [
            _c("div", { staticClass: "col-8" }, [
              _c("div", { staticClass: "icheck-primary" }, [
                _c("input", { attrs: { type: "checkbox", id: "remember" } }),
                _vm._v(" "),
                _c("label", { attrs: { for: "remember" } }, [
                  _vm._v("\n                        Remember Me\n                    ")
                ])
              ])
            ]),
            _vm._v(" "),
            _c("div", { staticClass: "col-4" }, [
              _c("button", {
                staticClass: "btn btn-primary btn-block",
                attrs: { type: "submit" }
              }, [_vm._v("Sign In")])
            ])
          ]);
        }
      ];
      __vue_render__2._withStripped = true;
      __vue_inject_styles__2 = void 0;
      __vue_scope_id__2 = void 0;
      __vue_module_identifier__2 = void 0;
      __vue_is_functional_template__2 = false;
      __vue_component__ = /* @__PURE__ */ __vue_normalize__({ render: __vue_render__2, staticRenderFns: __vue_staticRenderFns__2 }, __vue_inject_styles__2, __vue_script__2, __vue_scope_id__2, __vue_is_functional_template__2, __vue_module_identifier__2, false, void 0, void 0, void 0);
      Login_default = __vue_component__;
    }
  });

  // resource/js/components/users/ModalUser.vue
  var ModalUser_exports = {};
  __export(ModalUser_exports, {
    default: () => ModalUser_default
  });
  function __vue_normalize__2(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\users\\ModalUser.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var __vue_script__3, __vue_render__3, __vue_staticRenderFns__3, __vue_inject_styles__3, __vue_scope_id__3, __vue_module_identifier__3, __vue_is_functional_template__3, __vue_component__2, ModalUser_default;
  var init_ModalUser = __esm({
    "resource/js/components/users/ModalUser.vue"() {
      __vue_script__3 = {
        name: "u-modal",
        props: {
          csrf_token: {
            required: true
          }
        },
        data() {
          return {
            id_user: void 0,
            name_user: void 0,
            username: void 0,
            password: void 0,
            role: void 0,
            pic: "/assets/images/anonymous.png",
            url_pic: "/assets/images/anonymous.png",
            edit: false
          };
        },
        methods: {
          onFileChange(e) {
            const files = e.target.files || e.dataTransfer.files;
            if (!files.length)
              return;
            if (files[0].size > 2e6) {
              this.$swal.fire({
                icon: "warning",
                title: "The image is very heavy, the limit is up to 2mb"
              });
              return;
            }
            this.pic = files[0];
            return this.url_pic = URL.createObjectURL(files[0]);
          },
          handleSubmitUser() {
            const form_data = new FormData();
            form_data.append("csrf_token", this.csrf_token);
            form_data.append("name_user", this.name_user);
            form_data.append("username", this.username);
            form_data.append("password", this.password);
            form_data.append("role", this.role);
            form_data.append("pic", this.pic);
            if (this.edit) {
              axios({
                method: "post",
                url: `/users/edit/${this.id_user}`,
                headers: {
                  "Content-Type": "multipart/form-data"
                },
                data: form_data
              }).then((response) => {
                const { data: { status, response: resp } } = response;
                if (status) {
                  this.$emit("editData", resp);
                  this.$refs.closeModal.click();
                  this.reset();
                }
              });
            } else {
              axios({
                method: "post",
                url: "/users/create",
                headers: {
                  "Content-Type": "multipart/form-data"
                },
                data: form_data
              }).then((response) => {
                const { data: { status, response: resp } } = response;
                if (status) {
                  this.$refs.closeModal.click();
                  this.$emit("mutateUser", resp);
                  this.reset();
                } else {
                  this.$swal.fire({
                    icon: "error",
                    title: "Error.",
                    text: resp
                  });
                }
              });
            }
          },
          reset() {
            this.name_user = "";
            this.username = "";
            this.password = "";
            this.role = "";
            this.pic = "";
            this.url_pic = this.pic;
            this.edit = false;
          },
          editU(data_edit) {
            this.edit = true;
            this.id_user = data_edit.id;
            this.name_user = data_edit.name;
            this.username = data_edit.username;
            this.role = data_edit.role;
            this.pic = data_edit.pic;
            this.url_pic = data_edit.pic;
          }
        }
      };
      __vue_render__3 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", {
          staticClass: "modal fade",
          attrs: {
            id: "create-modal-user",
            tabindex: "-1",
            "aria-labelledby": "UserCreateModal",
            "aria-hidden": "true"
          }
        }, [
          _c("div", { staticClass: "modal-dialog" }, [
            _c("div", { staticClass: "modal-content" }, [
              _c("form", {
                attrs: {
                  role: "form",
                  method: "POST",
                  enctype: "multipart/form-data"
                },
                on: {
                  submit: function($event) {
                    $event.preventDefault();
                    return _vm.handleSubmitUser.apply(null, arguments);
                  }
                }
              }, [
                _c("div", { staticClass: "modal-header" }, [
                  _c("h5", {
                    staticClass: "modal-title",
                    attrs: { id: "UserCreateModal" }
                  }, [_vm._v("Add New User")]),
                  _vm._v(" "),
                  _c("button", {
                    staticClass: "btn-close",
                    attrs: {
                      type: "button",
                      "data-bs-dismiss": "modal",
                      "aria-label": "Close"
                    },
                    on: { click: _vm.reset }
                  })
                ]),
                _vm._v(" "),
                _c("div", { staticClass: "modal-body" }, [
                  _c("div", { staticClass: "card-body" }, [
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(0),
                        _vm._v(" "),
                        _c("input", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.name_user,
                              expression: "name_user"
                            }
                          ],
                          staticClass: "form-control",
                          attrs: {
                            type: "text",
                            name: "name_user",
                            id: "name_user",
                            placeholder: "Name User",
                            required: ""
                          },
                          domProps: { value: _vm.name_user },
                          on: {
                            input: function($event) {
                              if ($event.target.composing) {
                                return;
                              }
                              _vm.name_user = $event.target.value;
                            }
                          }
                        })
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(1),
                        _vm._v(" "),
                        _c("input", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.username,
                              expression: "username"
                            }
                          ],
                          staticClass: "form-control",
                          attrs: {
                            type: "text",
                            name: "username",
                            id: "username",
                            placeholder: "Username",
                            required: ""
                          },
                          domProps: { value: _vm.username },
                          on: {
                            input: function($event) {
                              if ($event.target.composing) {
                                return;
                              }
                              _vm.username = $event.target.value;
                            }
                          }
                        })
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(2),
                        _vm._v(" "),
                        _c("input", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.password,
                              expression: "password"
                            }
                          ],
                          staticClass: "form-control",
                          attrs: {
                            type: "password",
                            name: "password",
                            id: "password",
                            placeholder: "Password",
                            required: ""
                          },
                          domProps: { value: _vm.password },
                          on: {
                            input: function($event) {
                              if ($event.target.composing) {
                                return;
                              }
                              _vm.password = $event.target.value;
                            }
                          }
                        })
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(3),
                        _vm._v(" "),
                        _c("select", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.role,
                              expression: "role"
                            }
                          ],
                          staticClass: "form-select",
                          attrs: { name: "role", id: "role", required: "" },
                          on: {
                            change: function($event) {
                              var $$selectedVal = Array.prototype.filter.call($event.target.options, function(o) {
                                return o.selected;
                              }).map(function(o) {
                                var val = "_value" in o ? o._value : o.value;
                                return val;
                              });
                              _vm.role = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
                            }
                          }
                        }, [
                          _c("option", { attrs: { value: "" } }, [
                            _vm._v("Select user role")
                          ]),
                          _vm._v(" "),
                          _c("option", { attrs: { value: "1" } }, [
                            _vm._v("Administrator")
                          ]),
                          _vm._v(" "),
                          _c("option", { attrs: { value: "2" } }, [
                            _vm._v("Assistant")
                          ]),
                          _vm._v(" "),
                          _c("option", { attrs: { value: "3" } }, [
                            _vm._v("Seller")
                          ])
                        ])
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("h6", { staticClass: "card-title" }, [
                        _vm._v("Upload photo")
                      ]),
                      _vm._v(" "),
                      _c("input", {
                        staticClass: "form-control",
                        attrs: {
                          type: "file",
                          name: "pic",
                          accept: ".png, .jpg, .jpeg"
                        },
                        on: { change: _vm.onFileChange }
                      }),
                      _vm._v(" "),
                      _c("small", { staticClass: "text-muted" }, [
                        _vm._v("max weight 20mb ")
                      ]),
                      _vm._v(" "),
                      _c("div", { staticClass: "mt-2" }, [
                        _c("img", {
                          staticClass: "img-thumbnail",
                          attrs: { src: _vm.url_pic, width: "100" }
                        })
                      ])
                    ])
                  ])
                ]),
                _vm._v(" "),
                _c("div", { staticClass: "modal-footer" }, [
                  _c("button", {
                    ref: "closeModal",
                    staticClass: "btn btn-secondary",
                    attrs: { type: "button", "data-bs-dismiss": "modal" }
                  }, [_vm._v("\n            Close\n          ")]),
                  _vm._v(" "),
                  _c("button", { staticClass: "btn btn-primary", attrs: { type: "submit" } }, [_vm._v("Save user")])
                ])
              ])
            ])
          ])
        ]);
      };
      __vue_staticRenderFns__3 = [
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-user" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-key" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-lock" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-users" })
          ]);
        }
      ];
      __vue_render__3._withStripped = true;
      __vue_inject_styles__3 = void 0;
      __vue_scope_id__3 = void 0;
      __vue_module_identifier__3 = void 0;
      __vue_is_functional_template__3 = false;
      __vue_component__2 = /* @__PURE__ */ __vue_normalize__2({ render: __vue_render__3, staticRenderFns: __vue_staticRenderFns__3 }, __vue_inject_styles__3, __vue_script__3, __vue_scope_id__3, __vue_is_functional_template__3, __vue_module_identifier__3, false, void 0, void 0, void 0);
      ModalUser_default = __vue_component__2;
    }
  });

  // resource/js/components/users/TableUsers.vue
  var TableUsers_exports = {};
  __export(TableUsers_exports, {
    default: () => TableUsers_default
  });
  function __vue_normalize__3(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\users\\TableUsers.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var __vue_script__4, __vue_render__4, __vue_staticRenderFns__4, __vue_inject_styles__4, __vue_scope_id__4, __vue_module_identifier__4, __vue_is_functional_template__4, __vue_component__3, TableUsers_default;
  var init_TableUsers = __esm({
    "resource/js/components/users/TableUsers.vue"() {
      init_ModalUser();
      __vue_script__4 = {
        name: "u-table",
        props: {
          users: {
            type: String,
            required: true
          },
          csrf_token: {
            type: String,
            required: true
          }
        },
        components: {
          ModalUser: ModalUser_default
        },
        data() {
          return {
            u_search: "",
            userParser: JSON.parse(this.users),
            datatable: void 0,
            editB: false
          };
        },
        methods: {
          defineRole(role) {
            switch (parseInt(role)) {
              case 1:
                return "Admin";
              case 2:
                return "Assistant";
              case 3:
                return "Seller";
            }
          },
          defineState(state) {
            switch (parseInt(state)) {
              case 1:
                return "Active";
              case 0:
                return "Disabled";
            }
          },
          StateClass(state) {
            if (parseInt(state) == "1") {
              return "btn btn-success btn-sm";
            } else if (parseInt(state) == "0") {
              return "btn btn-danger btn-sm";
            }
          },
          UpdateState(id, state) {
            let newState = state == "1" ? "0" : "1";
            axios({
              method: "post",
              url: `/users/state/update/${id}`,
              data: {
                csrf_token: this.csrf_token,
                new_state: newState
              }
            }).then((response) => {
              const { data: { response: resp } } = response;
              const user = this.userParser.find((u) => u.id === resp.id);
              user.state = resp.state;
              this.mutable = user.state;
            });
            return this.mutable;
          },
          formatDate(date, timestamp = false) {
            let datetime;
            if (timestamp) {
              datetime = new Date(date * 1e3);
            } else {
              datetime = new Date(date);
            }
            return datetime.toLocaleDateString("es-Mx");
          },
          userPic(pic) {
            if (pic) {
              return pic;
            } else {
              return "/assets/images/anonymous.png";
            }
          },
          mutateData(data2) {
            this.userParser.push(data2);
            new Promise((res) => {
              this.datatable.destroy();
              res(true);
            }).then(() => {
              this.mountedDatatable();
            });
          },
          editData(data2) {
            const user = this.userParser.find((u) => u.id === data2.id);
            user.name = data2.name;
            user.username = data2.username;
            user.role = data2.role;
            user.pic = data2.pic;
            user.date = data2.date;
          },
          mountedDatatable() {
            return this.datatable = $("#datatable-user").DataTable({
              responsive: true,
              destroy: true,
              lengthChange: false,
              autoWidth: false,
              rowReorder: {
                selector: "td:nth-child(2)"
              }
            });
          },
          editU(id_u) {
            const data2 = this.userParser.find((u) => u.id === id_u);
            this.$refs.modal.editU(data2);
            $("#modal-user-button").click();
          },
          deleteU(id_u) {
            this.$swal.fire({
              title: "Are you sure?",
              text: "do you want to delete this user?",
              icon: "warning",
              showCancelButton: true,
              confirmButtonColor: "#3085d6",
              cancelButtonColor: "#d33",
              confirmButtonText: "Yes, delete it!"
            }).then((result) => {
              if (result.isConfirmed) {
                axios({
                  method: "post",
                  url: `/users/delete/${id_u}`,
                  data: {
                    csrf_token: this.csrf_token
                  }
                }).then((response) => {
                  const { data: { status } } = response;
                  if (status) {
                    this.$swal.fire("Deleted!", "the user was deleted.", "success");
                    this.userParser.splice(this.userParser.findIndex((u) => u.id === id_u), 1);
                  }
                });
              }
            });
          }
        },
        mounted() {
          this.mountedDatatable();
        }
      };
      __vue_render__4 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", { staticClass: "card" }, [
          _vm._m(0),
          _vm._v(" "),
          _c("div", { staticClass: "card-body" }, [
            _c("table", {
              staticClass: "table table-striped",
              attrs: { id: "datatable-user" }
            }, [
              _vm._m(1),
              _vm._v(" "),
              _c("tbody", _vm._l(_vm.userParser, function(user, index) {
                return _c("tr", { key: index }, [
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(index + 1))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(user.name))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(user.username))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _c("img", {
                      staticClass: "img-thumbnail rounded",
                      attrs: { src: _vm.userPic(user.pic), width: "50" }
                    })
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(_vm.defineRole(user.role)))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _c("button", {
                      class: _vm.StateClass(user.state),
                      attrs: {
                        type: "button",
                        title: "Activate or deactivate user"
                      },
                      on: {
                        click: function($event) {
                          return _vm.UpdateState(user.id, user.state);
                        }
                      }
                    }, [_vm._v(_vm._s(_vm.defineState(user.state)))])
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(user.last_login))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(_vm.formatDate(user.date, true)))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _c("div", [
                      _c("button", {
                        staticClass: "btn btn-warning edit",
                        on: {
                          click: function($event) {
                            return _vm.editU(user.id);
                          }
                        }
                      }, [_c("i", { staticClass: "fa fa-pencil" })]),
                      _vm._v(" "),
                      _c("button", {
                        staticClass: "btn btn-danger delete",
                        on: {
                          click: function($event) {
                            return _vm.deleteU(user.id);
                          }
                        }
                      }, [_c("i", { staticClass: "fa fa-times" })])
                    ])
                  ])
                ]);
              }), 0)
            ])
          ]),
          _vm._v(" "),
          _c("u-modal", {
            ref: "modal",
            attrs: { csrf_token: _vm.csrf_token },
            on: { mutateUser: _vm.mutateData, editData: _vm.editData }
          })
        ], 1);
      };
      __vue_staticRenderFns__4 = [
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("div", { staticClass: "card-header" }, [
            _c("h3", { staticClass: "card-title" }, [_vm._v("List users")])
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("thead", [
            _c("tr", [
              _c("th", { staticClass: "text-center" }, [_vm._v("#")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center desktop" }, [_vm._v("Name")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("User")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Pic")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Role")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center all" }, [_vm._v("Status")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Last Login")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Registered")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center all" }, [_vm._v("Action")])
            ])
          ]);
        }
      ];
      __vue_render__4._withStripped = true;
      __vue_inject_styles__4 = void 0;
      __vue_scope_id__4 = void 0;
      __vue_module_identifier__4 = void 0;
      __vue_is_functional_template__4 = false;
      __vue_component__3 = /* @__PURE__ */ __vue_normalize__3({ render: __vue_render__4, staticRenderFns: __vue_staticRenderFns__4 }, __vue_inject_styles__4, __vue_script__4, __vue_scope_id__4, __vue_is_functional_template__4, __vue_module_identifier__4, false, void 0, void 0, void 0);
      TableUsers_default = __vue_component__3;
    }
  });

  // resource/js/components/categories/ModalCategories.vue
  var ModalCategories_exports = {};
  __export(ModalCategories_exports, {
    default: () => ModalCategories_default
  });
  function __vue_normalize__4(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\categories\\ModalCategories.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var __vue_script__5, __vue_render__5, __vue_staticRenderFns__5, __vue_inject_styles__5, __vue_scope_id__5, __vue_module_identifier__5, __vue_is_functional_template__5, __vue_component__4, ModalCategories_default;
  var init_ModalCategories = __esm({
    "resource/js/components/categories/ModalCategories.vue"() {
      __vue_script__5 = {
        name: "cate-modal",
        props: {
          csrf_token: {
            required: true
          }
        },
        data() {
          return {
            id_category: void 0,
            name: void 0,
            description: void 0
          };
        },
        methods: {
          handleSubmitCategory() {
            const form_data = new FormData();
            form_data.append("csrf_token", this.csrf_token);
            form_data.append("name", this.name);
            form_data.append("description", this.description);
            if (this.edit) {
              axios({
                method: "post",
                url: `/categories/edit/${this.id_category}`,
                headers: {
                  "Content-Type": "multipart/form-data"
                },
                data: form_data
              }).then((response) => {
                const { data: { status, response: resp } } = response;
                if (status) {
                  this.$emit("editData", resp);
                  this.$refs.closeModal.click();
                  this.reset();
                }
              });
            } else {
              axios({
                method: "post",
                url: "/categories/create",
                headers: {
                  "Content-Type": "multipart/form-data"
                },
                data: form_data
              }).then((response) => {
                const { data: { status, response: resp } } = response;
                if (status) {
                  this.$refs.closeModal.click();
                  this.$emit("mutateCate", resp);
                  this.reset();
                } else {
                  this.$swal.fire({
                    icon: "error",
                    title: "Error.",
                    text: resp
                  });
                }
              });
            }
          },
          reset() {
            this.name = "";
            this.description = "";
            this.edit = false;
          },
          editCate(data_edit) {
            this.edit = true;
            this.id_category = data_edit.id;
            this.name = data_edit.name;
            this.description = data_edit.description;
          }
        }
      };
      __vue_render__5 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", {
          staticClass: "modal fade",
          attrs: {
            id: "create-modal-category",
            tabindex: "-1",
            "aria-labelledby": "CategoryCreateModal",
            "aria-hidden": "true"
          }
        }, [
          _c("div", { staticClass: "modal-dialog" }, [
            _c("div", { staticClass: "modal-content" }, [
              _c("form", {
                attrs: {
                  role: "form",
                  autocomplete: "off",
                  method: "POST",
                  enctype: "multipart/form-data"
                },
                on: {
                  submit: function($event) {
                    $event.preventDefault();
                    return _vm.handleSubmitCategory.apply(null, arguments);
                  }
                }
              }, [
                _c("div", { staticClass: "modal-header" }, [
                  _c("h5", {
                    staticClass: "modal-title",
                    attrs: { id: "CategoryCreateModal" }
                  }, [_vm._v("Add New Category")]),
                  _vm._v(" "),
                  _c("button", {
                    staticClass: "btn-close",
                    attrs: {
                      type: "button",
                      "data-bs-dismiss": "modal",
                      "aria-label": "Close"
                    },
                    on: { click: _vm.reset }
                  })
                ]),
                _vm._v(" "),
                _c("div", { staticClass: "modal-body" }, [
                  _c("div", { staticClass: "card-body" }, [
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(0),
                        _vm._v(" "),
                        _c("input", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.name,
                              expression: "name"
                            }
                          ],
                          staticClass: "form-control",
                          attrs: {
                            type: "text",
                            name: "name",
                            id: "name",
                            placeholder: "Name Category",
                            required: ""
                          },
                          domProps: { value: _vm.name },
                          on: {
                            input: function($event) {
                              if ($event.target.composing) {
                                return;
                              }
                              _vm.name = $event.target.value;
                            }
                          }
                        })
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(1),
                        _vm._v(" "),
                        _c("textarea", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.description,
                              expression: "description"
                            }
                          ],
                          staticClass: "form-control",
                          attrs: {
                            name: "description",
                            id: "description",
                            placeholder: "Add a Description"
                          },
                          domProps: { value: _vm.description },
                          on: {
                            input: function($event) {
                              if ($event.target.composing) {
                                return;
                              }
                              _vm.description = $event.target.value;
                            }
                          }
                        })
                      ])
                    ])
                  ])
                ]),
                _vm._v(" "),
                _c("div", { staticClass: "modal-footer" }, [
                  _c("button", {
                    ref: "closeModal",
                    staticClass: "btn btn-secondary",
                    attrs: { type: "button", "data-bs-dismiss": "modal" }
                  }, [_vm._v("\n            Close\n          ")]),
                  _vm._v(" "),
                  _c("button", { staticClass: "btn btn-primary", attrs: { type: "submit" } }, [_vm._v("Save category")])
                ])
              ])
            ])
          ])
        ]);
      };
      __vue_staticRenderFns__5 = [
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-th" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-align-center" })
          ]);
        }
      ];
      __vue_render__5._withStripped = true;
      __vue_inject_styles__5 = void 0;
      __vue_scope_id__5 = void 0;
      __vue_module_identifier__5 = void 0;
      __vue_is_functional_template__5 = false;
      __vue_component__4 = /* @__PURE__ */ __vue_normalize__4({ render: __vue_render__5, staticRenderFns: __vue_staticRenderFns__5 }, __vue_inject_styles__5, __vue_script__5, __vue_scope_id__5, __vue_is_functional_template__5, __vue_module_identifier__5, false, void 0, void 0, void 0);
      ModalCategories_default = __vue_component__4;
    }
  });

  // resource/js/components/categories/TableCategories.vue
  var TableCategories_exports = {};
  __export(TableCategories_exports, {
    default: () => TableCategories_default
  });
  function __vue_normalize__5(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\categories\\TableCategories.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var __vue_script__6, __vue_render__6, __vue_staticRenderFns__6, __vue_inject_styles__6, __vue_scope_id__6, __vue_module_identifier__6, __vue_is_functional_template__6, __vue_component__5, TableCategories_default;
  var init_TableCategories = __esm({
    "resource/js/components/categories/TableCategories.vue"() {
      init_ModalCategories();
      __vue_script__6 = {
        name: "cate-table",
        props: {
          categories: {
            type: String,
            required: true
          },
          csrf_token: {
            type: String,
            required: true
          }
        },
        components: {
          ModalCategory: ModalCategories_default
        },
        data() {
          return {
            u_search: "",
            categoryParser: JSON.parse(this.categories),
            datatable: void 0,
            editB: false
          };
        },
        methods: {
          mountedDatatable() {
            return this.datatable = $("#datatable-categories").DataTable({
              responsive: true,
              destroy: true,
              lengthChange: false,
              autoWidth: false,
              rowReorder: {
                selector: "td:nth-child(2)"
              }
            });
          },
          mutateData(data2) {
            this.categoryParser.push(data2);
            new Promise((res) => {
              this.datatable.destroy();
              res(true);
            }).then(() => {
              this.mountedDatatable();
            });
          },
          editData(data2) {
            const category = this.categoryParser.find((u) => u.id === data2.id);
            category.name = data2.name;
            category.description = data2.description;
          },
          editCate(id) {
            const data2 = this.categoryParser.find((u) => u.id === id);
            this.$refs.modal.editCate(data2);
            $("#modal-category-button").click();
          },
          deleteCate(id) {
            this.$swal.fire({
              title: "Are you sure?",
              text: "do you want to delete this category?",
              icon: "warning",
              showCancelButton: true,
              confirmButtonColor: "#3085d6",
              cancelButtonColor: "#d33",
              confirmButtonText: "Yes, delete it!"
            }).then((result) => {
              if (result.isConfirmed) {
                axios({
                  method: "post",
                  url: `/categories/delete/${id}`,
                  data: {
                    csrf_token: this.csrf_token
                  }
                }).then((response) => {
                  const { data: { status } } = response;
                  if (status) {
                    this.$swal.fire("Deleted!", "the category was deleted.", "success");
                    this.categoryParser.splice(this.categoryParser.findIndex((u) => u.id === id), 1);
                  }
                });
              }
            });
          }
        },
        mounted() {
          this.mountedDatatable();
        }
      };
      __vue_render__6 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", { staticClass: "card" }, [
          _vm._m(0),
          _vm._v(" "),
          _c("div", { staticClass: "card-body" }, [
            _c("table", {
              staticClass: "table table-striped",
              attrs: { id: "datatable-categories" }
            }, [
              _vm._m(1),
              _vm._v(" "),
              _c("tbody", _vm._l(_vm.categoryParser, function(category, index) {
                return _c("tr", { key: index }, [
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(index + 1))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(category.name))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(category.description))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _c("div", [
                      _c("button", {
                        staticClass: "btn btn-warning edit",
                        on: {
                          click: function($event) {
                            return _vm.editCate(category.id);
                          }
                        }
                      }, [_c("i", { staticClass: "fa fa-pencil" })]),
                      _vm._v(" "),
                      _c("button", {
                        staticClass: "btn btn-danger delete",
                        on: {
                          click: function($event) {
                            return _vm.deleteCate(category.id);
                          }
                        }
                      }, [_c("i", { staticClass: "fa fa-times" })])
                    ])
                  ])
                ]);
              }), 0)
            ])
          ]),
          _vm._v(" "),
          _c("cate-modal", {
            ref: "modal",
            attrs: { csrf_token: _vm.csrf_token },
            on: { mutateCate: _vm.mutateData, editData: _vm.editData }
          })
        ], 1);
      };
      __vue_staticRenderFns__6 = [
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("div", { staticClass: "card-header" }, [
            _c("h3", { staticClass: "card-title" }, [_vm._v("List categories")])
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("thead", [
            _c("tr", [
              _c("th", { staticClass: "text-center" }, [_vm._v("#")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Name")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center desktop" }, [
                _vm._v("Description")
              ]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center all" }, [_vm._v("Action")])
            ])
          ]);
        }
      ];
      __vue_render__6._withStripped = true;
      __vue_inject_styles__6 = void 0;
      __vue_scope_id__6 = void 0;
      __vue_module_identifier__6 = void 0;
      __vue_is_functional_template__6 = false;
      __vue_component__5 = /* @__PURE__ */ __vue_normalize__5({ render: __vue_render__6, staticRenderFns: __vue_staticRenderFns__6 }, __vue_inject_styles__6, __vue_script__6, __vue_scope_id__6, __vue_is_functional_template__6, __vue_module_identifier__6, false, void 0, void 0, void 0);
      TableCategories_default = __vue_component__5;
    }
  });

  // resource/js/components/products/ModalProducts.vue
  var ModalProducts_exports = {};
  __export(ModalProducts_exports, {
    default: () => ModalProducts_default
  });
  function __vue_normalize__6(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\products\\ModalProducts.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (true) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  function __vue_create_injector__() {
    const styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});
    const isOldIE = typeof navigator !== "undefined" && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]'))
        return;
      const group = isOldIE ? css.media || "default" : id;
      const style = styles[group] || (styles[group] = { ids: [], parts: [], element: void 0 });
      if (!style.ids.includes(id)) {
        let code = css.source;
        let index = style.ids.length;
        style.ids.push(id);
        if (false) {
          code += "\n/*# sourceURL=" + css.map.sources[0] + " */";
          code += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + " */";
        }
        if (isOldIE) {
          style.element = style.element || document.querySelector("style[data-group=" + group + "]");
        }
        if (!style.element) {
          const head = document.head || document.getElementsByTagName("head")[0];
          const el = style.element = document.createElement("style");
          el.type = "text/css";
          if (css.media)
            el.setAttribute("media", css.media);
          if (isOldIE) {
            el.setAttribute("data-group", group);
            el.setAttribute("data-next-index", "0");
          }
          head.appendChild(el);
        }
        if (isOldIE) {
          index = parseInt(style.element.getAttribute("data-next-index"));
          style.element.setAttribute("data-next-index", index + 1);
        }
        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join("\n");
        } else {
          const textNode = document.createTextNode(code);
          const nodes = style.element.childNodes;
          if (nodes[index])
            style.element.removeChild(nodes[index]);
          if (nodes.length)
            style.element.insertBefore(textNode, nodes[index]);
          else
            style.element.appendChild(textNode);
        }
      }
    };
  }
  var __vue_script__7, __vue_render__7, __vue_staticRenderFns__7, __vue_inject_styles__7, __vue_scope_id__7, __vue_module_identifier__7, __vue_is_functional_template__7, __vue_component__6, ModalProducts_default;
  var init_ModalProducts = __esm({
    "resource/js/components/products/ModalProducts.vue"() {
      __vue_script__7 = {
        name: "prod-modal",
        props: {
          csrf_token: {
            required: true
          },
          categories: {
            required: true
          }
        },
        data() {
          return {
            id_product: void 0,
            sku: void 0,
            name: void 0,
            description: "",
            image: "/assets/images/products/boxed-bg.jpg",
            url_image: "/assets/images/products/boxed-bg.jpg",
            category: "",
            stock: void 0,
            cost: void 0,
            price: void 0,
            earning: 40
          };
        },
        methods: {
          usePercentChange() {
            if (this.$refs.percent.checked) {
              this.$refs.percent.checked = false;
            } else {
              this.$refs.percent.checked = true;
            }
          },
          priceAuto() {
            this.price = this.$refs.percent.checked ? Number(this.cost) * Number(this.earning) / 100 + Number(this.cost) : Number(this.price);
          },
          handleSubmitProduct() {
            const form_data = new FormData();
            form_data.append("csrf_token", this.csrf_token);
            form_data.append("sku", this.sku.toUpperCase());
            form_data.append("name", this.name);
            form_data.append("description", this.description);
            form_data.append("image", this.image);
            form_data.append("category", this.category);
            form_data.append("stock", this.stock);
            form_data.append("cost", this.cost);
            form_data.append("price", this.price);
            if (this.edit) {
              axios({
                method: "post",
                url: `/products/edit/${this.id_product}`,
                headers: {
                  "Content-Type": "multipart/form-data"
                },
                data: form_data
              }).then((response) => {
                const { data: { status, response: [product] } } = response;
                if (status) {
                  this.$emit("editData", product);
                  this.$refs.closeModal.click();
                  this.reset();
                }
              });
            } else {
              axios({
                method: "post",
                url: "/products/create",
                headers: {
                  "Content-Type": "multipart/form-data"
                },
                data: form_data
              }).then((response) => {
                const { data: { status, response: [product] } } = response;
                if (status) {
                  this.$refs.closeModal.click();
                  this.$emit("mutateProd", product);
                  this.reset();
                } else {
                  this.$swal.fire({
                    icon: "error",
                    title: "Error.",
                    text: response.data.response
                  });
                }
              });
            }
          },
          onFileChange(e) {
            const files = e.target.files || e.dataTransfer.files;
            if (!files.length)
              return;
            if (files[0].size > 2e6) {
              this.$swal.fire({
                icon: "warning",
                title: "The image is very heavy, the limit is up to 2mb"
              });
              return;
            }
            this.image = files[0];
            return this.url_image = URL.createObjectURL(files[0]);
          },
          reset() {
            this.id_product = void 0, this.sku = void 0, this.name = void 0, this.description = void 0, this.image = "/assets/images/products/boxed-bg.jpg", this.url_image = this.image, this.category = void 0, this.stock = void 0, this.cost = void 0, this.price = void 0, this.earning = 40;
            this.edit = false;
          },
          editProd(data_edit) {
            this.edit = true;
            this.id_product = data_edit.id;
            this.sku = data_edit.sku;
            this.name = data_edit.name;
            this.description = data_edit.description;
            this.image = data_edit.image;
            this.url_image = data_edit.image;
            this.category = data_edit.category.id;
            this.stock = data_edit.stock;
            this.cost = data_edit.cost;
            this.price = data_edit.price;
            this.earning = this.price / this.cost * 100;
          }
        }
      };
      __vue_render__7 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", {
          staticClass: "modal fade",
          attrs: {
            id: "create-modal-product",
            tabindex: "-1",
            "aria-labelledby": "ProductCreateModal",
            "aria-hidden": "true"
          }
        }, [
          _c("div", { staticClass: "modal-dialog" }, [
            _c("div", { staticClass: "modal-content" }, [
              _c("form", {
                attrs: {
                  role: "form",
                  autocomplete: "off",
                  method: "POST",
                  enctype: "multipart/form-data"
                },
                on: {
                  submit: function($event) {
                    $event.preventDefault();
                    return _vm.handleSubmitProduct.apply(null, arguments);
                  }
                }
              }, [
                _c("div", { staticClass: "modal-header" }, [
                  _c("h5", {
                    staticClass: "modal-title",
                    attrs: { id: "ProductCreateModal" }
                  }, [_vm._v("Add New Product")]),
                  _vm._v(" "),
                  _c("button", {
                    staticClass: "btn-close",
                    attrs: {
                      type: "button",
                      "data-bs-dismiss": "modal",
                      "aria-label": "Close"
                    },
                    on: { click: _vm.reset }
                  })
                ]),
                _vm._v(" "),
                _c("div", { staticClass: "modal-body" }, [
                  _c("div", { staticClass: "card-body" }, [
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(0),
                        _vm._v(" "),
                        _c("input", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.sku,
                              expression: "sku"
                            }
                          ],
                          staticClass: "form-control",
                          attrs: {
                            type: "text",
                            name: "sku",
                            id: "sku",
                            placeholder: "Sku product",
                            required: ""
                          },
                          domProps: { value: _vm.sku },
                          on: {
                            input: function($event) {
                              if ($event.target.composing) {
                                return;
                              }
                              _vm.sku = $event.target.value;
                            }
                          }
                        })
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(1),
                        _vm._v(" "),
                        _c("input", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.name,
                              expression: "name"
                            }
                          ],
                          staticClass: "form-control",
                          attrs: {
                            type: "text",
                            name: "name",
                            id: "name",
                            placeholder: "Name product",
                            required: ""
                          },
                          domProps: { value: _vm.name },
                          on: {
                            input: function($event) {
                              if ($event.target.composing) {
                                return;
                              }
                              _vm.name = $event.target.value;
                            }
                          }
                        })
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(2),
                        _vm._v(" "),
                        _c("textarea", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.description,
                              expression: "description"
                            }
                          ],
                          staticClass: "form-control",
                          attrs: {
                            name: "description",
                            id: "description",
                            placeholder: "Add a Description"
                          },
                          domProps: { value: _vm.description },
                          on: {
                            input: function($event) {
                              if ($event.target.composing) {
                                return;
                              }
                              _vm.description = $event.target.value;
                            }
                          }
                        })
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(3),
                        _vm._v(" "),
                        _c("select", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.category,
                              expression: "category"
                            }
                          ],
                          staticClass: "form-select",
                          attrs: {
                            name: "category",
                            id: "category",
                            required: ""
                          },
                          on: {
                            change: function($event) {
                              var $$selectedVal = Array.prototype.filter.call($event.target.options, function(o) {
                                return o.selected;
                              }).map(function(o) {
                                var val = "_value" in o ? o._value : o.value;
                                return val;
                              });
                              _vm.category = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
                            }
                          }
                        }, [
                          _c("option", { attrs: { disabled: "", selected: "" } }, [_vm._v("Select category")]),
                          _vm._v(" "),
                          _vm._l(_vm.categories, function(category, index) {
                            return _c("option", { key: index, domProps: { value: category.id } }, [_vm._v(_vm._s(category.name))]);
                          })
                        ], 2)
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(4),
                        _vm._v(" "),
                        _c("input", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.stock,
                              expression: "stock"
                            }
                          ],
                          staticClass: "form-control",
                          attrs: {
                            type: "number",
                            name: "stock",
                            id: "stock",
                            placeholder: "Stock",
                            required: "",
                            step: "1",
                            min: "1"
                          },
                          domProps: { value: _vm.stock },
                          on: {
                            input: function($event) {
                              if ($event.target.composing) {
                                return;
                              }
                              _vm.stock = $event.target.value;
                            }
                          }
                        })
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group row" }, [
                      _c("div", { staticClass: "col-sm-6" }, [
                        _c("div", { staticClass: "input-group input-group-lg" }, [
                          _vm._m(5),
                          _vm._v(" "),
                          _c("input", {
                            directives: [
                              {
                                name: "model",
                                rawName: "v-model",
                                value: _vm.cost,
                                expression: "cost"
                              }
                            ],
                            staticClass: "form-control",
                            attrs: {
                              type: "number",
                              name: "cost",
                              id: "cost",
                              placeholder: "Cost price",
                              required: "",
                              min: "0.01",
                              step: "0.01"
                            },
                            domProps: { value: _vm.cost },
                            on: {
                              change: _vm.priceAuto,
                              input: function($event) {
                                if ($event.target.composing) {
                                  return;
                                }
                                _vm.cost = $event.target.value;
                              }
                            }
                          })
                        ])
                      ]),
                      _vm._v(" "),
                      _c("div", { staticClass: "col-sm-6" }, [
                        _c("div", { staticClass: "input-group input-group-lg" }, [
                          _vm._m(6),
                          _vm._v(" "),
                          _c("input", {
                            directives: [
                              {
                                name: "model",
                                rawName: "v-model",
                                value: _vm.price,
                                expression: "price"
                              }
                            ],
                            staticClass: "form-control",
                            attrs: {
                              type: "number",
                              name: "price",
                              id: "price",
                              placeholder: "Sale price",
                              required: "",
                              min: "0.01",
                              step: "0.01"
                            },
                            domProps: { value: _vm.price },
                            on: {
                              input: function($event) {
                                if ($event.target.composing) {
                                  return;
                                }
                                _vm.price = $event.target.value;
                              }
                            }
                          })
                        ]),
                        _vm._v(" "),
                        _c("div", { staticClass: "row mt-4" }, [
                          _c("div", { staticClass: "col-sm-6" }, [
                            _c("div", { staticClass: "form-group icheck-primary" }, [
                              _c("input", {
                                ref: "percent",
                                attrs: { type: "checkbox", checked: "" },
                                on: { click: _vm.usePercentChange }
                              }),
                              _vm._v(" "),
                              _c("label", {
                                staticClass: "fs-7",
                                attrs: { for: "use-percent" },
                                on: { click: _vm.usePercentChange }
                              }, [
                                _vm._v("\n                        Use percentage\n                      ")
                              ])
                            ])
                          ]),
                          _vm._v(" "),
                          _c("div", { staticClass: "col-sm-6 p-md-0" }, [
                            _c("div", { staticClass: "input-group input-group-lg" }, [
                              _c("input", {
                                directives: [
                                  {
                                    name: "model",
                                    rawName: "v-model",
                                    value: _vm.earning,
                                    expression: "earning"
                                  }
                                ],
                                staticClass: "form-control fs-7",
                                attrs: { type: "number", min: "0" },
                                domProps: { value: _vm.earning },
                                on: {
                                  change: _vm.priceAuto,
                                  input: function($event) {
                                    if ($event.target.composing) {
                                      return;
                                    }
                                    _vm.earning = $event.target.value;
                                  }
                                }
                              }),
                              _vm._v(" "),
                              _vm._m(7)
                            ])
                          ])
                        ])
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("h6", { staticClass: "card-title" }, [
                        _vm._v("Upload image")
                      ]),
                      _vm._v(" "),
                      _c("input", {
                        staticClass: "form-control",
                        attrs: {
                          type: "file",
                          name: "image",
                          accept: ".png, .jpg, .jpeg"
                        },
                        on: { change: _vm.onFileChange }
                      }),
                      _vm._v(" "),
                      _c("small", { staticClass: "text-muted" }, [
                        _vm._v("max weight 2mb ")
                      ]),
                      _vm._v(" "),
                      _c("div", { staticClass: "mt-2" }, [
                        _c("img", {
                          staticClass: "img-thumbnail",
                          attrs: { src: _vm.url_image, width: "100" }
                        })
                      ])
                    ])
                  ])
                ]),
                _vm._v(" "),
                _c("div", { staticClass: "modal-footer" }, [
                  _c("button", {
                    ref: "closeModal",
                    staticClass: "btn btn-secondary",
                    attrs: { type: "button", "data-bs-dismiss": "modal" }
                  }, [_vm._v("\n            Close\n          ")]),
                  _vm._v(" "),
                  _c("button", { staticClass: "btn btn-primary", attrs: { type: "submit" } }, [_vm._v("Save category")])
                ])
              ])
            ])
          ])
        ]);
      };
      __vue_staticRenderFns__7 = [
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-barcode" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-box-archive" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-align-center" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-list-check" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-boxes-stacked" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-coins" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-money-check-dollar" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-percent fs-7" })
          ]);
        }
      ];
      __vue_render__7._withStripped = true;
      __vue_inject_styles__7 = function(inject2) {
        if (!inject2)
          return;
        inject2("data-v-8ce46910_0", { source: "\n.fs-7{\n  font-size: 0.8rem !important;\n}\n", map: { "version": 3, "sources": ["resource\\js\\components\\products\\ModalProducts.vue"], "names": [], "mappings": ";AAiWA;EACA,4BAAA;AACA", "file": "ModalProducts.vue", "sourcesContent": [`<template>\r
  <div\r
    class="modal fade"\r
    id="create-modal-product"\r
    tabindex="-1"\r
    aria-labelledby="ProductCreateModal"\r
    aria-hidden="true"\r
  >\r
    <div class="modal-dialog">\r
      <div class="modal-content">\r
        <form role="form" v-on:submit.prevent="handleSubmitProduct" autocomplete="off" method="POST" enctype="multipart/form-data">\r
          <div class="modal-header">\r
            <h5 class="modal-title" id="ProductCreateModal">Add New Product</h5>\r
            <button\r
              type="button"\r
              class="btn-close"\r
              data-bs-dismiss="modal"\r
              aria-label="Close"\r
              @click="reset"\r
            ></button>\r
          </div>\r
          <div class="modal-body">\r
            <div class="card-body">\r
              <div class="form-group">\r
                \r
                <div class="input-group input-group-lg">\r
                  <span class="input-group-text"\r
                    ><i class="fa fa-barcode"></i\r
                  ></span>\r
                  <input\r
                    type="text"\r
                    name="sku"\r
                    id="sku"\r
                    class="form-control"\r
                    placeholder="Sku product"\r
                    v-model="sku"\r
                    required\r
                  />\r
                </div>\r
\r
              </div>\r
\r
              <div class="form-group">\r
                \r
                <div class="input-group input-group-lg">\r
                  <span class="input-group-text">\r
                    <i class="fa fa-box-archive"></i>\r
                  </span>\r
                  <input\r
                    type="text"\r
                    name="name"\r
                    id="name"\r
                    class="form-control"\r
                    placeholder="Name product"\r
                    v-model="name"\r
                    required\r
                  />\r
                </div>\r
\r
              </div>\r
\r
              <div class="form-group">\r
                <div class="input-group input-group-lg">\r
                  <span class="input-group-text">\r
                    <i class="fa fa-align-center"></i>\r
                  </span>\r
                  <textarea\r
                    name="description"\r
                    id="description"\r
                    class="form-control"\r
                    placeholder="Add a Description"\r
                    v-model="description"\r
                  >\r
                  </textarea>\r
                </div>\r
\r
              </div>\r
\r
              <div class="form-group">\r
                <div class="input-group input-group-lg">\r
                  <span class="input-group-text"\r
                    ><i class="fa fa-list-check"></i\r
                  ></span>\r
                  <select\r
                    name="category"\r
                    id="category"\r
                    class="form-select"\r
                    v-model="category"\r
                    required\r
                  >\r
                    <option disabled selected>Select category</option>\r
                    <option v-for="(category, index) in categories" :key="index" :value="category.id">{{ category.name }}</option>\r
                  </select>\r
                </div>\r
              </div>\r
\r
              <div class="form-group">\r
                <div class="input-group input-group-lg">\r
                  <span class="input-group-text">\r
                    <i class="fa fa-boxes-stacked"></i>\r
                  </span>\r
                  <input\r
                    type="number"\r
                    name="stock"\r
                    id="stock"\r
                    class="form-control"\r
                    placeholder="Stock"\r
                    v-model="stock"\r
                    required\r
                    step="1"\r
                    min="1"\r
                  />\r
                </div>\r
              </div>\r
\r
              <div class="form-group row">\r
                <div class="col-sm-6">\r
                  <div class="input-group input-group-lg">\r
                    <span class="input-group-text">\r
                      <i class="fa fa-coins"></i>\r
                    </span>\r
                    <input\r
                      type="number"\r
                      name="cost"\r
                      id="cost"\r
                      class="form-control"\r
                      placeholder="Cost price"\r
                      v-model="cost"\r
                      required\r
                      min="0.01"\r
                      step="0.01"\r
                      @change="priceAuto"\r
                    />\r
                  </div>\r
                </div>\r
                \r
                <div class="col-sm-6">\r
                  <div class="input-group input-group-lg">\r
                    <span class="input-group-text">\r
                      <i class="fa fa-money-check-dollar"></i>\r
                    </span>\r
                    <input\r
                      type="number"\r
                      name="price"\r
                      id="price"\r
                      class="form-control"\r
                      placeholder="Sale price"\r
                      v-model="price"\r
                      required\r
                      min="0.01"\r
                      step="0.01"\r
                    />\r
                  </div>\r
                  \r
                  <div class="row mt-4">\r
\r
                    <div class="col-sm-6">\r
                      <div class="form-group icheck-primary">\r
                          <input type="checkbox" ref="percent" @click="usePercentChange" checked>\r
                        <label for="use-percent" class="fs-7" @click="usePercentChange">\r
                          Use percentage\r
                        </label>\r
                      </div>\r
                    </div>\r
                    \r
                    <div class="col-sm-6 p-md-0">\r
                      <div class="input-group input-group-lg">\r
                        <input type="number" class="form-control fs-7" min="0" v-model="earning" @change="priceAuto">\r
                        <span class="input-group-text"><i class="fa fa-percent fs-7"></i></span>\r
                      </div>\r
                    </div>\r
                  </div>\r
                </div>\r
\r
              </div>\r
              \r
              <div class="form-group">\r
                <h6 class="card-title">Upload image</h6>\r
                <input\r
                  type="file"\r
                  class="form-control"\r
                  name="image"\r
                  v-on:change="onFileChange"\r
                  accept=".png, .jpg, .jpeg"\r
                />\r
                <small class="text-muted">max weight 2mb </small>\r
                <div class="mt-2">\r
                  <img :src="url_image" class="img-thumbnail" width="100" />\r
                </div>\r
              </div>\r
\r
            </div>\r
\r
          </div>\r
\r
          <div class="modal-footer">\r
            <button\r
              type="button"\r
              class="btn btn-secondary"\r
              data-bs-dismiss="modal"\r
              ref="closeModal"\r
            >\r
              Close\r
            </button>\r
            <button type="submit" class="btn btn-primary">Save category</button>\r
          </div>\r
\r
        </form>\r
        \r
      </div>\r
\r
    </div>\r
\r
  </div>\r
</template>\r
<script>\r
export default {\r
  name: "prod-modal",\r
  props: {\r
    csrf_token: {\r
      required: true,\r
    },\r
    categories: {\r
      required: true\r
    },\r
  },\r
  data() {\r
    return {\r
      id_product: undefined,\r
      sku: undefined,\r
      name: undefined,\r
      description: '',\r
      image: "/assets/images/products/boxed-bg.jpg",\r
      url_image: "/assets/images/products/boxed-bg.jpg",\r
      category: '',\r
      stock: undefined,\r
      cost: undefined,\r
      price: undefined,\r
      earning: 40,\r
    };\r
  },\r
  methods: {\r
    usePercentChange(){\r
      if(this.$refs.percent.checked){\r
        this.$refs.percent.checked = false;\r
      }else{\r
        this.$refs.percent.checked = true;\r
      }\r
    },\r
    priceAuto(){\r
      this.price = (this.$refs.percent.checked) \r
                  ?\r
              ((Number(this.cost) * Number(this.earning)) / 100) + Number(this.cost)\r
                  :\r
              Number(this.price);\r
    },\r
    handleSubmitProduct() {\r
      const form_data = new FormData();\r
      form_data.append("csrf_token", this.csrf_token);\r
      form_data.append("sku", this.sku.toUpperCase());\r
      form_data.append('name', this.name);\r
      form_data.append('description', this.description);\r
      form_data.append('image', this.image);\r
      form_data.append('category', this.category);\r
      form_data.append('stock', this.stock);\r
      form_data.append('cost', this.cost);\r
      form_data.append('price', this.price);\r
\r
      if(this.edit){\r
          axios({\r
            method:'post',\r
            url: \`/products/edit/\${this.id_product}\`,\r
            headers: {\r
                'Content-Type': 'multipart/form-data'\r
            },\r
            data: form_data\r
          }).then(response => {\r
            const { data: { status, response:[ product ] } } = response;\r
            if(status){\r
              this.$emit('editData', product);\r
              this.$refs.closeModal.click();\r
              this.reset();\r
            }\r
          });\r
        }else{\r
          axios({\r
            method:'post',\r
            url: '/products/create',\r
            headers: {\r
                'Content-Type': 'multipart/form-data'\r
            },\r
            data: form_data\r
          }).then(response =>{\r
            const { data: { status, response: [ product ] } } = response;\r
            if(status){\r
              this.$refs.closeModal.click();\r
              this.$emit('mutateProd', product);\r
              this.reset();\r
            }else{\r
              this.$swal.fire({\r
                icon: 'error',\r
                title: 'Error.',\r
                text: response.data.response,\r
              });\r
            }\r
          })\r
        }\r
    },\r
    onFileChange(e) {\r
      const files = e.target.files || e.dataTransfer.files;\r
      if (!files.length) return;\r
      if(files[0].size > 2000000){\r
        this.$swal.fire({\r
          icon: 'warning',\r
          title: 'The image is very heavy, the limit is up to 2mb'\r
        })\r
        return;\r
      }\r
      this.image = files[0];\r
      return (this.url_image = URL.createObjectURL(files[0]));\r
    },\r
    reset() {\r
      this.id_product = undefined,\r
      this.sku = undefined,\r
      this.name = undefined,\r
      this.description = undefined,\r
      this.image = "/assets/images/products/boxed-bg.jpg",\r
      this.url_image = this.image,\r
      this.category = undefined,\r
      this.stock = undefined,\r
      this.cost = undefined,\r
      this.price = undefined,\r
      this.earning = 40;\r
      this.edit = false;\r
    },\r
    editProd(data_edit) {\r
      this.edit = true;\r
      this.id_product = data_edit.id;\r
      this.sku = data_edit.sku;\r
      this.name = data_edit.name;\r
      this.description = data_edit.description;\r
      this.image = data_edit.image;\r
      this.url_image = data_edit.image;\r
      this.category = data_edit.category.id;\r
      this.stock = data_edit.stock;\r
      this.cost = data_edit.cost;\r
      this.price = data_edit.price;\r
      this.earning = (this.price / this.cost) * 100;\r
    },\r
  },\r
};\r
<\/script>\r
<style>\r
  .fs-7{\r
    font-size: 0.8rem !important;\r
  }\r
</style>`] }, media: void 0 });
      };
      __vue_scope_id__7 = void 0;
      __vue_module_identifier__7 = void 0;
      __vue_is_functional_template__7 = false;
      __vue_component__6 = /* @__PURE__ */ __vue_normalize__6({ render: __vue_render__7, staticRenderFns: __vue_staticRenderFns__7 }, __vue_inject_styles__7, __vue_script__7, __vue_scope_id__7, __vue_is_functional_template__7, __vue_module_identifier__7, false, __vue_create_injector__, void 0, void 0);
      ModalProducts_default = __vue_component__6;
    }
  });

  // resource/js/components/products/TableProducts.vue
  var TableProducts_exports = {};
  __export(TableProducts_exports, {
    default: () => TableProducts_default
  });
  function __vue_normalize__7(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\products\\TableProducts.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var import_moment, __vue_script__8, __vue_render__8, __vue_staticRenderFns__8, __vue_inject_styles__8, __vue_scope_id__8, __vue_module_identifier__8, __vue_is_functional_template__8, __vue_component__7, TableProducts_default;
  var init_TableProducts = __esm({
    "resource/js/components/products/TableProducts.vue"() {
      import_moment = __toESM(require_moment());
      init_ModalProducts();
      __vue_script__8 = {
        name: "prod-table",
        props: {
          products: {
            type: String,
            required: true
          },
          csrf_token: {
            type: String,
            required: true
          },
          categories: {
            type: String,
            required: true
          }
        },
        components: {
          ModalProduct: ModalProducts_default
        },
        data() {
          return {
            u_search: "",
            productsParser: JSON.parse(this.products),
            datatable: void 0,
            editB: false,
            categoriesParser: JSON.parse(this.categories),
            getProduct: true,
            mutable_data: void 0
          };
        },
        filters: {
          formatTotal(val) {
            const formatter = new Intl.NumberFormat("en-US", {
              style: "currency",
              currency: "USD"
            });
            return formatter.format(val);
          }
        },
        methods: {
          dataProducts(page = 2) {
            axios({
              method: "get",
              url: `/api/products/all/page/${page}`,
              data: {
                csrf_token: this.csrf_token
              }
            }).then((response) => {
              const { data: { products } } = response;
              if (!response.data.status) {
                this.getProduct = false;
                this.mutable_data = void 0;
              }
              if (this.getProduct) {
                this.mutable_data = response.data;
                products.map((value, index) => {
                  this.productsParser.push(value);
                });
              }
            }).then(() => {
              if (this.getProduct) {
                this.dataProducts(this.mutable_data.next_page);
              }
            });
          },
          mountedDatatable() {
            return this.datatable = $("#datatable-products").DataTable({
              responsive: true,
              destroy: true,
              lengthChange: false,
              autoWidth: false,
              rowReorder: {
                selector: "td:nth-child(2)"
              }
            });
          },
          mutateData(data2) {
            this.productsParser.push(data2);
            new Promise((res) => {
              this.datatable.destroy();
              res(true);
            }).then(() => {
              this.mountedDatatable();
            });
          },
          prodPic(image) {
            if (image) {
              return image;
            } else {
              return "/assets/images/products/boxed-bg.jpg";
            }
          },
          editData(data2) {
            const product = this.productsParser.find((u) => u.id === data2.id);
            product.sku = data2.sku;
            product.name = data2.name;
            product.description = data2.description;
            product.image = data2.image;
            product.stock = data2.stock;
            product.cost = data2.cost;
            product.price = data2.price;
          },
          editProd(id) {
            const data2 = this.productsParser.find((u) => u.id === id);
            this.$refs.modal.editProd(data2);
            $("#modal-product-button").click();
          },
          deleteProd(id) {
            this.$swal.fire({
              title: "Are you sure?",
              text: "do you want to delete this product?",
              icon: "warning",
              showCancelButton: true,
              confirmButtonColor: "#3085d6",
              cancelButtonColor: "#d33",
              confirmButtonText: "Yes, delete it!"
            }).then((result) => {
              if (result.isConfirmed) {
                axios({
                  method: "post",
                  url: `/products/delete/${id}`,
                  data: {
                    csrf_token: this.csrf_token
                  }
                }).then((response) => {
                  const { data: { status } } = response;
                  if (status) {
                    this.$swal.fire("Deleted!", "the product was deleted.", "success");
                    this.productsParser.splice(this.productsParser.findIndex((u) => u.id === id), 1);
                  }
                });
              }
            });
          },
          formatDate(timestamp) {
            return (0, import_moment.default)(timestamp).format("l");
          }
        },
        mounted() {
          this.mountedDatatable();
          this.dataProducts();
        }
      };
      __vue_render__8 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", { staticClass: "card" }, [
          _vm._m(0),
          _vm._v(" "),
          _c("div", { staticClass: "card-body" }, [
            _c("table", {
              staticClass: "table table-striped",
              attrs: { id: "datatable-products" }
            }, [
              _vm._m(1),
              _vm._v(" "),
              _c("tbody", _vm._l(_vm.productsParser, function(product, index) {
                return _c("tr", { key: index }, [
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(index + 1))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(product.sku))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(product.name))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(product.description))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _c("img", {
                      staticClass: "img-thumbnail rounded",
                      attrs: { src: _vm.prodPic(product.image), width: "50" }
                    })
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(product.category.name))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(product.stock))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(_vm._f("formatTotal")(product.cost)))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(_vm._f("formatTotal")(product.price)))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(_vm.formatDate(product.created_at)))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _c("div", [
                      _c("button", {
                        staticClass: "btn btn-warning edit",
                        on: {
                          click: function($event) {
                            return _vm.editProd(product.id);
                          }
                        }
                      }, [_c("i", { staticClass: "fa fa-pencil" })]),
                      _vm._v(" "),
                      _c("button", {
                        staticClass: "btn btn-danger delete",
                        on: {
                          click: function($event) {
                            return _vm.deleteProd(product.id);
                          }
                        }
                      }, [_c("i", { staticClass: "fa fa-times" })])
                    ])
                  ])
                ]);
              }), 0)
            ])
          ]),
          _vm._v(" "),
          _c("prod-modal", {
            ref: "modal",
            attrs: { csrf_token: _vm.csrf_token, categories: _vm.categoriesParser },
            on: { mutateProd: _vm.mutateData, editData: _vm.editData }
          })
        ], 1);
      };
      __vue_staticRenderFns__8 = [
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("div", { staticClass: "card-header" }, [
            _c("h3", { staticClass: "card-title" }, [_vm._v("List products")])
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("thead", [
            _c("tr", [
              _c("th", { staticClass: "text-center" }, [_vm._v("#")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("SKU")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Name")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Description")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Image")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Category")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Stock")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Cost price")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Sale price")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Date")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center all" }, [_vm._v("Action")])
            ])
          ]);
        }
      ];
      __vue_render__8._withStripped = true;
      __vue_inject_styles__8 = void 0;
      __vue_scope_id__8 = void 0;
      __vue_module_identifier__8 = void 0;
      __vue_is_functional_template__8 = false;
      __vue_component__7 = /* @__PURE__ */ __vue_normalize__7({ render: __vue_render__8, staticRenderFns: __vue_staticRenderFns__8 }, __vue_inject_styles__8, __vue_script__8, __vue_scope_id__8, __vue_is_functional_template__8, __vue_module_identifier__8, false, void 0, void 0, void 0);
      TableProducts_default = __vue_component__7;
    }
  });

  // node_modules/imask/esm/_rollupPluginBabelHelpers-b054ecd2.js
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props2) {
    for (var i = 0; i < props2.length; i++) {
      var descriptor = props2[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass)
      _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _possibleConstructorReturn(self2, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self2);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null)
        break;
    }
    return object;
  }
  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get2(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (!base)
          return;
        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }
        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set3(target2, property2, value2, receiver2) {
        var base = _superPropBase(target2, property2);
        var desc;
        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.set) {
            desc.set.call(receiver2, value2);
            return true;
          } else if (!desc.writable) {
            return false;
          }
        }
        desc = Object.getOwnPropertyDescriptor(receiver2, property2);
        if (desc) {
          if (!desc.writable) {
            return false;
          }
          desc.value = value2;
          Object.defineProperty(receiver2, property2, desc);
        } else {
          _defineProperty(receiver2, property2, value2);
        }
        return true;
      };
    }
    return set(target, property, value, receiver);
  }
  function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new Error("failed to set property");
    }
    return value;
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var init_rollupPluginBabelHelpers_b054ecd2 = __esm({
    "node_modules/imask/esm/_rollupPluginBabelHelpers-b054ecd2.js"() {
    }
  });

  // node_modules/imask/esm/core/change-details.js
  var ChangeDetails;
  var init_change_details = __esm({
    "node_modules/imask/esm/core/change-details.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      ChangeDetails = /* @__PURE__ */ function() {
        function ChangeDetails2(details) {
          _classCallCheck(this, ChangeDetails2);
          Object.assign(this, {
            inserted: "",
            rawInserted: "",
            skip: false,
            tailShift: 0
          }, details);
        }
        _createClass(ChangeDetails2, [{
          key: "aggregate",
          value: function aggregate(details) {
            this.rawInserted += details.rawInserted;
            this.skip = this.skip || details.skip;
            this.inserted += details.inserted;
            this.tailShift += details.tailShift;
            return this;
          }
        }, {
          key: "offset",
          get: function get2() {
            return this.tailShift + this.inserted.length;
          }
        }]);
        return ChangeDetails2;
      }();
    }
  });

  // node_modules/imask/esm/core/utils.js
  function isString(str) {
    return typeof str === "string" || str instanceof String;
  }
  function forceDirection(direction) {
    switch (direction) {
      case DIRECTION.LEFT:
        return DIRECTION.FORCE_LEFT;
      case DIRECTION.RIGHT:
        return DIRECTION.FORCE_RIGHT;
      default:
        return direction;
    }
  }
  function escapeRegExp(str) {
    return str.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
  }
  function normalizePrepare(prep) {
    return Array.isArray(prep) ? prep : [prep, new ChangeDetails()];
  }
  function objectIncludes(b, a) {
    if (a === b)
      return true;
    var arrA = Array.isArray(a), arrB = Array.isArray(b), i;
    if (arrA && arrB) {
      if (a.length != b.length)
        return false;
      for (i = 0; i < a.length; i++) {
        if (!objectIncludes(a[i], b[i]))
          return false;
      }
      return true;
    }
    if (arrA != arrB)
      return false;
    if (a && b && _typeof(a) === "object" && _typeof(b) === "object") {
      var dateA = a instanceof Date, dateB = b instanceof Date;
      if (dateA && dateB)
        return a.getTime() == b.getTime();
      if (dateA != dateB)
        return false;
      var regexpA = a instanceof RegExp, regexpB = b instanceof RegExp;
      if (regexpA && regexpB)
        return a.toString() == b.toString();
      if (regexpA != regexpB)
        return false;
      var keys = Object.keys(a);
      for (i = 0; i < keys.length; i++) {
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      }
      for (i = 0; i < keys.length; i++) {
        if (!objectIncludes(b[keys[i]], a[keys[i]]))
          return false;
      }
      return true;
    } else if (a && b && typeof a === "function" && typeof b === "function") {
      return a.toString() === b.toString();
    }
    return false;
  }
  var DIRECTION;
  var init_utils = __esm({
    "node_modules/imask/esm/core/utils.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_change_details();
      DIRECTION = {
        NONE: "NONE",
        LEFT: "LEFT",
        FORCE_LEFT: "FORCE_LEFT",
        RIGHT: "RIGHT",
        FORCE_RIGHT: "FORCE_RIGHT"
      };
    }
  });

  // node_modules/imask/esm/core/action-details.js
  var ActionDetails;
  var init_action_details = __esm({
    "node_modules/imask/esm/core/action-details.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_utils();
      init_change_details();
      ActionDetails = /* @__PURE__ */ function() {
        function ActionDetails2(value, cursorPos, oldValue, oldSelection) {
          _classCallCheck(this, ActionDetails2);
          this.value = value;
          this.cursorPos = cursorPos;
          this.oldValue = oldValue;
          this.oldSelection = oldSelection;
          while (this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos)) {
            --this.oldSelection.start;
          }
        }
        _createClass(ActionDetails2, [{
          key: "startChangePos",
          get: function get2() {
            return Math.min(this.cursorPos, this.oldSelection.start);
          }
        }, {
          key: "insertedCount",
          get: function get2() {
            return this.cursorPos - this.startChangePos;
          }
        }, {
          key: "inserted",
          get: function get2() {
            return this.value.substr(this.startChangePos, this.insertedCount);
          }
        }, {
          key: "removedCount",
          get: function get2() {
            return Math.max(this.oldSelection.end - this.startChangePos || this.oldValue.length - this.value.length, 0);
          }
        }, {
          key: "removed",
          get: function get2() {
            return this.oldValue.substr(this.startChangePos, this.removedCount);
          }
        }, {
          key: "head",
          get: function get2() {
            return this.value.substring(0, this.startChangePos);
          }
        }, {
          key: "tail",
          get: function get2() {
            return this.value.substring(this.startChangePos + this.insertedCount);
          }
        }, {
          key: "removeDirection",
          get: function get2() {
            if (!this.removedCount || this.insertedCount)
              return DIRECTION.NONE;
            return (this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos) && this.oldSelection.end === this.oldSelection.start ? DIRECTION.RIGHT : DIRECTION.LEFT;
          }
        }]);
        return ActionDetails2;
      }();
    }
  });

  // node_modules/imask/esm/core/continuous-tail-details.js
  var ContinuousTailDetails;
  var init_continuous_tail_details = __esm({
    "node_modules/imask/esm/core/continuous-tail-details.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      ContinuousTailDetails = /* @__PURE__ */ function() {
        function ContinuousTailDetails2() {
          var value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var from = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          var stop = arguments.length > 2 ? arguments[2] : void 0;
          _classCallCheck(this, ContinuousTailDetails2);
          this.value = value;
          this.from = from;
          this.stop = stop;
        }
        _createClass(ContinuousTailDetails2, [{
          key: "toString",
          value: function toString2() {
            return this.value;
          }
        }, {
          key: "extend",
          value: function extend(tail) {
            this.value += String(tail);
          }
        }, {
          key: "appendTo",
          value: function appendTo(masked) {
            return masked.append(this.toString(), {
              tail: true
            }).aggregate(masked._appendPlaceholder());
          }
        }, {
          key: "state",
          get: function get2() {
            return {
              value: this.value,
              from: this.from,
              stop: this.stop
            };
          },
          set: function set3(state) {
            Object.assign(this, state);
          }
        }, {
          key: "unshift",
          value: function unshift(beforePos) {
            if (!this.value.length || beforePos != null && this.from >= beforePos)
              return "";
            var shiftChar = this.value[0];
            this.value = this.value.slice(1);
            return shiftChar;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (!this.value.length)
              return "";
            var shiftChar = this.value[this.value.length - 1];
            this.value = this.value.slice(0, -1);
            return shiftChar;
          }
        }]);
        return ContinuousTailDetails2;
      }();
    }
  });

  // node_modules/imask/esm/core/holder.js
  function IMask(el) {
    var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return new IMask.InputMask(el, opts);
  }
  var init_holder = __esm({
    "node_modules/imask/esm/core/holder.js"() {
    }
  });

  // node_modules/imask/esm/masked/base.js
  var Masked;
  var init_base = __esm({
    "node_modules/imask/esm/masked/base.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_change_details();
      init_continuous_tail_details();
      init_utils();
      init_holder();
      Masked = /* @__PURE__ */ function() {
        function Masked2(opts) {
          _classCallCheck(this, Masked2);
          this._value = "";
          this._update(Object.assign({}, Masked2.DEFAULTS, opts));
          this.isInitialized = true;
        }
        _createClass(Masked2, [{
          key: "updateOptions",
          value: function updateOptions(opts) {
            if (!Object.keys(opts).length)
              return;
            this.withValueRefresh(this._update.bind(this, opts));
          }
        }, {
          key: "_update",
          value: function _update(opts) {
            Object.assign(this, opts);
          }
        }, {
          key: "state",
          get: function get2() {
            return {
              _value: this.value
            };
          },
          set: function set3(state) {
            this._value = state._value;
          }
        }, {
          key: "reset",
          value: function reset() {
            this._value = "";
          }
        }, {
          key: "value",
          get: function get2() {
            return this._value;
          },
          set: function set3(value) {
            this.resolve(value);
          }
        }, {
          key: "resolve",
          value: function resolve(value) {
            this.reset();
            this.append(value, {
              input: true
            }, "");
            this.doCommit();
            return this.value;
          }
        }, {
          key: "unmaskedValue",
          get: function get2() {
            return this.value;
          },
          set: function set3(value) {
            this.reset();
            this.append(value, {}, "");
            this.doCommit();
          }
        }, {
          key: "typedValue",
          get: function get2() {
            return this.doParse(this.value);
          },
          set: function set3(value) {
            this.value = this.doFormat(value);
          }
        }, {
          key: "rawInputValue",
          get: function get2() {
            return this.extractInput(0, this.value.length, {
              raw: true
            });
          },
          set: function set3(value) {
            this.reset();
            this.append(value, {
              raw: true
            }, "");
            this.doCommit();
          }
        }, {
          key: "isComplete",
          get: function get2() {
            return true;
          }
        }, {
          key: "isFilled",
          get: function get2() {
            return this.isComplete;
          }
        }, {
          key: "nearestInputPos",
          value: function nearestInputPos(cursorPos, direction) {
            return cursorPos;
          }
        }, {
          key: "extractInput",
          value: function extractInput() {
            var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
            return this.value.slice(fromPos, toPos);
          }
        }, {
          key: "extractTail",
          value: function extractTail() {
            var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
            return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);
          }
        }, {
          key: "appendTail",
          value: function appendTail(tail) {
            if (isString(tail))
              tail = new ContinuousTailDetails(String(tail));
            return tail.appendTo(this);
          }
        }, {
          key: "_appendCharRaw",
          value: function _appendCharRaw(ch) {
            if (!ch)
              return new ChangeDetails();
            this._value += ch;
            return new ChangeDetails({
              inserted: ch,
              rawInserted: ch
            });
          }
        }, {
          key: "_appendChar",
          value: function _appendChar(ch) {
            var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var checkTail = arguments.length > 2 ? arguments[2] : void 0;
            var consistentState = this.state;
            var details;
            var _normalizePrepare = normalizePrepare(this.doPrepare(ch, flags));
            var _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2);
            ch = _normalizePrepare2[0];
            details = _normalizePrepare2[1];
            details = details.aggregate(this._appendCharRaw(ch, flags));
            if (details.inserted) {
              var consistentTail;
              var appended = this.doValidate(flags) !== false;
              if (appended && checkTail != null) {
                var beforeTailState = this.state;
                if (this.overwrite === true) {
                  consistentTail = checkTail.state;
                  checkTail.unshift(this.value.length);
                }
                var tailDetails = this.appendTail(checkTail);
                appended = tailDetails.rawInserted === checkTail.toString();
                if (!(appended && tailDetails.inserted) && this.overwrite === "shift") {
                  this.state = beforeTailState;
                  consistentTail = checkTail.state;
                  checkTail.shift();
                  tailDetails = this.appendTail(checkTail);
                  appended = tailDetails.rawInserted === checkTail.toString();
                }
                if (appended && tailDetails.inserted)
                  this.state = beforeTailState;
              }
              if (!appended) {
                details = new ChangeDetails();
                this.state = consistentState;
                if (checkTail && consistentTail)
                  checkTail.state = consistentTail;
              }
            }
            return details;
          }
        }, {
          key: "_appendPlaceholder",
          value: function _appendPlaceholder() {
            return new ChangeDetails();
          }
        }, {
          key: "_appendEager",
          value: function _appendEager() {
            return new ChangeDetails();
          }
        }, {
          key: "append",
          value: function append(str, flags, tail) {
            if (!isString(str))
              throw new Error("value should be string");
            var details = new ChangeDetails();
            var checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;
            if (flags && flags.tail)
              flags._beforeTailState = this.state;
            for (var ci = 0; ci < str.length; ++ci) {
              details.aggregate(this._appendChar(str[ci], flags, checkTail));
            }
            if (checkTail != null) {
              details.tailShift += this.appendTail(checkTail).tailShift;
            }
            if (this.eager && flags !== null && flags !== void 0 && flags.input && str) {
              details.aggregate(this._appendEager());
            }
            return details;
          }
        }, {
          key: "remove",
          value: function remove() {
            var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
            this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);
            return new ChangeDetails();
          }
        }, {
          key: "withValueRefresh",
          value: function withValueRefresh(fn) {
            if (this._refreshing || !this.isInitialized)
              return fn();
            this._refreshing = true;
            var rawInput = this.rawInputValue;
            var value = this.value;
            var ret = fn();
            this.rawInputValue = rawInput;
            if (this.value && this.value !== value && value.indexOf(this.value) === 0) {
              this.append(value.slice(this.value.length), {}, "");
            }
            delete this._refreshing;
            return ret;
          }
        }, {
          key: "runIsolated",
          value: function runIsolated(fn) {
            if (this._isolated || !this.isInitialized)
              return fn(this);
            this._isolated = true;
            var state = this.state;
            var ret = fn(this);
            this.state = state;
            delete this._isolated;
            return ret;
          }
        }, {
          key: "doPrepare",
          value: function doPrepare(str) {
            var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return this.prepare ? this.prepare(str, this, flags) : str;
          }
        }, {
          key: "doValidate",
          value: function doValidate(flags) {
            return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));
          }
        }, {
          key: "doCommit",
          value: function doCommit() {
            if (this.commit)
              this.commit(this.value, this);
          }
        }, {
          key: "doFormat",
          value: function doFormat(value) {
            return this.format ? this.format(value, this) : value;
          }
        }, {
          key: "doParse",
          value: function doParse(str) {
            return this.parse ? this.parse(str, this) : str;
          }
        }, {
          key: "splice",
          value: function splice(start, deleteCount, inserted, removeDirection) {
            var tailPos = start + deleteCount;
            var tail = this.extractTail(tailPos);
            var oldRawValue;
            if (this.eager) {
              removeDirection = forceDirection(removeDirection);
              oldRawValue = this.extractInput(0, tailPos, {
                raw: true
              });
            }
            var startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !this.eager ? DIRECTION.NONE : removeDirection);
            var details = new ChangeDetails({
              tailShift: startChangePos - start
            }).aggregate(this.remove(startChangePos));
            if (this.eager && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {
              if (removeDirection === DIRECTION.FORCE_LEFT) {
                var valLength;
                while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {
                  details.aggregate(new ChangeDetails({
                    tailShift: -1
                  })).aggregate(this.remove(valLength - 1));
                }
              } else if (removeDirection === DIRECTION.FORCE_RIGHT) {
                tail.unshift();
              }
            }
            return details.aggregate(this.append(inserted, {
              input: true
            }, tail));
          }
        }, {
          key: "maskEquals",
          value: function maskEquals(mask) {
            return this.mask === mask;
          }
        }]);
        return Masked2;
      }();
      Masked.DEFAULTS = {
        format: function format(v) {
          return v;
        },
        parse: function parse(v) {
          return v;
        }
      };
      IMask.Masked = Masked;
    }
  });

  // node_modules/imask/esm/masked/factory.js
  function maskedClass(mask) {
    if (mask == null) {
      throw new Error("mask property should be defined");
    }
    if (mask instanceof RegExp)
      return IMask.MaskedRegExp;
    if (isString(mask))
      return IMask.MaskedPattern;
    if (mask instanceof Date || mask === Date)
      return IMask.MaskedDate;
    if (mask instanceof Number || typeof mask === "number" || mask === Number)
      return IMask.MaskedNumber;
    if (Array.isArray(mask) || mask === Array)
      return IMask.MaskedDynamic;
    if (IMask.Masked && mask.prototype instanceof IMask.Masked)
      return mask;
    if (mask instanceof IMask.Masked)
      return mask.constructor;
    if (mask instanceof Function)
      return IMask.MaskedFunction;
    console.warn("Mask not found for mask", mask);
    return IMask.Masked;
  }
  function createMask(opts) {
    if (IMask.Masked && opts instanceof IMask.Masked)
      return opts;
    opts = Object.assign({}, opts);
    var mask = opts.mask;
    if (IMask.Masked && mask instanceof IMask.Masked)
      return mask;
    var MaskedClass = maskedClass(mask);
    if (!MaskedClass)
      throw new Error("Masked class is not found for provided mask, appropriate module needs to be import manually before creating mask.");
    return new MaskedClass(opts);
  }
  var init_factory = __esm({
    "node_modules/imask/esm/masked/factory.js"() {
      init_utils();
      init_holder();
      init_rollupPluginBabelHelpers_b054ecd2();
      init_change_details();
      IMask.createMask = createMask;
    }
  });

  // node_modules/imask/esm/masked/pattern/input-definition.js
  var _excluded, DEFAULT_INPUT_DEFINITIONS, PatternInputDefinition;
  var init_input_definition = __esm({
    "node_modules/imask/esm/masked/pattern/input-definition.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_factory();
      init_change_details();
      init_utils();
      init_holder();
      _excluded = ["mask"];
      DEFAULT_INPUT_DEFINITIONS = {
        "0": /\d/,
        "a": /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        "*": /./
      };
      PatternInputDefinition = /* @__PURE__ */ function() {
        function PatternInputDefinition2(opts) {
          _classCallCheck(this, PatternInputDefinition2);
          var mask = opts.mask, blockOpts = _objectWithoutProperties(opts, _excluded);
          this.masked = createMask({
            mask
          });
          Object.assign(this, blockOpts);
        }
        _createClass(PatternInputDefinition2, [{
          key: "reset",
          value: function reset() {
            this.isFilled = false;
            this.masked.reset();
          }
        }, {
          key: "remove",
          value: function remove() {
            var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
            if (fromPos === 0 && toPos >= 1) {
              this.isFilled = false;
              return this.masked.remove(fromPos, toPos);
            }
            return new ChangeDetails();
          }
        }, {
          key: "value",
          get: function get2() {
            return this.masked.value || (this.isFilled && !this.isOptional ? this.placeholderChar : "");
          }
        }, {
          key: "unmaskedValue",
          get: function get2() {
            return this.masked.unmaskedValue;
          }
        }, {
          key: "isComplete",
          get: function get2() {
            return Boolean(this.masked.value) || this.isOptional;
          }
        }, {
          key: "_appendChar",
          value: function _appendChar(ch) {
            var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (this.isFilled)
              return new ChangeDetails();
            var state = this.masked.state;
            var details = this.masked._appendChar(ch, flags);
            if (details.inserted && this.doValidate(flags) === false) {
              details.inserted = details.rawInserted = "";
              this.masked.state = state;
            }
            if (!details.inserted && !this.isOptional && !this.lazy && !flags.input) {
              details.inserted = this.placeholderChar;
            }
            details.skip = !details.inserted && !this.isOptional;
            this.isFilled = Boolean(details.inserted);
            return details;
          }
        }, {
          key: "append",
          value: function append() {
            var _this$masked;
            return (_this$masked = this.masked).append.apply(_this$masked, arguments);
          }
        }, {
          key: "_appendPlaceholder",
          value: function _appendPlaceholder() {
            var details = new ChangeDetails();
            if (this.isFilled || this.isOptional)
              return details;
            this.isFilled = true;
            details.inserted = this.placeholderChar;
            return details;
          }
        }, {
          key: "_appendEager",
          value: function _appendEager() {
            return new ChangeDetails();
          }
        }, {
          key: "extractTail",
          value: function extractTail() {
            var _this$masked2;
            return (_this$masked2 = this.masked).extractTail.apply(_this$masked2, arguments);
          }
        }, {
          key: "appendTail",
          value: function appendTail() {
            var _this$masked3;
            return (_this$masked3 = this.masked).appendTail.apply(_this$masked3, arguments);
          }
        }, {
          key: "extractInput",
          value: function extractInput() {
            var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
            var flags = arguments.length > 2 ? arguments[2] : void 0;
            return this.masked.extractInput(fromPos, toPos, flags);
          }
        }, {
          key: "nearestInputPos",
          value: function nearestInputPos(cursorPos) {
            var direction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DIRECTION.NONE;
            var minPos = 0;
            var maxPos = this.value.length;
            var boundPos = Math.min(Math.max(cursorPos, minPos), maxPos);
            switch (direction) {
              case DIRECTION.LEFT:
              case DIRECTION.FORCE_LEFT:
                return this.isComplete ? boundPos : minPos;
              case DIRECTION.RIGHT:
              case DIRECTION.FORCE_RIGHT:
                return this.isComplete ? boundPos : maxPos;
              case DIRECTION.NONE:
              default:
                return boundPos;
            }
          }
        }, {
          key: "doValidate",
          value: function doValidate() {
            var _this$masked4, _this$parent;
            return (_this$masked4 = this.masked).doValidate.apply(_this$masked4, arguments) && (!this.parent || (_this$parent = this.parent).doValidate.apply(_this$parent, arguments));
          }
        }, {
          key: "doCommit",
          value: function doCommit() {
            this.masked.doCommit();
          }
        }, {
          key: "state",
          get: function get2() {
            return {
              masked: this.masked.state,
              isFilled: this.isFilled
            };
          },
          set: function set3(state) {
            this.masked.state = state.masked;
            this.isFilled = state.isFilled;
          }
        }]);
        return PatternInputDefinition2;
      }();
    }
  });

  // node_modules/imask/esm/masked/pattern/fixed-definition.js
  var PatternFixedDefinition;
  var init_fixed_definition = __esm({
    "node_modules/imask/esm/masked/pattern/fixed-definition.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_change_details();
      init_utils();
      init_continuous_tail_details();
      PatternFixedDefinition = /* @__PURE__ */ function() {
        function PatternFixedDefinition2(opts) {
          _classCallCheck(this, PatternFixedDefinition2);
          Object.assign(this, opts);
          this._value = "";
          this.isFixed = true;
        }
        _createClass(PatternFixedDefinition2, [{
          key: "value",
          get: function get2() {
            return this._value;
          }
        }, {
          key: "unmaskedValue",
          get: function get2() {
            return this.isUnmasking ? this.value : "";
          }
        }, {
          key: "reset",
          value: function reset() {
            this._isRawInput = false;
            this._value = "";
          }
        }, {
          key: "remove",
          value: function remove() {
            var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._value.length;
            this._value = this._value.slice(0, fromPos) + this._value.slice(toPos);
            if (!this._value)
              this._isRawInput = false;
            return new ChangeDetails();
          }
        }, {
          key: "nearestInputPos",
          value: function nearestInputPos(cursorPos) {
            var direction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DIRECTION.NONE;
            var minPos = 0;
            var maxPos = this._value.length;
            switch (direction) {
              case DIRECTION.LEFT:
              case DIRECTION.FORCE_LEFT:
                return minPos;
              case DIRECTION.NONE:
              case DIRECTION.RIGHT:
              case DIRECTION.FORCE_RIGHT:
              default:
                return maxPos;
            }
          }
        }, {
          key: "extractInput",
          value: function extractInput() {
            var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._value.length;
            var flags = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return flags.raw && this._isRawInput && this._value.slice(fromPos, toPos) || "";
          }
        }, {
          key: "isComplete",
          get: function get2() {
            return true;
          }
        }, {
          key: "isFilled",
          get: function get2() {
            return Boolean(this._value);
          }
        }, {
          key: "_appendChar",
          value: function _appendChar(ch) {
            var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var details = new ChangeDetails();
            if (this._value)
              return details;
            var appended = this.char === ch;
            var isResolved = appended && (this.isUnmasking || flags.input || flags.raw) && !this.eager && !flags.tail;
            if (isResolved)
              details.rawInserted = this.char;
            this._value = details.inserted = this.char;
            this._isRawInput = isResolved && (flags.raw || flags.input);
            return details;
          }
        }, {
          key: "_appendEager",
          value: function _appendEager() {
            return this._appendChar(this.char);
          }
        }, {
          key: "_appendPlaceholder",
          value: function _appendPlaceholder() {
            var details = new ChangeDetails();
            if (this._value)
              return details;
            this._value = details.inserted = this.char;
            return details;
          }
        }, {
          key: "extractTail",
          value: function extractTail() {
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
            return new ContinuousTailDetails("");
          }
        }, {
          key: "appendTail",
          value: function appendTail(tail) {
            if (isString(tail))
              tail = new ContinuousTailDetails(String(tail));
            return tail.appendTo(this);
          }
        }, {
          key: "append",
          value: function append(str, flags, tail) {
            var details = this._appendChar(str[0], flags);
            if (tail != null) {
              details.tailShift += this.appendTail(tail).tailShift;
            }
            return details;
          }
        }, {
          key: "doCommit",
          value: function doCommit() {
          }
        }, {
          key: "state",
          get: function get2() {
            return {
              _value: this._value,
              _isRawInput: this._isRawInput
            };
          },
          set: function set3(state) {
            Object.assign(this, state);
          }
        }]);
        return PatternFixedDefinition2;
      }();
    }
  });

  // node_modules/imask/esm/masked/pattern/chunk-tail-details.js
  var _excluded2, ChunksTailDetails;
  var init_chunk_tail_details = __esm({
    "node_modules/imask/esm/masked/pattern/chunk-tail-details.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_change_details();
      init_utils();
      init_continuous_tail_details();
      init_holder();
      _excluded2 = ["chunks"];
      ChunksTailDetails = /* @__PURE__ */ function() {
        function ChunksTailDetails2() {
          var chunks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          var from = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          _classCallCheck(this, ChunksTailDetails2);
          this.chunks = chunks;
          this.from = from;
        }
        _createClass(ChunksTailDetails2, [{
          key: "toString",
          value: function toString2() {
            return this.chunks.map(String).join("");
          }
        }, {
          key: "extend",
          value: function extend(tailChunk) {
            if (!String(tailChunk))
              return;
            if (isString(tailChunk))
              tailChunk = new ContinuousTailDetails(String(tailChunk));
            var lastChunk = this.chunks[this.chunks.length - 1];
            var extendLast = lastChunk && (lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && tailChunk.from === lastChunk.from + lastChunk.toString().length;
            if (tailChunk instanceof ContinuousTailDetails) {
              if (extendLast) {
                lastChunk.extend(tailChunk.toString());
              } else {
                this.chunks.push(tailChunk);
              }
            } else if (tailChunk instanceof ChunksTailDetails2) {
              if (tailChunk.stop == null) {
                var firstTailChunk;
                while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {
                  firstTailChunk = tailChunk.chunks.shift();
                  firstTailChunk.from += tailChunk.from;
                  this.extend(firstTailChunk);
                }
              }
              if (tailChunk.toString()) {
                tailChunk.stop = tailChunk.blockIndex;
                this.chunks.push(tailChunk);
              }
            }
          }
        }, {
          key: "appendTo",
          value: function appendTo(masked) {
            if (!(masked instanceof IMask.MaskedPattern)) {
              var tail = new ContinuousTailDetails(this.toString());
              return tail.appendTo(masked);
            }
            var details = new ChangeDetails();
            for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {
              var chunk = this.chunks[ci];
              var lastBlockIter = masked._mapPosToBlock(masked.value.length);
              var stop = chunk.stop;
              var chunkBlock = void 0;
              if (stop != null && (!lastBlockIter || lastBlockIter.index <= stop)) {
                if (chunk instanceof ChunksTailDetails2 || masked._stops.indexOf(stop) >= 0) {
                  details.aggregate(masked._appendPlaceholder(stop));
                }
                chunkBlock = chunk instanceof ChunksTailDetails2 && masked._blocks[stop];
              }
              if (chunkBlock) {
                var tailDetails = chunkBlock.appendTail(chunk);
                tailDetails.skip = false;
                details.aggregate(tailDetails);
                masked._value += tailDetails.inserted;
                var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);
                if (remainChars)
                  details.aggregate(masked.append(remainChars, {
                    tail: true
                  }));
              } else {
                details.aggregate(masked.append(chunk.toString(), {
                  tail: true
                }));
              }
            }
            return details;
          }
        }, {
          key: "state",
          get: function get2() {
            return {
              chunks: this.chunks.map(function(c) {
                return c.state;
              }),
              from: this.from,
              stop: this.stop,
              blockIndex: this.blockIndex
            };
          },
          set: function set3(state) {
            var chunks = state.chunks, props2 = _objectWithoutProperties(state, _excluded2);
            Object.assign(this, props2);
            this.chunks = chunks.map(function(cstate) {
              var chunk = "chunks" in cstate ? new ChunksTailDetails2() : new ContinuousTailDetails();
              chunk.state = cstate;
              return chunk;
            });
          }
        }, {
          key: "unshift",
          value: function unshift(beforePos) {
            if (!this.chunks.length || beforePos != null && this.from >= beforePos)
              return "";
            var chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;
            var ci = 0;
            while (ci < this.chunks.length) {
              var chunk = this.chunks[ci];
              var shiftChar = chunk.unshift(chunkShiftPos);
              if (chunk.toString()) {
                if (!shiftChar)
                  break;
                ++ci;
              } else {
                this.chunks.splice(ci, 1);
              }
              if (shiftChar)
                return shiftChar;
            }
            return "";
          }
        }, {
          key: "shift",
          value: function shift() {
            if (!this.chunks.length)
              return "";
            var ci = this.chunks.length - 1;
            while (0 <= ci) {
              var chunk = this.chunks[ci];
              var shiftChar = chunk.shift();
              if (chunk.toString()) {
                if (!shiftChar)
                  break;
                --ci;
              } else {
                this.chunks.splice(ci, 1);
              }
              if (shiftChar)
                return shiftChar;
            }
            return "";
          }
        }]);
        return ChunksTailDetails2;
      }();
    }
  });

  // node_modules/imask/esm/masked/pattern/cursor.js
  var PatternCursor;
  var init_cursor = __esm({
    "node_modules/imask/esm/masked/pattern/cursor.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_utils();
      init_change_details();
      PatternCursor = /* @__PURE__ */ function() {
        function PatternCursor2(masked, pos) {
          _classCallCheck(this, PatternCursor2);
          this.masked = masked;
          this._log = [];
          var _ref = masked._mapPosToBlock(pos) || (pos < 0 ? {
            index: 0,
            offset: 0
          } : {
            index: this.masked._blocks.length,
            offset: 0
          }), offset = _ref.offset, index = _ref.index;
          this.offset = offset;
          this.index = index;
          this.ok = false;
        }
        _createClass(PatternCursor2, [{
          key: "block",
          get: function get2() {
            return this.masked._blocks[this.index];
          }
        }, {
          key: "pos",
          get: function get2() {
            return this.masked._blockStartPos(this.index) + this.offset;
          }
        }, {
          key: "state",
          get: function get2() {
            return {
              index: this.index,
              offset: this.offset,
              ok: this.ok
            };
          },
          set: function set3(s) {
            Object.assign(this, s);
          }
        }, {
          key: "pushState",
          value: function pushState() {
            this._log.push(this.state);
          }
        }, {
          key: "popState",
          value: function popState() {
            var s = this._log.pop();
            this.state = s;
            return s;
          }
        }, {
          key: "bindBlock",
          value: function bindBlock() {
            if (this.block)
              return;
            if (this.index < 0) {
              this.index = 0;
              this.offset = 0;
            }
            if (this.index >= this.masked._blocks.length) {
              this.index = this.masked._blocks.length - 1;
              this.offset = this.block.value.length;
            }
          }
        }, {
          key: "_pushLeft",
          value: function _pushLeft(fn) {
            this.pushState();
            for (this.bindBlock(); 0 <= this.index; --this.index, this.offset = ((_this$block = this.block) === null || _this$block === void 0 ? void 0 : _this$block.value.length) || 0) {
              var _this$block;
              if (fn())
                return this.ok = true;
            }
            return this.ok = false;
          }
        }, {
          key: "_pushRight",
          value: function _pushRight(fn) {
            this.pushState();
            for (this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0) {
              if (fn())
                return this.ok = true;
            }
            return this.ok = false;
          }
        }, {
          key: "pushLeftBeforeFilled",
          value: function pushLeftBeforeFilled() {
            var _this = this;
            return this._pushLeft(function() {
              if (_this.block.isFixed || !_this.block.value)
                return;
              _this.offset = _this.block.nearestInputPos(_this.offset, DIRECTION.FORCE_LEFT);
              if (_this.offset !== 0)
                return true;
            });
          }
        }, {
          key: "pushLeftBeforeInput",
          value: function pushLeftBeforeInput() {
            var _this2 = this;
            return this._pushLeft(function() {
              if (_this2.block.isFixed)
                return;
              _this2.offset = _this2.block.nearestInputPos(_this2.offset, DIRECTION.LEFT);
              return true;
            });
          }
        }, {
          key: "pushLeftBeforeRequired",
          value: function pushLeftBeforeRequired() {
            var _this3 = this;
            return this._pushLeft(function() {
              if (_this3.block.isFixed || _this3.block.isOptional && !_this3.block.value)
                return;
              _this3.offset = _this3.block.nearestInputPos(_this3.offset, DIRECTION.LEFT);
              return true;
            });
          }
        }, {
          key: "pushRightBeforeFilled",
          value: function pushRightBeforeFilled() {
            var _this4 = this;
            return this._pushRight(function() {
              if (_this4.block.isFixed || !_this4.block.value)
                return;
              _this4.offset = _this4.block.nearestInputPos(_this4.offset, DIRECTION.FORCE_RIGHT);
              if (_this4.offset !== _this4.block.value.length)
                return true;
            });
          }
        }, {
          key: "pushRightBeforeInput",
          value: function pushRightBeforeInput() {
            var _this5 = this;
            return this._pushRight(function() {
              if (_this5.block.isFixed)
                return;
              _this5.offset = _this5.block.nearestInputPos(_this5.offset, DIRECTION.NONE);
              return true;
            });
          }
        }, {
          key: "pushRightBeforeRequired",
          value: function pushRightBeforeRequired() {
            var _this6 = this;
            return this._pushRight(function() {
              if (_this6.block.isFixed || _this6.block.isOptional && !_this6.block.value)
                return;
              _this6.offset = _this6.block.nearestInputPos(_this6.offset, DIRECTION.NONE);
              return true;
            });
          }
        }]);
        return PatternCursor2;
      }();
    }
  });

  // node_modules/imask/esm/masked/regexp.js
  var MaskedRegExp;
  var init_regexp = __esm({
    "node_modules/imask/esm/masked/regexp.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_base();
      init_holder();
      init_change_details();
      init_continuous_tail_details();
      init_utils();
      MaskedRegExp = /* @__PURE__ */ function(_Masked) {
        _inherits(MaskedRegExp2, _Masked);
        var _super = _createSuper(MaskedRegExp2);
        function MaskedRegExp2() {
          _classCallCheck(this, MaskedRegExp2);
          return _super.apply(this, arguments);
        }
        _createClass(MaskedRegExp2, [{
          key: "_update",
          value: function _update(opts) {
            if (opts.mask)
              opts.validate = function(value) {
                return value.search(opts.mask) >= 0;
              };
            _get(_getPrototypeOf(MaskedRegExp2.prototype), "_update", this).call(this, opts);
          }
        }]);
        return MaskedRegExp2;
      }(Masked);
      IMask.MaskedRegExp = MaskedRegExp;
    }
  });

  // node_modules/imask/esm/masked/pattern.js
  var _excluded3, MaskedPattern;
  var init_pattern = __esm({
    "node_modules/imask/esm/masked/pattern.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_utils();
      init_change_details();
      init_base();
      init_input_definition();
      init_fixed_definition();
      init_chunk_tail_details();
      init_cursor();
      init_factory();
      init_holder();
      init_regexp();
      init_continuous_tail_details();
      _excluded3 = ["_blocks"];
      MaskedPattern = /* @__PURE__ */ function(_Masked) {
        _inherits(MaskedPattern2, _Masked);
        var _super = _createSuper(MaskedPattern2);
        function MaskedPattern2() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          _classCallCheck(this, MaskedPattern2);
          opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);
          return _super.call(this, Object.assign({}, MaskedPattern2.DEFAULTS, opts));
        }
        _createClass(MaskedPattern2, [{
          key: "_update",
          value: function _update() {
            var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            opts.definitions = Object.assign({}, this.definitions, opts.definitions);
            _get(_getPrototypeOf(MaskedPattern2.prototype), "_update", this).call(this, opts);
            this._rebuildMask();
          }
        }, {
          key: "_rebuildMask",
          value: function _rebuildMask() {
            var _this = this;
            var defs = this.definitions;
            this._blocks = [];
            this._stops = [];
            this._maskedBlocks = {};
            var pattern = this.mask;
            if (!pattern || !defs)
              return;
            var unmaskingBlock = false;
            var optionalBlock = false;
            for (var i = 0; i < pattern.length; ++i) {
              if (this.blocks) {
                var _ret = function() {
                  var p = pattern.slice(i);
                  var bNames = Object.keys(_this.blocks).filter(function(bName2) {
                    return p.indexOf(bName2) === 0;
                  });
                  bNames.sort(function(a, b) {
                    return b.length - a.length;
                  });
                  var bName = bNames[0];
                  if (bName) {
                    var maskedBlock = createMask(Object.assign({
                      parent: _this,
                      lazy: _this.lazy,
                      eager: _this.eager,
                      placeholderChar: _this.placeholderChar,
                      overwrite: _this.overwrite
                    }, _this.blocks[bName]));
                    if (maskedBlock) {
                      _this._blocks.push(maskedBlock);
                      if (!_this._maskedBlocks[bName])
                        _this._maskedBlocks[bName] = [];
                      _this._maskedBlocks[bName].push(_this._blocks.length - 1);
                    }
                    i += bName.length - 1;
                    return "continue";
                  }
                }();
                if (_ret === "continue")
                  continue;
              }
              var char = pattern[i];
              var isInput = char in defs;
              if (char === MaskedPattern2.STOP_CHAR) {
                this._stops.push(this._blocks.length);
                continue;
              }
              if (char === "{" || char === "}") {
                unmaskingBlock = !unmaskingBlock;
                continue;
              }
              if (char === "[" || char === "]") {
                optionalBlock = !optionalBlock;
                continue;
              }
              if (char === MaskedPattern2.ESCAPE_CHAR) {
                ++i;
                char = pattern[i];
                if (!char)
                  break;
                isInput = false;
              }
              var def2 = isInput ? new PatternInputDefinition({
                parent: this,
                lazy: this.lazy,
                eager: this.eager,
                placeholderChar: this.placeholderChar,
                mask: defs[char],
                isOptional: optionalBlock
              }) : new PatternFixedDefinition({
                char,
                eager: this.eager,
                isUnmasking: unmaskingBlock
              });
              this._blocks.push(def2);
            }
          }
        }, {
          key: "state",
          get: function get2() {
            return Object.assign({}, _get(_getPrototypeOf(MaskedPattern2.prototype), "state", this), {
              _blocks: this._blocks.map(function(b) {
                return b.state;
              })
            });
          },
          set: function set3(state) {
            var _blocks = state._blocks, maskedState = _objectWithoutProperties(state, _excluded3);
            this._blocks.forEach(function(b, bi) {
              return b.state = _blocks[bi];
            });
            _set(_getPrototypeOf(MaskedPattern2.prototype), "state", maskedState, this, true);
          }
        }, {
          key: "reset",
          value: function reset() {
            _get(_getPrototypeOf(MaskedPattern2.prototype), "reset", this).call(this);
            this._blocks.forEach(function(b) {
              return b.reset();
            });
          }
        }, {
          key: "isComplete",
          get: function get2() {
            return this._blocks.every(function(b) {
              return b.isComplete;
            });
          }
        }, {
          key: "isFilled",
          get: function get2() {
            return this._blocks.every(function(b) {
              return b.isFilled;
            });
          }
        }, {
          key: "isFixed",
          get: function get2() {
            return this._blocks.every(function(b) {
              return b.isFixed;
            });
          }
        }, {
          key: "isOptional",
          get: function get2() {
            return this._blocks.every(function(b) {
              return b.isOptional;
            });
          }
        }, {
          key: "doCommit",
          value: function doCommit() {
            this._blocks.forEach(function(b) {
              return b.doCommit();
            });
            _get(_getPrototypeOf(MaskedPattern2.prototype), "doCommit", this).call(this);
          }
        }, {
          key: "unmaskedValue",
          get: function get2() {
            return this._blocks.reduce(function(str, b) {
              return str += b.unmaskedValue;
            }, "");
          },
          set: function set3(unmaskedValue) {
            _set(_getPrototypeOf(MaskedPattern2.prototype), "unmaskedValue", unmaskedValue, this, true);
          }
        }, {
          key: "value",
          get: function get2() {
            return this._blocks.reduce(function(str, b) {
              return str += b.value;
            }, "");
          },
          set: function set3(value) {
            _set(_getPrototypeOf(MaskedPattern2.prototype), "value", value, this, true);
          }
        }, {
          key: "appendTail",
          value: function appendTail(tail) {
            return _get(_getPrototypeOf(MaskedPattern2.prototype), "appendTail", this).call(this, tail).aggregate(this._appendPlaceholder());
          }
        }, {
          key: "_appendEager",
          value: function _appendEager() {
            var _this$_mapPosToBlock;
            var details = new ChangeDetails();
            var startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;
            if (startBlockIndex == null)
              return details;
            if (this._blocks[startBlockIndex].isFilled)
              ++startBlockIndex;
            for (var bi = startBlockIndex; bi < this._blocks.length; ++bi) {
              var d = this._blocks[bi]._appendEager();
              if (!d.inserted)
                break;
              details.aggregate(d);
            }
            return details;
          }
        }, {
          key: "_appendCharRaw",
          value: function _appendCharRaw(ch) {
            var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var blockIter = this._mapPosToBlock(this.value.length);
            var details = new ChangeDetails();
            if (!blockIter)
              return details;
            for (var bi = blockIter.index; ; ++bi) {
              var _flags$_beforeTailSta;
              var _block = this._blocks[bi];
              if (!_block)
                break;
              var blockDetails = _block._appendChar(ch, Object.assign({}, flags, {
                _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta._blocks[bi]
              }));
              var skip = blockDetails.skip;
              details.aggregate(blockDetails);
              if (skip || blockDetails.rawInserted)
                break;
            }
            return details;
          }
        }, {
          key: "extractTail",
          value: function extractTail() {
            var _this2 = this;
            var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
            var chunkTail = new ChunksTailDetails();
            if (fromPos === toPos)
              return chunkTail;
            this._forEachBlocksInRange(fromPos, toPos, function(b, bi, bFromPos, bToPos) {
              var blockChunk = b.extractTail(bFromPos, bToPos);
              blockChunk.stop = _this2._findStopBefore(bi);
              blockChunk.from = _this2._blockStartPos(bi);
              if (blockChunk instanceof ChunksTailDetails)
                blockChunk.blockIndex = bi;
              chunkTail.extend(blockChunk);
            });
            return chunkTail;
          }
        }, {
          key: "extractInput",
          value: function extractInput() {
            var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
            var flags = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (fromPos === toPos)
              return "";
            var input = "";
            this._forEachBlocksInRange(fromPos, toPos, function(b, _, fromPos2, toPos2) {
              input += b.extractInput(fromPos2, toPos2, flags);
            });
            return input;
          }
        }, {
          key: "_findStopBefore",
          value: function _findStopBefore(blockIndex) {
            var stopBefore;
            for (var si = 0; si < this._stops.length; ++si) {
              var stop = this._stops[si];
              if (stop <= blockIndex)
                stopBefore = stop;
              else
                break;
            }
            return stopBefore;
          }
        }, {
          key: "_appendPlaceholder",
          value: function _appendPlaceholder(toBlockIndex) {
            var _this3 = this;
            var details = new ChangeDetails();
            if (this.lazy && toBlockIndex == null)
              return details;
            var startBlockIter = this._mapPosToBlock(this.value.length);
            if (!startBlockIter)
              return details;
            var startBlockIndex = startBlockIter.index;
            var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;
            this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function(b) {
              if (!b.lazy || toBlockIndex != null) {
                var args = b._blocks != null ? [b._blocks.length] : [];
                var bDetails = b._appendPlaceholder.apply(b, args);
                _this3._value += bDetails.inserted;
                details.aggregate(bDetails);
              }
            });
            return details;
          }
        }, {
          key: "_mapPosToBlock",
          value: function _mapPosToBlock(pos) {
            var accVal = "";
            for (var bi = 0; bi < this._blocks.length; ++bi) {
              var _block2 = this._blocks[bi];
              var blockStartPos = accVal.length;
              accVal += _block2.value;
              if (pos <= accVal.length) {
                return {
                  index: bi,
                  offset: pos - blockStartPos
                };
              }
            }
          }
        }, {
          key: "_blockStartPos",
          value: function _blockStartPos(blockIndex) {
            return this._blocks.slice(0, blockIndex).reduce(function(pos, b) {
              return pos += b.value.length;
            }, 0);
          }
        }, {
          key: "_forEachBlocksInRange",
          value: function _forEachBlocksInRange(fromPos) {
            var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
            var fn = arguments.length > 2 ? arguments[2] : void 0;
            var fromBlockIter = this._mapPosToBlock(fromPos);
            if (fromBlockIter) {
              var toBlockIter = this._mapPosToBlock(toPos);
              var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;
              var fromBlockStartPos = fromBlockIter.offset;
              var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;
              fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);
              if (toBlockIter && !isSameBlock) {
                for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {
                  fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);
                }
                fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);
              }
            }
          }
        }, {
          key: "remove",
          value: function remove() {
            var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
            var removeDetails = _get(_getPrototypeOf(MaskedPattern2.prototype), "remove", this).call(this, fromPos, toPos);
            this._forEachBlocksInRange(fromPos, toPos, function(b, _, bFromPos, bToPos) {
              removeDetails.aggregate(b.remove(bFromPos, bToPos));
            });
            return removeDetails;
          }
        }, {
          key: "nearestInputPos",
          value: function nearestInputPos(cursorPos) {
            var direction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DIRECTION.NONE;
            if (!this._blocks.length)
              return 0;
            var cursor = new PatternCursor(this, cursorPos);
            if (direction === DIRECTION.NONE) {
              if (cursor.pushRightBeforeInput())
                return cursor.pos;
              cursor.popState();
              if (cursor.pushLeftBeforeInput())
                return cursor.pos;
              return this.value.length;
            }
            if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {
              if (direction === DIRECTION.LEFT) {
                cursor.pushRightBeforeFilled();
                if (cursor.ok && cursor.pos === cursorPos)
                  return cursorPos;
                cursor.popState();
              }
              cursor.pushLeftBeforeInput();
              cursor.pushLeftBeforeRequired();
              cursor.pushLeftBeforeFilled();
              if (direction === DIRECTION.LEFT) {
                cursor.pushRightBeforeInput();
                cursor.pushRightBeforeRequired();
                if (cursor.ok && cursor.pos <= cursorPos)
                  return cursor.pos;
                cursor.popState();
                if (cursor.ok && cursor.pos <= cursorPos)
                  return cursor.pos;
                cursor.popState();
              }
              if (cursor.ok)
                return cursor.pos;
              if (direction === DIRECTION.FORCE_LEFT)
                return 0;
              cursor.popState();
              if (cursor.ok)
                return cursor.pos;
              cursor.popState();
              if (cursor.ok)
                return cursor.pos;
              return 0;
            }
            if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {
              cursor.pushRightBeforeInput();
              cursor.pushRightBeforeRequired();
              if (cursor.pushRightBeforeFilled())
                return cursor.pos;
              if (direction === DIRECTION.FORCE_RIGHT)
                return this.value.length;
              cursor.popState();
              if (cursor.ok)
                return cursor.pos;
              cursor.popState();
              if (cursor.ok)
                return cursor.pos;
              return this.nearestInputPos(cursorPos, DIRECTION.LEFT);
            }
            return cursorPos;
          }
        }, {
          key: "maskedBlock",
          value: function maskedBlock(name) {
            return this.maskedBlocks(name)[0];
          }
        }, {
          key: "maskedBlocks",
          value: function maskedBlocks(name) {
            var _this4 = this;
            var indices = this._maskedBlocks[name];
            if (!indices)
              return [];
            return indices.map(function(gi) {
              return _this4._blocks[gi];
            });
          }
        }]);
        return MaskedPattern2;
      }(Masked);
      MaskedPattern.DEFAULTS = {
        lazy: true,
        placeholderChar: "_"
      };
      MaskedPattern.STOP_CHAR = "`";
      MaskedPattern.ESCAPE_CHAR = "\\";
      MaskedPattern.InputDefinition = PatternInputDefinition;
      MaskedPattern.FixedDefinition = PatternFixedDefinition;
      IMask.MaskedPattern = MaskedPattern;
    }
  });

  // node_modules/imask/esm/masked/range.js
  var MaskedRange;
  var init_range = __esm({
    "node_modules/imask/esm/masked/range.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_pattern();
      init_utils();
      init_holder();
      init_change_details();
      init_base();
      init_continuous_tail_details();
      init_input_definition();
      init_factory();
      init_fixed_definition();
      init_chunk_tail_details();
      init_cursor();
      init_regexp();
      MaskedRange = /* @__PURE__ */ function(_MaskedPattern) {
        _inherits(MaskedRange2, _MaskedPattern);
        var _super = _createSuper(MaskedRange2);
        function MaskedRange2() {
          _classCallCheck(this, MaskedRange2);
          return _super.apply(this, arguments);
        }
        _createClass(MaskedRange2, [{
          key: "_matchFrom",
          get: function get2() {
            return this.maxLength - String(this.from).length;
          }
        }, {
          key: "_update",
          value: function _update(opts) {
            opts = Object.assign({
              to: this.to || 0,
              from: this.from || 0,
              maxLength: this.maxLength || 0
            }, opts);
            var maxLength = String(opts.to).length;
            if (opts.maxLength != null)
              maxLength = Math.max(maxLength, opts.maxLength);
            opts.maxLength = maxLength;
            var fromStr = String(opts.from).padStart(maxLength, "0");
            var toStr = String(opts.to).padStart(maxLength, "0");
            var sameCharsCount = 0;
            while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) {
              ++sameCharsCount;
            }
            opts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, "\\0") + "0".repeat(maxLength - sameCharsCount);
            _get(_getPrototypeOf(MaskedRange2.prototype), "_update", this).call(this, opts);
          }
        }, {
          key: "isComplete",
          get: function get2() {
            return _get(_getPrototypeOf(MaskedRange2.prototype), "isComplete", this) && Boolean(this.value);
          }
        }, {
          key: "boundaries",
          value: function boundaries(str) {
            var minstr = "";
            var maxstr = "";
            var _ref = str.match(/^(\D*)(\d*)(\D*)/) || [], _ref2 = _slicedToArray(_ref, 3), placeholder = _ref2[1], num = _ref2[2];
            if (num) {
              minstr = "0".repeat(placeholder.length) + num;
              maxstr = "9".repeat(placeholder.length) + num;
            }
            minstr = minstr.padEnd(this.maxLength, "0");
            maxstr = maxstr.padEnd(this.maxLength, "9");
            return [minstr, maxstr];
          }
        }, {
          key: "doPrepare",
          value: function doPrepare(ch) {
            var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var details;
            var _normalizePrepare = normalizePrepare(_get(_getPrototypeOf(MaskedRange2.prototype), "doPrepare", this).call(this, ch.replace(/\D/g, ""), flags));
            var _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2);
            ch = _normalizePrepare2[0];
            details = _normalizePrepare2[1];
            if (!this.autofix || !ch)
              return ch;
            var fromStr = String(this.from).padStart(this.maxLength, "0");
            var toStr = String(this.to).padStart(this.maxLength, "0");
            var nextVal = this.value + ch;
            if (nextVal.length > this.maxLength)
              return "";
            var _this$boundaries = this.boundaries(nextVal), _this$boundaries2 = _slicedToArray(_this$boundaries, 2), minstr = _this$boundaries2[0], maxstr = _this$boundaries2[1];
            if (Number(maxstr) < this.from)
              return fromStr[nextVal.length - 1];
            if (Number(minstr) > this.to) {
              if (this.autofix === "pad" && nextVal.length < this.maxLength) {
                return ["", details.aggregate(this.append(fromStr[nextVal.length - 1] + ch, flags))];
              }
              return toStr[nextVal.length - 1];
            }
            return ch;
          }
        }, {
          key: "doValidate",
          value: function doValidate() {
            var _get2;
            var str = this.value;
            var firstNonZero = str.search(/[^0]/);
            if (firstNonZero === -1 && str.length <= this._matchFrom)
              return true;
            var _this$boundaries3 = this.boundaries(str), _this$boundaries4 = _slicedToArray(_this$boundaries3, 2), minstr = _this$boundaries4[0], maxstr = _this$boundaries4[1];
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return this.from <= Number(maxstr) && Number(minstr) <= this.to && (_get2 = _get(_getPrototypeOf(MaskedRange2.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args));
          }
        }]);
        return MaskedRange2;
      }(MaskedPattern);
      IMask.MaskedRange = MaskedRange;
    }
  });

  // node_modules/imask/esm/masked/date.js
  var MaskedDate;
  var init_date = __esm({
    "node_modules/imask/esm/masked/date.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_pattern();
      init_range();
      init_holder();
      init_utils();
      init_change_details();
      init_base();
      init_continuous_tail_details();
      init_input_definition();
      init_factory();
      init_fixed_definition();
      init_chunk_tail_details();
      init_cursor();
      init_regexp();
      MaskedDate = /* @__PURE__ */ function(_MaskedPattern) {
        _inherits(MaskedDate2, _MaskedPattern);
        var _super = _createSuper(MaskedDate2);
        function MaskedDate2(opts) {
          _classCallCheck(this, MaskedDate2);
          return _super.call(this, Object.assign({}, MaskedDate2.DEFAULTS, opts));
        }
        _createClass(MaskedDate2, [{
          key: "_update",
          value: function _update(opts) {
            if (opts.mask === Date)
              delete opts.mask;
            if (opts.pattern)
              opts.mask = opts.pattern;
            var blocks = opts.blocks;
            opts.blocks = Object.assign({}, MaskedDate2.GET_DEFAULT_BLOCKS());
            if (opts.min)
              opts.blocks.Y.from = opts.min.getFullYear();
            if (opts.max)
              opts.blocks.Y.to = opts.max.getFullYear();
            if (opts.min && opts.max && opts.blocks.Y.from === opts.blocks.Y.to) {
              opts.blocks.m.from = opts.min.getMonth() + 1;
              opts.blocks.m.to = opts.max.getMonth() + 1;
              if (opts.blocks.m.from === opts.blocks.m.to) {
                opts.blocks.d.from = opts.min.getDate();
                opts.blocks.d.to = opts.max.getDate();
              }
            }
            Object.assign(opts.blocks, this.blocks, blocks);
            Object.keys(opts.blocks).forEach(function(bk) {
              var b = opts.blocks[bk];
              if (!("autofix" in b) && "autofix" in opts)
                b.autofix = opts.autofix;
            });
            _get(_getPrototypeOf(MaskedDate2.prototype), "_update", this).call(this, opts);
          }
        }, {
          key: "doValidate",
          value: function doValidate() {
            var _get2;
            var date = this.date;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return (_get2 = _get(_getPrototypeOf(MaskedDate2.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args)) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));
          }
        }, {
          key: "isDateExist",
          value: function isDateExist(str) {
            return this.format(this.parse(str, this), this).indexOf(str) >= 0;
          }
        }, {
          key: "date",
          get: function get2() {
            return this.typedValue;
          },
          set: function set3(date) {
            this.typedValue = date;
          }
        }, {
          key: "typedValue",
          get: function get2() {
            return this.isComplete ? _get(_getPrototypeOf(MaskedDate2.prototype), "typedValue", this) : null;
          },
          set: function set3(value) {
            _set(_getPrototypeOf(MaskedDate2.prototype), "typedValue", value, this, true);
          }
        }, {
          key: "maskEquals",
          value: function maskEquals(mask) {
            return mask === Date || _get(_getPrototypeOf(MaskedDate2.prototype), "maskEquals", this).call(this, mask);
          }
        }]);
        return MaskedDate2;
      }(MaskedPattern);
      MaskedDate.DEFAULTS = {
        pattern: "d{.}`m{.}`Y",
        format: function format2(date) {
          if (!date)
            return "";
          var day = String(date.getDate()).padStart(2, "0");
          var month = String(date.getMonth() + 1).padStart(2, "0");
          var year = date.getFullYear();
          return [day, month, year].join(".");
        },
        parse: function parse2(str) {
          var _str$split = str.split("."), _str$split2 = _slicedToArray(_str$split, 3), day = _str$split2[0], month = _str$split2[1], year = _str$split2[2];
          return new Date(year, month - 1, day);
        }
      };
      MaskedDate.GET_DEFAULT_BLOCKS = function() {
        return {
          d: {
            mask: MaskedRange,
            from: 1,
            to: 31,
            maxLength: 2
          },
          m: {
            mask: MaskedRange,
            from: 1,
            to: 12,
            maxLength: 2
          },
          Y: {
            mask: MaskedRange,
            from: 1900,
            to: 9999
          }
        };
      };
      IMask.MaskedDate = MaskedDate;
    }
  });

  // node_modules/imask/esm/controls/mask-element.js
  var MaskElement;
  var init_mask_element = __esm({
    "node_modules/imask/esm/controls/mask-element.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_holder();
      MaskElement = /* @__PURE__ */ function() {
        function MaskElement2() {
          _classCallCheck(this, MaskElement2);
        }
        _createClass(MaskElement2, [{
          key: "selectionStart",
          get: function get2() {
            var start;
            try {
              start = this._unsafeSelectionStart;
            } catch (e) {
            }
            return start != null ? start : this.value.length;
          }
        }, {
          key: "selectionEnd",
          get: function get2() {
            var end;
            try {
              end = this._unsafeSelectionEnd;
            } catch (e) {
            }
            return end != null ? end : this.value.length;
          }
        }, {
          key: "select",
          value: function select(start, end) {
            if (start == null || end == null || start === this.selectionStart && end === this.selectionEnd)
              return;
            try {
              this._unsafeSelect(start, end);
            } catch (e) {
            }
          }
        }, {
          key: "_unsafeSelect",
          value: function _unsafeSelect(start, end) {
          }
        }, {
          key: "isActive",
          get: function get2() {
            return false;
          }
        }, {
          key: "bindEvents",
          value: function bindEvents(handlers) {
          }
        }, {
          key: "unbindEvents",
          value: function unbindEvents() {
          }
        }]);
        return MaskElement2;
      }();
      IMask.MaskElement = MaskElement;
    }
  });

  // node_modules/imask/esm/controls/html-mask-element.js
  var HTMLMaskElement;
  var init_html_mask_element = __esm({
    "node_modules/imask/esm/controls/html-mask-element.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_mask_element();
      init_holder();
      HTMLMaskElement = /* @__PURE__ */ function(_MaskElement) {
        _inherits(HTMLMaskElement2, _MaskElement);
        var _super = _createSuper(HTMLMaskElement2);
        function HTMLMaskElement2(input) {
          var _this;
          _classCallCheck(this, HTMLMaskElement2);
          _this = _super.call(this);
          _this.input = input;
          _this._handlers = {};
          return _this;
        }
        _createClass(HTMLMaskElement2, [{
          key: "rootElement",
          get: function get2() {
            var _this$input$getRootNo, _this$input$getRootNo2, _this$input;
            return (_this$input$getRootNo = (_this$input$getRootNo2 = (_this$input = this.input).getRootNode) === null || _this$input$getRootNo2 === void 0 ? void 0 : _this$input$getRootNo2.call(_this$input)) !== null && _this$input$getRootNo !== void 0 ? _this$input$getRootNo : document;
          }
        }, {
          key: "isActive",
          get: function get2() {
            return this.input === this.rootElement.activeElement;
          }
        }, {
          key: "_unsafeSelectionStart",
          get: function get2() {
            return this.input.selectionStart;
          }
        }, {
          key: "_unsafeSelectionEnd",
          get: function get2() {
            return this.input.selectionEnd;
          }
        }, {
          key: "_unsafeSelect",
          value: function _unsafeSelect(start, end) {
            this.input.setSelectionRange(start, end);
          }
        }, {
          key: "value",
          get: function get2() {
            return this.input.value;
          },
          set: function set3(value) {
            this.input.value = value;
          }
        }, {
          key: "bindEvents",
          value: function bindEvents(handlers) {
            var _this2 = this;
            Object.keys(handlers).forEach(function(event) {
              return _this2._toggleEventHandler(HTMLMaskElement2.EVENTS_MAP[event], handlers[event]);
            });
          }
        }, {
          key: "unbindEvents",
          value: function unbindEvents() {
            var _this3 = this;
            Object.keys(this._handlers).forEach(function(event) {
              return _this3._toggleEventHandler(event);
            });
          }
        }, {
          key: "_toggleEventHandler",
          value: function _toggleEventHandler(event, handler2) {
            if (this._handlers[event]) {
              this.input.removeEventListener(event, this._handlers[event]);
              delete this._handlers[event];
            }
            if (handler2) {
              this.input.addEventListener(event, handler2);
              this._handlers[event] = handler2;
            }
          }
        }]);
        return HTMLMaskElement2;
      }(MaskElement);
      HTMLMaskElement.EVENTS_MAP = {
        selectionChange: "keydown",
        input: "input",
        drop: "drop",
        click: "click",
        focus: "focus",
        commit: "blur"
      };
      IMask.HTMLMaskElement = HTMLMaskElement;
    }
  });

  // node_modules/imask/esm/controls/html-contenteditable-mask-element.js
  var HTMLContenteditableMaskElement;
  var init_html_contenteditable_mask_element = __esm({
    "node_modules/imask/esm/controls/html-contenteditable-mask-element.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_html_mask_element();
      init_holder();
      init_mask_element();
      HTMLContenteditableMaskElement = /* @__PURE__ */ function(_HTMLMaskElement) {
        _inherits(HTMLContenteditableMaskElement2, _HTMLMaskElement);
        var _super = _createSuper(HTMLContenteditableMaskElement2);
        function HTMLContenteditableMaskElement2() {
          _classCallCheck(this, HTMLContenteditableMaskElement2);
          return _super.apply(this, arguments);
        }
        _createClass(HTMLContenteditableMaskElement2, [{
          key: "_unsafeSelectionStart",
          get: function get2() {
            var root = this.rootElement;
            var selection = root.getSelection && root.getSelection();
            var anchorOffset = selection && selection.anchorOffset;
            var focusOffset = selection && selection.focusOffset;
            if (focusOffset == null || anchorOffset == null || anchorOffset < focusOffset) {
              return anchorOffset;
            }
            return focusOffset;
          }
        }, {
          key: "_unsafeSelectionEnd",
          get: function get2() {
            var root = this.rootElement;
            var selection = root.getSelection && root.getSelection();
            var anchorOffset = selection && selection.anchorOffset;
            var focusOffset = selection && selection.focusOffset;
            if (focusOffset == null || anchorOffset == null || anchorOffset > focusOffset) {
              return anchorOffset;
            }
            return focusOffset;
          }
        }, {
          key: "_unsafeSelect",
          value: function _unsafeSelect(start, end) {
            if (!this.rootElement.createRange)
              return;
            var range = this.rootElement.createRange();
            range.setStart(this.input.firstChild || this.input, start);
            range.setEnd(this.input.lastChild || this.input, end);
            var root = this.rootElement;
            var selection = root.getSelection && root.getSelection();
            if (selection) {
              selection.removeAllRanges();
              selection.addRange(range);
            }
          }
        }, {
          key: "value",
          get: function get2() {
            return this.input.textContent;
          },
          set: function set3(value) {
            this.input.textContent = value;
          }
        }]);
        return HTMLContenteditableMaskElement2;
      }(HTMLMaskElement);
      IMask.HTMLContenteditableMaskElement = HTMLContenteditableMaskElement;
    }
  });

  // node_modules/imask/esm/controls/input.js
  var _excluded4, InputMask;
  var init_input = __esm({
    "node_modules/imask/esm/controls/input.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_utils();
      init_action_details();
      init_date();
      init_factory();
      init_mask_element();
      init_html_mask_element();
      init_html_contenteditable_mask_element();
      init_holder();
      init_change_details();
      init_pattern();
      init_base();
      init_continuous_tail_details();
      init_input_definition();
      init_fixed_definition();
      init_chunk_tail_details();
      init_cursor();
      init_regexp();
      init_range();
      _excluded4 = ["mask"];
      InputMask = /* @__PURE__ */ function() {
        function InputMask2(el, opts) {
          _classCallCheck(this, InputMask2);
          this.el = el instanceof MaskElement ? el : el.isContentEditable && el.tagName !== "INPUT" && el.tagName !== "TEXTAREA" ? new HTMLContenteditableMaskElement(el) : new HTMLMaskElement(el);
          this.masked = createMask(opts);
          this._listeners = {};
          this._value = "";
          this._unmaskedValue = "";
          this._saveSelection = this._saveSelection.bind(this);
          this._onInput = this._onInput.bind(this);
          this._onChange = this._onChange.bind(this);
          this._onDrop = this._onDrop.bind(this);
          this._onFocus = this._onFocus.bind(this);
          this._onClick = this._onClick.bind(this);
          this.alignCursor = this.alignCursor.bind(this);
          this.alignCursorFriendly = this.alignCursorFriendly.bind(this);
          this._bindEvents();
          this.updateValue();
          this._onChange();
        }
        _createClass(InputMask2, [{
          key: "mask",
          get: function get2() {
            return this.masked.mask;
          },
          set: function set3(mask) {
            if (this.maskEquals(mask))
              return;
            if (!(mask instanceof IMask.Masked) && this.masked.constructor === maskedClass(mask)) {
              this.masked.updateOptions({
                mask
              });
              return;
            }
            var masked = createMask({
              mask
            });
            masked.unmaskedValue = this.masked.unmaskedValue;
            this.masked = masked;
          }
        }, {
          key: "maskEquals",
          value: function maskEquals(mask) {
            var _this$masked;
            return mask == null || ((_this$masked = this.masked) === null || _this$masked === void 0 ? void 0 : _this$masked.maskEquals(mask));
          }
        }, {
          key: "value",
          get: function get2() {
            return this._value;
          },
          set: function set3(str) {
            this.masked.value = str;
            this.updateControl();
            this.alignCursor();
          }
        }, {
          key: "unmaskedValue",
          get: function get2() {
            return this._unmaskedValue;
          },
          set: function set3(str) {
            this.masked.unmaskedValue = str;
            this.updateControl();
            this.alignCursor();
          }
        }, {
          key: "typedValue",
          get: function get2() {
            return this.masked.typedValue;
          },
          set: function set3(val) {
            this.masked.typedValue = val;
            this.updateControl();
            this.alignCursor();
          }
        }, {
          key: "_bindEvents",
          value: function _bindEvents() {
            this.el.bindEvents({
              selectionChange: this._saveSelection,
              input: this._onInput,
              drop: this._onDrop,
              click: this._onClick,
              focus: this._onFocus,
              commit: this._onChange
            });
          }
        }, {
          key: "_unbindEvents",
          value: function _unbindEvents() {
            if (this.el)
              this.el.unbindEvents();
          }
        }, {
          key: "_fireEvent",
          value: function _fireEvent(ev) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            var listeners = this._listeners[ev];
            if (!listeners)
              return;
            listeners.forEach(function(l) {
              return l.apply(void 0, args);
            });
          }
        }, {
          key: "selectionStart",
          get: function get2() {
            return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;
          }
        }, {
          key: "cursorPos",
          get: function get2() {
            return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;
          },
          set: function set3(pos) {
            if (!this.el || !this.el.isActive)
              return;
            this.el.select(pos, pos);
            this._saveSelection();
          }
        }, {
          key: "_saveSelection",
          value: function _saveSelection() {
            if (this.value !== this.el.value) {
              console.warn("Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly.");
            }
            this._selection = {
              start: this.selectionStart,
              end: this.cursorPos
            };
          }
        }, {
          key: "updateValue",
          value: function updateValue() {
            this.masked.value = this.el.value;
            this._value = this.masked.value;
          }
        }, {
          key: "updateControl",
          value: function updateControl() {
            var newUnmaskedValue = this.masked.unmaskedValue;
            var newValue = this.masked.value;
            var isChanged = this.unmaskedValue !== newUnmaskedValue || this.value !== newValue;
            this._unmaskedValue = newUnmaskedValue;
            this._value = newValue;
            if (this.el.value !== newValue)
              this.el.value = newValue;
            if (isChanged)
              this._fireChangeEvents();
          }
        }, {
          key: "updateOptions",
          value: function updateOptions(opts) {
            var mask = opts.mask, restOpts = _objectWithoutProperties(opts, _excluded4);
            var updateMask = !this.maskEquals(mask);
            var updateOpts = !objectIncludes(this.masked, restOpts);
            if (updateMask)
              this.mask = mask;
            if (updateOpts)
              this.masked.updateOptions(restOpts);
            if (updateMask || updateOpts)
              this.updateControl();
          }
        }, {
          key: "updateCursor",
          value: function updateCursor(cursorPos) {
            if (cursorPos == null)
              return;
            this.cursorPos = cursorPos;
            this._delayUpdateCursor(cursorPos);
          }
        }, {
          key: "_delayUpdateCursor",
          value: function _delayUpdateCursor(cursorPos) {
            var _this = this;
            this._abortUpdateCursor();
            this._changingCursorPos = cursorPos;
            this._cursorChanging = setTimeout(function() {
              if (!_this.el)
                return;
              _this.cursorPos = _this._changingCursorPos;
              _this._abortUpdateCursor();
            }, 10);
          }
        }, {
          key: "_fireChangeEvents",
          value: function _fireChangeEvents() {
            this._fireEvent("accept", this._inputEvent);
            if (this.masked.isComplete)
              this._fireEvent("complete", this._inputEvent);
          }
        }, {
          key: "_abortUpdateCursor",
          value: function _abortUpdateCursor() {
            if (this._cursorChanging) {
              clearTimeout(this._cursorChanging);
              delete this._cursorChanging;
            }
          }
        }, {
          key: "alignCursor",
          value: function alignCursor() {
            this.cursorPos = this.masked.nearestInputPos(this.masked.nearestInputPos(this.cursorPos, DIRECTION.LEFT));
          }
        }, {
          key: "alignCursorFriendly",
          value: function alignCursorFriendly() {
            if (this.selectionStart !== this.cursorPos)
              return;
            this.alignCursor();
          }
        }, {
          key: "on",
          value: function on(ev, handler2) {
            if (!this._listeners[ev])
              this._listeners[ev] = [];
            this._listeners[ev].push(handler2);
            return this;
          }
        }, {
          key: "off",
          value: function off(ev, handler2) {
            if (!this._listeners[ev])
              return this;
            if (!handler2) {
              delete this._listeners[ev];
              return this;
            }
            var hIndex = this._listeners[ev].indexOf(handler2);
            if (hIndex >= 0)
              this._listeners[ev].splice(hIndex, 1);
            return this;
          }
        }, {
          key: "_onInput",
          value: function _onInput(e) {
            this._inputEvent = e;
            this._abortUpdateCursor();
            if (!this._selection)
              return this.updateValue();
            var details = new ActionDetails(this.el.value, this.cursorPos, this.value, this._selection);
            var oldRawValue = this.masked.rawInputValue;
            var offset = this.masked.splice(details.startChangePos, details.removed.length, details.inserted, details.removeDirection).offset;
            var removeDirection = oldRawValue === this.masked.rawInputValue ? details.removeDirection : DIRECTION.NONE;
            var cursorPos = this.masked.nearestInputPos(details.startChangePos + offset, removeDirection);
            if (removeDirection !== DIRECTION.NONE)
              cursorPos = this.masked.nearestInputPos(cursorPos, DIRECTION.NONE);
            this.updateControl();
            this.updateCursor(cursorPos);
            delete this._inputEvent;
          }
        }, {
          key: "_onChange",
          value: function _onChange() {
            if (this.value !== this.el.value) {
              this.updateValue();
            }
            this.masked.doCommit();
            this.updateControl();
            this._saveSelection();
          }
        }, {
          key: "_onDrop",
          value: function _onDrop(ev) {
            ev.preventDefault();
            ev.stopPropagation();
          }
        }, {
          key: "_onFocus",
          value: function _onFocus(ev) {
            this.alignCursorFriendly();
          }
        }, {
          key: "_onClick",
          value: function _onClick(ev) {
            this.alignCursorFriendly();
          }
        }, {
          key: "destroy",
          value: function destroy() {
            this._unbindEvents();
            this._listeners.length = 0;
            delete this.el;
          }
        }]);
        return InputMask2;
      }();
      IMask.InputMask = InputMask;
    }
  });

  // node_modules/imask/esm/masked/enum.js
  var MaskedEnum;
  var init_enum = __esm({
    "node_modules/imask/esm/masked/enum.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_pattern();
      init_holder();
      init_utils();
      init_change_details();
      init_base();
      init_continuous_tail_details();
      init_input_definition();
      init_factory();
      init_fixed_definition();
      init_chunk_tail_details();
      init_cursor();
      init_regexp();
      MaskedEnum = /* @__PURE__ */ function(_MaskedPattern) {
        _inherits(MaskedEnum2, _MaskedPattern);
        var _super = _createSuper(MaskedEnum2);
        function MaskedEnum2() {
          _classCallCheck(this, MaskedEnum2);
          return _super.apply(this, arguments);
        }
        _createClass(MaskedEnum2, [{
          key: "_update",
          value: function _update(opts) {
            if (opts.enum)
              opts.mask = "*".repeat(opts.enum[0].length);
            _get(_getPrototypeOf(MaskedEnum2.prototype), "_update", this).call(this, opts);
          }
        }, {
          key: "doValidate",
          value: function doValidate() {
            var _this = this, _get2;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return this.enum.some(function(e) {
              return e.indexOf(_this.unmaskedValue) >= 0;
            }) && (_get2 = _get(_getPrototypeOf(MaskedEnum2.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args));
          }
        }]);
        return MaskedEnum2;
      }(MaskedPattern);
      IMask.MaskedEnum = MaskedEnum;
    }
  });

  // node_modules/imask/esm/masked/number.js
  var MaskedNumber;
  var init_number = __esm({
    "node_modules/imask/esm/masked/number.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_utils();
      init_change_details();
      init_base();
      init_holder();
      init_continuous_tail_details();
      MaskedNumber = /* @__PURE__ */ function(_Masked) {
        _inherits(MaskedNumber2, _Masked);
        var _super = _createSuper(MaskedNumber2);
        function MaskedNumber2(opts) {
          _classCallCheck(this, MaskedNumber2);
          return _super.call(this, Object.assign({}, MaskedNumber2.DEFAULTS, opts));
        }
        _createClass(MaskedNumber2, [{
          key: "_update",
          value: function _update(opts) {
            _get(_getPrototypeOf(MaskedNumber2.prototype), "_update", this).call(this, opts);
            this._updateRegExps();
          }
        }, {
          key: "_updateRegExps",
          value: function _updateRegExps() {
            var start = "^" + (this.allowNegative ? "[+|\\-]?" : "");
            var midInput = "(0|([1-9]+\\d*))?";
            var mid = "\\d*";
            var end = (this.scale ? "(" + escapeRegExp(this.radix) + "\\d{0," + this.scale + "})?" : "") + "$";
            this._numberRegExpInput = new RegExp(start + midInput + end);
            this._numberRegExp = new RegExp(start + mid + end);
            this._mapToRadixRegExp = new RegExp("[" + this.mapToRadix.map(escapeRegExp).join("") + "]", "g");
            this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), "g");
          }
        }, {
          key: "_removeThousandsSeparators",
          value: function _removeThousandsSeparators(value) {
            return value.replace(this._thousandsSeparatorRegExp, "");
          }
        }, {
          key: "_insertThousandsSeparators",
          value: function _insertThousandsSeparators(value) {
            var parts = value.split(this.radix);
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator);
            return parts.join(this.radix);
          }
        }, {
          key: "doPrepare",
          value: function doPrepare(ch) {
            var _get2;
            ch = ch.replace(this._mapToRadixRegExp, this.radix);
            var noSepCh = this._removeThousandsSeparators(ch);
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            var _normalizePrepare = normalizePrepare((_get2 = _get(_getPrototypeOf(MaskedNumber2.prototype), "doPrepare", this)).call.apply(_get2, [this, noSepCh].concat(args))), _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2), prepCh = _normalizePrepare2[0], details = _normalizePrepare2[1];
            if (ch && !noSepCh)
              details.skip = true;
            return [prepCh, details];
          }
        }, {
          key: "_separatorsCount",
          value: function _separatorsCount(to) {
            var extendOnSeparators = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var count = 0;
            for (var pos = 0; pos < to; ++pos) {
              if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {
                ++count;
                if (extendOnSeparators)
                  to += this.thousandsSeparator.length;
              }
            }
            return count;
          }
        }, {
          key: "_separatorsCountFromSlice",
          value: function _separatorsCountFromSlice() {
            var slice = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._value;
            return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);
          }
        }, {
          key: "extractInput",
          value: function extractInput() {
            var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
            var flags = arguments.length > 2 ? arguments[2] : void 0;
            var _this$_adjustRangeWit = this._adjustRangeWithSeparators(fromPos, toPos);
            var _this$_adjustRangeWit2 = _slicedToArray(_this$_adjustRangeWit, 2);
            fromPos = _this$_adjustRangeWit2[0];
            toPos = _this$_adjustRangeWit2[1];
            return this._removeThousandsSeparators(_get(_getPrototypeOf(MaskedNumber2.prototype), "extractInput", this).call(this, fromPos, toPos, flags));
          }
        }, {
          key: "_appendCharRaw",
          value: function _appendCharRaw(ch) {
            var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (!this.thousandsSeparator)
              return _get(_getPrototypeOf(MaskedNumber2.prototype), "_appendCharRaw", this).call(this, ch, flags);
            var prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;
            var prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);
            this._value = this._removeThousandsSeparators(this.value);
            var appendDetails = _get(_getPrototypeOf(MaskedNumber2.prototype), "_appendCharRaw", this).call(this, ch, flags);
            this._value = this._insertThousandsSeparators(this._value);
            var beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;
            var beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);
            appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;
            appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;
            return appendDetails;
          }
        }, {
          key: "_findSeparatorAround",
          value: function _findSeparatorAround(pos) {
            if (this.thousandsSeparator) {
              var searchFrom = pos - this.thousandsSeparator.length + 1;
              var separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);
              if (separatorPos <= pos)
                return separatorPos;
            }
            return -1;
          }
        }, {
          key: "_adjustRangeWithSeparators",
          value: function _adjustRangeWithSeparators(from, to) {
            var separatorAroundFromPos = this._findSeparatorAround(from);
            if (separatorAroundFromPos >= 0)
              from = separatorAroundFromPos;
            var separatorAroundToPos = this._findSeparatorAround(to);
            if (separatorAroundToPos >= 0)
              to = separatorAroundToPos + this.thousandsSeparator.length;
            return [from, to];
          }
        }, {
          key: "remove",
          value: function remove() {
            var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
            var _this$_adjustRangeWit3 = this._adjustRangeWithSeparators(fromPos, toPos);
            var _this$_adjustRangeWit4 = _slicedToArray(_this$_adjustRangeWit3, 2);
            fromPos = _this$_adjustRangeWit4[0];
            toPos = _this$_adjustRangeWit4[1];
            var valueBeforePos = this.value.slice(0, fromPos);
            var valueAfterPos = this.value.slice(toPos);
            var prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);
            this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));
            var beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);
            return new ChangeDetails({
              tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length
            });
          }
        }, {
          key: "nearestInputPos",
          value: function nearestInputPos(cursorPos, direction) {
            if (!this.thousandsSeparator)
              return cursorPos;
            switch (direction) {
              case DIRECTION.NONE:
              case DIRECTION.LEFT:
              case DIRECTION.FORCE_LEFT: {
                var separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);
                if (separatorAtLeftPos >= 0) {
                  var separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;
                  if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {
                    return separatorAtLeftPos;
                  }
                }
                break;
              }
              case DIRECTION.RIGHT:
              case DIRECTION.FORCE_RIGHT: {
                var separatorAtRightPos = this._findSeparatorAround(cursorPos);
                if (separatorAtRightPos >= 0) {
                  return separatorAtRightPos + this.thousandsSeparator.length;
                }
              }
            }
            return cursorPos;
          }
        }, {
          key: "doValidate",
          value: function doValidate(flags) {
            var regexp = flags.input ? this._numberRegExpInput : this._numberRegExp;
            var valid = regexp.test(this._removeThousandsSeparators(this.value));
            if (valid) {
              var number = this.number;
              valid = valid && !isNaN(number) && (this.min == null || this.min >= 0 || this.min <= this.number) && (this.max == null || this.max <= 0 || this.number <= this.max);
            }
            return valid && _get(_getPrototypeOf(MaskedNumber2.prototype), "doValidate", this).call(this, flags);
          }
        }, {
          key: "doCommit",
          value: function doCommit() {
            if (this.value) {
              var number = this.number;
              var validnum = number;
              if (this.min != null)
                validnum = Math.max(validnum, this.min);
              if (this.max != null)
                validnum = Math.min(validnum, this.max);
              if (validnum !== number)
                this.unmaskedValue = String(validnum);
              var formatted = this.value;
              if (this.normalizeZeros)
                formatted = this._normalizeZeros(formatted);
              if (this.padFractionalZeros && this.scale > 0)
                formatted = this._padFractionalZeros(formatted);
              this._value = formatted;
            }
            _get(_getPrototypeOf(MaskedNumber2.prototype), "doCommit", this).call(this);
          }
        }, {
          key: "_normalizeZeros",
          value: function _normalizeZeros(value) {
            var parts = this._removeThousandsSeparators(value).split(this.radix);
            parts[0] = parts[0].replace(/^(\D*)(0*)(\d*)/, function(match, sign, zeros, num) {
              return sign + num;
            });
            if (value.length && !/\d$/.test(parts[0]))
              parts[0] = parts[0] + "0";
            if (parts.length > 1) {
              parts[1] = parts[1].replace(/0*$/, "");
              if (!parts[1].length)
                parts.length = 1;
            }
            return this._insertThousandsSeparators(parts.join(this.radix));
          }
        }, {
          key: "_padFractionalZeros",
          value: function _padFractionalZeros(value) {
            if (!value)
              return value;
            var parts = value.split(this.radix);
            if (parts.length < 2)
              parts.push("");
            parts[1] = parts[1].padEnd(this.scale, "0");
            return parts.join(this.radix);
          }
        }, {
          key: "unmaskedValue",
          get: function get2() {
            return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, ".");
          },
          set: function set3(unmaskedValue) {
            _set(_getPrototypeOf(MaskedNumber2.prototype), "unmaskedValue", unmaskedValue.replace(".", this.radix), this, true);
          }
        }, {
          key: "typedValue",
          get: function get2() {
            return Number(this.unmaskedValue);
          },
          set: function set3(n) {
            _set(_getPrototypeOf(MaskedNumber2.prototype), "unmaskedValue", String(n), this, true);
          }
        }, {
          key: "number",
          get: function get2() {
            return this.typedValue;
          },
          set: function set3(number) {
            this.typedValue = number;
          }
        }, {
          key: "allowNegative",
          get: function get2() {
            return this.signed || this.min != null && this.min < 0 || this.max != null && this.max < 0;
          }
        }]);
        return MaskedNumber2;
      }(Masked);
      MaskedNumber.DEFAULTS = {
        radix: ",",
        thousandsSeparator: "",
        mapToRadix: ["."],
        scale: 2,
        signed: false,
        normalizeZeros: true,
        padFractionalZeros: false
      };
      IMask.MaskedNumber = MaskedNumber;
    }
  });

  // node_modules/imask/esm/masked/function.js
  var MaskedFunction;
  var init_function = __esm({
    "node_modules/imask/esm/masked/function.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_base();
      init_holder();
      init_change_details();
      init_continuous_tail_details();
      init_utils();
      MaskedFunction = /* @__PURE__ */ function(_Masked) {
        _inherits(MaskedFunction2, _Masked);
        var _super = _createSuper(MaskedFunction2);
        function MaskedFunction2() {
          _classCallCheck(this, MaskedFunction2);
          return _super.apply(this, arguments);
        }
        _createClass(MaskedFunction2, [{
          key: "_update",
          value: function _update(opts) {
            if (opts.mask)
              opts.validate = opts.mask;
            _get(_getPrototypeOf(MaskedFunction2.prototype), "_update", this).call(this, opts);
          }
        }]);
        return MaskedFunction2;
      }(Masked);
      IMask.MaskedFunction = MaskedFunction;
    }
  });

  // node_modules/imask/esm/masked/dynamic.js
  var _excluded5, MaskedDynamic;
  var init_dynamic = __esm({
    "node_modules/imask/esm/masked/dynamic.js"() {
      init_rollupPluginBabelHelpers_b054ecd2();
      init_change_details();
      init_factory();
      init_base();
      init_holder();
      init_utils();
      init_continuous_tail_details();
      _excluded5 = ["compiledMasks", "currentMaskRef", "currentMask"];
      MaskedDynamic = /* @__PURE__ */ function(_Masked) {
        _inherits(MaskedDynamic2, _Masked);
        var _super = _createSuper(MaskedDynamic2);
        function MaskedDynamic2(opts) {
          var _this;
          _classCallCheck(this, MaskedDynamic2);
          _this = _super.call(this, Object.assign({}, MaskedDynamic2.DEFAULTS, opts));
          _this.currentMask = null;
          return _this;
        }
        _createClass(MaskedDynamic2, [{
          key: "_update",
          value: function _update(opts) {
            _get(_getPrototypeOf(MaskedDynamic2.prototype), "_update", this).call(this, opts);
            if ("mask" in opts) {
              this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(function(m) {
                return createMask(m);
              }) : [];
            }
          }
        }, {
          key: "_appendCharRaw",
          value: function _appendCharRaw(ch) {
            var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var details = this._applyDispatch(ch, flags);
            if (this.currentMask) {
              details.aggregate(this.currentMask._appendChar(ch, flags));
            }
            return details;
          }
        }, {
          key: "_applyDispatch",
          value: function _applyDispatch() {
            var appended = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
            var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;
            var inputValue = this.rawInputValue;
            var insertValue = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._rawInputValue : inputValue;
            var tailValue = inputValue.slice(insertValue.length);
            var prevMask = this.currentMask;
            var details = new ChangeDetails();
            var prevMaskState = prevMask && prevMask.state;
            this.currentMask = this.doDispatch(appended, Object.assign({}, flags));
            if (this.currentMask) {
              if (this.currentMask !== prevMask) {
                this.currentMask.reset();
                if (insertValue) {
                  var d = this.currentMask.append(insertValue, {
                    raw: true
                  });
                  details.tailShift = d.inserted.length - prevValueBeforeTail.length;
                }
                if (tailValue) {
                  details.tailShift += this.currentMask.append(tailValue, {
                    raw: true,
                    tail: true
                  }).tailShift;
                }
              } else {
                this.currentMask.state = prevMaskState;
              }
            }
            return details;
          }
        }, {
          key: "_appendPlaceholder",
          value: function _appendPlaceholder() {
            var details = this._applyDispatch.apply(this, arguments);
            if (this.currentMask) {
              details.aggregate(this.currentMask._appendPlaceholder());
            }
            return details;
          }
        }, {
          key: "_appendEager",
          value: function _appendEager() {
            var details = this._applyDispatch.apply(this, arguments);
            if (this.currentMask) {
              details.aggregate(this.currentMask._appendEager());
            }
            return details;
          }
        }, {
          key: "doDispatch",
          value: function doDispatch(appended) {
            var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return this.dispatch(appended, this, flags);
          }
        }, {
          key: "doValidate",
          value: function doValidate() {
            var _get2, _this$currentMask;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return (_get2 = _get(_getPrototypeOf(MaskedDynamic2.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args)) && (!this.currentMask || (_this$currentMask = this.currentMask).doValidate.apply(_this$currentMask, args));
          }
        }, {
          key: "reset",
          value: function reset() {
            var _this$currentMask2;
            (_this$currentMask2 = this.currentMask) === null || _this$currentMask2 === void 0 ? void 0 : _this$currentMask2.reset();
            this.compiledMasks.forEach(function(m) {
              return m.reset();
            });
          }
        }, {
          key: "value",
          get: function get2() {
            return this.currentMask ? this.currentMask.value : "";
          },
          set: function set3(value) {
            _set(_getPrototypeOf(MaskedDynamic2.prototype), "value", value, this, true);
          }
        }, {
          key: "unmaskedValue",
          get: function get2() {
            return this.currentMask ? this.currentMask.unmaskedValue : "";
          },
          set: function set3(unmaskedValue) {
            _set(_getPrototypeOf(MaskedDynamic2.prototype), "unmaskedValue", unmaskedValue, this, true);
          }
        }, {
          key: "typedValue",
          get: function get2() {
            return this.currentMask ? this.currentMask.typedValue : "";
          },
          set: function set3(value) {
            var unmaskedValue = String(value);
            if (this.currentMask) {
              this.currentMask.typedValue = value;
              unmaskedValue = this.currentMask.unmaskedValue;
            }
            this.unmaskedValue = unmaskedValue;
          }
        }, {
          key: "isComplete",
          get: function get2() {
            var _this$currentMask3;
            return Boolean((_this$currentMask3 = this.currentMask) === null || _this$currentMask3 === void 0 ? void 0 : _this$currentMask3.isComplete);
          }
        }, {
          key: "isFilled",
          get: function get2() {
            var _this$currentMask4;
            return Boolean((_this$currentMask4 = this.currentMask) === null || _this$currentMask4 === void 0 ? void 0 : _this$currentMask4.isFilled);
          }
        }, {
          key: "remove",
          value: function remove() {
            var details = new ChangeDetails();
            if (this.currentMask) {
              var _this$currentMask5;
              details.aggregate((_this$currentMask5 = this.currentMask).remove.apply(_this$currentMask5, arguments)).aggregate(this._applyDispatch());
            }
            return details;
          }
        }, {
          key: "state",
          get: function get2() {
            return Object.assign({}, _get(_getPrototypeOf(MaskedDynamic2.prototype), "state", this), {
              _rawInputValue: this.rawInputValue,
              compiledMasks: this.compiledMasks.map(function(m) {
                return m.state;
              }),
              currentMaskRef: this.currentMask,
              currentMask: this.currentMask && this.currentMask.state
            });
          },
          set: function set3(state) {
            var compiledMasks = state.compiledMasks, currentMaskRef = state.currentMaskRef, currentMask = state.currentMask, maskedState = _objectWithoutProperties(state, _excluded5);
            this.compiledMasks.forEach(function(m, mi) {
              return m.state = compiledMasks[mi];
            });
            if (currentMaskRef != null) {
              this.currentMask = currentMaskRef;
              this.currentMask.state = currentMask;
            }
            _set(_getPrototypeOf(MaskedDynamic2.prototype), "state", maskedState, this, true);
          }
        }, {
          key: "extractInput",
          value: function extractInput() {
            var _this$currentMask6;
            return this.currentMask ? (_this$currentMask6 = this.currentMask).extractInput.apply(_this$currentMask6, arguments) : "";
          }
        }, {
          key: "extractTail",
          value: function extractTail() {
            var _this$currentMask7, _get3;
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            return this.currentMask ? (_this$currentMask7 = this.currentMask).extractTail.apply(_this$currentMask7, args) : (_get3 = _get(_getPrototypeOf(MaskedDynamic2.prototype), "extractTail", this)).call.apply(_get3, [this].concat(args));
          }
        }, {
          key: "doCommit",
          value: function doCommit() {
            if (this.currentMask)
              this.currentMask.doCommit();
            _get(_getPrototypeOf(MaskedDynamic2.prototype), "doCommit", this).call(this);
          }
        }, {
          key: "nearestInputPos",
          value: function nearestInputPos() {
            var _this$currentMask8, _get4;
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            return this.currentMask ? (_this$currentMask8 = this.currentMask).nearestInputPos.apply(_this$currentMask8, args) : (_get4 = _get(_getPrototypeOf(MaskedDynamic2.prototype), "nearestInputPos", this)).call.apply(_get4, [this].concat(args));
          }
        }, {
          key: "overwrite",
          get: function get2() {
            return this.currentMask ? this.currentMask.overwrite : _get(_getPrototypeOf(MaskedDynamic2.prototype), "overwrite", this);
          },
          set: function set3(overwrite) {
            console.warn('"overwrite" option is not available in dynamic mask, use this option in siblings');
          }
        }, {
          key: "eager",
          get: function get2() {
            return this.currentMask ? this.currentMask.eager : _get(_getPrototypeOf(MaskedDynamic2.prototype), "eager", this);
          },
          set: function set3(eager) {
            console.warn('"eager" option is not available in dynamic mask, use this option in siblings');
          }
        }, {
          key: "maskEquals",
          value: function maskEquals(mask) {
            return Array.isArray(mask) && this.compiledMasks.every(function(m, mi) {
              var _mask$mi;
              return m.maskEquals((_mask$mi = mask[mi]) === null || _mask$mi === void 0 ? void 0 : _mask$mi.mask);
            });
          }
        }]);
        return MaskedDynamic2;
      }(Masked);
      MaskedDynamic.DEFAULTS = {
        dispatch: function dispatch(appended, masked, flags) {
          if (!masked.compiledMasks.length)
            return;
          var inputValue = masked.rawInputValue;
          var inputs = masked.compiledMasks.map(function(m, index) {
            m.reset();
            m.append(inputValue, {
              raw: true
            });
            m.append(appended, flags);
            var weight = m.rawInputValue.length;
            return {
              weight,
              index
            };
          });
          inputs.sort(function(i1, i2) {
            return i2.weight - i1.weight;
          });
          return masked.compiledMasks[inputs[0].index];
        }
      };
      IMask.MaskedDynamic = MaskedDynamic;
    }
  });

  // node_modules/imask/esm/masked/pipe.js
  function createPipe(mask) {
    var from = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : PIPE_TYPE.MASKED;
    var to = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : PIPE_TYPE.MASKED;
    var masked = createMask(mask);
    return function(value) {
      return masked.runIsolated(function(m) {
        m[from] = value;
        return m[to];
      });
    };
  }
  function pipe(value) {
    for (var _len = arguments.length, pipeArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      pipeArgs[_key - 1] = arguments[_key];
    }
    return createPipe.apply(void 0, pipeArgs)(value);
  }
  var PIPE_TYPE;
  var init_pipe = __esm({
    "node_modules/imask/esm/masked/pipe.js"() {
      init_factory();
      init_holder();
      init_utils();
      init_rollupPluginBabelHelpers_b054ecd2();
      init_change_details();
      PIPE_TYPE = {
        MASKED: "value",
        UNMASKED: "unmaskedValue",
        TYPED: "typedValue"
      };
      IMask.PIPE_TYPE = PIPE_TYPE;
      IMask.createPipe = createPipe;
      IMask.pipe = pipe;
    }
  });

  // node_modules/imask/esm/index.js
  var init_esm = __esm({
    "node_modules/imask/esm/index.js"() {
      init_input();
      init_holder();
      init_holder();
      init_base();
      init_pattern();
      init_enum();
      init_range();
      init_number();
      init_date();
      init_regexp();
      init_function();
      init_dynamic();
      init_factory();
      init_mask_element();
      init_html_mask_element();
      init_html_contenteditable_mask_element();
      init_pipe();
      init_rollupPluginBabelHelpers_b054ecd2();
      init_utils();
      init_change_details();
      init_action_details();
      init_continuous_tail_details();
      init_input_definition();
      init_fixed_definition();
      init_chunk_tail_details();
      init_cursor();
      try {
        globalThis.IMask = IMask;
      } catch (e) {
      }
    }
  });

  // node_modules/imask/esm/imask.js
  var init_imask = __esm({
    "node_modules/imask/esm/imask.js"() {
      init_input();
      init_holder();
      init_holder();
      init_rollupPluginBabelHelpers_b054ecd2();
      init_utils();
      init_change_details();
      init_action_details();
      init_date();
      init_pattern();
      init_base();
      init_continuous_tail_details();
      init_input_definition();
      init_factory();
      init_fixed_definition();
      init_chunk_tail_details();
      init_cursor();
      init_regexp();
      init_range();
      init_mask_element();
      init_html_mask_element();
      init_html_contenteditable_mask_element();
    }
  });

  // node_modules/vue/dist/vue.runtime.common.dev.js
  var require_vue_runtime_common_dev = __commonJS({
    "node_modules/vue/dist/vue.runtime.common.dev.js"(exports, module) {
      "use strict";
      var emptyObject = Object.freeze({});
      function isUndef2(v) {
        return v === void 0 || v === null;
      }
      function isDef(v) {
        return v !== void 0 && v !== null;
      }
      function isTrue(v) {
        return v === true;
      }
      function isFalse(v) {
        return v === false;
      }
      function isPrimitive2(value) {
        return typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "boolean";
      }
      function isObject2(obj) {
        return obj !== null && typeof obj === "object";
      }
      var _toString = Object.prototype.toString;
      function toRawType(value) {
        return _toString.call(value).slice(8, -1);
      }
      function isPlainObject2(obj) {
        return _toString.call(obj) === "[object Object]";
      }
      function isRegExp(v) {
        return _toString.call(v) === "[object RegExp]";
      }
      function isValidArrayIndex2(val) {
        var n = parseFloat(String(val));
        return n >= 0 && Math.floor(n) === n && isFinite(val);
      }
      function isPromise(val) {
        return isDef(val) && typeof val.then === "function" && typeof val.catch === "function";
      }
      function toString2(val) {
        return val == null ? "" : Array.isArray(val) || isPlainObject2(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
      }
      function toNumber(val) {
        var n = parseFloat(val);
        return isNaN(n) ? val : n;
      }
      function makeMap(str, expectsLowerCase) {
        var map = /* @__PURE__ */ Object.create(null);
        var list = str.split(",");
        for (var i = 0; i < list.length; i++) {
          map[list[i]] = true;
        }
        return expectsLowerCase ? function(val) {
          return map[val.toLowerCase()];
        } : function(val) {
          return map[val];
        };
      }
      var isBuiltInTag = makeMap("slot,component", true);
      var isReservedAttribute = makeMap("key,ref,slot,slot-scope,is");
      function remove(arr, item) {
        if (arr.length) {
          var index2 = arr.indexOf(item);
          if (index2 > -1) {
            return arr.splice(index2, 1);
          }
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function hasOwn2(obj, key) {
        return hasOwnProperty.call(obj, key);
      }
      function cached(fn) {
        var cache = /* @__PURE__ */ Object.create(null);
        return function cachedFn(str) {
          var hit = cache[str];
          return hit || (cache[str] = fn(str));
        };
      }
      var camelizeRE = /-(\w)/g;
      var camelize = cached(function(str) {
        return str.replace(camelizeRE, function(_, c) {
          return c ? c.toUpperCase() : "";
        });
      });
      var capitalize = cached(function(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      });
      var hyphenateRE = /\B([A-Z])/g;
      var hyphenate = cached(function(str) {
        return str.replace(hyphenateRE, "-$1").toLowerCase();
      });
      function polyfillBind(fn, ctx) {
        function boundFn(a) {
          var l = arguments.length;
          return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
        }
        boundFn._length = fn.length;
        return boundFn;
      }
      function nativeBind(fn, ctx) {
        return fn.bind(ctx);
      }
      var bind = Function.prototype.bind ? nativeBind : polyfillBind;
      function toArray(list, start) {
        start = start || 0;
        var i = list.length - start;
        var ret = new Array(i);
        while (i--) {
          ret[i] = list[i + start];
        }
        return ret;
      }
      function extend(to, _from) {
        for (var key in _from) {
          to[key] = _from[key];
        }
        return to;
      }
      function toObject(arr) {
        var res = {};
        for (var i = 0; i < arr.length; i++) {
          if (arr[i]) {
            extend(res, arr[i]);
          }
        }
        return res;
      }
      function noop(a, b, c) {
      }
      var no = function(a, b, c) {
        return false;
      };
      var identity = function(_) {
        return _;
      };
      function looseEqual(a, b) {
        if (a === b) {
          return true;
        }
        var isObjectA = isObject2(a);
        var isObjectB = isObject2(b);
        if (isObjectA && isObjectB) {
          try {
            var isArrayA = Array.isArray(a);
            var isArrayB = Array.isArray(b);
            if (isArrayA && isArrayB) {
              return a.length === b.length && a.every(function(e, i) {
                return looseEqual(e, b[i]);
              });
            } else if (a instanceof Date && b instanceof Date) {
              return a.getTime() === b.getTime();
            } else if (!isArrayA && !isArrayB) {
              var keysA = Object.keys(a);
              var keysB = Object.keys(b);
              return keysA.length === keysB.length && keysA.every(function(key) {
                return looseEqual(a[key], b[key]);
              });
            } else {
              return false;
            }
          } catch (e) {
            return false;
          }
        } else if (!isObjectA && !isObjectB) {
          return String(a) === String(b);
        } else {
          return false;
        }
      }
      function looseIndexOf(arr, val) {
        for (var i = 0; i < arr.length; i++) {
          if (looseEqual(arr[i], val)) {
            return i;
          }
        }
        return -1;
      }
      function once(fn) {
        var called = false;
        return function() {
          if (!called) {
            called = true;
            fn.apply(this, arguments);
          }
        };
      }
      var SSR_ATTR = "data-server-rendered";
      var ASSET_TYPES = [
        "component",
        "directive",
        "filter"
      ];
      var LIFECYCLE_HOOKS = [
        "beforeCreate",
        "created",
        "beforeMount",
        "mounted",
        "beforeUpdate",
        "updated",
        "beforeDestroy",
        "destroyed",
        "activated",
        "deactivated",
        "errorCaptured",
        "serverPrefetch"
      ];
      var config = {
        optionMergeStrategies: /* @__PURE__ */ Object.create(null),
        silent: false,
        productionTip: true,
        devtools: true,
        performance: false,
        errorHandler: null,
        warnHandler: null,
        ignoredElements: [],
        keyCodes: /* @__PURE__ */ Object.create(null),
        isReservedTag: no,
        isReservedAttr: no,
        isUnknownElement: no,
        getTagNamespace: noop,
        parsePlatformTagName: identity,
        mustUseProp: no,
        async: true,
        _lifecycleHooks: LIFECYCLE_HOOKS
      };
      var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
      function isReserved(str) {
        var c = (str + "").charCodeAt(0);
        return c === 36 || c === 95;
      }
      function def2(obj, key, val, enumerable) {
        Object.defineProperty(obj, key, {
          value: val,
          enumerable: !!enumerable,
          writable: true,
          configurable: true
        });
      }
      var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");
      function parsePath(path) {
        if (bailRE.test(path)) {
          return;
        }
        var segments = path.split(".");
        return function(obj) {
          for (var i = 0; i < segments.length; i++) {
            if (!obj) {
              return;
            }
            obj = obj[segments[i]];
          }
          return obj;
        };
      }
      var hasProto = "__proto__" in {};
      var inBrowser = typeof window !== "undefined";
      var inWeex = typeof WXEnvironment !== "undefined" && !!WXEnvironment.platform;
      var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
      var UA = inBrowser && window.navigator.userAgent.toLowerCase();
      var isIE = UA && /msie|trident/.test(UA);
      var isIE9 = UA && UA.indexOf("msie 9.0") > 0;
      var isEdge = UA && UA.indexOf("edge/") > 0;
      var isAndroid = UA && UA.indexOf("android") > 0 || weexPlatform === "android";
      var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === "ios";
      var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
      var isPhantomJS = UA && /phantomjs/.test(UA);
      var isFF = UA && UA.match(/firefox\/(\d+)/);
      var nativeWatch = {}.watch;
      var supportsPassive = false;
      if (inBrowser) {
        try {
          opts = {};
          Object.defineProperty(opts, "passive", {
            get: function get2() {
              supportsPassive = true;
            }
          });
          window.addEventListener("test-passive", null, opts);
        } catch (e) {
        }
      }
      var opts;
      var _isServer;
      var isServerRendering = function() {
        if (_isServer === void 0) {
          if (!inBrowser && !inWeex && typeof global !== "undefined") {
            _isServer = global["process"] && global["process"].env.VUE_ENV === "server";
          } else {
            _isServer = false;
          }
        }
        return _isServer;
      };
      var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
      function isNative2(Ctor) {
        return typeof Ctor === "function" && /native code/.test(Ctor.toString());
      }
      var hasSymbol2 = typeof Symbol !== "undefined" && isNative2(Symbol) && typeof Reflect !== "undefined" && isNative2(Reflect.ownKeys);
      var _Set;
      if (typeof Set !== "undefined" && isNative2(Set)) {
        _Set = Set;
      } else {
        _Set = /* @__PURE__ */ function() {
          function Set2() {
            this.set = /* @__PURE__ */ Object.create(null);
          }
          Set2.prototype.has = function has2(key) {
            return this.set[key] === true;
          };
          Set2.prototype.add = function add2(key) {
            this.set[key] = true;
          };
          Set2.prototype.clear = function clear() {
            this.set = /* @__PURE__ */ Object.create(null);
          };
          return Set2;
        }();
      }
      var warn2 = noop;
      var tip = noop;
      var generateComponentTrace = noop;
      var formatComponentName = noop;
      {
        hasConsole = typeof console !== "undefined";
        classifyRE = /(?:^|[-_])(\w)/g;
        classify = function(str) {
          return str.replace(classifyRE, function(c) {
            return c.toUpperCase();
          }).replace(/[-_]/g, "");
        };
        warn2 = function(msg, vm) {
          var trace = vm ? generateComponentTrace(vm) : "";
          if (config.warnHandler) {
            config.warnHandler.call(null, msg, vm, trace);
          } else if (hasConsole && !config.silent) {
            console.error("[Vue warn]: " + msg + trace);
          }
        };
        tip = function(msg, vm) {
          if (hasConsole && !config.silent) {
            console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ""));
          }
        };
        formatComponentName = function(vm, includeFile) {
          if (vm.$root === vm) {
            return "<Root>";
          }
          var options = typeof vm === "function" && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
          var name = options.name || options._componentTag;
          var file = options.__file;
          if (!name && file) {
            var match = file.match(/([^/\\]+)\.vue$/);
            name = match && match[1];
          }
          return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : "");
        };
        repeat = function(str, n) {
          var res = "";
          while (n) {
            if (n % 2 === 1) {
              res += str;
            }
            if (n > 1) {
              str += str;
            }
            n >>= 1;
          }
          return res;
        };
        generateComponentTrace = function(vm) {
          if (vm._isVue && vm.$parent) {
            var tree = [];
            var currentRecursiveSequence = 0;
            while (vm) {
              if (tree.length > 0) {
                var last = tree[tree.length - 1];
                if (last.constructor === vm.constructor) {
                  currentRecursiveSequence++;
                  vm = vm.$parent;
                  continue;
                } else if (currentRecursiveSequence > 0) {
                  tree[tree.length - 1] = [last, currentRecursiveSequence];
                  currentRecursiveSequence = 0;
                }
              }
              tree.push(vm);
              vm = vm.$parent;
            }
            return "\n\nfound in\n\n" + tree.map(function(vm2, i) {
              return "" + (i === 0 ? "---> " : repeat(" ", 5 + i * 2)) + (Array.isArray(vm2) ? formatComponentName(vm2[0]) + "... (" + vm2[1] + " recursive calls)" : formatComponentName(vm2));
            }).join("\n");
          } else {
            return "\n\n(found in " + formatComponentName(vm) + ")";
          }
        };
      }
      var hasConsole;
      var classifyRE;
      var classify;
      var repeat;
      var uid = 0;
      var Dep = function Dep2() {
        this.id = uid++;
        this.subs = [];
      };
      Dep.prototype.addSub = function addSub(sub) {
        this.subs.push(sub);
      };
      Dep.prototype.removeSub = function removeSub(sub) {
        remove(this.subs, sub);
      };
      Dep.prototype.depend = function depend() {
        if (Dep.target) {
          Dep.target.addDep(this);
        }
      };
      Dep.prototype.notify = function notify() {
        var subs = this.subs.slice();
        if (!config.async) {
          subs.sort(function(a, b) {
            return a.id - b.id;
          });
        }
        for (var i = 0, l = subs.length; i < l; i++) {
          subs[i].update();
        }
      };
      Dep.target = null;
      var targetStack = [];
      function pushTarget(target2) {
        targetStack.push(target2);
        Dep.target = target2;
      }
      function popTarget() {
        targetStack.pop();
        Dep.target = targetStack[targetStack.length - 1];
      }
      var VNode = function VNode2(tag, data2, children, text, elm, context, componentOptions, asyncFactory) {
        this.tag = tag;
        this.data = data2;
        this.children = children;
        this.text = text;
        this.elm = elm;
        this.ns = void 0;
        this.context = context;
        this.fnContext = void 0;
        this.fnOptions = void 0;
        this.fnScopeId = void 0;
        this.key = data2 && data2.key;
        this.componentOptions = componentOptions;
        this.componentInstance = void 0;
        this.parent = void 0;
        this.raw = false;
        this.isStatic = false;
        this.isRootInsert = true;
        this.isComment = false;
        this.isCloned = false;
        this.isOnce = false;
        this.asyncFactory = asyncFactory;
        this.asyncMeta = void 0;
        this.isAsyncPlaceholder = false;
      };
      var prototypeAccessors = { child: { configurable: true } };
      prototypeAccessors.child.get = function() {
        return this.componentInstance;
      };
      Object.defineProperties(VNode.prototype, prototypeAccessors);
      var createEmptyVNode = function(text) {
        if (text === void 0)
          text = "";
        var node = new VNode();
        node.text = text;
        node.isComment = true;
        return node;
      };
      function createTextVNode(val) {
        return new VNode(void 0, void 0, void 0, String(val));
      }
      function cloneVNode(vnode) {
        var cloned = new VNode(vnode.tag, vnode.data, vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
        cloned.ns = vnode.ns;
        cloned.isStatic = vnode.isStatic;
        cloned.key = vnode.key;
        cloned.isComment = vnode.isComment;
        cloned.fnContext = vnode.fnContext;
        cloned.fnOptions = vnode.fnOptions;
        cloned.fnScopeId = vnode.fnScopeId;
        cloned.asyncMeta = vnode.asyncMeta;
        cloned.isCloned = true;
        return cloned;
      }
      var arrayProto = Array.prototype;
      var arrayMethods = Object.create(arrayProto);
      var methodsToPatch = [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice",
        "sort",
        "reverse"
      ];
      methodsToPatch.forEach(function(method) {
        var original = arrayProto[method];
        def2(arrayMethods, method, function mutator() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var result = original.apply(this, args);
          var ob = this.__ob__;
          var inserted;
          switch (method) {
            case "push":
            case "unshift":
              inserted = args;
              break;
            case "splice":
              inserted = args.slice(2);
              break;
          }
          if (inserted) {
            ob.observeArray(inserted);
          }
          ob.dep.notify();
          return result;
        });
      });
      var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
      var shouldObserve = true;
      function toggleObserving(value) {
        shouldObserve = value;
      }
      var Observer = function Observer2(value) {
        this.value = value;
        this.dep = new Dep();
        this.vmCount = 0;
        def2(value, "__ob__", this);
        if (Array.isArray(value)) {
          if (hasProto) {
            protoAugment(value, arrayMethods);
          } else {
            copyAugment(value, arrayMethods, arrayKeys);
          }
          this.observeArray(value);
        } else {
          this.walk(value);
        }
      };
      Observer.prototype.walk = function walk(obj) {
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) {
          defineReactive$$1(obj, keys[i]);
        }
      };
      Observer.prototype.observeArray = function observeArray(items) {
        for (var i = 0, l = items.length; i < l; i++) {
          observe2(items[i]);
        }
      };
      function protoAugment(target2, src) {
        target2.__proto__ = src;
      }
      function copyAugment(target2, src, keys) {
        for (var i = 0, l = keys.length; i < l; i++) {
          var key = keys[i];
          def2(target2, key, src[key]);
        }
      }
      function observe2(value, asRootData) {
        if (!isObject2(value) || value instanceof VNode) {
          return;
        }
        var ob;
        if (hasOwn2(value, "__ob__") && value.__ob__ instanceof Observer) {
          ob = value.__ob__;
        } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject2(value)) && Object.isExtensible(value) && !value._isVue) {
          ob = new Observer(value);
        }
        if (asRootData && ob) {
          ob.vmCount++;
        }
        return ob;
      }
      function defineReactive$$1(obj, key, val, customSetter, shallow) {
        var dep = new Dep();
        var property = Object.getOwnPropertyDescriptor(obj, key);
        if (property && property.configurable === false) {
          return;
        }
        var getter = property && property.get;
        var setter = property && property.set;
        if ((!getter || setter) && arguments.length === 2) {
          val = obj[key];
        }
        var childOb = !shallow && observe2(val);
        Object.defineProperty(obj, key, {
          enumerable: true,
          configurable: true,
          get: function reactiveGetter() {
            var value = getter ? getter.call(obj) : val;
            if (Dep.target) {
              dep.depend();
              if (childOb) {
                childOb.dep.depend();
                if (Array.isArray(value)) {
                  dependArray(value);
                }
              }
            }
            return value;
          },
          set: function reactiveSetter(newVal) {
            var value = getter ? getter.call(obj) : val;
            if (newVal === value || newVal !== newVal && value !== value) {
              return;
            }
            if (customSetter) {
              customSetter();
            }
            if (getter && !setter) {
              return;
            }
            if (setter) {
              setter.call(obj, newVal);
            } else {
              val = newVal;
            }
            childOb = !shallow && observe2(newVal);
            dep.notify();
          }
        });
      }
      function set3(target2, key, val) {
        if (isUndef2(target2) || isPrimitive2(target2)) {
          warn2("Cannot set reactive property on undefined, null, or primitive value: " + target2);
        }
        if (Array.isArray(target2) && isValidArrayIndex2(key)) {
          target2.length = Math.max(target2.length, key);
          target2.splice(key, 1, val);
          return val;
        }
        if (key in target2 && !(key in Object.prototype)) {
          target2[key] = val;
          return val;
        }
        var ob = target2.__ob__;
        if (target2._isVue || ob && ob.vmCount) {
          warn2("Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.");
          return val;
        }
        if (!ob) {
          target2[key] = val;
          return val;
        }
        defineReactive$$1(ob.value, key, val);
        ob.dep.notify();
        return val;
      }
      function del2(target2, key) {
        if (isUndef2(target2) || isPrimitive2(target2)) {
          warn2("Cannot delete reactive property on undefined, null, or primitive value: " + target2);
        }
        if (Array.isArray(target2) && isValidArrayIndex2(key)) {
          target2.splice(key, 1);
          return;
        }
        var ob = target2.__ob__;
        if (target2._isVue || ob && ob.vmCount) {
          warn2("Avoid deleting properties on a Vue instance or its root $data - just set it to null.");
          return;
        }
        if (!hasOwn2(target2, key)) {
          return;
        }
        delete target2[key];
        if (!ob) {
          return;
        }
        ob.dep.notify();
      }
      function dependArray(value) {
        for (var e = void 0, i = 0, l = value.length; i < l; i++) {
          e = value[i];
          e && e.__ob__ && e.__ob__.dep.depend();
          if (Array.isArray(e)) {
            dependArray(e);
          }
        }
      }
      var strats = config.optionMergeStrategies;
      {
        strats.el = strats.propsData = function(parent, child, vm, key) {
          if (!vm) {
            warn2('option "' + key + '" can only be used during instance creation with the `new` keyword.');
          }
          return defaultStrat(parent, child);
        };
      }
      function mergeData2(to, from) {
        if (!from) {
          return to;
        }
        var key, toVal, fromVal;
        var keys = hasSymbol2 ? Reflect.ownKeys(from) : Object.keys(from);
        for (var i = 0; i < keys.length; i++) {
          key = keys[i];
          if (key === "__ob__") {
            continue;
          }
          toVal = to[key];
          fromVal = from[key];
          if (!hasOwn2(to, key)) {
            set3(to, key, fromVal);
          } else if (toVal !== fromVal && isPlainObject2(toVal) && isPlainObject2(fromVal)) {
            mergeData2(toVal, fromVal);
          }
        }
        return to;
      }
      function mergeDataOrFn(parentVal, childVal, vm) {
        if (!vm) {
          if (!childVal) {
            return parentVal;
          }
          if (!parentVal) {
            return childVal;
          }
          return function mergedDataFn() {
            return mergeData2(typeof childVal === "function" ? childVal.call(this, this) : childVal, typeof parentVal === "function" ? parentVal.call(this, this) : parentVal);
          };
        } else {
          return function mergedInstanceDataFn() {
            var instanceData = typeof childVal === "function" ? childVal.call(vm, vm) : childVal;
            var defaultData = typeof parentVal === "function" ? parentVal.call(vm, vm) : parentVal;
            if (instanceData) {
              return mergeData2(instanceData, defaultData);
            } else {
              return defaultData;
            }
          };
        }
      }
      strats.data = function(parentVal, childVal, vm) {
        if (!vm) {
          if (childVal && typeof childVal !== "function") {
            warn2('The "data" option should be a function that returns a per-instance value in component definitions.', vm);
            return parentVal;
          }
          return mergeDataOrFn(parentVal, childVal);
        }
        return mergeDataOrFn(parentVal, childVal, vm);
      };
      function mergeHook(parentVal, childVal) {
        var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
        return res ? dedupeHooks(res) : res;
      }
      function dedupeHooks(hooks2) {
        var res = [];
        for (var i = 0; i < hooks2.length; i++) {
          if (res.indexOf(hooks2[i]) === -1) {
            res.push(hooks2[i]);
          }
        }
        return res;
      }
      LIFECYCLE_HOOKS.forEach(function(hook) {
        strats[hook] = mergeHook;
      });
      function mergeAssets(parentVal, childVal, vm, key) {
        var res = Object.create(parentVal || null);
        if (childVal) {
          assertObjectType(key, childVal, vm);
          return extend(res, childVal);
        } else {
          return res;
        }
      }
      ASSET_TYPES.forEach(function(type) {
        strats[type + "s"] = mergeAssets;
      });
      strats.watch = function(parentVal, childVal, vm, key) {
        if (parentVal === nativeWatch) {
          parentVal = void 0;
        }
        if (childVal === nativeWatch) {
          childVal = void 0;
        }
        if (!childVal) {
          return Object.create(parentVal || null);
        }
        {
          assertObjectType(key, childVal, vm);
        }
        if (!parentVal) {
          return childVal;
        }
        var ret = {};
        extend(ret, parentVal);
        for (var key$1 in childVal) {
          var parent = ret[key$1];
          var child = childVal[key$1];
          if (parent && !Array.isArray(parent)) {
            parent = [parent];
          }
          ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
        }
        return ret;
      };
      strats.props = strats.methods = strats.inject = strats.computed = function(parentVal, childVal, vm, key) {
        if (childVal && true) {
          assertObjectType(key, childVal, vm);
        }
        if (!parentVal) {
          return childVal;
        }
        var ret = /* @__PURE__ */ Object.create(null);
        extend(ret, parentVal);
        if (childVal) {
          extend(ret, childVal);
        }
        return ret;
      };
      strats.provide = mergeDataOrFn;
      var defaultStrat = function(parentVal, childVal) {
        return childVal === void 0 ? parentVal : childVal;
      };
      function checkComponents(options) {
        for (var key in options.components) {
          validateComponentName(key);
        }
      }
      function validateComponentName(name) {
        if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
          warn2('Invalid component name: "' + name + '". Component names should conform to valid custom element name in html5 specification.');
        }
        if (isBuiltInTag(name) || config.isReservedTag(name)) {
          warn2("Do not use built-in or reserved HTML elements as component id: " + name);
        }
      }
      function normalizeProps(options, vm) {
        var props3 = options.props;
        if (!props3) {
          return;
        }
        var res = {};
        var i, val, name;
        if (Array.isArray(props3)) {
          i = props3.length;
          while (i--) {
            val = props3[i];
            if (typeof val === "string") {
              name = camelize(val);
              res[name] = { type: null };
            } else {
              warn2("props must be strings when using array syntax.");
            }
          }
        } else if (isPlainObject2(props3)) {
          for (var key in props3) {
            val = props3[key];
            name = camelize(key);
            res[name] = isPlainObject2(val) ? val : { type: val };
          }
        } else {
          warn2('Invalid value for option "props": expected an Array or an Object, but got ' + toRawType(props3) + ".", vm);
        }
        options.props = res;
      }
      function normalizeInject(options, vm) {
        var inject2 = options.inject;
        if (!inject2) {
          return;
        }
        var normalized = options.inject = {};
        if (Array.isArray(inject2)) {
          for (var i = 0; i < inject2.length; i++) {
            normalized[inject2[i]] = { from: inject2[i] };
          }
        } else if (isPlainObject2(inject2)) {
          for (var key in inject2) {
            var val = inject2[key];
            normalized[key] = isPlainObject2(val) ? extend({ from: key }, val) : { from: val };
          }
        } else {
          warn2('Invalid value for option "inject": expected an Array or an Object, but got ' + toRawType(inject2) + ".", vm);
        }
      }
      function normalizeDirectives(options) {
        var dirs = options.directives;
        if (dirs) {
          for (var key in dirs) {
            var def$$1 = dirs[key];
            if (typeof def$$1 === "function") {
              dirs[key] = { bind: def$$1, update: def$$1 };
            }
          }
        }
      }
      function assertObjectType(name, value, vm) {
        if (!isPlainObject2(value)) {
          warn2('Invalid value for option "' + name + '": expected an Object, but got ' + toRawType(value) + ".", vm);
        }
      }
      function mergeOptions(parent, child, vm) {
        {
          checkComponents(child);
        }
        if (typeof child === "function") {
          child = child.options;
        }
        normalizeProps(child, vm);
        normalizeInject(child, vm);
        normalizeDirectives(child);
        if (!child._base) {
          if (child.extends) {
            parent = mergeOptions(parent, child.extends, vm);
          }
          if (child.mixins) {
            for (var i = 0, l = child.mixins.length; i < l; i++) {
              parent = mergeOptions(parent, child.mixins[i], vm);
            }
          }
        }
        var options = {};
        var key;
        for (key in parent) {
          mergeField(key);
        }
        for (key in child) {
          if (!hasOwn2(parent, key)) {
            mergeField(key);
          }
        }
        function mergeField(key2) {
          var strat = strats[key2] || defaultStrat;
          options[key2] = strat(parent[key2], child[key2], vm, key2);
        }
        return options;
      }
      function resolveAsset(options, type, id, warnMissing) {
        if (typeof id !== "string") {
          return;
        }
        var assets = options[type];
        if (hasOwn2(assets, id)) {
          return assets[id];
        }
        var camelizedId = camelize(id);
        if (hasOwn2(assets, camelizedId)) {
          return assets[camelizedId];
        }
        var PascalCaseId = capitalize(camelizedId);
        if (hasOwn2(assets, PascalCaseId)) {
          return assets[PascalCaseId];
        }
        var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
        if (warnMissing && !res) {
          warn2("Failed to resolve " + type.slice(0, -1) + ": " + id, options);
        }
        return res;
      }
      function validateProp(key, propOptions, propsData, vm) {
        var prop = propOptions[key];
        var absent = !hasOwn2(propsData, key);
        var value = propsData[key];
        var booleanIndex = getTypeIndex(Boolean, prop.type);
        if (booleanIndex > -1) {
          if (absent && !hasOwn2(prop, "default")) {
            value = false;
          } else if (value === "" || value === hyphenate(key)) {
            var stringIndex = getTypeIndex(String, prop.type);
            if (stringIndex < 0 || booleanIndex < stringIndex) {
              value = true;
            }
          }
        }
        if (value === void 0) {
          value = getPropDefaultValue(vm, prop, key);
          var prevShouldObserve = shouldObserve;
          toggleObserving(true);
          observe2(value);
          toggleObserving(prevShouldObserve);
        }
        {
          assertProp(prop, key, value, vm, absent);
        }
        return value;
      }
      function getPropDefaultValue(vm, prop, key) {
        if (!hasOwn2(prop, "default")) {
          return void 0;
        }
        var def3 = prop.default;
        if (isObject2(def3)) {
          warn2('Invalid default value for prop "' + key + '": Props with type Object/Array must use a factory function to return the default value.', vm);
        }
        if (vm && vm.$options.propsData && vm.$options.propsData[key] === void 0 && vm._props[key] !== void 0) {
          return vm._props[key];
        }
        return typeof def3 === "function" && getType(prop.type) !== "Function" ? def3.call(vm) : def3;
      }
      function assertProp(prop, name, value, vm, absent) {
        if (prop.required && absent) {
          warn2('Missing required prop: "' + name + '"', vm);
          return;
        }
        if (value == null && !prop.required) {
          return;
        }
        var type = prop.type;
        var valid = !type || type === true;
        var expectedTypes = [];
        if (type) {
          if (!Array.isArray(type)) {
            type = [type];
          }
          for (var i = 0; i < type.length && !valid; i++) {
            var assertedType = assertType(value, type[i], vm);
            expectedTypes.push(assertedType.expectedType || "");
            valid = assertedType.valid;
          }
        }
        var haveExpectedTypes = expectedTypes.some(function(t) {
          return t;
        });
        if (!valid && haveExpectedTypes) {
          warn2(getInvalidTypeMessage(name, value, expectedTypes), vm);
          return;
        }
        var validator2 = prop.validator;
        if (validator2) {
          if (!validator2(value)) {
            warn2('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
          }
        }
      }
      var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
      function assertType(value, type, vm) {
        var valid;
        var expectedType = getType(type);
        if (simpleCheckRE.test(expectedType)) {
          var t = typeof value;
          valid = t === expectedType.toLowerCase();
          if (!valid && t === "object") {
            valid = value instanceof type;
          }
        } else if (expectedType === "Object") {
          valid = isPlainObject2(value);
        } else if (expectedType === "Array") {
          valid = Array.isArray(value);
        } else {
          try {
            valid = value instanceof type;
          } catch (e) {
            warn2('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
            valid = false;
          }
        }
        return {
          valid,
          expectedType
        };
      }
      var functionTypeCheckRE = /^\s*function (\w+)/;
      function getType(fn) {
        var match = fn && fn.toString().match(functionTypeCheckRE);
        return match ? match[1] : "";
      }
      function isSameType(a, b) {
        return getType(a) === getType(b);
      }
      function getTypeIndex(type, expectedTypes) {
        if (!Array.isArray(expectedTypes)) {
          return isSameType(expectedTypes, type) ? 0 : -1;
        }
        for (var i = 0, len = expectedTypes.length; i < len; i++) {
          if (isSameType(expectedTypes[i], type)) {
            return i;
          }
        }
        return -1;
      }
      function getInvalidTypeMessage(name, value, expectedTypes) {
        var message = 'Invalid prop: type check failed for prop "' + name + '". Expected ' + expectedTypes.map(capitalize).join(", ");
        var expectedType = expectedTypes[0];
        var receivedType = toRawType(value);
        if (expectedTypes.length === 1 && isExplicable(expectedType) && isExplicable(typeof value) && !isBoolean(expectedType, receivedType)) {
          message += " with value " + styleValue(value, expectedType);
        }
        message += ", got " + receivedType + " ";
        if (isExplicable(receivedType)) {
          message += "with value " + styleValue(value, receivedType) + ".";
        }
        return message;
      }
      function styleValue(value, type) {
        if (type === "String") {
          return '"' + value + '"';
        } else if (type === "Number") {
          return "" + Number(value);
        } else {
          return "" + value;
        }
      }
      var EXPLICABLE_TYPES = ["string", "number", "boolean"];
      function isExplicable(value) {
        return EXPLICABLE_TYPES.some(function(elem) {
          return value.toLowerCase() === elem;
        });
      }
      function isBoolean() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        return args.some(function(elem) {
          return elem.toLowerCase() === "boolean";
        });
      }
      function handleError(err, vm, info) {
        pushTarget();
        try {
          if (vm) {
            var cur = vm;
            while (cur = cur.$parent) {
              var hooks2 = cur.$options.errorCaptured;
              if (hooks2) {
                for (var i = 0; i < hooks2.length; i++) {
                  try {
                    var capture = hooks2[i].call(cur, err, vm, info) === false;
                    if (capture) {
                      return;
                    }
                  } catch (e) {
                    globalHandleError(e, cur, "errorCaptured hook");
                  }
                }
              }
            }
          }
          globalHandleError(err, vm, info);
        } finally {
          popTarget();
        }
      }
      function invokeWithErrorHandling(handler2, context, args, vm, info) {
        var res;
        try {
          res = args ? handler2.apply(context, args) : handler2.call(context);
          if (res && !res._isVue && isPromise(res) && !res._handled) {
            res.catch(function(e) {
              return handleError(e, vm, info + " (Promise/async)");
            });
            res._handled = true;
          }
        } catch (e) {
          handleError(e, vm, info);
        }
        return res;
      }
      function globalHandleError(err, vm, info) {
        if (config.errorHandler) {
          try {
            return config.errorHandler.call(null, err, vm, info);
          } catch (e) {
            if (e !== err) {
              logError2(e, null, "config.errorHandler");
            }
          }
        }
        logError2(err, vm, info);
      }
      function logError2(err, vm, info) {
        {
          warn2("Error in " + info + ': "' + err.toString() + '"', vm);
        }
        if ((inBrowser || inWeex) && typeof console !== "undefined") {
          console.error(err);
        } else {
          throw err;
        }
      }
      var isUsingMicroTask = false;
      var callbacks = [];
      var pending = false;
      function flushCallbacks() {
        pending = false;
        var copies = callbacks.slice(0);
        callbacks.length = 0;
        for (var i = 0; i < copies.length; i++) {
          copies[i]();
        }
      }
      var timerFunc;
      if (typeof Promise !== "undefined" && isNative2(Promise)) {
        p = Promise.resolve();
        timerFunc = function() {
          p.then(flushCallbacks);
          if (isIOS) {
            setTimeout(noop);
          }
        };
        isUsingMicroTask = true;
      } else if (!isIE && typeof MutationObserver !== "undefined" && (isNative2(MutationObserver) || MutationObserver.toString() === "[object MutationObserverConstructor]")) {
        counter = 1;
        observer = new MutationObserver(flushCallbacks);
        textNode = document.createTextNode(String(counter));
        observer.observe(textNode, {
          characterData: true
        });
        timerFunc = function() {
          counter = (counter + 1) % 2;
          textNode.data = String(counter);
        };
        isUsingMicroTask = true;
      } else if (typeof setImmediate !== "undefined" && isNative2(setImmediate)) {
        timerFunc = function() {
          setImmediate(flushCallbacks);
        };
      } else {
        timerFunc = function() {
          setTimeout(flushCallbacks, 0);
        };
      }
      var p;
      var counter;
      var observer;
      var textNode;
      function nextTick2(cb, ctx) {
        var _resolve;
        callbacks.push(function() {
          if (cb) {
            try {
              cb.call(ctx);
            } catch (e) {
              handleError(e, ctx, "nextTick");
            }
          } else if (_resolve) {
            _resolve(ctx);
          }
        });
        if (!pending) {
          pending = true;
          timerFunc();
        }
        if (!cb && typeof Promise !== "undefined") {
          return new Promise(function(resolve) {
            _resolve = resolve;
          });
        }
      }
      var initProxy;
      {
        allowedGlobals = makeMap("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,require");
        warnNonPresent = function(target2, key) {
          warn2('Property or method "' + key + '" is not defined on the instance but referenced during render. Make sure that this property is reactive, either in the data option, or for class-based components, by initializing the property. See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target2);
        };
        warnReservedPrefix = function(target2, key) {
          warn2('Property "' + key + '" must be accessed with "$data.' + key + '" because properties starting with "$" or "_" are not proxied in the Vue instance to prevent conflicts with Vue internals. See: https://vuejs.org/v2/api/#data', target2);
        };
        hasProxy = typeof Proxy !== "undefined" && isNative2(Proxy);
        if (hasProxy) {
          isBuiltInModifier = makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact");
          config.keyCodes = new Proxy(config.keyCodes, {
            set: function set4(target2, key, value) {
              if (isBuiltInModifier(key)) {
                warn2("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
                return false;
              } else {
                target2[key] = value;
                return true;
              }
            }
          });
        }
        hasHandler = {
          has: function has2(target2, key) {
            var has3 = key in target2;
            var isAllowed = allowedGlobals(key) || typeof key === "string" && key.charAt(0) === "_" && !(key in target2.$data);
            if (!has3 && !isAllowed) {
              if (key in target2.$data) {
                warnReservedPrefix(target2, key);
              } else {
                warnNonPresent(target2, key);
              }
            }
            return has3 || !isAllowed;
          }
        };
        getHandler = {
          get: function get2(target2, key) {
            if (typeof key === "string" && !(key in target2)) {
              if (key in target2.$data) {
                warnReservedPrefix(target2, key);
              } else {
                warnNonPresent(target2, key);
              }
            }
            return target2[key];
          }
        };
        initProxy = function initProxy2(vm) {
          if (hasProxy) {
            var options = vm.$options;
            var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
            vm._renderProxy = new Proxy(vm, handlers);
          } else {
            vm._renderProxy = vm;
          }
        };
      }
      var allowedGlobals;
      var warnNonPresent;
      var warnReservedPrefix;
      var hasProxy;
      var isBuiltInModifier;
      var hasHandler;
      var getHandler;
      var seenObjects = new _Set();
      function traverse2(val) {
        _traverse(val, seenObjects);
        seenObjects.clear();
      }
      function _traverse(val, seen) {
        var i, keys;
        var isA = Array.isArray(val);
        if (!isA && !isObject2(val) || Object.isFrozen(val) || val instanceof VNode) {
          return;
        }
        if (val.__ob__) {
          var depId = val.__ob__.dep.id;
          if (seen.has(depId)) {
            return;
          }
          seen.add(depId);
        }
        if (isA) {
          i = val.length;
          while (i--) {
            _traverse(val[i], seen);
          }
        } else {
          keys = Object.keys(val);
          i = keys.length;
          while (i--) {
            _traverse(val[keys[i]], seen);
          }
        }
      }
      var mark;
      var measure;
      {
        perf = inBrowser && window.performance;
        if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
          mark = function(tag) {
            return perf.mark(tag);
          };
          measure = function(name, startTag, endTag) {
            perf.measure(name, startTag, endTag);
            perf.clearMarks(startTag);
            perf.clearMarks(endTag);
          };
        }
      }
      var perf;
      var normalizeEvent = cached(function(name) {
        var passive = name.charAt(0) === "&";
        name = passive ? name.slice(1) : name;
        var once$$1 = name.charAt(0) === "~";
        name = once$$1 ? name.slice(1) : name;
        var capture = name.charAt(0) === "!";
        name = capture ? name.slice(1) : name;
        return {
          name,
          once: once$$1,
          capture,
          passive
        };
      });
      function createFnInvoker(fns, vm) {
        function invoker() {
          var arguments$1 = arguments;
          var fns2 = invoker.fns;
          if (Array.isArray(fns2)) {
            var cloned = fns2.slice();
            for (var i = 0; i < cloned.length; i++) {
              invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
            }
          } else {
            return invokeWithErrorHandling(fns2, null, arguments, vm, "v-on handler");
          }
        }
        invoker.fns = fns;
        return invoker;
      }
      function updateListeners(on, oldOn, add2, remove$$1, createOnceHandler2, vm) {
        var name, def$$1, cur, old, event;
        for (name in on) {
          def$$1 = cur = on[name];
          old = oldOn[name];
          event = normalizeEvent(name);
          if (isUndef2(cur)) {
            warn2('Invalid handler for event "' + event.name + '": got ' + String(cur), vm);
          } else if (isUndef2(old)) {
            if (isUndef2(cur.fns)) {
              cur = on[name] = createFnInvoker(cur, vm);
            }
            if (isTrue(event.once)) {
              cur = on[name] = createOnceHandler2(event.name, cur, event.capture);
            }
            add2(event.name, cur, event.capture, event.passive, event.params);
          } else if (cur !== old) {
            old.fns = cur;
            on[name] = old;
          }
        }
        for (name in oldOn) {
          if (isUndef2(on[name])) {
            event = normalizeEvent(name);
            remove$$1(event.name, oldOn[name], event.capture);
          }
        }
      }
      function mergeVNodeHook(def3, hookKey, hook) {
        if (def3 instanceof VNode) {
          def3 = def3.data.hook || (def3.data.hook = {});
        }
        var invoker;
        var oldHook = def3[hookKey];
        function wrappedHook() {
          hook.apply(this, arguments);
          remove(invoker.fns, wrappedHook);
        }
        if (isUndef2(oldHook)) {
          invoker = createFnInvoker([wrappedHook]);
        } else {
          if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
            invoker = oldHook;
            invoker.fns.push(wrappedHook);
          } else {
            invoker = createFnInvoker([oldHook, wrappedHook]);
          }
        }
        invoker.merged = true;
        def3[hookKey] = invoker;
      }
      function extractPropsFromVNodeData(data2, Ctor, tag) {
        var propOptions = Ctor.options.props;
        if (isUndef2(propOptions)) {
          return;
        }
        var res = {};
        var attrs2 = data2.attrs;
        var props3 = data2.props;
        if (isDef(attrs2) || isDef(props3)) {
          for (var key in propOptions) {
            var altKey = hyphenate(key);
            {
              var keyInLowerCase = key.toLowerCase();
              if (key !== keyInLowerCase && attrs2 && hasOwn2(attrs2, keyInLowerCase)) {
                tip('Prop "' + keyInLowerCase + '" is passed to component ' + formatComponentName(tag || Ctor) + ', but the declared prop name is "' + key + '". Note that HTML attributes are case-insensitive and camelCased props need to use their kebab-case equivalents when using in-DOM templates. You should probably use "' + altKey + '" instead of "' + key + '".');
              }
            }
            checkProp(res, props3, key, altKey, true) || checkProp(res, attrs2, key, altKey, false);
          }
        }
        return res;
      }
      function checkProp(res, hash, key, altKey, preserve) {
        if (isDef(hash)) {
          if (hasOwn2(hash, key)) {
            res[key] = hash[key];
            if (!preserve) {
              delete hash[key];
            }
            return true;
          } else if (hasOwn2(hash, altKey)) {
            res[key] = hash[altKey];
            if (!preserve) {
              delete hash[altKey];
            }
            return true;
          }
        }
        return false;
      }
      function simpleNormalizeChildren(children) {
        for (var i = 0; i < children.length; i++) {
          if (Array.isArray(children[i])) {
            return Array.prototype.concat.apply([], children);
          }
        }
        return children;
      }
      function normalizeChildren(children) {
        return isPrimitive2(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : void 0;
      }
      function isTextNode(node) {
        return isDef(node) && isDef(node.text) && isFalse(node.isComment);
      }
      function normalizeArrayChildren(children, nestedIndex) {
        var res = [];
        var i, c, lastIndex, last;
        for (i = 0; i < children.length; i++) {
          c = children[i];
          if (isUndef2(c) || typeof c === "boolean") {
            continue;
          }
          lastIndex = res.length - 1;
          last = res[lastIndex];
          if (Array.isArray(c)) {
            if (c.length > 0) {
              c = normalizeArrayChildren(c, (nestedIndex || "") + "_" + i);
              if (isTextNode(c[0]) && isTextNode(last)) {
                res[lastIndex] = createTextVNode(last.text + c[0].text);
                c.shift();
              }
              res.push.apply(res, c);
            }
          } else if (isPrimitive2(c)) {
            if (isTextNode(last)) {
              res[lastIndex] = createTextVNode(last.text + c);
            } else if (c !== "") {
              res.push(createTextVNode(c));
            }
          } else {
            if (isTextNode(c) && isTextNode(last)) {
              res[lastIndex] = createTextVNode(last.text + c.text);
            } else {
              if (isTrue(children._isVList) && isDef(c.tag) && isUndef2(c.key) && isDef(nestedIndex)) {
                c.key = "__vlist" + nestedIndex + "_" + i + "__";
              }
              res.push(c);
            }
          }
        }
        return res;
      }
      function initProvide(vm) {
        var provide2 = vm.$options.provide;
        if (provide2) {
          vm._provided = typeof provide2 === "function" ? provide2.call(vm) : provide2;
        }
      }
      function initInjections(vm) {
        var result = resolveInject(vm.$options.inject, vm);
        if (result) {
          toggleObserving(false);
          Object.keys(result).forEach(function(key) {
            {
              defineReactive$$1(vm, key, result[key], function() {
                warn2('Avoid mutating an injected value directly since the changes will be overwritten whenever the provided component re-renders. injection being mutated: "' + key + '"', vm);
              });
            }
          });
          toggleObserving(true);
        }
      }
      function resolveInject(inject2, vm) {
        if (inject2) {
          var result = /* @__PURE__ */ Object.create(null);
          var keys = hasSymbol2 ? Reflect.ownKeys(inject2) : Object.keys(inject2);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key === "__ob__") {
              continue;
            }
            var provideKey = inject2[key].from;
            var source = vm;
            while (source) {
              if (source._provided && hasOwn2(source._provided, provideKey)) {
                result[key] = source._provided[provideKey];
                break;
              }
              source = source.$parent;
            }
            if (!source) {
              if ("default" in inject2[key]) {
                var provideDefault = inject2[key].default;
                result[key] = typeof provideDefault === "function" ? provideDefault.call(vm) : provideDefault;
              } else {
                warn2('Injection "' + key + '" not found', vm);
              }
            }
          }
          return result;
        }
      }
      function resolveSlots2(children, context) {
        if (!children || !children.length) {
          return {};
        }
        var slots = {};
        for (var i = 0, l = children.length; i < l; i++) {
          var child = children[i];
          var data2 = child.data;
          if (data2 && data2.attrs && data2.attrs.slot) {
            delete data2.attrs.slot;
          }
          if ((child.context === context || child.fnContext === context) && data2 && data2.slot != null) {
            var name = data2.slot;
            var slot = slots[name] || (slots[name] = []);
            if (child.tag === "template") {
              slot.push.apply(slot, child.children || []);
            } else {
              slot.push(child);
            }
          } else {
            (slots.default || (slots.default = [])).push(child);
          }
        }
        for (var name$1 in slots) {
          if (slots[name$1].every(isWhitespace)) {
            delete slots[name$1];
          }
        }
        return slots;
      }
      function isWhitespace(node) {
        return node.isComment && !node.asyncFactory || node.text === " ";
      }
      function isAsyncPlaceholder(node) {
        return node.isComment && node.asyncFactory;
      }
      function normalizeScopedSlots(slots, normalSlots, prevSlots) {
        var res;
        var hasNormalSlots = Object.keys(normalSlots).length > 0;
        var isStable = slots ? !!slots.$stable : !hasNormalSlots;
        var key = slots && slots.$key;
        if (!slots) {
          res = {};
        } else if (slots._normalized) {
          return slots._normalized;
        } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
          return prevSlots;
        } else {
          res = {};
          for (var key$1 in slots) {
            if (slots[key$1] && key$1[0] !== "$") {
              res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
            }
          }
        }
        for (var key$2 in normalSlots) {
          if (!(key$2 in res)) {
            res[key$2] = proxyNormalSlot(normalSlots, key$2);
          }
        }
        if (slots && Object.isExtensible(slots)) {
          slots._normalized = res;
        }
        def2(res, "$stable", isStable);
        def2(res, "$key", key);
        def2(res, "$hasNormal", hasNormalSlots);
        return res;
      }
      function normalizeScopedSlot(normalSlots, key, fn) {
        var normalized = function() {
          var res = arguments.length ? fn.apply(null, arguments) : fn({});
          res = res && typeof res === "object" && !Array.isArray(res) ? [res] : normalizeChildren(res);
          var vnode = res && res[0];
          return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) ? void 0 : res;
        };
        if (fn.proxy) {
          Object.defineProperty(normalSlots, key, {
            get: normalized,
            enumerable: true,
            configurable: true
          });
        }
        return normalized;
      }
      function proxyNormalSlot(slots, key) {
        return function() {
          return slots[key];
        };
      }
      function renderList(val, render2) {
        var ret, i, l, keys, key;
        if (Array.isArray(val) || typeof val === "string") {
          ret = new Array(val.length);
          for (i = 0, l = val.length; i < l; i++) {
            ret[i] = render2(val[i], i);
          }
        } else if (typeof val === "number") {
          ret = new Array(val);
          for (i = 0; i < val; i++) {
            ret[i] = render2(i + 1, i);
          }
        } else if (isObject2(val)) {
          if (hasSymbol2 && val[Symbol.iterator]) {
            ret = [];
            var iterator = val[Symbol.iterator]();
            var result = iterator.next();
            while (!result.done) {
              ret.push(render2(result.value, ret.length));
              result = iterator.next();
            }
          } else {
            keys = Object.keys(val);
            ret = new Array(keys.length);
            for (i = 0, l = keys.length; i < l; i++) {
              key = keys[i];
              ret[i] = render2(val[key], key, i);
            }
          }
        }
        if (!isDef(ret)) {
          ret = [];
        }
        ret._isVList = true;
        return ret;
      }
      function renderSlot(name, fallbackRender, props3, bindObject) {
        var scopedSlotFn = this.$scopedSlots[name];
        var nodes;
        if (scopedSlotFn) {
          props3 = props3 || {};
          if (bindObject) {
            if (!isObject2(bindObject)) {
              warn2("slot v-bind without argument expects an Object", this);
            }
            props3 = extend(extend({}, bindObject), props3);
          }
          nodes = scopedSlotFn(props3) || (typeof fallbackRender === "function" ? fallbackRender() : fallbackRender);
        } else {
          nodes = this.$slots[name] || (typeof fallbackRender === "function" ? fallbackRender() : fallbackRender);
        }
        var target2 = props3 && props3.slot;
        if (target2) {
          return this.$createElement("template", { slot: target2 }, nodes);
        } else {
          return nodes;
        }
      }
      function resolveFilter(id) {
        return resolveAsset(this.$options, "filters", id, true) || identity;
      }
      function isKeyNotMatch(expect, actual) {
        if (Array.isArray(expect)) {
          return expect.indexOf(actual) === -1;
        } else {
          return expect !== actual;
        }
      }
      function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
        var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
        if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
          return isKeyNotMatch(builtInKeyName, eventKeyName);
        } else if (mappedKeyCode) {
          return isKeyNotMatch(mappedKeyCode, eventKeyCode);
        } else if (eventKeyName) {
          return hyphenate(eventKeyName) !== key;
        }
        return eventKeyCode === void 0;
      }
      function bindObjectProps(data2, tag, value, asProp, isSync) {
        if (value) {
          if (!isObject2(value)) {
            warn2("v-bind without argument expects an Object or Array value", this);
          } else {
            if (Array.isArray(value)) {
              value = toObject(value);
            }
            var hash;
            var loop = function(key2) {
              if (key2 === "class" || key2 === "style" || isReservedAttribute(key2)) {
                hash = data2;
              } else {
                var type = data2.attrs && data2.attrs.type;
                hash = asProp || config.mustUseProp(tag, type, key2) ? data2.domProps || (data2.domProps = {}) : data2.attrs || (data2.attrs = {});
              }
              var camelizedKey = camelize(key2);
              var hyphenatedKey = hyphenate(key2);
              if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
                hash[key2] = value[key2];
                if (isSync) {
                  var on = data2.on || (data2.on = {});
                  on["update:" + key2] = function($event) {
                    value[key2] = $event;
                  };
                }
              }
            };
            for (var key in value)
              loop(key);
          }
        }
        return data2;
      }
      function renderStatic(index2, isInFor) {
        var cached2 = this._staticTrees || (this._staticTrees = []);
        var tree = cached2[index2];
        if (tree && !isInFor) {
          return tree;
        }
        tree = cached2[index2] = this.$options.staticRenderFns[index2].call(this._renderProxy, null, this);
        markStatic(tree, "__static__" + index2, false);
        return tree;
      }
      function markOnce(tree, index2, key) {
        markStatic(tree, "__once__" + index2 + (key ? "_" + key : ""), true);
        return tree;
      }
      function markStatic(tree, key, isOnce) {
        if (Array.isArray(tree)) {
          for (var i = 0; i < tree.length; i++) {
            if (tree[i] && typeof tree[i] !== "string") {
              markStaticNode(tree[i], key + "_" + i, isOnce);
            }
          }
        } else {
          markStaticNode(tree, key, isOnce);
        }
      }
      function markStaticNode(node, key, isOnce) {
        node.isStatic = true;
        node.key = key;
        node.isOnce = isOnce;
      }
      function bindObjectListeners(data2, value) {
        if (value) {
          if (!isPlainObject2(value)) {
            warn2("v-on without argument expects an Object value", this);
          } else {
            var on = data2.on = data2.on ? extend({}, data2.on) : {};
            for (var key in value) {
              var existing = on[key];
              var ours = value[key];
              on[key] = existing ? [].concat(existing, ours) : ours;
            }
          }
        }
        return data2;
      }
      function resolveScopedSlots2(fns, res, hasDynamicKeys, contentHashKey) {
        res = res || { $stable: !hasDynamicKeys };
        for (var i = 0; i < fns.length; i++) {
          var slot = fns[i];
          if (Array.isArray(slot)) {
            resolveScopedSlots2(slot, res, hasDynamicKeys);
          } else if (slot) {
            if (slot.proxy) {
              slot.fn.proxy = true;
            }
            res[slot.key] = slot.fn;
          }
        }
        if (contentHashKey) {
          res.$key = contentHashKey;
        }
        return res;
      }
      function bindDynamicKeys(baseObj, values) {
        for (var i = 0; i < values.length; i += 2) {
          var key = values[i];
          if (typeof key === "string" && key) {
            baseObj[values[i]] = values[i + 1];
          } else if (key !== "" && key !== null) {
            warn2("Invalid value for dynamic directive argument (expected string or null): " + key, this);
          }
        }
        return baseObj;
      }
      function prependModifier(value, symbol) {
        return typeof value === "string" ? symbol + value : value;
      }
      function installRenderHelpers(target2) {
        target2._o = markOnce;
        target2._n = toNumber;
        target2._s = toString2;
        target2._l = renderList;
        target2._t = renderSlot;
        target2._q = looseEqual;
        target2._i = looseIndexOf;
        target2._m = renderStatic;
        target2._f = resolveFilter;
        target2._k = checkKeyCodes;
        target2._b = bindObjectProps;
        target2._v = createTextVNode;
        target2._e = createEmptyVNode;
        target2._u = resolveScopedSlots2;
        target2._g = bindObjectListeners;
        target2._d = bindDynamicKeys;
        target2._p = prependModifier;
      }
      function FunctionalRenderContext(data2, props3, children, parent, Ctor) {
        var this$1 = this;
        var options = Ctor.options;
        var contextVm;
        if (hasOwn2(parent, "_uid")) {
          contextVm = Object.create(parent);
          contextVm._original = parent;
        } else {
          contextVm = parent;
          parent = parent._original;
        }
        var isCompiled = isTrue(options._compiled);
        var needNormalization = !isCompiled;
        this.data = data2;
        this.props = props3;
        this.children = children;
        this.parent = parent;
        this.listeners = data2.on || emptyObject;
        this.injections = resolveInject(options.inject, parent);
        this.slots = function() {
          if (!this$1.$slots) {
            normalizeScopedSlots(data2.scopedSlots, this$1.$slots = resolveSlots2(children, parent));
          }
          return this$1.$slots;
        };
        Object.defineProperty(this, "scopedSlots", {
          enumerable: true,
          get: function get2() {
            return normalizeScopedSlots(data2.scopedSlots, this.slots());
          }
        });
        if (isCompiled) {
          this.$options = options;
          this.$slots = this.slots();
          this.$scopedSlots = normalizeScopedSlots(data2.scopedSlots, this.$slots);
        }
        if (options._scopeId) {
          this._c = function(a, b, c, d) {
            var vnode = createElement3(contextVm, a, b, c, d, needNormalization);
            if (vnode && !Array.isArray(vnode)) {
              vnode.fnScopeId = options._scopeId;
              vnode.fnContext = parent;
            }
            return vnode;
          };
        } else {
          this._c = function(a, b, c, d) {
            return createElement3(contextVm, a, b, c, d, needNormalization);
          };
        }
      }
      installRenderHelpers(FunctionalRenderContext.prototype);
      function createFunctionalComponent(Ctor, propsData, data2, contextVm, children) {
        var options = Ctor.options;
        var props3 = {};
        var propOptions = options.props;
        if (isDef(propOptions)) {
          for (var key in propOptions) {
            props3[key] = validateProp(key, propOptions, propsData || emptyObject);
          }
        } else {
          if (isDef(data2.attrs)) {
            mergeProps(props3, data2.attrs);
          }
          if (isDef(data2.props)) {
            mergeProps(props3, data2.props);
          }
        }
        var renderContext = new FunctionalRenderContext(data2, props3, children, contextVm, Ctor);
        var vnode = options.render.call(null, renderContext._c, renderContext);
        if (vnode instanceof VNode) {
          return cloneAndMarkFunctionalResult(vnode, data2, renderContext.parent, options, renderContext);
        } else if (Array.isArray(vnode)) {
          var vnodes = normalizeChildren(vnode) || [];
          var res = new Array(vnodes.length);
          for (var i = 0; i < vnodes.length; i++) {
            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data2, renderContext.parent, options, renderContext);
          }
          return res;
        }
      }
      function cloneAndMarkFunctionalResult(vnode, data2, contextVm, options, renderContext) {
        var clone = cloneVNode(vnode);
        clone.fnContext = contextVm;
        clone.fnOptions = options;
        {
          (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
        }
        if (data2.slot) {
          (clone.data || (clone.data = {})).slot = data2.slot;
        }
        return clone;
      }
      function mergeProps(to, from) {
        for (var key in from) {
          to[camelize(key)] = from[key];
        }
      }
      var componentVNodeHooks = {
        init: function init(vnode, hydrating) {
          if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
            var mountedNode = vnode;
            componentVNodeHooks.prepatch(mountedNode, mountedNode);
          } else {
            var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
            child.$mount(hydrating ? vnode.elm : void 0, hydrating);
          }
        },
        prepatch: function prepatch(oldVnode, vnode) {
          var options = vnode.componentOptions;
          var child = vnode.componentInstance = oldVnode.componentInstance;
          updateChildComponent(child, options.propsData, options.listeners, vnode, options.children);
        },
        insert: function insert(vnode) {
          var context = vnode.context;
          var componentInstance = vnode.componentInstance;
          if (!componentInstance._isMounted) {
            componentInstance._isMounted = true;
            callHook(componentInstance, "mounted");
          }
          if (vnode.data.keepAlive) {
            if (context._isMounted) {
              queueActivatedComponent(componentInstance);
            } else {
              activateChildComponent(componentInstance, true);
            }
          }
        },
        destroy: function destroy(vnode) {
          var componentInstance = vnode.componentInstance;
          if (!componentInstance._isDestroyed) {
            if (!vnode.data.keepAlive) {
              componentInstance.$destroy();
            } else {
              deactivateChildComponent(componentInstance, true);
            }
          }
        }
      };
      var hooksToMerge = Object.keys(componentVNodeHooks);
      function createComponent(Ctor, data2, context, children, tag) {
        if (isUndef2(Ctor)) {
          return;
        }
        var baseCtor = context.$options._base;
        if (isObject2(Ctor)) {
          Ctor = baseCtor.extend(Ctor);
        }
        if (typeof Ctor !== "function") {
          {
            warn2("Invalid Component definition: " + String(Ctor), context);
          }
          return;
        }
        var asyncFactory;
        if (isUndef2(Ctor.cid)) {
          asyncFactory = Ctor;
          Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
          if (Ctor === void 0) {
            return createAsyncPlaceholder(asyncFactory, data2, context, children, tag);
          }
        }
        data2 = data2 || {};
        resolveConstructorOptions(Ctor);
        if (isDef(data2.model)) {
          transformModel(Ctor.options, data2);
        }
        var propsData = extractPropsFromVNodeData(data2, Ctor, tag);
        if (isTrue(Ctor.options.functional)) {
          return createFunctionalComponent(Ctor, propsData, data2, context, children);
        }
        var listeners = data2.on;
        data2.on = data2.nativeOn;
        if (isTrue(Ctor.options.abstract)) {
          var slot = data2.slot;
          data2 = {};
          if (slot) {
            data2.slot = slot;
          }
        }
        installComponentHooks(data2);
        var name = Ctor.options.name || tag;
        var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ""), data2, void 0, void 0, void 0, context, { Ctor, propsData, listeners, tag, children }, asyncFactory);
        return vnode;
      }
      function createComponentInstanceForVnode(vnode, parent) {
        var options = {
          _isComponent: true,
          _parentVnode: vnode,
          parent
        };
        var inlineTemplate = vnode.data.inlineTemplate;
        if (isDef(inlineTemplate)) {
          options.render = inlineTemplate.render;
          options.staticRenderFns = inlineTemplate.staticRenderFns;
        }
        return new vnode.componentOptions.Ctor(options);
      }
      function installComponentHooks(data2) {
        var hooks2 = data2.hook || (data2.hook = {});
        for (var i = 0; i < hooksToMerge.length; i++) {
          var key = hooksToMerge[i];
          var existing = hooks2[key];
          var toMerge = componentVNodeHooks[key];
          if (existing !== toMerge && !(existing && existing._merged)) {
            hooks2[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
          }
        }
      }
      function mergeHook$1(f1, f2) {
        var merged = function(a, b) {
          f1(a, b);
          f2(a, b);
        };
        merged._merged = true;
        return merged;
      }
      function transformModel(options, data2) {
        var prop = options.model && options.model.prop || "value";
        var event = options.model && options.model.event || "input";
        (data2.attrs || (data2.attrs = {}))[prop] = data2.model.value;
        var on = data2.on || (data2.on = {});
        var existing = on[event];
        var callback = data2.model.callback;
        if (isDef(existing)) {
          if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
            on[event] = [callback].concat(existing);
          }
        } else {
          on[event] = callback;
        }
      }
      var SIMPLE_NORMALIZE = 1;
      var ALWAYS_NORMALIZE = 2;
      function createElement3(context, tag, data2, children, normalizationType, alwaysNormalize) {
        if (Array.isArray(data2) || isPrimitive2(data2)) {
          normalizationType = children;
          children = data2;
          data2 = void 0;
        }
        if (isTrue(alwaysNormalize)) {
          normalizationType = ALWAYS_NORMALIZE;
        }
        return _createElement(context, tag, data2, children, normalizationType);
      }
      function _createElement(context, tag, data2, children, normalizationType) {
        if (isDef(data2) && isDef(data2.__ob__)) {
          warn2("Avoid using observed data object as vnode data: " + JSON.stringify(data2) + "\nAlways create fresh vnode data objects in each render!", context);
          return createEmptyVNode();
        }
        if (isDef(data2) && isDef(data2.is)) {
          tag = data2.is;
        }
        if (!tag) {
          return createEmptyVNode();
        }
        if (isDef(data2) && isDef(data2.key) && !isPrimitive2(data2.key)) {
          {
            warn2("Avoid using non-primitive value as key, use string/number value instead.", context);
          }
        }
        if (Array.isArray(children) && typeof children[0] === "function") {
          data2 = data2 || {};
          data2.scopedSlots = { default: children[0] };
          children.length = 0;
        }
        if (normalizationType === ALWAYS_NORMALIZE) {
          children = normalizeChildren(children);
        } else if (normalizationType === SIMPLE_NORMALIZE) {
          children = simpleNormalizeChildren(children);
        }
        var vnode, ns;
        if (typeof tag === "string") {
          var Ctor;
          ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
          if (config.isReservedTag(tag)) {
            if (isDef(data2) && isDef(data2.nativeOn) && data2.tag !== "component") {
              warn2("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">.", context);
            }
            vnode = new VNode(config.parsePlatformTagName(tag), data2, children, void 0, void 0, context);
          } else if ((!data2 || !data2.pre) && isDef(Ctor = resolveAsset(context.$options, "components", tag))) {
            vnode = createComponent(Ctor, data2, context, children, tag);
          } else {
            vnode = new VNode(tag, data2, children, void 0, void 0, context);
          }
        } else {
          vnode = createComponent(tag, data2, context, children);
        }
        if (Array.isArray(vnode)) {
          return vnode;
        } else if (isDef(vnode)) {
          if (isDef(ns)) {
            applyNS(vnode, ns);
          }
          if (isDef(data2)) {
            registerDeepBindings(data2);
          }
          return vnode;
        } else {
          return createEmptyVNode();
        }
      }
      function applyNS(vnode, ns, force) {
        vnode.ns = ns;
        if (vnode.tag === "foreignObject") {
          ns = void 0;
          force = true;
        }
        if (isDef(vnode.children)) {
          for (var i = 0, l = vnode.children.length; i < l; i++) {
            var child = vnode.children[i];
            if (isDef(child.tag) && (isUndef2(child.ns) || isTrue(force) && child.tag !== "svg")) {
              applyNS(child, ns, force);
            }
          }
        }
      }
      function registerDeepBindings(data2) {
        if (isObject2(data2.style)) {
          traverse2(data2.style);
        }
        if (isObject2(data2.class)) {
          traverse2(data2.class);
        }
      }
      function initRender(vm) {
        vm._vnode = null;
        vm._staticTrees = null;
        var options = vm.$options;
        var parentVnode = vm.$vnode = options._parentVnode;
        var renderContext = parentVnode && parentVnode.context;
        vm.$slots = resolveSlots2(options._renderChildren, renderContext);
        vm.$scopedSlots = emptyObject;
        vm._c = function(a, b, c, d) {
          return createElement3(vm, a, b, c, d, false);
        };
        vm.$createElement = function(a, b, c, d) {
          return createElement3(vm, a, b, c, d, true);
        };
        var parentData = parentVnode && parentVnode.data;
        {
          defineReactive$$1(vm, "$attrs", parentData && parentData.attrs || emptyObject, function() {
            !isUpdatingChildComponent && warn2("$attrs is readonly.", vm);
          }, true);
          defineReactive$$1(vm, "$listeners", options._parentListeners || emptyObject, function() {
            !isUpdatingChildComponent && warn2("$listeners is readonly.", vm);
          }, true);
        }
      }
      var currentRenderingInstance = null;
      function renderMixin(Vue5) {
        installRenderHelpers(Vue5.prototype);
        Vue5.prototype.$nextTick = function(fn) {
          return nextTick2(fn, this);
        };
        Vue5.prototype._render = function() {
          var vm = this;
          var ref3 = vm.$options;
          var render2 = ref3.render;
          var _parentVnode = ref3._parentVnode;
          if (_parentVnode) {
            vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
          }
          vm.$vnode = _parentVnode;
          var vnode;
          try {
            currentRenderingInstance = vm;
            vnode = render2.call(vm._renderProxy, vm.$createElement);
          } catch (e) {
            handleError(e, vm, "render");
            if (vm.$options.renderError) {
              try {
                vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
              } catch (e2) {
                handleError(e2, vm, "renderError");
                vnode = vm._vnode;
              }
            } else {
              vnode = vm._vnode;
            }
          } finally {
            currentRenderingInstance = null;
          }
          if (Array.isArray(vnode) && vnode.length === 1) {
            vnode = vnode[0];
          }
          if (!(vnode instanceof VNode)) {
            if (Array.isArray(vnode)) {
              warn2("Multiple root nodes returned from render function. Render function should return a single root node.", vm);
            }
            vnode = createEmptyVNode();
          }
          vnode.parent = _parentVnode;
          return vnode;
        };
      }
      function ensureCtor(comp, base) {
        if (comp.__esModule || hasSymbol2 && comp[Symbol.toStringTag] === "Module") {
          comp = comp.default;
        }
        return isObject2(comp) ? base.extend(comp) : comp;
      }
      function createAsyncPlaceholder(factory, data2, context, children, tag) {
        var node = createEmptyVNode();
        node.asyncFactory = factory;
        node.asyncMeta = { data: data2, context, children, tag };
        return node;
      }
      function resolveAsyncComponent(factory, baseCtor) {
        if (isTrue(factory.error) && isDef(factory.errorComp)) {
          return factory.errorComp;
        }
        if (isDef(factory.resolved)) {
          return factory.resolved;
        }
        var owner = currentRenderingInstance;
        if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
          factory.owners.push(owner);
        }
        if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
          return factory.loadingComp;
        }
        if (owner && !isDef(factory.owners)) {
          var owners = factory.owners = [owner];
          var sync = true;
          var timerLoading = null;
          var timerTimeout = null;
          owner.$on("hook:destroyed", function() {
            return remove(owners, owner);
          });
          var forceRender = function(renderCompleted) {
            for (var i = 0, l = owners.length; i < l; i++) {
              owners[i].$forceUpdate();
            }
            if (renderCompleted) {
              owners.length = 0;
              if (timerLoading !== null) {
                clearTimeout(timerLoading);
                timerLoading = null;
              }
              if (timerTimeout !== null) {
                clearTimeout(timerTimeout);
                timerTimeout = null;
              }
            }
          };
          var resolve = once(function(res2) {
            factory.resolved = ensureCtor(res2, baseCtor);
            if (!sync) {
              forceRender(true);
            } else {
              owners.length = 0;
            }
          });
          var reject = once(function(reason) {
            warn2("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ""));
            if (isDef(factory.errorComp)) {
              factory.error = true;
              forceRender(true);
            }
          });
          var res = factory(resolve, reject);
          if (isObject2(res)) {
            if (isPromise(res)) {
              if (isUndef2(factory.resolved)) {
                res.then(resolve, reject);
              }
            } else if (isPromise(res.component)) {
              res.component.then(resolve, reject);
              if (isDef(res.error)) {
                factory.errorComp = ensureCtor(res.error, baseCtor);
              }
              if (isDef(res.loading)) {
                factory.loadingComp = ensureCtor(res.loading, baseCtor);
                if (res.delay === 0) {
                  factory.loading = true;
                } else {
                  timerLoading = setTimeout(function() {
                    timerLoading = null;
                    if (isUndef2(factory.resolved) && isUndef2(factory.error)) {
                      factory.loading = true;
                      forceRender(false);
                    }
                  }, res.delay || 200);
                }
              }
              if (isDef(res.timeout)) {
                timerTimeout = setTimeout(function() {
                  timerTimeout = null;
                  if (isUndef2(factory.resolved)) {
                    reject("timeout (" + res.timeout + "ms)");
                  }
                }, res.timeout);
              }
            }
          }
          sync = false;
          return factory.loading ? factory.loadingComp : factory.resolved;
        }
      }
      function getFirstComponentChild(children) {
        if (Array.isArray(children)) {
          for (var i = 0; i < children.length; i++) {
            var c = children[i];
            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
              return c;
            }
          }
        }
      }
      function initEvents(vm) {
        vm._events = /* @__PURE__ */ Object.create(null);
        vm._hasHookEvent = false;
        var listeners = vm.$options._parentListeners;
        if (listeners) {
          updateComponentListeners(vm, listeners);
        }
      }
      var target;
      function add(event, fn) {
        target.$on(event, fn);
      }
      function remove$1(event, fn) {
        target.$off(event, fn);
      }
      function createOnceHandler(event, fn) {
        var _target = target;
        return function onceHandler() {
          var res = fn.apply(null, arguments);
          if (res !== null) {
            _target.$off(event, onceHandler);
          }
        };
      }
      function updateComponentListeners(vm, listeners, oldListeners) {
        target = vm;
        updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
        target = void 0;
      }
      function eventsMixin(Vue5) {
        var hookRE = /^hook:/;
        Vue5.prototype.$on = function(event, fn) {
          var vm = this;
          if (Array.isArray(event)) {
            for (var i = 0, l = event.length; i < l; i++) {
              vm.$on(event[i], fn);
            }
          } else {
            (vm._events[event] || (vm._events[event] = [])).push(fn);
            if (hookRE.test(event)) {
              vm._hasHookEvent = true;
            }
          }
          return vm;
        };
        Vue5.prototype.$once = function(event, fn) {
          var vm = this;
          function on() {
            vm.$off(event, on);
            fn.apply(vm, arguments);
          }
          on.fn = fn;
          vm.$on(event, on);
          return vm;
        };
        Vue5.prototype.$off = function(event, fn) {
          var vm = this;
          if (!arguments.length) {
            vm._events = /* @__PURE__ */ Object.create(null);
            return vm;
          }
          if (Array.isArray(event)) {
            for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
              vm.$off(event[i$1], fn);
            }
            return vm;
          }
          var cbs = vm._events[event];
          if (!cbs) {
            return vm;
          }
          if (!fn) {
            vm._events[event] = null;
            return vm;
          }
          var cb;
          var i = cbs.length;
          while (i--) {
            cb = cbs[i];
            if (cb === fn || cb.fn === fn) {
              cbs.splice(i, 1);
              break;
            }
          }
          return vm;
        };
        Vue5.prototype.$emit = function(event) {
          var vm = this;
          {
            var lowerCaseEvent = event.toLowerCase();
            if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
              tip('Event "' + lowerCaseEvent + '" is emitted in component ' + formatComponentName(vm) + ' but the handler is registered for "' + event + '". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "' + hyphenate(event) + '" instead of "' + event + '".');
            }
          }
          var cbs = vm._events[event];
          if (cbs) {
            cbs = cbs.length > 1 ? toArray(cbs) : cbs;
            var args = toArray(arguments, 1);
            var info = 'event handler for "' + event + '"';
            for (var i = 0, l = cbs.length; i < l; i++) {
              invokeWithErrorHandling(cbs[i], vm, args, vm, info);
            }
          }
          return vm;
        };
      }
      var activeInstance = null;
      var isUpdatingChildComponent = false;
      function setActiveInstance(vm) {
        var prevActiveInstance = activeInstance;
        activeInstance = vm;
        return function() {
          activeInstance = prevActiveInstance;
        };
      }
      function initLifecycle(vm) {
        var options = vm.$options;
        var parent = options.parent;
        if (parent && !options.abstract) {
          while (parent.$options.abstract && parent.$parent) {
            parent = parent.$parent;
          }
          parent.$children.push(vm);
        }
        vm.$parent = parent;
        vm.$root = parent ? parent.$root : vm;
        vm.$children = [];
        vm.$refs = {};
        vm._watcher = null;
        vm._inactive = null;
        vm._directInactive = false;
        vm._isMounted = false;
        vm._isDestroyed = false;
        vm._isBeingDestroyed = false;
      }
      function lifecycleMixin(Vue5) {
        Vue5.prototype._update = function(vnode, hydrating) {
          var vm = this;
          var prevEl = vm.$el;
          var prevVnode = vm._vnode;
          var restoreActiveInstance = setActiveInstance(vm);
          vm._vnode = vnode;
          if (!prevVnode) {
            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false);
          } else {
            vm.$el = vm.__patch__(prevVnode, vnode);
          }
          restoreActiveInstance();
          if (prevEl) {
            prevEl.__vue__ = null;
          }
          if (vm.$el) {
            vm.$el.__vue__ = vm;
          }
          if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
            vm.$parent.$el = vm.$el;
          }
        };
        Vue5.prototype.$forceUpdate = function() {
          var vm = this;
          if (vm._watcher) {
            vm._watcher.update();
          }
        };
        Vue5.prototype.$destroy = function() {
          var vm = this;
          if (vm._isBeingDestroyed) {
            return;
          }
          callHook(vm, "beforeDestroy");
          vm._isBeingDestroyed = true;
          var parent = vm.$parent;
          if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
            remove(parent.$children, vm);
          }
          if (vm._watcher) {
            vm._watcher.teardown();
          }
          var i = vm._watchers.length;
          while (i--) {
            vm._watchers[i].teardown();
          }
          if (vm._data.__ob__) {
            vm._data.__ob__.vmCount--;
          }
          vm._isDestroyed = true;
          vm.__patch__(vm._vnode, null);
          callHook(vm, "destroyed");
          vm.$off();
          if (vm.$el) {
            vm.$el.__vue__ = null;
          }
          if (vm.$vnode) {
            vm.$vnode.parent = null;
          }
        };
      }
      function mountComponent(vm, el, hydrating) {
        vm.$el = el;
        if (!vm.$options.render) {
          vm.$options.render = createEmptyVNode;
          {
            if (vm.$options.template && vm.$options.template.charAt(0) !== "#" || vm.$options.el || el) {
              warn2("You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.", vm);
            } else {
              warn2("Failed to mount component: template or render function not defined.", vm);
            }
          }
        }
        callHook(vm, "beforeMount");
        var updateComponent;
        if (config.performance && mark) {
          updateComponent = function() {
            var name = vm._name;
            var id = vm._uid;
            var startTag = "vue-perf-start:" + id;
            var endTag = "vue-perf-end:" + id;
            mark(startTag);
            var vnode = vm._render();
            mark(endTag);
            measure("vue " + name + " render", startTag, endTag);
            mark(startTag);
            vm._update(vnode, hydrating);
            mark(endTag);
            measure("vue " + name + " patch", startTag, endTag);
          };
        } else {
          updateComponent = function() {
            vm._update(vm._render(), hydrating);
          };
        }
        new Watcher(vm, updateComponent, noop, {
          before: function before() {
            if (vm._isMounted && !vm._isDestroyed) {
              callHook(vm, "beforeUpdate");
            }
          }
        }, true);
        hydrating = false;
        if (vm.$vnode == null) {
          vm._isMounted = true;
          callHook(vm, "mounted");
        }
        return vm;
      }
      function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
        {
          isUpdatingChildComponent = true;
        }
        var newScopedSlots = parentVnode.data.scopedSlots;
        var oldScopedSlots = vm.$scopedSlots;
        var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key);
        var needsForceUpdate = !!(renderChildren || vm.$options._renderChildren || hasDynamicScopedSlot);
        vm.$options._parentVnode = parentVnode;
        vm.$vnode = parentVnode;
        if (vm._vnode) {
          vm._vnode.parent = parentVnode;
        }
        vm.$options._renderChildren = renderChildren;
        vm.$attrs = parentVnode.data.attrs || emptyObject;
        vm.$listeners = listeners || emptyObject;
        if (propsData && vm.$options.props) {
          toggleObserving(false);
          var props3 = vm._props;
          var propKeys = vm.$options._propKeys || [];
          for (var i = 0; i < propKeys.length; i++) {
            var key = propKeys[i];
            var propOptions = vm.$options.props;
            props3[key] = validateProp(key, propOptions, propsData, vm);
          }
          toggleObserving(true);
          vm.$options.propsData = propsData;
        }
        listeners = listeners || emptyObject;
        var oldListeners = vm.$options._parentListeners;
        vm.$options._parentListeners = listeners;
        updateComponentListeners(vm, listeners, oldListeners);
        if (needsForceUpdate) {
          vm.$slots = resolveSlots2(renderChildren, parentVnode.context);
          vm.$forceUpdate();
        }
        {
          isUpdatingChildComponent = false;
        }
      }
      function isInInactiveTree(vm) {
        while (vm && (vm = vm.$parent)) {
          if (vm._inactive) {
            return true;
          }
        }
        return false;
      }
      function activateChildComponent(vm, direct) {
        if (direct) {
          vm._directInactive = false;
          if (isInInactiveTree(vm)) {
            return;
          }
        } else if (vm._directInactive) {
          return;
        }
        if (vm._inactive || vm._inactive === null) {
          vm._inactive = false;
          for (var i = 0; i < vm.$children.length; i++) {
            activateChildComponent(vm.$children[i]);
          }
          callHook(vm, "activated");
        }
      }
      function deactivateChildComponent(vm, direct) {
        if (direct) {
          vm._directInactive = true;
          if (isInInactiveTree(vm)) {
            return;
          }
        }
        if (!vm._inactive) {
          vm._inactive = true;
          for (var i = 0; i < vm.$children.length; i++) {
            deactivateChildComponent(vm.$children[i]);
          }
          callHook(vm, "deactivated");
        }
      }
      function callHook(vm, hook) {
        pushTarget();
        var handlers = vm.$options[hook];
        var info = hook + " hook";
        if (handlers) {
          for (var i = 0, j = handlers.length; i < j; i++) {
            invokeWithErrorHandling(handlers[i], vm, null, vm, info);
          }
        }
        if (vm._hasHookEvent) {
          vm.$emit("hook:" + hook);
        }
        popTarget();
      }
      var MAX_UPDATE_COUNT = 100;
      var queue = [];
      var activatedChildren = [];
      var has = {};
      var circular = {};
      var waiting = false;
      var flushing = false;
      var index = 0;
      function resetSchedulerState() {
        index = queue.length = activatedChildren.length = 0;
        has = {};
        {
          circular = {};
        }
        waiting = flushing = false;
      }
      var currentFlushTimestamp = 0;
      var getNow = Date.now;
      if (inBrowser && !isIE) {
        performance = window.performance;
        if (performance && typeof performance.now === "function" && getNow() > document.createEvent("Event").timeStamp) {
          getNow = function() {
            return performance.now();
          };
        }
      }
      var performance;
      function flushSchedulerQueue() {
        currentFlushTimestamp = getNow();
        flushing = true;
        var watcher, id;
        queue.sort(function(a, b) {
          return a.id - b.id;
        });
        for (index = 0; index < queue.length; index++) {
          watcher = queue[index];
          if (watcher.before) {
            watcher.before();
          }
          id = watcher.id;
          has[id] = null;
          watcher.run();
          if (has[id] != null) {
            circular[id] = (circular[id] || 0) + 1;
            if (circular[id] > MAX_UPDATE_COUNT) {
              warn2("You may have an infinite update loop " + (watcher.user ? 'in watcher with expression "' + watcher.expression + '"' : "in a component render function."), watcher.vm);
              break;
            }
          }
        }
        var activatedQueue = activatedChildren.slice();
        var updatedQueue = queue.slice();
        resetSchedulerState();
        callActivatedHooks(activatedQueue);
        callUpdatedHooks(updatedQueue);
        if (devtools && config.devtools) {
          devtools.emit("flush");
        }
      }
      function callUpdatedHooks(queue2) {
        var i = queue2.length;
        while (i--) {
          var watcher = queue2[i];
          var vm = watcher.vm;
          if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
            callHook(vm, "updated");
          }
        }
      }
      function queueActivatedComponent(vm) {
        vm._inactive = false;
        activatedChildren.push(vm);
      }
      function callActivatedHooks(queue2) {
        for (var i = 0; i < queue2.length; i++) {
          queue2[i]._inactive = true;
          activateChildComponent(queue2[i], true);
        }
      }
      function queueWatcher(watcher) {
        var id = watcher.id;
        if (has[id] == null) {
          has[id] = true;
          if (!flushing) {
            queue.push(watcher);
          } else {
            var i = queue.length - 1;
            while (i > index && queue[i].id > watcher.id) {
              i--;
            }
            queue.splice(i + 1, 0, watcher);
          }
          if (!waiting) {
            waiting = true;
            if (!config.async) {
              flushSchedulerQueue();
              return;
            }
            nextTick2(flushSchedulerQueue);
          }
        }
      }
      var uid$2 = 0;
      var Watcher = function Watcher2(vm, expOrFn, cb, options, isRenderWatcher) {
        this.vm = vm;
        if (isRenderWatcher) {
          vm._watcher = this;
        }
        vm._watchers.push(this);
        if (options) {
          this.deep = !!options.deep;
          this.user = !!options.user;
          this.lazy = !!options.lazy;
          this.sync = !!options.sync;
          this.before = options.before;
        } else {
          this.deep = this.user = this.lazy = this.sync = false;
        }
        this.cb = cb;
        this.id = ++uid$2;
        this.active = true;
        this.dirty = this.lazy;
        this.deps = [];
        this.newDeps = [];
        this.depIds = new _Set();
        this.newDepIds = new _Set();
        this.expression = expOrFn.toString();
        if (typeof expOrFn === "function") {
          this.getter = expOrFn;
        } else {
          this.getter = parsePath(expOrFn);
          if (!this.getter) {
            this.getter = noop;
            warn2('Failed watching path: "' + expOrFn + '" Watcher only accepts simple dot-delimited paths. For full control, use a function instead.', vm);
          }
        }
        this.value = this.lazy ? void 0 : this.get();
      };
      Watcher.prototype.get = function get2() {
        pushTarget(this);
        var value;
        var vm = this.vm;
        try {
          value = this.getter.call(vm, vm);
        } catch (e) {
          if (this.user) {
            handleError(e, vm, 'getter for watcher "' + this.expression + '"');
          } else {
            throw e;
          }
        } finally {
          if (this.deep) {
            traverse2(value);
          }
          popTarget();
          this.cleanupDeps();
        }
        return value;
      };
      Watcher.prototype.addDep = function addDep(dep) {
        var id = dep.id;
        if (!this.newDepIds.has(id)) {
          this.newDepIds.add(id);
          this.newDeps.push(dep);
          if (!this.depIds.has(id)) {
            dep.addSub(this);
          }
        }
      };
      Watcher.prototype.cleanupDeps = function cleanupDeps() {
        var i = this.deps.length;
        while (i--) {
          var dep = this.deps[i];
          if (!this.newDepIds.has(dep.id)) {
            dep.removeSub(this);
          }
        }
        var tmp = this.depIds;
        this.depIds = this.newDepIds;
        this.newDepIds = tmp;
        this.newDepIds.clear();
        tmp = this.deps;
        this.deps = this.newDeps;
        this.newDeps = tmp;
        this.newDeps.length = 0;
      };
      Watcher.prototype.update = function update() {
        if (this.lazy) {
          this.dirty = true;
        } else if (this.sync) {
          this.run();
        } else {
          queueWatcher(this);
        }
      };
      Watcher.prototype.run = function run() {
        if (this.active) {
          var value = this.get();
          if (value !== this.value || isObject2(value) || this.deep) {
            var oldValue = this.value;
            this.value = value;
            if (this.user) {
              var info = 'callback for watcher "' + this.expression + '"';
              invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
            } else {
              this.cb.call(this.vm, value, oldValue);
            }
          }
        }
      };
      Watcher.prototype.evaluate = function evaluate() {
        this.value = this.get();
        this.dirty = false;
      };
      Watcher.prototype.depend = function depend() {
        var i = this.deps.length;
        while (i--) {
          this.deps[i].depend();
        }
      };
      Watcher.prototype.teardown = function teardown() {
        if (this.active) {
          if (!this.vm._isBeingDestroyed) {
            remove(this.vm._watchers, this);
          }
          var i = this.deps.length;
          while (i--) {
            this.deps[i].removeSub(this);
          }
          this.active = false;
        }
      };
      var sharedPropertyDefinition = {
        enumerable: true,
        configurable: true,
        get: noop,
        set: noop
      };
      function proxy2(target2, sourceKey, key) {
        sharedPropertyDefinition.get = function proxyGetter() {
          return this[sourceKey][key];
        };
        sharedPropertyDefinition.set = function proxySetter(val) {
          this[sourceKey][key] = val;
        };
        Object.defineProperty(target2, key, sharedPropertyDefinition);
      }
      function initState(vm) {
        vm._watchers = [];
        var opts2 = vm.$options;
        if (opts2.props) {
          initProps(vm, opts2.props);
        }
        if (opts2.methods) {
          initMethods(vm, opts2.methods);
        }
        if (opts2.data) {
          initData(vm);
        } else {
          observe2(vm._data = {}, true);
        }
        if (opts2.computed) {
          initComputed(vm, opts2.computed);
        }
        if (opts2.watch && opts2.watch !== nativeWatch) {
          initWatch(vm, opts2.watch);
        }
      }
      function initProps(vm, propsOptions) {
        var propsData = vm.$options.propsData || {};
        var props3 = vm._props = {};
        var keys = vm.$options._propKeys = [];
        var isRoot = !vm.$parent;
        if (!isRoot) {
          toggleObserving(false);
        }
        var loop = function(key2) {
          keys.push(key2);
          var value = validateProp(key2, propsOptions, propsData, vm);
          {
            var hyphenatedKey = hyphenate(key2);
            if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
              warn2('"' + hyphenatedKey + '" is a reserved attribute and cannot be used as component prop.', vm);
            }
            defineReactive$$1(props3, key2, value, function() {
              if (!isRoot && !isUpdatingChildComponent) {
                warn2(`Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: "` + key2 + '"', vm);
              }
            });
          }
          if (!(key2 in vm)) {
            proxy2(vm, "_props", key2);
          }
        };
        for (var key in propsOptions)
          loop(key);
        toggleObserving(true);
      }
      function initData(vm) {
        var data2 = vm.$options.data;
        data2 = vm._data = typeof data2 === "function" ? getData(data2, vm) : data2 || {};
        if (!isPlainObject2(data2)) {
          data2 = {};
          warn2("data functions should return an object:\nhttps://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function", vm);
        }
        var keys = Object.keys(data2);
        var props3 = vm.$options.props;
        var methods = vm.$options.methods;
        var i = keys.length;
        while (i--) {
          var key = keys[i];
          {
            if (methods && hasOwn2(methods, key)) {
              warn2('Method "' + key + '" has already been defined as a data property.', vm);
            }
          }
          if (props3 && hasOwn2(props3, key)) {
            warn2('The data property "' + key + '" is already declared as a prop. Use prop default value instead.', vm);
          } else if (!isReserved(key)) {
            proxy2(vm, "_data", key);
          }
        }
        observe2(data2, true);
      }
      function getData(data2, vm) {
        pushTarget();
        try {
          return data2.call(vm, vm);
        } catch (e) {
          handleError(e, vm, "data()");
          return {};
        } finally {
          popTarget();
        }
      }
      var computedWatcherOptions = { lazy: true };
      function initComputed(vm, computed2) {
        var watchers = vm._computedWatchers = /* @__PURE__ */ Object.create(null);
        var isSSR = isServerRendering();
        for (var key in computed2) {
          var userDef = computed2[key];
          var getter = typeof userDef === "function" ? userDef : userDef.get;
          if (getter == null) {
            warn2('Getter is missing for computed property "' + key + '".', vm);
          }
          if (!isSSR) {
            watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
          }
          if (!(key in vm)) {
            defineComputed(vm, key, userDef);
          } else {
            if (key in vm.$data) {
              warn2('The computed property "' + key + '" is already defined in data.', vm);
            } else if (vm.$options.props && key in vm.$options.props) {
              warn2('The computed property "' + key + '" is already defined as a prop.', vm);
            } else if (vm.$options.methods && key in vm.$options.methods) {
              warn2('The computed property "' + key + '" is already defined as a method.', vm);
            }
          }
        }
      }
      function defineComputed(target2, key, userDef) {
        var shouldCache = !isServerRendering();
        if (typeof userDef === "function") {
          sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
          sharedPropertyDefinition.set = noop;
        } else {
          sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
          sharedPropertyDefinition.set = userDef.set || noop;
        }
        if (sharedPropertyDefinition.set === noop) {
          sharedPropertyDefinition.set = function() {
            warn2('Computed property "' + key + '" was assigned to but it has no setter.', this);
          };
        }
        Object.defineProperty(target2, key, sharedPropertyDefinition);
      }
      function createComputedGetter(key) {
        return function computedGetter() {
          var watcher = this._computedWatchers && this._computedWatchers[key];
          if (watcher) {
            if (watcher.dirty) {
              watcher.evaluate();
            }
            if (Dep.target) {
              watcher.depend();
            }
            return watcher.value;
          }
        };
      }
      function createGetterInvoker(fn) {
        return function computedGetter() {
          return fn.call(this, this);
        };
      }
      function initMethods(vm, methods) {
        var props3 = vm.$options.props;
        for (var key in methods) {
          {
            if (typeof methods[key] !== "function") {
              warn2('Method "' + key + '" has type "' + typeof methods[key] + '" in the component definition. Did you reference the function correctly?', vm);
            }
            if (props3 && hasOwn2(props3, key)) {
              warn2('Method "' + key + '" has already been defined as a prop.', vm);
            }
            if (key in vm && isReserved(key)) {
              warn2('Method "' + key + '" conflicts with an existing Vue instance method. Avoid defining component methods that start with _ or $.');
            }
          }
          vm[key] = typeof methods[key] !== "function" ? noop : bind(methods[key], vm);
        }
      }
      function initWatch(vm, watch2) {
        for (var key in watch2) {
          var handler2 = watch2[key];
          if (Array.isArray(handler2)) {
            for (var i = 0; i < handler2.length; i++) {
              createWatcher2(vm, key, handler2[i]);
            }
          } else {
            createWatcher2(vm, key, handler2);
          }
        }
      }
      function createWatcher2(vm, expOrFn, handler2, options) {
        if (isPlainObject2(handler2)) {
          options = handler2;
          handler2 = handler2.handler;
        }
        if (typeof handler2 === "string") {
          handler2 = vm[handler2];
        }
        return vm.$watch(expOrFn, handler2, options);
      }
      function stateMixin(Vue5) {
        var dataDef = {};
        dataDef.get = function() {
          return this._data;
        };
        var propsDef = {};
        propsDef.get = function() {
          return this._props;
        };
        {
          dataDef.set = function() {
            warn2("Avoid replacing instance root $data. Use nested data properties instead.", this);
          };
          propsDef.set = function() {
            warn2("$props is readonly.", this);
          };
        }
        Object.defineProperty(Vue5.prototype, "$data", dataDef);
        Object.defineProperty(Vue5.prototype, "$props", propsDef);
        Vue5.prototype.$set = set3;
        Vue5.prototype.$delete = del2;
        Vue5.prototype.$watch = function(expOrFn, cb, options) {
          var vm = this;
          if (isPlainObject2(cb)) {
            return createWatcher2(vm, expOrFn, cb, options);
          }
          options = options || {};
          options.user = true;
          var watcher = new Watcher(vm, expOrFn, cb, options);
          if (options.immediate) {
            var info = 'callback for immediate watcher "' + watcher.expression + '"';
            pushTarget();
            invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
            popTarget();
          }
          return function unwatchFn() {
            watcher.teardown();
          };
        };
      }
      var uid$3 = 0;
      function initMixin(Vue5) {
        Vue5.prototype._init = function(options) {
          var vm = this;
          vm._uid = uid$3++;
          var startTag, endTag;
          if (config.performance && mark) {
            startTag = "vue-perf-start:" + vm._uid;
            endTag = "vue-perf-end:" + vm._uid;
            mark(startTag);
          }
          vm._isVue = true;
          if (options && options._isComponent) {
            initInternalComponent(vm, options);
          } else {
            vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
          }
          {
            initProxy(vm);
          }
          vm._self = vm;
          initLifecycle(vm);
          initEvents(vm);
          initRender(vm);
          callHook(vm, "beforeCreate");
          initInjections(vm);
          initState(vm);
          initProvide(vm);
          callHook(vm, "created");
          if (config.performance && mark) {
            vm._name = formatComponentName(vm, false);
            mark(endTag);
            measure("vue " + vm._name + " init", startTag, endTag);
          }
          if (vm.$options.el) {
            vm.$mount(vm.$options.el);
          }
        };
      }
      function initInternalComponent(vm, options) {
        var opts2 = vm.$options = Object.create(vm.constructor.options);
        var parentVnode = options._parentVnode;
        opts2.parent = options.parent;
        opts2._parentVnode = parentVnode;
        var vnodeComponentOptions = parentVnode.componentOptions;
        opts2.propsData = vnodeComponentOptions.propsData;
        opts2._parentListeners = vnodeComponentOptions.listeners;
        opts2._renderChildren = vnodeComponentOptions.children;
        opts2._componentTag = vnodeComponentOptions.tag;
        if (options.render) {
          opts2.render = options.render;
          opts2.staticRenderFns = options.staticRenderFns;
        }
      }
      function resolveConstructorOptions(Ctor) {
        var options = Ctor.options;
        if (Ctor.super) {
          var superOptions = resolveConstructorOptions(Ctor.super);
          var cachedSuperOptions = Ctor.superOptions;
          if (superOptions !== cachedSuperOptions) {
            Ctor.superOptions = superOptions;
            var modifiedOptions = resolveModifiedOptions(Ctor);
            if (modifiedOptions) {
              extend(Ctor.extendOptions, modifiedOptions);
            }
            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
            if (options.name) {
              options.components[options.name] = Ctor;
            }
          }
        }
        return options;
      }
      function resolveModifiedOptions(Ctor) {
        var modified;
        var latest = Ctor.options;
        var sealed = Ctor.sealedOptions;
        for (var key in latest) {
          if (latest[key] !== sealed[key]) {
            if (!modified) {
              modified = {};
            }
            modified[key] = latest[key];
          }
        }
        return modified;
      }
      function Vue4(options) {
        if (!(this instanceof Vue4)) {
          warn2("Vue is a constructor and should be called with the `new` keyword");
        }
        this._init(options);
      }
      initMixin(Vue4);
      stateMixin(Vue4);
      eventsMixin(Vue4);
      lifecycleMixin(Vue4);
      renderMixin(Vue4);
      function initUse(Vue5) {
        Vue5.use = function(plugin) {
          var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
          if (installedPlugins.indexOf(plugin) > -1) {
            return this;
          }
          var args = toArray(arguments, 1);
          args.unshift(this);
          if (typeof plugin.install === "function") {
            plugin.install.apply(plugin, args);
          } else if (typeof plugin === "function") {
            plugin.apply(null, args);
          }
          installedPlugins.push(plugin);
          return this;
        };
      }
      function initMixin$1(Vue5) {
        Vue5.mixin = function(mixin2) {
          this.options = mergeOptions(this.options, mixin2);
          return this;
        };
      }
      function initExtend(Vue5) {
        Vue5.cid = 0;
        var cid = 1;
        Vue5.extend = function(extendOptions) {
          extendOptions = extendOptions || {};
          var Super = this;
          var SuperId = Super.cid;
          var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
          if (cachedCtors[SuperId]) {
            return cachedCtors[SuperId];
          }
          var name = extendOptions.name || Super.options.name;
          if (name) {
            validateComponentName(name);
          }
          var Sub = function VueComponent(options) {
            this._init(options);
          };
          Sub.prototype = Object.create(Super.prototype);
          Sub.prototype.constructor = Sub;
          Sub.cid = cid++;
          Sub.options = mergeOptions(Super.options, extendOptions);
          Sub["super"] = Super;
          if (Sub.options.props) {
            initProps$1(Sub);
          }
          if (Sub.options.computed) {
            initComputed$1(Sub);
          }
          Sub.extend = Super.extend;
          Sub.mixin = Super.mixin;
          Sub.use = Super.use;
          ASSET_TYPES.forEach(function(type) {
            Sub[type] = Super[type];
          });
          if (name) {
            Sub.options.components[name] = Sub;
          }
          Sub.superOptions = Super.options;
          Sub.extendOptions = extendOptions;
          Sub.sealedOptions = extend({}, Sub.options);
          cachedCtors[SuperId] = Sub;
          return Sub;
        };
      }
      function initProps$1(Comp) {
        var props3 = Comp.options.props;
        for (var key in props3) {
          proxy2(Comp.prototype, "_props", key);
        }
      }
      function initComputed$1(Comp) {
        var computed2 = Comp.options.computed;
        for (var key in computed2) {
          defineComputed(Comp.prototype, key, computed2[key]);
        }
      }
      function initAssetRegisters(Vue5) {
        ASSET_TYPES.forEach(function(type) {
          Vue5[type] = function(id, definition) {
            if (!definition) {
              return this.options[type + "s"][id];
            } else {
              if (type === "component") {
                validateComponentName(id);
              }
              if (type === "component" && isPlainObject2(definition)) {
                definition.name = definition.name || id;
                definition = this.options._base.extend(definition);
              }
              if (type === "directive" && typeof definition === "function") {
                definition = { bind: definition, update: definition };
              }
              this.options[type + "s"][id] = definition;
              return definition;
            }
          };
        });
      }
      function getComponentName(opts2) {
        return opts2 && (opts2.Ctor.options.name || opts2.tag);
      }
      function matches(pattern, name) {
        if (Array.isArray(pattern)) {
          return pattern.indexOf(name) > -1;
        } else if (typeof pattern === "string") {
          return pattern.split(",").indexOf(name) > -1;
        } else if (isRegExp(pattern)) {
          return pattern.test(name);
        }
        return false;
      }
      function pruneCache(keepAliveInstance, filter) {
        var cache = keepAliveInstance.cache;
        var keys = keepAliveInstance.keys;
        var _vnode = keepAliveInstance._vnode;
        for (var key in cache) {
          var entry = cache[key];
          if (entry) {
            var name = entry.name;
            if (name && !filter(name)) {
              pruneCacheEntry(cache, key, keys, _vnode);
            }
          }
        }
      }
      function pruneCacheEntry(cache, key, keys, current) {
        var entry = cache[key];
        if (entry && (!current || entry.tag !== current.tag)) {
          entry.componentInstance.$destroy();
        }
        cache[key] = null;
        remove(keys, key);
      }
      var patternTypes = [String, RegExp, Array];
      var KeepAlive = {
        name: "keep-alive",
        abstract: true,
        props: {
          include: patternTypes,
          exclude: patternTypes,
          max: [String, Number]
        },
        methods: {
          cacheVNode: function cacheVNode() {
            var ref3 = this;
            var cache = ref3.cache;
            var keys = ref3.keys;
            var vnodeToCache = ref3.vnodeToCache;
            var keyToCache = ref3.keyToCache;
            if (vnodeToCache) {
              var tag = vnodeToCache.tag;
              var componentInstance = vnodeToCache.componentInstance;
              var componentOptions = vnodeToCache.componentOptions;
              cache[keyToCache] = {
                name: getComponentName(componentOptions),
                tag,
                componentInstance
              };
              keys.push(keyToCache);
              if (this.max && keys.length > parseInt(this.max)) {
                pruneCacheEntry(cache, keys[0], keys, this._vnode);
              }
              this.vnodeToCache = null;
            }
          }
        },
        created: function created() {
          this.cache = /* @__PURE__ */ Object.create(null);
          this.keys = [];
        },
        destroyed: function destroyed2() {
          for (var key in this.cache) {
            pruneCacheEntry(this.cache, key, this.keys);
          }
        },
        mounted: function mounted2() {
          var this$1 = this;
          this.cacheVNode();
          this.$watch("include", function(val) {
            pruneCache(this$1, function(name) {
              return matches(val, name);
            });
          });
          this.$watch("exclude", function(val) {
            pruneCache(this$1, function(name) {
              return !matches(val, name);
            });
          });
        },
        updated: function updated() {
          this.cacheVNode();
        },
        render: function render2() {
          var slot = this.$slots.default;
          var vnode = getFirstComponentChild(slot);
          var componentOptions = vnode && vnode.componentOptions;
          if (componentOptions) {
            var name = getComponentName(componentOptions);
            var ref3 = this;
            var include = ref3.include;
            var exclude = ref3.exclude;
            if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
              return vnode;
            }
            var ref$1 = this;
            var cache = ref$1.cache;
            var keys = ref$1.keys;
            var key = vnode.key == null ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : "") : vnode.key;
            if (cache[key]) {
              vnode.componentInstance = cache[key].componentInstance;
              remove(keys, key);
              keys.push(key);
            } else {
              this.vnodeToCache = vnode;
              this.keyToCache = key;
            }
            vnode.data.keepAlive = true;
          }
          return vnode || slot && slot[0];
        }
      };
      var builtInComponents = {
        KeepAlive
      };
      function initGlobalAPI(Vue5) {
        var configDef = {};
        configDef.get = function() {
          return config;
        };
        {
          configDef.set = function() {
            warn2("Do not replace the Vue.config object, set individual fields instead.");
          };
        }
        Object.defineProperty(Vue5, "config", configDef);
        Vue5.util = {
          warn: warn2,
          extend,
          mergeOptions,
          defineReactive: defineReactive$$1
        };
        Vue5.set = set3;
        Vue5.delete = del2;
        Vue5.nextTick = nextTick2;
        Vue5.observable = function(obj) {
          observe2(obj);
          return obj;
        };
        Vue5.options = /* @__PURE__ */ Object.create(null);
        ASSET_TYPES.forEach(function(type) {
          Vue5.options[type + "s"] = /* @__PURE__ */ Object.create(null);
        });
        Vue5.options._base = Vue5;
        extend(Vue5.options.components, builtInComponents);
        initUse(Vue5);
        initMixin$1(Vue5);
        initExtend(Vue5);
        initAssetRegisters(Vue5);
      }
      initGlobalAPI(Vue4);
      Object.defineProperty(Vue4.prototype, "$isServer", {
        get: isServerRendering
      });
      Object.defineProperty(Vue4.prototype, "$ssrContext", {
        get: function get2() {
          return this.$vnode && this.$vnode.ssrContext;
        }
      });
      Object.defineProperty(Vue4, "FunctionalRenderContext", {
        value: FunctionalRenderContext
      });
      Vue4.version = "2.6.14";
      var isReservedAttr = makeMap("style,class");
      var acceptValue = makeMap("input,textarea,option,select,progress");
      var mustUseProp = function(tag, type, attr) {
        return attr === "value" && acceptValue(tag) && type !== "button" || attr === "selected" && tag === "option" || attr === "checked" && tag === "input" || attr === "muted" && tag === "video";
      };
      var isEnumeratedAttr = makeMap("contenteditable,draggable,spellcheck");
      var isValidContentEditableValue = makeMap("events,caret,typing,plaintext-only");
      var convertEnumeratedValue = function(key, value) {
        return isFalsyAttrValue(value) || value === "false" ? "false" : key === "contenteditable" && isValidContentEditableValue(value) ? value : "true";
      };
      var isBooleanAttr = makeMap("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible");
      var xlinkNS = "http://www.w3.org/1999/xlink";
      var isXlink = function(name) {
        return name.charAt(5) === ":" && name.slice(0, 5) === "xlink";
      };
      var getXlinkProp = function(name) {
        return isXlink(name) ? name.slice(6, name.length) : "";
      };
      var isFalsyAttrValue = function(val) {
        return val == null || val === false;
      };
      function genClassForVnode(vnode) {
        var data2 = vnode.data;
        var parentNode2 = vnode;
        var childNode = vnode;
        while (isDef(childNode.componentInstance)) {
          childNode = childNode.componentInstance._vnode;
          if (childNode && childNode.data) {
            data2 = mergeClassData(childNode.data, data2);
          }
        }
        while (isDef(parentNode2 = parentNode2.parent)) {
          if (parentNode2 && parentNode2.data) {
            data2 = mergeClassData(data2, parentNode2.data);
          }
        }
        return renderClass(data2.staticClass, data2.class);
      }
      function mergeClassData(child, parent) {
        return {
          staticClass: concat(child.staticClass, parent.staticClass),
          class: isDef(child.class) ? [child.class, parent.class] : parent.class
        };
      }
      function renderClass(staticClass, dynamicClass) {
        if (isDef(staticClass) || isDef(dynamicClass)) {
          return concat(staticClass, stringifyClass(dynamicClass));
        }
        return "";
      }
      function concat(a, b) {
        return a ? b ? a + " " + b : a : b || "";
      }
      function stringifyClass(value) {
        if (Array.isArray(value)) {
          return stringifyArray(value);
        }
        if (isObject2(value)) {
          return stringifyObject(value);
        }
        if (typeof value === "string") {
          return value;
        }
        return "";
      }
      function stringifyArray(value) {
        var res = "";
        var stringified;
        for (var i = 0, l = value.length; i < l; i++) {
          if (isDef(stringified = stringifyClass(value[i])) && stringified !== "") {
            if (res) {
              res += " ";
            }
            res += stringified;
          }
        }
        return res;
      }
      function stringifyObject(value) {
        var res = "";
        for (var key in value) {
          if (value[key]) {
            if (res) {
              res += " ";
            }
            res += key;
          }
        }
        return res;
      }
      var namespaceMap = {
        svg: "http://www.w3.org/2000/svg",
        math: "http://www.w3.org/1998/Math/MathML"
      };
      var isHTMLTag = makeMap("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot");
      var isSVG = makeMap("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", true);
      var isReservedTag = function(tag) {
        return isHTMLTag(tag) || isSVG(tag);
      };
      function getTagNamespace(tag) {
        if (isSVG(tag)) {
          return "svg";
        }
        if (tag === "math") {
          return "math";
        }
      }
      var unknownElementCache = /* @__PURE__ */ Object.create(null);
      function isUnknownElement(tag) {
        if (!inBrowser) {
          return true;
        }
        if (isReservedTag(tag)) {
          return false;
        }
        tag = tag.toLowerCase();
        if (unknownElementCache[tag] != null) {
          return unknownElementCache[tag];
        }
        var el = document.createElement(tag);
        if (tag.indexOf("-") > -1) {
          return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
        } else {
          return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
        }
      }
      var isTextInputType = makeMap("text,number,password,search,email,tel,url");
      function query(el) {
        if (typeof el === "string") {
          var selected = document.querySelector(el);
          if (!selected) {
            warn2("Cannot find element: " + el);
            return document.createElement("div");
          }
          return selected;
        } else {
          return el;
        }
      }
      function createElement$1(tagName2, vnode) {
        var elm = document.createElement(tagName2);
        if (tagName2 !== "select") {
          return elm;
        }
        if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== void 0) {
          elm.setAttribute("multiple", "multiple");
        }
        return elm;
      }
      function createElementNS(namespace, tagName2) {
        return document.createElementNS(namespaceMap[namespace], tagName2);
      }
      function createTextNode(text) {
        return document.createTextNode(text);
      }
      function createComment(text) {
        return document.createComment(text);
      }
      function insertBefore(parentNode2, newNode, referenceNode) {
        parentNode2.insertBefore(newNode, referenceNode);
      }
      function removeChild(node, child) {
        node.removeChild(child);
      }
      function appendChild(node, child) {
        node.appendChild(child);
      }
      function parentNode(node) {
        return node.parentNode;
      }
      function nextSibling(node) {
        return node.nextSibling;
      }
      function tagName(node) {
        return node.tagName;
      }
      function setTextContent(node, text) {
        node.textContent = text;
      }
      function setStyleScope(node, scopeId) {
        node.setAttribute(scopeId, "");
      }
      var nodeOps = /* @__PURE__ */ Object.freeze({
        createElement: createElement$1,
        createElementNS,
        createTextNode,
        createComment,
        insertBefore,
        removeChild,
        appendChild,
        parentNode,
        nextSibling,
        tagName,
        setTextContent,
        setStyleScope
      });
      var ref2 = {
        create: function create(_, vnode) {
          registerRef(vnode);
        },
        update: function update(oldVnode, vnode) {
          if (oldVnode.data.ref !== vnode.data.ref) {
            registerRef(oldVnode, true);
            registerRef(vnode);
          }
        },
        destroy: function destroy(vnode) {
          registerRef(vnode, true);
        }
      };
      function registerRef(vnode, isRemoval) {
        var key = vnode.data.ref;
        if (!isDef(key)) {
          return;
        }
        var vm = vnode.context;
        var ref3 = vnode.componentInstance || vnode.elm;
        var refs = vm.$refs;
        if (isRemoval) {
          if (Array.isArray(refs[key])) {
            remove(refs[key], ref3);
          } else if (refs[key] === ref3) {
            refs[key] = void 0;
          }
        } else {
          if (vnode.data.refInFor) {
            if (!Array.isArray(refs[key])) {
              refs[key] = [ref3];
            } else if (refs[key].indexOf(ref3) < 0) {
              refs[key].push(ref3);
            }
          } else {
            refs[key] = ref3;
          }
        }
      }
      var emptyNode = new VNode("", {}, []);
      var hooks = ["create", "activate", "update", "remove", "destroy"];
      function sameVnode(a, b) {
        return a.key === b.key && a.asyncFactory === b.asyncFactory && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && isUndef2(b.asyncFactory.error));
      }
      function sameInputType(a, b) {
        if (a.tag !== "input") {
          return true;
        }
        var i;
        var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
        var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
        return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
      }
      function createKeyToOldIdx(children, beginIdx, endIdx) {
        var i, key;
        var map = {};
        for (i = beginIdx; i <= endIdx; ++i) {
          key = children[i].key;
          if (isDef(key)) {
            map[key] = i;
          }
        }
        return map;
      }
      function createPatchFunction(backend) {
        var i, j;
        var cbs = {};
        var modules2 = backend.modules;
        var nodeOps2 = backend.nodeOps;
        for (i = 0; i < hooks.length; ++i) {
          cbs[hooks[i]] = [];
          for (j = 0; j < modules2.length; ++j) {
            if (isDef(modules2[j][hooks[i]])) {
              cbs[hooks[i]].push(modules2[j][hooks[i]]);
            }
          }
        }
        function emptyNodeAt(elm) {
          return new VNode(nodeOps2.tagName(elm).toLowerCase(), {}, [], void 0, elm);
        }
        function createRmCb(childElm, listeners) {
          function remove$$1() {
            if (--remove$$1.listeners === 0) {
              removeNode(childElm);
            }
          }
          remove$$1.listeners = listeners;
          return remove$$1;
        }
        function removeNode(el) {
          var parent = nodeOps2.parentNode(el);
          if (isDef(parent)) {
            nodeOps2.removeChild(parent, el);
          }
        }
        function isUnknownElement$$1(vnode, inVPre) {
          return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function(ignore) {
            return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
          })) && config.isUnknownElement(vnode.tag);
        }
        var creatingElmInVPre = 0;
        function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index2) {
          if (isDef(vnode.elm) && isDef(ownerArray)) {
            vnode = ownerArray[index2] = cloneVNode(vnode);
          }
          vnode.isRootInsert = !nested;
          if (createComponent2(vnode, insertedVnodeQueue, parentElm, refElm)) {
            return;
          }
          var data2 = vnode.data;
          var children = vnode.children;
          var tag = vnode.tag;
          if (isDef(tag)) {
            {
              if (data2 && data2.pre) {
                creatingElmInVPre++;
              }
              if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
                warn2("Unknown custom element: <" + tag + '> - did you register the component correctly? For recursive components, make sure to provide the "name" option.', vnode.context);
              }
            }
            vnode.elm = vnode.ns ? nodeOps2.createElementNS(vnode.ns, tag) : nodeOps2.createElement(tag, vnode);
            setScope(vnode);
            {
              createChildren(vnode, children, insertedVnodeQueue);
              if (isDef(data2)) {
                invokeCreateHooks(vnode, insertedVnodeQueue);
              }
              insert(parentElm, vnode.elm, refElm);
            }
            if (data2 && data2.pre) {
              creatingElmInVPre--;
            }
          } else if (isTrue(vnode.isComment)) {
            vnode.elm = nodeOps2.createComment(vnode.text);
            insert(parentElm, vnode.elm, refElm);
          } else {
            vnode.elm = nodeOps2.createTextNode(vnode.text);
            insert(parentElm, vnode.elm, refElm);
          }
        }
        function createComponent2(vnode, insertedVnodeQueue, parentElm, refElm) {
          var i2 = vnode.data;
          if (isDef(i2)) {
            var isReactivated = isDef(vnode.componentInstance) && i2.keepAlive;
            if (isDef(i2 = i2.hook) && isDef(i2 = i2.init)) {
              i2(vnode, false);
            }
            if (isDef(vnode.componentInstance)) {
              initComponent(vnode, insertedVnodeQueue);
              insert(parentElm, vnode.elm, refElm);
              if (isTrue(isReactivated)) {
                reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
              }
              return true;
            }
          }
        }
        function initComponent(vnode, insertedVnodeQueue) {
          if (isDef(vnode.data.pendingInsert)) {
            insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
            vnode.data.pendingInsert = null;
          }
          vnode.elm = vnode.componentInstance.$el;
          if (isPatchable(vnode)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            setScope(vnode);
          } else {
            registerRef(vnode);
            insertedVnodeQueue.push(vnode);
          }
        }
        function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
          var i2;
          var innerNode = vnode;
          while (innerNode.componentInstance) {
            innerNode = innerNode.componentInstance._vnode;
            if (isDef(i2 = innerNode.data) && isDef(i2 = i2.transition)) {
              for (i2 = 0; i2 < cbs.activate.length; ++i2) {
                cbs.activate[i2](emptyNode, innerNode);
              }
              insertedVnodeQueue.push(innerNode);
              break;
            }
          }
          insert(parentElm, vnode.elm, refElm);
        }
        function insert(parent, elm, ref$$1) {
          if (isDef(parent)) {
            if (isDef(ref$$1)) {
              if (nodeOps2.parentNode(ref$$1) === parent) {
                nodeOps2.insertBefore(parent, elm, ref$$1);
              }
            } else {
              nodeOps2.appendChild(parent, elm);
            }
          }
        }
        function createChildren(vnode, children, insertedVnodeQueue) {
          if (Array.isArray(children)) {
            {
              checkDuplicateKeys(children);
            }
            for (var i2 = 0; i2 < children.length; ++i2) {
              createElm(children[i2], insertedVnodeQueue, vnode.elm, null, true, children, i2);
            }
          } else if (isPrimitive2(vnode.text)) {
            nodeOps2.appendChild(vnode.elm, nodeOps2.createTextNode(String(vnode.text)));
          }
        }
        function isPatchable(vnode) {
          while (vnode.componentInstance) {
            vnode = vnode.componentInstance._vnode;
          }
          return isDef(vnode.tag);
        }
        function invokeCreateHooks(vnode, insertedVnodeQueue) {
          for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
            cbs.create[i$1](emptyNode, vnode);
          }
          i = vnode.data.hook;
          if (isDef(i)) {
            if (isDef(i.create)) {
              i.create(emptyNode, vnode);
            }
            if (isDef(i.insert)) {
              insertedVnodeQueue.push(vnode);
            }
          }
        }
        function setScope(vnode) {
          var i2;
          if (isDef(i2 = vnode.fnScopeId)) {
            nodeOps2.setStyleScope(vnode.elm, i2);
          } else {
            var ancestor = vnode;
            while (ancestor) {
              if (isDef(i2 = ancestor.context) && isDef(i2 = i2.$options._scopeId)) {
                nodeOps2.setStyleScope(vnode.elm, i2);
              }
              ancestor = ancestor.parent;
            }
          }
          if (isDef(i2 = activeInstance) && i2 !== vnode.context && i2 !== vnode.fnContext && isDef(i2 = i2.$options._scopeId)) {
            nodeOps2.setStyleScope(vnode.elm, i2);
          }
        }
        function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
          for (; startIdx <= endIdx; ++startIdx) {
            createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
          }
        }
        function invokeDestroyHook(vnode) {
          var i2, j2;
          var data2 = vnode.data;
          if (isDef(data2)) {
            if (isDef(i2 = data2.hook) && isDef(i2 = i2.destroy)) {
              i2(vnode);
            }
            for (i2 = 0; i2 < cbs.destroy.length; ++i2) {
              cbs.destroy[i2](vnode);
            }
          }
          if (isDef(i2 = vnode.children)) {
            for (j2 = 0; j2 < vnode.children.length; ++j2) {
              invokeDestroyHook(vnode.children[j2]);
            }
          }
        }
        function removeVnodes(vnodes, startIdx, endIdx) {
          for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (isDef(ch)) {
              if (isDef(ch.tag)) {
                removeAndInvokeRemoveHook(ch);
                invokeDestroyHook(ch);
              } else {
                removeNode(ch.elm);
              }
            }
          }
        }
        function removeAndInvokeRemoveHook(vnode, rm) {
          if (isDef(rm) || isDef(vnode.data)) {
            var i2;
            var listeners = cbs.remove.length + 1;
            if (isDef(rm)) {
              rm.listeners += listeners;
            } else {
              rm = createRmCb(vnode.elm, listeners);
            }
            if (isDef(i2 = vnode.componentInstance) && isDef(i2 = i2._vnode) && isDef(i2.data)) {
              removeAndInvokeRemoveHook(i2, rm);
            }
            for (i2 = 0; i2 < cbs.remove.length; ++i2) {
              cbs.remove[i2](vnode, rm);
            }
            if (isDef(i2 = vnode.data.hook) && isDef(i2 = i2.remove)) {
              i2(vnode, rm);
            } else {
              rm();
            }
          } else {
            removeNode(vnode.elm);
          }
        }
        function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
          var oldStartIdx = 0;
          var newStartIdx = 0;
          var oldEndIdx = oldCh.length - 1;
          var oldStartVnode = oldCh[0];
          var oldEndVnode = oldCh[oldEndIdx];
          var newEndIdx = newCh.length - 1;
          var newStartVnode = newCh[0];
          var newEndVnode = newCh[newEndIdx];
          var oldKeyToIdx, idxInOld, vnodeToMove, refElm;
          var canMove = !removeOnly;
          {
            checkDuplicateKeys(newCh);
          }
          while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (isUndef2(oldStartVnode)) {
              oldStartVnode = oldCh[++oldStartIdx];
            } else if (isUndef2(oldEndVnode)) {
              oldEndVnode = oldCh[--oldEndIdx];
            } else if (sameVnode(oldStartVnode, newStartVnode)) {
              patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
              oldStartVnode = oldCh[++oldStartIdx];
              newStartVnode = newCh[++newStartIdx];
            } else if (sameVnode(oldEndVnode, newEndVnode)) {
              patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
              oldEndVnode = oldCh[--oldEndIdx];
              newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newEndVnode)) {
              patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
              canMove && nodeOps2.insertBefore(parentElm, oldStartVnode.elm, nodeOps2.nextSibling(oldEndVnode.elm));
              oldStartVnode = oldCh[++oldStartIdx];
              newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldEndVnode, newStartVnode)) {
              patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
              canMove && nodeOps2.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
              oldEndVnode = oldCh[--oldEndIdx];
              newStartVnode = newCh[++newStartIdx];
            } else {
              if (isUndef2(oldKeyToIdx)) {
                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
              }
              idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
              if (isUndef2(idxInOld)) {
                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
              } else {
                vnodeToMove = oldCh[idxInOld];
                if (sameVnode(vnodeToMove, newStartVnode)) {
                  patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                  oldCh[idxInOld] = void 0;
                  canMove && nodeOps2.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
                } else {
                  createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                }
              }
              newStartVnode = newCh[++newStartIdx];
            }
          }
          if (oldStartIdx > oldEndIdx) {
            refElm = isUndef2(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
          } else if (newStartIdx > newEndIdx) {
            removeVnodes(oldCh, oldStartIdx, oldEndIdx);
          }
        }
        function checkDuplicateKeys(children) {
          var seenKeys = {};
          for (var i2 = 0; i2 < children.length; i2++) {
            var vnode = children[i2];
            var key = vnode.key;
            if (isDef(key)) {
              if (seenKeys[key]) {
                warn2("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
              } else {
                seenKeys[key] = true;
              }
            }
          }
        }
        function findIdxInOld(node, oldCh, start, end) {
          for (var i2 = start; i2 < end; i2++) {
            var c = oldCh[i2];
            if (isDef(c) && sameVnode(node, c)) {
              return i2;
            }
          }
        }
        function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index2, removeOnly) {
          if (oldVnode === vnode) {
            return;
          }
          if (isDef(vnode.elm) && isDef(ownerArray)) {
            vnode = ownerArray[index2] = cloneVNode(vnode);
          }
          var elm = vnode.elm = oldVnode.elm;
          if (isTrue(oldVnode.isAsyncPlaceholder)) {
            if (isDef(vnode.asyncFactory.resolved)) {
              hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
            } else {
              vnode.isAsyncPlaceholder = true;
            }
            return;
          }
          if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
            vnode.componentInstance = oldVnode.componentInstance;
            return;
          }
          var i2;
          var data2 = vnode.data;
          if (isDef(data2) && isDef(i2 = data2.hook) && isDef(i2 = i2.prepatch)) {
            i2(oldVnode, vnode);
          }
          var oldCh = oldVnode.children;
          var ch = vnode.children;
          if (isDef(data2) && isPatchable(vnode)) {
            for (i2 = 0; i2 < cbs.update.length; ++i2) {
              cbs.update[i2](oldVnode, vnode);
            }
            if (isDef(i2 = data2.hook) && isDef(i2 = i2.update)) {
              i2(oldVnode, vnode);
            }
          }
          if (isUndef2(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
              if (oldCh !== ch) {
                updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
              }
            } else if (isDef(ch)) {
              {
                checkDuplicateKeys(ch);
              }
              if (isDef(oldVnode.text)) {
                nodeOps2.setTextContent(elm, "");
              }
              addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            } else if (isDef(oldCh)) {
              removeVnodes(oldCh, 0, oldCh.length - 1);
            } else if (isDef(oldVnode.text)) {
              nodeOps2.setTextContent(elm, "");
            }
          } else if (oldVnode.text !== vnode.text) {
            nodeOps2.setTextContent(elm, vnode.text);
          }
          if (isDef(data2)) {
            if (isDef(i2 = data2.hook) && isDef(i2 = i2.postpatch)) {
              i2(oldVnode, vnode);
            }
          }
        }
        function invokeInsertHook(vnode, queue2, initial) {
          if (isTrue(initial) && isDef(vnode.parent)) {
            vnode.parent.data.pendingInsert = queue2;
          } else {
            for (var i2 = 0; i2 < queue2.length; ++i2) {
              queue2[i2].data.hook.insert(queue2[i2]);
            }
          }
        }
        var hydrationBailed = false;
        var isRenderedModule = makeMap("attrs,class,staticClass,staticStyle,key");
        function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
          var i2;
          var tag = vnode.tag;
          var data2 = vnode.data;
          var children = vnode.children;
          inVPre = inVPre || data2 && data2.pre;
          vnode.elm = elm;
          if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
            vnode.isAsyncPlaceholder = true;
            return true;
          }
          {
            if (!assertNodeMatch(elm, vnode, inVPre)) {
              return false;
            }
          }
          if (isDef(data2)) {
            if (isDef(i2 = data2.hook) && isDef(i2 = i2.init)) {
              i2(vnode, true);
            }
            if (isDef(i2 = vnode.componentInstance)) {
              initComponent(vnode, insertedVnodeQueue);
              return true;
            }
          }
          if (isDef(tag)) {
            if (isDef(children)) {
              if (!elm.hasChildNodes()) {
                createChildren(vnode, children, insertedVnodeQueue);
              } else {
                if (isDef(i2 = data2) && isDef(i2 = i2.domProps) && isDef(i2 = i2.innerHTML)) {
                  if (i2 !== elm.innerHTML) {
                    if (typeof console !== "undefined" && !hydrationBailed) {
                      hydrationBailed = true;
                      console.warn("Parent: ", elm);
                      console.warn("server innerHTML: ", i2);
                      console.warn("client innerHTML: ", elm.innerHTML);
                    }
                    return false;
                  }
                } else {
                  var childrenMatch = true;
                  var childNode = elm.firstChild;
                  for (var i$1 = 0; i$1 < children.length; i$1++) {
                    if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                      childrenMatch = false;
                      break;
                    }
                    childNode = childNode.nextSibling;
                  }
                  if (!childrenMatch || childNode) {
                    if (typeof console !== "undefined" && !hydrationBailed) {
                      hydrationBailed = true;
                      console.warn("Parent: ", elm);
                      console.warn("Mismatching childNodes vs. VNodes: ", elm.childNodes, children);
                    }
                    return false;
                  }
                }
              }
            }
            if (isDef(data2)) {
              var fullInvoke = false;
              for (var key in data2) {
                if (!isRenderedModule(key)) {
                  fullInvoke = true;
                  invokeCreateHooks(vnode, insertedVnodeQueue);
                  break;
                }
              }
              if (!fullInvoke && data2["class"]) {
                traverse2(data2["class"]);
              }
            }
          } else if (elm.data !== vnode.text) {
            elm.data = vnode.text;
          }
          return true;
        }
        function assertNodeMatch(node, vnode, inVPre) {
          if (isDef(vnode.tag)) {
            return vnode.tag.indexOf("vue-component") === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
          } else {
            return node.nodeType === (vnode.isComment ? 8 : 3);
          }
        }
        return function patch2(oldVnode, vnode, hydrating, removeOnly) {
          if (isUndef2(vnode)) {
            if (isDef(oldVnode)) {
              invokeDestroyHook(oldVnode);
            }
            return;
          }
          var isInitialPatch = false;
          var insertedVnodeQueue = [];
          if (isUndef2(oldVnode)) {
            isInitialPatch = true;
            createElm(vnode, insertedVnodeQueue);
          } else {
            var isRealElement = isDef(oldVnode.nodeType);
            if (!isRealElement && sameVnode(oldVnode, vnode)) {
              patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
            } else {
              if (isRealElement) {
                if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
                  oldVnode.removeAttribute(SSR_ATTR);
                  hydrating = true;
                }
                if (isTrue(hydrating)) {
                  if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                    invokeInsertHook(vnode, insertedVnodeQueue, true);
                    return oldVnode;
                  } else {
                    warn2("The client-side rendered virtual DOM tree is not matching server-rendered content. This is likely caused by incorrect HTML markup, for example nesting block-level elements inside <p>, or missing <tbody>. Bailing hydration and performing full client-side render.");
                  }
                }
                oldVnode = emptyNodeAt(oldVnode);
              }
              var oldElm = oldVnode.elm;
              var parentElm = nodeOps2.parentNode(oldElm);
              createElm(vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps2.nextSibling(oldElm));
              if (isDef(vnode.parent)) {
                var ancestor = vnode.parent;
                var patchable = isPatchable(vnode);
                while (ancestor) {
                  for (var i2 = 0; i2 < cbs.destroy.length; ++i2) {
                    cbs.destroy[i2](ancestor);
                  }
                  ancestor.elm = vnode.elm;
                  if (patchable) {
                    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                      cbs.create[i$1](emptyNode, ancestor);
                    }
                    var insert2 = ancestor.data.hook.insert;
                    if (insert2.merged) {
                      for (var i$2 = 1; i$2 < insert2.fns.length; i$2++) {
                        insert2.fns[i$2]();
                      }
                    }
                  } else {
                    registerRef(ancestor);
                  }
                  ancestor = ancestor.parent;
                }
              }
              if (isDef(parentElm)) {
                removeVnodes([oldVnode], 0, 0);
              } else if (isDef(oldVnode.tag)) {
                invokeDestroyHook(oldVnode);
              }
            }
          }
          invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
          return vnode.elm;
        };
      }
      var directives = {
        create: updateDirectives,
        update: updateDirectives,
        destroy: function unbindDirectives(vnode) {
          updateDirectives(vnode, emptyNode);
        }
      };
      function updateDirectives(oldVnode, vnode) {
        if (oldVnode.data.directives || vnode.data.directives) {
          _update(oldVnode, vnode);
        }
      }
      function _update(oldVnode, vnode) {
        var isCreate = oldVnode === emptyNode;
        var isDestroy = vnode === emptyNode;
        var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
        var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
        var dirsWithInsert = [];
        var dirsWithPostpatch = [];
        var key, oldDir, dir;
        for (key in newDirs) {
          oldDir = oldDirs[key];
          dir = newDirs[key];
          if (!oldDir) {
            callHook$1(dir, "bind", vnode, oldVnode);
            if (dir.def && dir.def.inserted) {
              dirsWithInsert.push(dir);
            }
          } else {
            dir.oldValue = oldDir.value;
            dir.oldArg = oldDir.arg;
            callHook$1(dir, "update", vnode, oldVnode);
            if (dir.def && dir.def.componentUpdated) {
              dirsWithPostpatch.push(dir);
            }
          }
        }
        if (dirsWithInsert.length) {
          var callInsert = function() {
            for (var i = 0; i < dirsWithInsert.length; i++) {
              callHook$1(dirsWithInsert[i], "inserted", vnode, oldVnode);
            }
          };
          if (isCreate) {
            mergeVNodeHook(vnode, "insert", callInsert);
          } else {
            callInsert();
          }
        }
        if (dirsWithPostpatch.length) {
          mergeVNodeHook(vnode, "postpatch", function() {
            for (var i = 0; i < dirsWithPostpatch.length; i++) {
              callHook$1(dirsWithPostpatch[i], "componentUpdated", vnode, oldVnode);
            }
          });
        }
        if (!isCreate) {
          for (key in oldDirs) {
            if (!newDirs[key]) {
              callHook$1(oldDirs[key], "unbind", oldVnode, oldVnode, isDestroy);
            }
          }
        }
      }
      var emptyModifiers = /* @__PURE__ */ Object.create(null);
      function normalizeDirectives$1(dirs, vm) {
        var res = /* @__PURE__ */ Object.create(null);
        if (!dirs) {
          return res;
        }
        var i, dir;
        for (i = 0; i < dirs.length; i++) {
          dir = dirs[i];
          if (!dir.modifiers) {
            dir.modifiers = emptyModifiers;
          }
          res[getRawDirName(dir)] = dir;
          dir.def = resolveAsset(vm.$options, "directives", dir.name, true);
        }
        return res;
      }
      function getRawDirName(dir) {
        return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join(".");
      }
      function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
        var fn = dir.def && dir.def[hook];
        if (fn) {
          try {
            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
          } catch (e) {
            handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
          }
        }
      }
      var baseModules = [
        ref2,
        directives
      ];
      function updateAttrs(oldVnode, vnode) {
        var opts2 = vnode.componentOptions;
        if (isDef(opts2) && opts2.Ctor.options.inheritAttrs === false) {
          return;
        }
        if (isUndef2(oldVnode.data.attrs) && isUndef2(vnode.data.attrs)) {
          return;
        }
        var key, cur, old;
        var elm = vnode.elm;
        var oldAttrs = oldVnode.data.attrs || {};
        var attrs2 = vnode.data.attrs || {};
        if (isDef(attrs2.__ob__)) {
          attrs2 = vnode.data.attrs = extend({}, attrs2);
        }
        for (key in attrs2) {
          cur = attrs2[key];
          old = oldAttrs[key];
          if (old !== cur) {
            setAttr(elm, key, cur, vnode.data.pre);
          }
        }
        if ((isIE || isEdge) && attrs2.value !== oldAttrs.value) {
          setAttr(elm, "value", attrs2.value);
        }
        for (key in oldAttrs) {
          if (isUndef2(attrs2[key])) {
            if (isXlink(key)) {
              elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
            } else if (!isEnumeratedAttr(key)) {
              elm.removeAttribute(key);
            }
          }
        }
      }
      function setAttr(el, key, value, isInPre) {
        if (isInPre || el.tagName.indexOf("-") > -1) {
          baseSetAttr(el, key, value);
        } else if (isBooleanAttr(key)) {
          if (isFalsyAttrValue(value)) {
            el.removeAttribute(key);
          } else {
            value = key === "allowfullscreen" && el.tagName === "EMBED" ? "true" : key;
            el.setAttribute(key, value);
          }
        } else if (isEnumeratedAttr(key)) {
          el.setAttribute(key, convertEnumeratedValue(key, value));
        } else if (isXlink(key)) {
          if (isFalsyAttrValue(value)) {
            el.removeAttributeNS(xlinkNS, getXlinkProp(key));
          } else {
            el.setAttributeNS(xlinkNS, key, value);
          }
        } else {
          baseSetAttr(el, key, value);
        }
      }
      function baseSetAttr(el, key, value) {
        if (isFalsyAttrValue(value)) {
          el.removeAttribute(key);
        } else {
          if (isIE && !isIE9 && el.tagName === "TEXTAREA" && key === "placeholder" && value !== "" && !el.__ieph) {
            var blocker = function(e) {
              e.stopImmediatePropagation();
              el.removeEventListener("input", blocker);
            };
            el.addEventListener("input", blocker);
            el.__ieph = true;
          }
          el.setAttribute(key, value);
        }
      }
      var attrs = {
        create: updateAttrs,
        update: updateAttrs
      };
      function updateClass(oldVnode, vnode) {
        var el = vnode.elm;
        var data2 = vnode.data;
        var oldData = oldVnode.data;
        if (isUndef2(data2.staticClass) && isUndef2(data2.class) && (isUndef2(oldData) || isUndef2(oldData.staticClass) && isUndef2(oldData.class))) {
          return;
        }
        var cls = genClassForVnode(vnode);
        var transitionClass = el._transitionClasses;
        if (isDef(transitionClass)) {
          cls = concat(cls, stringifyClass(transitionClass));
        }
        if (cls !== el._prevClass) {
          el.setAttribute("class", cls);
          el._prevClass = cls;
        }
      }
      var klass = {
        create: updateClass,
        update: updateClass
      };
      var RANGE_TOKEN = "__r";
      var CHECKBOX_RADIO_TOKEN = "__c";
      function normalizeEvents(on) {
        if (isDef(on[RANGE_TOKEN])) {
          var event = isIE ? "change" : "input";
          on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
          delete on[RANGE_TOKEN];
        }
        if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
          on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
          delete on[CHECKBOX_RADIO_TOKEN];
        }
      }
      var target$1;
      function createOnceHandler$1(event, handler2, capture) {
        var _target = target$1;
        return function onceHandler() {
          var res = handler2.apply(null, arguments);
          if (res !== null) {
            remove$2(event, onceHandler, capture, _target);
          }
        };
      }
      var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
      function add$1(name, handler2, capture, passive) {
        if (useMicrotaskFix) {
          var attachedTimestamp = currentFlushTimestamp;
          var original = handler2;
          handler2 = original._wrapper = function(e) {
            if (e.target === e.currentTarget || e.timeStamp >= attachedTimestamp || e.timeStamp <= 0 || e.target.ownerDocument !== document) {
              return original.apply(this, arguments);
            }
          };
        }
        target$1.addEventListener(name, handler2, supportsPassive ? { capture, passive } : capture);
      }
      function remove$2(name, handler2, capture, _target) {
        (_target || target$1).removeEventListener(name, handler2._wrapper || handler2, capture);
      }
      function updateDOMListeners(oldVnode, vnode) {
        if (isUndef2(oldVnode.data.on) && isUndef2(vnode.data.on)) {
          return;
        }
        var on = vnode.data.on || {};
        var oldOn = oldVnode.data.on || {};
        target$1 = vnode.elm;
        normalizeEvents(on);
        updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
        target$1 = void 0;
      }
      var events = {
        create: updateDOMListeners,
        update: updateDOMListeners
      };
      var svgContainer;
      function updateDOMProps(oldVnode, vnode) {
        if (isUndef2(oldVnode.data.domProps) && isUndef2(vnode.data.domProps)) {
          return;
        }
        var key, cur;
        var elm = vnode.elm;
        var oldProps = oldVnode.data.domProps || {};
        var props3 = vnode.data.domProps || {};
        if (isDef(props3.__ob__)) {
          props3 = vnode.data.domProps = extend({}, props3);
        }
        for (key in oldProps) {
          if (!(key in props3)) {
            elm[key] = "";
          }
        }
        for (key in props3) {
          cur = props3[key];
          if (key === "textContent" || key === "innerHTML") {
            if (vnode.children) {
              vnode.children.length = 0;
            }
            if (cur === oldProps[key]) {
              continue;
            }
            if (elm.childNodes.length === 1) {
              elm.removeChild(elm.childNodes[0]);
            }
          }
          if (key === "value" && elm.tagName !== "PROGRESS") {
            elm._value = cur;
            var strCur = isUndef2(cur) ? "" : String(cur);
            if (shouldUpdateValue(elm, strCur)) {
              elm.value = strCur;
            }
          } else if (key === "innerHTML" && isSVG(elm.tagName) && isUndef2(elm.innerHTML)) {
            svgContainer = svgContainer || document.createElement("div");
            svgContainer.innerHTML = "<svg>" + cur + "</svg>";
            var svg = svgContainer.firstChild;
            while (elm.firstChild) {
              elm.removeChild(elm.firstChild);
            }
            while (svg.firstChild) {
              elm.appendChild(svg.firstChild);
            }
          } else if (cur !== oldProps[key]) {
            try {
              elm[key] = cur;
            } catch (e) {
            }
          }
        }
      }
      function shouldUpdateValue(elm, checkVal) {
        return !elm.composing && (elm.tagName === "OPTION" || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
      }
      function isNotInFocusAndDirty(elm, checkVal) {
        var notInFocus = true;
        try {
          notInFocus = document.activeElement !== elm;
        } catch (e) {
        }
        return notInFocus && elm.value !== checkVal;
      }
      function isDirtyWithModifiers(elm, newVal) {
        var value = elm.value;
        var modifiers = elm._vModifiers;
        if (isDef(modifiers)) {
          if (modifiers.number) {
            return toNumber(value) !== toNumber(newVal);
          }
          if (modifiers.trim) {
            return value.trim() !== newVal.trim();
          }
        }
        return value !== newVal;
      }
      var domProps = {
        create: updateDOMProps,
        update: updateDOMProps
      };
      var parseStyleText = cached(function(cssText) {
        var res = {};
        var listDelimiter = /;(?![^(]*\))/g;
        var propertyDelimiter = /:(.+)/;
        cssText.split(listDelimiter).forEach(function(item) {
          if (item) {
            var tmp = item.split(propertyDelimiter);
            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
          }
        });
        return res;
      });
      function normalizeStyleData(data2) {
        var style2 = normalizeStyleBinding(data2.style);
        return data2.staticStyle ? extend(data2.staticStyle, style2) : style2;
      }
      function normalizeStyleBinding(bindingStyle) {
        if (Array.isArray(bindingStyle)) {
          return toObject(bindingStyle);
        }
        if (typeof bindingStyle === "string") {
          return parseStyleText(bindingStyle);
        }
        return bindingStyle;
      }
      function getStyle(vnode, checkChild) {
        var res = {};
        var styleData;
        if (checkChild) {
          var childNode = vnode;
          while (childNode.componentInstance) {
            childNode = childNode.componentInstance._vnode;
            if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
              extend(res, styleData);
            }
          }
        }
        if (styleData = normalizeStyleData(vnode.data)) {
          extend(res, styleData);
        }
        var parentNode2 = vnode;
        while (parentNode2 = parentNode2.parent) {
          if (parentNode2.data && (styleData = normalizeStyleData(parentNode2.data))) {
            extend(res, styleData);
          }
        }
        return res;
      }
      var cssVarRE = /^--/;
      var importantRE = /\s*!important$/;
      var setProp = function(el, name, val) {
        if (cssVarRE.test(name)) {
          el.style.setProperty(name, val);
        } else if (importantRE.test(val)) {
          el.style.setProperty(hyphenate(name), val.replace(importantRE, ""), "important");
        } else {
          var normalizedName = normalize(name);
          if (Array.isArray(val)) {
            for (var i = 0, len = val.length; i < len; i++) {
              el.style[normalizedName] = val[i];
            }
          } else {
            el.style[normalizedName] = val;
          }
        }
      };
      var vendorNames = ["Webkit", "Moz", "ms"];
      var emptyStyle;
      var normalize = cached(function(prop) {
        emptyStyle = emptyStyle || document.createElement("div").style;
        prop = camelize(prop);
        if (prop !== "filter" && prop in emptyStyle) {
          return prop;
        }
        var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
        for (var i = 0; i < vendorNames.length; i++) {
          var name = vendorNames[i] + capName;
          if (name in emptyStyle) {
            return name;
          }
        }
      });
      function updateStyle(oldVnode, vnode) {
        var data2 = vnode.data;
        var oldData = oldVnode.data;
        if (isUndef2(data2.staticStyle) && isUndef2(data2.style) && isUndef2(oldData.staticStyle) && isUndef2(oldData.style)) {
          return;
        }
        var cur, name;
        var el = vnode.elm;
        var oldStaticStyle = oldData.staticStyle;
        var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
        var oldStyle = oldStaticStyle || oldStyleBinding;
        var style2 = normalizeStyleBinding(vnode.data.style) || {};
        vnode.data.normalizedStyle = isDef(style2.__ob__) ? extend({}, style2) : style2;
        var newStyle = getStyle(vnode, true);
        for (name in oldStyle) {
          if (isUndef2(newStyle[name])) {
            setProp(el, name, "");
          }
        }
        for (name in newStyle) {
          cur = newStyle[name];
          if (cur !== oldStyle[name]) {
            setProp(el, name, cur == null ? "" : cur);
          }
        }
      }
      var style = {
        create: updateStyle,
        update: updateStyle
      };
      var whitespaceRE = /\s+/;
      function addClass(el, cls) {
        if (!cls || !(cls = cls.trim())) {
          return;
        }
        if (el.classList) {
          if (cls.indexOf(" ") > -1) {
            cls.split(whitespaceRE).forEach(function(c) {
              return el.classList.add(c);
            });
          } else {
            el.classList.add(cls);
          }
        } else {
          var cur = " " + (el.getAttribute("class") || "") + " ";
          if (cur.indexOf(" " + cls + " ") < 0) {
            el.setAttribute("class", (cur + cls).trim());
          }
        }
      }
      function removeClass(el, cls) {
        if (!cls || !(cls = cls.trim())) {
          return;
        }
        if (el.classList) {
          if (cls.indexOf(" ") > -1) {
            cls.split(whitespaceRE).forEach(function(c) {
              return el.classList.remove(c);
            });
          } else {
            el.classList.remove(cls);
          }
          if (!el.classList.length) {
            el.removeAttribute("class");
          }
        } else {
          var cur = " " + (el.getAttribute("class") || "") + " ";
          var tar = " " + cls + " ";
          while (cur.indexOf(tar) >= 0) {
            cur = cur.replace(tar, " ");
          }
          cur = cur.trim();
          if (cur) {
            el.setAttribute("class", cur);
          } else {
            el.removeAttribute("class");
          }
        }
      }
      function resolveTransition(def$$1) {
        if (!def$$1) {
          return;
        }
        if (typeof def$$1 === "object") {
          var res = {};
          if (def$$1.css !== false) {
            extend(res, autoCssTransition(def$$1.name || "v"));
          }
          extend(res, def$$1);
          return res;
        } else if (typeof def$$1 === "string") {
          return autoCssTransition(def$$1);
        }
      }
      var autoCssTransition = cached(function(name) {
        return {
          enterClass: name + "-enter",
          enterToClass: name + "-enter-to",
          enterActiveClass: name + "-enter-active",
          leaveClass: name + "-leave",
          leaveToClass: name + "-leave-to",
          leaveActiveClass: name + "-leave-active"
        };
      });
      var hasTransition = inBrowser && !isIE9;
      var TRANSITION = "transition";
      var ANIMATION = "animation";
      var transitionProp = "transition";
      var transitionEndEvent = "transitionend";
      var animationProp = "animation";
      var animationEndEvent = "animationend";
      if (hasTransition) {
        if (window.ontransitionend === void 0 && window.onwebkittransitionend !== void 0) {
          transitionProp = "WebkitTransition";
          transitionEndEvent = "webkitTransitionEnd";
        }
        if (window.onanimationend === void 0 && window.onwebkitanimationend !== void 0) {
          animationProp = "WebkitAnimation";
          animationEndEvent = "webkitAnimationEnd";
        }
      }
      var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function(fn) {
        return fn();
      };
      function nextFrame(fn) {
        raf(function() {
          raf(fn);
        });
      }
      function addTransitionClass(el, cls) {
        var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
        if (transitionClasses.indexOf(cls) < 0) {
          transitionClasses.push(cls);
          addClass(el, cls);
        }
      }
      function removeTransitionClass(el, cls) {
        if (el._transitionClasses) {
          remove(el._transitionClasses, cls);
        }
        removeClass(el, cls);
      }
      function whenTransitionEnds(el, expectedType, cb) {
        var ref3 = getTransitionInfo(el, expectedType);
        var type = ref3.type;
        var timeout = ref3.timeout;
        var propCount = ref3.propCount;
        if (!type) {
          return cb();
        }
        var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
        var ended = 0;
        var end = function() {
          el.removeEventListener(event, onEnd);
          cb();
        };
        var onEnd = function(e) {
          if (e.target === el) {
            if (++ended >= propCount) {
              end();
            }
          }
        };
        setTimeout(function() {
          if (ended < propCount) {
            end();
          }
        }, timeout + 1);
        el.addEventListener(event, onEnd);
      }
      var transformRE = /\b(transform|all)(,|$)/;
      function getTransitionInfo(el, expectedType) {
        var styles = window.getComputedStyle(el);
        var transitionDelays = (styles[transitionProp + "Delay"] || "").split(", ");
        var transitionDurations = (styles[transitionProp + "Duration"] || "").split(", ");
        var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
        var animationDelays = (styles[animationProp + "Delay"] || "").split(", ");
        var animationDurations = (styles[animationProp + "Duration"] || "").split(", ");
        var animationTimeout = getTimeout(animationDelays, animationDurations);
        var type;
        var timeout = 0;
        var propCount = 0;
        if (expectedType === TRANSITION) {
          if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
          }
        } else if (expectedType === ANIMATION) {
          if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
          }
        } else {
          timeout = Math.max(transitionTimeout, animationTimeout);
          type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
          propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
        }
        var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + "Property"]);
        return {
          type,
          timeout,
          propCount,
          hasTransform
        };
      }
      function getTimeout(delays, durations) {
        while (delays.length < durations.length) {
          delays = delays.concat(delays);
        }
        return Math.max.apply(null, durations.map(function(d, i) {
          return toMs(d) + toMs(delays[i]);
        }));
      }
      function toMs(s) {
        return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
      }
      function enter(vnode, toggleDisplay) {
        var el = vnode.elm;
        if (isDef(el._leaveCb)) {
          el._leaveCb.cancelled = true;
          el._leaveCb();
        }
        var data2 = resolveTransition(vnode.data.transition);
        if (isUndef2(data2)) {
          return;
        }
        if (isDef(el._enterCb) || el.nodeType !== 1) {
          return;
        }
        var css = data2.css;
        var type = data2.type;
        var enterClass = data2.enterClass;
        var enterToClass = data2.enterToClass;
        var enterActiveClass = data2.enterActiveClass;
        var appearClass = data2.appearClass;
        var appearToClass = data2.appearToClass;
        var appearActiveClass = data2.appearActiveClass;
        var beforeEnter = data2.beforeEnter;
        var enter2 = data2.enter;
        var afterEnter = data2.afterEnter;
        var enterCancelled = data2.enterCancelled;
        var beforeAppear = data2.beforeAppear;
        var appear = data2.appear;
        var afterAppear = data2.afterAppear;
        var appearCancelled = data2.appearCancelled;
        var duration = data2.duration;
        var context = activeInstance;
        var transitionNode = activeInstance.$vnode;
        while (transitionNode && transitionNode.parent) {
          context = transitionNode.context;
          transitionNode = transitionNode.parent;
        }
        var isAppear = !context._isMounted || !vnode.isRootInsert;
        if (isAppear && !appear && appear !== "") {
          return;
        }
        var startClass = isAppear && appearClass ? appearClass : enterClass;
        var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
        var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
        var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
        var enterHook = isAppear ? typeof appear === "function" ? appear : enter2 : enter2;
        var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
        var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
        var explicitEnterDuration = toNumber(isObject2(duration) ? duration.enter : duration);
        if (explicitEnterDuration != null) {
          checkDuration(explicitEnterDuration, "enter", vnode);
        }
        var expectsCSS = css !== false && !isIE9;
        var userWantsControl = getHookArgumentsLength(enterHook);
        var cb = el._enterCb = once(function() {
          if (expectsCSS) {
            removeTransitionClass(el, toClass);
            removeTransitionClass(el, activeClass);
          }
          if (cb.cancelled) {
            if (expectsCSS) {
              removeTransitionClass(el, startClass);
            }
            enterCancelledHook && enterCancelledHook(el);
          } else {
            afterEnterHook && afterEnterHook(el);
          }
          el._enterCb = null;
        });
        if (!vnode.data.show) {
          mergeVNodeHook(vnode, "insert", function() {
            var parent = el.parentNode;
            var pendingNode = parent && parent._pending && parent._pending[vnode.key];
            if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
              pendingNode.elm._leaveCb();
            }
            enterHook && enterHook(el, cb);
          });
        }
        beforeEnterHook && beforeEnterHook(el);
        if (expectsCSS) {
          addTransitionClass(el, startClass);
          addTransitionClass(el, activeClass);
          nextFrame(function() {
            removeTransitionClass(el, startClass);
            if (!cb.cancelled) {
              addTransitionClass(el, toClass);
              if (!userWantsControl) {
                if (isValidDuration(explicitEnterDuration)) {
                  setTimeout(cb, explicitEnterDuration);
                } else {
                  whenTransitionEnds(el, type, cb);
                }
              }
            }
          });
        }
        if (vnode.data.show) {
          toggleDisplay && toggleDisplay();
          enterHook && enterHook(el, cb);
        }
        if (!expectsCSS && !userWantsControl) {
          cb();
        }
      }
      function leave(vnode, rm) {
        var el = vnode.elm;
        if (isDef(el._enterCb)) {
          el._enterCb.cancelled = true;
          el._enterCb();
        }
        var data2 = resolveTransition(vnode.data.transition);
        if (isUndef2(data2) || el.nodeType !== 1) {
          return rm();
        }
        if (isDef(el._leaveCb)) {
          return;
        }
        var css = data2.css;
        var type = data2.type;
        var leaveClass = data2.leaveClass;
        var leaveToClass = data2.leaveToClass;
        var leaveActiveClass = data2.leaveActiveClass;
        var beforeLeave = data2.beforeLeave;
        var leave2 = data2.leave;
        var afterLeave = data2.afterLeave;
        var leaveCancelled = data2.leaveCancelled;
        var delayLeave = data2.delayLeave;
        var duration = data2.duration;
        var expectsCSS = css !== false && !isIE9;
        var userWantsControl = getHookArgumentsLength(leave2);
        var explicitLeaveDuration = toNumber(isObject2(duration) ? duration.leave : duration);
        if (isDef(explicitLeaveDuration)) {
          checkDuration(explicitLeaveDuration, "leave", vnode);
        }
        var cb = el._leaveCb = once(function() {
          if (el.parentNode && el.parentNode._pending) {
            el.parentNode._pending[vnode.key] = null;
          }
          if (expectsCSS) {
            removeTransitionClass(el, leaveToClass);
            removeTransitionClass(el, leaveActiveClass);
          }
          if (cb.cancelled) {
            if (expectsCSS) {
              removeTransitionClass(el, leaveClass);
            }
            leaveCancelled && leaveCancelled(el);
          } else {
            rm();
            afterLeave && afterLeave(el);
          }
          el._leaveCb = null;
        });
        if (delayLeave) {
          delayLeave(performLeave);
        } else {
          performLeave();
        }
        function performLeave() {
          if (cb.cancelled) {
            return;
          }
          if (!vnode.data.show && el.parentNode) {
            (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
          }
          beforeLeave && beforeLeave(el);
          if (expectsCSS) {
            addTransitionClass(el, leaveClass);
            addTransitionClass(el, leaveActiveClass);
            nextFrame(function() {
              removeTransitionClass(el, leaveClass);
              if (!cb.cancelled) {
                addTransitionClass(el, leaveToClass);
                if (!userWantsControl) {
                  if (isValidDuration(explicitLeaveDuration)) {
                    setTimeout(cb, explicitLeaveDuration);
                  } else {
                    whenTransitionEnds(el, type, cb);
                  }
                }
              }
            });
          }
          leave2 && leave2(el, cb);
          if (!expectsCSS && !userWantsControl) {
            cb();
          }
        }
      }
      function checkDuration(val, name, vnode) {
        if (typeof val !== "number") {
          warn2("<transition> explicit " + name + " duration is not a valid number - got " + JSON.stringify(val) + ".", vnode.context);
        } else if (isNaN(val)) {
          warn2("<transition> explicit " + name + " duration is NaN - the duration expression might be incorrect.", vnode.context);
        }
      }
      function isValidDuration(val) {
        return typeof val === "number" && !isNaN(val);
      }
      function getHookArgumentsLength(fn) {
        if (isUndef2(fn)) {
          return false;
        }
        var invokerFns = fn.fns;
        if (isDef(invokerFns)) {
          return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
        } else {
          return (fn._length || fn.length) > 1;
        }
      }
      function _enter(_, vnode) {
        if (vnode.data.show !== true) {
          enter(vnode);
        }
      }
      var transition = inBrowser ? {
        create: _enter,
        activate: _enter,
        remove: function remove$$1(vnode, rm) {
          if (vnode.data.show !== true) {
            leave(vnode, rm);
          } else {
            rm();
          }
        }
      } : {};
      var platformModules = [
        attrs,
        klass,
        events,
        domProps,
        style,
        transition
      ];
      var modules = platformModules.concat(baseModules);
      var patch = createPatchFunction({ nodeOps, modules });
      if (isIE9) {
        document.addEventListener("selectionchange", function() {
          var el = document.activeElement;
          if (el && el.vmodel) {
            trigger(el, "input");
          }
        });
      }
      var directive2 = {
        inserted: function inserted(el, binding, vnode, oldVnode) {
          if (vnode.tag === "select") {
            if (oldVnode.elm && !oldVnode.elm._vOptions) {
              mergeVNodeHook(vnode, "postpatch", function() {
                directive2.componentUpdated(el, binding, vnode);
              });
            } else {
              setSelected(el, binding, vnode.context);
            }
            el._vOptions = [].map.call(el.options, getValue);
          } else if (vnode.tag === "textarea" || isTextInputType(el.type)) {
            el._vModifiers = binding.modifiers;
            if (!binding.modifiers.lazy) {
              el.addEventListener("compositionstart", onCompositionStart);
              el.addEventListener("compositionend", onCompositionEnd);
              el.addEventListener("change", onCompositionEnd);
              if (isIE9) {
                el.vmodel = true;
              }
            }
          }
        },
        componentUpdated: function componentUpdated(el, binding, vnode) {
          if (vnode.tag === "select") {
            setSelected(el, binding, vnode.context);
            var prevOptions = el._vOptions;
            var curOptions = el._vOptions = [].map.call(el.options, getValue);
            if (curOptions.some(function(o, i) {
              return !looseEqual(o, prevOptions[i]);
            })) {
              var needReset = el.multiple ? binding.value.some(function(v) {
                return hasNoMatchingOption(v, curOptions);
              }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
              if (needReset) {
                trigger(el, "change");
              }
            }
          }
        }
      };
      function setSelected(el, binding, vm) {
        actuallySetSelected(el, binding, vm);
        if (isIE || isEdge) {
          setTimeout(function() {
            actuallySetSelected(el, binding, vm);
          }, 0);
        }
      }
      function actuallySetSelected(el, binding, vm) {
        var value = binding.value;
        var isMultiple = el.multiple;
        if (isMultiple && !Array.isArray(value)) {
          warn2('<select multiple v-model="' + binding.expression + '"> expects an Array value for its binding, but got ' + Object.prototype.toString.call(value).slice(8, -1), vm);
          return;
        }
        var selected, option;
        for (var i = 0, l = el.options.length; i < l; i++) {
          option = el.options[i];
          if (isMultiple) {
            selected = looseIndexOf(value, getValue(option)) > -1;
            if (option.selected !== selected) {
              option.selected = selected;
            }
          } else {
            if (looseEqual(getValue(option), value)) {
              if (el.selectedIndex !== i) {
                el.selectedIndex = i;
              }
              return;
            }
          }
        }
        if (!isMultiple) {
          el.selectedIndex = -1;
        }
      }
      function hasNoMatchingOption(value, options) {
        return options.every(function(o) {
          return !looseEqual(o, value);
        });
      }
      function getValue(option) {
        return "_value" in option ? option._value : option.value;
      }
      function onCompositionStart(e) {
        e.target.composing = true;
      }
      function onCompositionEnd(e) {
        if (!e.target.composing) {
          return;
        }
        e.target.composing = false;
        trigger(e.target, "input");
      }
      function trigger(el, type) {
        var e = document.createEvent("HTMLEvents");
        e.initEvent(type, true, true);
        el.dispatchEvent(e);
      }
      function locateNode(vnode) {
        return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
      }
      var show = {
        bind: function bind2(el, ref3, vnode) {
          var value = ref3.value;
          vnode = locateNode(vnode);
          var transition$$1 = vnode.data && vnode.data.transition;
          var originalDisplay = el.__vOriginalDisplay = el.style.display === "none" ? "" : el.style.display;
          if (value && transition$$1) {
            vnode.data.show = true;
            enter(vnode, function() {
              el.style.display = originalDisplay;
            });
          } else {
            el.style.display = value ? originalDisplay : "none";
          }
        },
        update: function update(el, ref3, vnode) {
          var value = ref3.value;
          var oldValue = ref3.oldValue;
          if (!value === !oldValue) {
            return;
          }
          vnode = locateNode(vnode);
          var transition$$1 = vnode.data && vnode.data.transition;
          if (transition$$1) {
            vnode.data.show = true;
            if (value) {
              enter(vnode, function() {
                el.style.display = el.__vOriginalDisplay;
              });
            } else {
              leave(vnode, function() {
                el.style.display = "none";
              });
            }
          } else {
            el.style.display = value ? el.__vOriginalDisplay : "none";
          }
        },
        unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
          if (!isDestroy) {
            el.style.display = el.__vOriginalDisplay;
          }
        }
      };
      var platformDirectives = {
        model: directive2,
        show
      };
      var transitionProps = {
        name: String,
        appear: Boolean,
        css: Boolean,
        mode: String,
        type: String,
        enterClass: String,
        leaveClass: String,
        enterToClass: String,
        leaveToClass: String,
        enterActiveClass: String,
        leaveActiveClass: String,
        appearClass: String,
        appearActiveClass: String,
        appearToClass: String,
        duration: [Number, String, Object]
      };
      function getRealChild(vnode) {
        var compOptions = vnode && vnode.componentOptions;
        if (compOptions && compOptions.Ctor.options.abstract) {
          return getRealChild(getFirstComponentChild(compOptions.children));
        } else {
          return vnode;
        }
      }
      function extractTransitionData(comp) {
        var data2 = {};
        var options = comp.$options;
        for (var key in options.propsData) {
          data2[key] = comp[key];
        }
        var listeners = options._parentListeners;
        for (var key$1 in listeners) {
          data2[camelize(key$1)] = listeners[key$1];
        }
        return data2;
      }
      function placeholder(h, rawChild) {
        if (/\d-keep-alive$/.test(rawChild.tag)) {
          return h("keep-alive", {
            props: rawChild.componentOptions.propsData
          });
        }
      }
      function hasParentTransition(vnode) {
        while (vnode = vnode.parent) {
          if (vnode.data.transition) {
            return true;
          }
        }
      }
      function isSameChild(child, oldChild) {
        return oldChild.key === child.key && oldChild.tag === child.tag;
      }
      var isNotTextNode = function(c) {
        return c.tag || isAsyncPlaceholder(c);
      };
      var isVShowDirective = function(d) {
        return d.name === "show";
      };
      var Transition = {
        name: "transition",
        props: transitionProps,
        abstract: true,
        render: function render2(h) {
          var this$1 = this;
          var children = this.$slots.default;
          if (!children) {
            return;
          }
          children = children.filter(isNotTextNode);
          if (!children.length) {
            return;
          }
          if (children.length > 1) {
            warn2("<transition> can only be used on a single element. Use <transition-group> for lists.", this.$parent);
          }
          var mode = this.mode;
          if (mode && mode !== "in-out" && mode !== "out-in") {
            warn2("invalid <transition> mode: " + mode, this.$parent);
          }
          var rawChild = children[0];
          if (hasParentTransition(this.$vnode)) {
            return rawChild;
          }
          var child = getRealChild(rawChild);
          if (!child) {
            return rawChild;
          }
          if (this._leaving) {
            return placeholder(h, rawChild);
          }
          var id = "__transition-" + this._uid + "-";
          child.key = child.key == null ? child.isComment ? id + "comment" : id + child.tag : isPrimitive2(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
          var data2 = (child.data || (child.data = {})).transition = extractTransitionData(this);
          var oldRawChild = this._vnode;
          var oldChild = getRealChild(oldRawChild);
          if (child.data.directives && child.data.directives.some(isVShowDirective)) {
            child.data.show = true;
          }
          if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
            var oldData = oldChild.data.transition = extend({}, data2);
            if (mode === "out-in") {
              this._leaving = true;
              mergeVNodeHook(oldData, "afterLeave", function() {
                this$1._leaving = false;
                this$1.$forceUpdate();
              });
              return placeholder(h, rawChild);
            } else if (mode === "in-out") {
              if (isAsyncPlaceholder(child)) {
                return oldRawChild;
              }
              var delayedLeave;
              var performLeave = function() {
                delayedLeave();
              };
              mergeVNodeHook(data2, "afterEnter", performLeave);
              mergeVNodeHook(data2, "enterCancelled", performLeave);
              mergeVNodeHook(oldData, "delayLeave", function(leave2) {
                delayedLeave = leave2;
              });
            }
          }
          return rawChild;
        }
      };
      var props2 = extend({
        tag: String,
        moveClass: String
      }, transitionProps);
      delete props2.mode;
      var TransitionGroup = {
        props: props2,
        beforeMount: function beforeMount() {
          var this$1 = this;
          var update = this._update;
          this._update = function(vnode, hydrating) {
            var restoreActiveInstance = setActiveInstance(this$1);
            this$1.__patch__(this$1._vnode, this$1.kept, false, true);
            this$1._vnode = this$1.kept;
            restoreActiveInstance();
            update.call(this$1, vnode, hydrating);
          };
        },
        render: function render2(h) {
          var tag = this.tag || this.$vnode.data.tag || "span";
          var map = /* @__PURE__ */ Object.create(null);
          var prevChildren = this.prevChildren = this.children;
          var rawChildren = this.$slots.default || [];
          var children = this.children = [];
          var transitionData = extractTransitionData(this);
          for (var i = 0; i < rawChildren.length; i++) {
            var c = rawChildren[i];
            if (c.tag) {
              if (c.key != null && String(c.key).indexOf("__vlist") !== 0) {
                children.push(c);
                map[c.key] = c;
                (c.data || (c.data = {})).transition = transitionData;
              } else {
                var opts2 = c.componentOptions;
                var name = opts2 ? opts2.Ctor.options.name || opts2.tag || "" : c.tag;
                warn2("<transition-group> children must be keyed: <" + name + ">");
              }
            }
          }
          if (prevChildren) {
            var kept = [];
            var removed = [];
            for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
              var c$1 = prevChildren[i$1];
              c$1.data.transition = transitionData;
              c$1.data.pos = c$1.elm.getBoundingClientRect();
              if (map[c$1.key]) {
                kept.push(c$1);
              } else {
                removed.push(c$1);
              }
            }
            this.kept = h(tag, null, kept);
            this.removed = removed;
          }
          return h(tag, null, children);
        },
        updated: function updated() {
          var children = this.prevChildren;
          var moveClass = this.moveClass || (this.name || "v") + "-move";
          if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
            return;
          }
          children.forEach(callPendingCbs);
          children.forEach(recordPosition);
          children.forEach(applyTranslation);
          this._reflow = document.body.offsetHeight;
          children.forEach(function(c) {
            if (c.data.moved) {
              var el = c.elm;
              var s = el.style;
              addTransitionClass(el, moveClass);
              s.transform = s.WebkitTransform = s.transitionDuration = "";
              el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
                if (e && e.target !== el) {
                  return;
                }
                if (!e || /transform$/.test(e.propertyName)) {
                  el.removeEventListener(transitionEndEvent, cb);
                  el._moveCb = null;
                  removeTransitionClass(el, moveClass);
                }
              });
            }
          });
        },
        methods: {
          hasMove: function hasMove(el, moveClass) {
            if (!hasTransition) {
              return false;
            }
            if (this._hasMove) {
              return this._hasMove;
            }
            var clone = el.cloneNode();
            if (el._transitionClasses) {
              el._transitionClasses.forEach(function(cls) {
                removeClass(clone, cls);
              });
            }
            addClass(clone, moveClass);
            clone.style.display = "none";
            this.$el.appendChild(clone);
            var info = getTransitionInfo(clone);
            this.$el.removeChild(clone);
            return this._hasMove = info.hasTransform;
          }
        }
      };
      function callPendingCbs(c) {
        if (c.elm._moveCb) {
          c.elm._moveCb();
        }
        if (c.elm._enterCb) {
          c.elm._enterCb();
        }
      }
      function recordPosition(c) {
        c.data.newPos = c.elm.getBoundingClientRect();
      }
      function applyTranslation(c) {
        var oldPos = c.data.pos;
        var newPos = c.data.newPos;
        var dx = oldPos.left - newPos.left;
        var dy = oldPos.top - newPos.top;
        if (dx || dy) {
          c.data.moved = true;
          var s = c.elm.style;
          s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
          s.transitionDuration = "0s";
        }
      }
      var platformComponents = {
        Transition,
        TransitionGroup
      };
      Vue4.config.mustUseProp = mustUseProp;
      Vue4.config.isReservedTag = isReservedTag;
      Vue4.config.isReservedAttr = isReservedAttr;
      Vue4.config.getTagNamespace = getTagNamespace;
      Vue4.config.isUnknownElement = isUnknownElement;
      extend(Vue4.options.directives, platformDirectives);
      extend(Vue4.options.components, platformComponents);
      Vue4.prototype.__patch__ = inBrowser ? patch : noop;
      Vue4.prototype.$mount = function(el, hydrating) {
        el = el && inBrowser ? query(el) : void 0;
        return mountComponent(this, el, hydrating);
      };
      if (inBrowser) {
        setTimeout(function() {
          if (config.devtools) {
            if (devtools) {
              devtools.emit("init", Vue4);
            } else {
              console[console.info ? "info" : "log"]("Download the Vue Devtools extension for a better development experience:\nhttps://github.com/vuejs/vue-devtools");
            }
          }
          if (config.productionTip !== false && typeof console !== "undefined") {
            console[console.info ? "info" : "log"]("You are running Vue in development mode.\nMake sure to turn on production mode when deploying for production.\nSee more tips at https://vuejs.org/guide/deployment.html");
          }
        }, 0);
      }
      module.exports = Vue4;
    }
  });

  // node_modules/vue/dist/vue.runtime.common.js
  var require_vue_runtime_common = __commonJS({
    "node_modules/vue/dist/vue.runtime.common.js"(exports, module) {
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_vue_runtime_common_dev();
      }
    }
  });

  // node_modules/@vue/composition-api/dist/vue-composition-api.mjs
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  function warn$1(message) {
    var _a;
    warn(message, (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy);
  }
  function recordEffectScope(effect, scope) {
    var _a;
    scope = scope || activeEffectScope;
    if (scope && scope.active) {
      scope.effects.push(effect);
      return;
    }
    var vm = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;
    vm && vm.$on("hook:destroyed", function() {
      return effect.stop();
    });
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function getCurrentScopeVM() {
    var _a, _b;
    return ((_a = getCurrentScope()) === null || _a === void 0 ? void 0 : _a.vm) || ((_b = getCurrentInstance()) === null || _b === void 0 ? void 0 : _b.proxy);
  }
  function bindCurrentScopeToVM(vm) {
    if (!vm.scope) {
      var scope_1 = new EffectScopeImpl(vm.proxy);
      vm.scope = scope_1;
      vm.proxy.$on("hook:destroyed", function() {
        return scope_1.stop();
      });
    }
    return vm.scope;
  }
  function isVue(obj) {
    return obj && isFunction(obj) && obj.name === "Vue";
  }
  function isVueRegistered(Vue4) {
    return vueConstructor && hasOwn(Vue4, PluginInstalledFlag);
  }
  function getVueConstructor() {
    if (true) {
      assert(vueConstructor, "must call Vue.use(VueCompositionAPI) before using any function.");
    }
    return vueConstructor;
  }
  function getRegisteredVueOrDefault() {
    var constructor = vueConstructor || vueDependency;
    if (true) {
      assert(constructor, "No vue dependency found.");
    }
    return constructor;
  }
  function setVueConstructor(Vue4) {
    if (vueConstructor && Vue4.__proto__ !== vueConstructor.__proto__) {
      warn("[vue-composition-api] another instance of Vue installed");
    }
    vueConstructor = Vue4;
    Object.defineProperty(Vue4, PluginInstalledFlag, {
      configurable: true,
      writable: true,
      value: true
    });
  }
  function withCurrentInstanceTrackingDisabled(fn) {
    var prev = currentInstanceTracking;
    currentInstanceTracking = false;
    try {
      fn();
    } finally {
      currentInstanceTracking = prev;
    }
  }
  function setCurrentInstance(instance) {
    if (!currentInstanceTracking)
      return;
    var prev = currentInstance;
    prev === null || prev === void 0 ? void 0 : prev.scope.off();
    currentInstance = instance;
    currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.scope.on();
  }
  function getCurrentInstance() {
    return currentInstance;
  }
  function toVue3ComponentInstance(vm) {
    if (instanceMapCache.has(vm)) {
      return instanceMapCache.get(vm);
    }
    var instance = {
      proxy: vm,
      update: vm.$forceUpdate,
      type: vm.$options,
      uid: vm._uid,
      emit: vm.$emit.bind(vm),
      parent: null,
      root: null
    };
    bindCurrentScopeToVM(instance);
    var instanceProps = [
      "data",
      "props",
      "attrs",
      "refs",
      "vnode",
      "slots"
    ];
    instanceProps.forEach(function(prop) {
      proxy(instance, prop, {
        get: function() {
          return vm["$".concat(prop)];
        }
      });
    });
    proxy(instance, "isMounted", {
      get: function() {
        return vm._isMounted;
      }
    });
    proxy(instance, "isUnmounted", {
      get: function() {
        return vm._isDestroyed;
      }
    });
    proxy(instance, "isDeactivated", {
      get: function() {
        return vm._inactive;
      }
    });
    proxy(instance, "emitted", {
      get: function() {
        return vm._events;
      }
    });
    instanceMapCache.set(vm, instance);
    if (vm.$parent) {
      instance.parent = toVue3ComponentInstance(vm.$parent);
    }
    if (vm.$root) {
      instance.root = toVue3ComponentInstance(vm.$root);
    }
    return instance;
  }
  function isNative(Ctor) {
    return typeof Ctor === "function" && /native code/.test(Ctor.toString());
  }
  function proxy(target, key, _a) {
    var get2 = _a.get, set3 = _a.set;
    Object.defineProperty(target, key, {
      enumerable: true,
      configurable: true,
      get: get2 || noopFn,
      set: set3 || noopFn
    });
  }
  function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    });
  }
  function hasOwn(obj, key) {
    return Object.hasOwnProperty.call(obj, key);
  }
  function assert(condition, msg) {
    if (!condition) {
      throw new Error("[vue-composition-api] ".concat(msg));
    }
  }
  function isPrimitive(value) {
    return typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "boolean";
  }
  function isArray(x) {
    return Array.isArray(x);
  }
  function isValidArrayIndex(val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val) && n <= MAX_VALID_ARRAY_LENGTH;
  }
  function isObject(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject(x) {
    return toString(x) === "[object Object]";
  }
  function isFunction(x) {
    return typeof x === "function";
  }
  function isUndef(v) {
    return v === void 0 || v === null;
  }
  function warn(msg, vm) {
    var Vue4 = getRegisteredVueOrDefault();
    if (!Vue4 || !Vue4.util)
      console.warn("[vue-composition-api] ".concat(msg));
    else
      Vue4.util.warn(msg, vm);
  }
  function logError(err, vm, info) {
    if (true) {
      warn("Error in ".concat(info, ': "').concat(err.toString(), '"'), vm);
    }
    if (typeof window !== "undefined" && typeof console !== "undefined") {
      console.error(err);
    } else {
      throw err;
    }
  }
  function isSame(value1, value2) {
    if (value1 === value2) {
      return value1 !== 0 || 1 / value1 === 1 / value2;
    } else {
      return value1 !== value1 && value2 !== value2;
    }
  }
  function getCurrentInstanceForFn(hook, target) {
    target = target || getCurrentInstance();
    if (!target) {
      warn("".concat(hook, " is called when there is no active component instance to be ") + "associated with. Lifecycle injection APIs can only be used during execution of setup().");
    }
    return target;
  }
  function defineComponentInstance(Ctor, options) {
    if (options === void 0) {
      options = {};
    }
    var silent = Ctor.config.silent;
    Ctor.config.silent = true;
    var vm = new Ctor(options);
    Ctor.config.silent = silent;
    return vm;
  }
  function isComponentInstance(obj) {
    var Vue4 = getVueConstructor();
    return Vue4 && obj instanceof Vue4;
  }
  function createSlotProxy(vm, slotName) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!vm.$scopedSlots[slotName]) {
        if (true)
          return warn("slots.".concat(slotName, '() got called outside of the "render()" scope'), vm);
        return;
      }
      return vm.$scopedSlots[slotName].apply(vm, args);
    };
  }
  function resolveSlots(slots, normalSlots) {
    var res;
    if (!slots) {
      res = {};
    } else if (slots._normalized) {
      return slots._normalized;
    } else {
      res = {};
      for (var key in slots) {
        if (slots[key] && key[0] !== "$") {
          res[key] = true;
        }
      }
    }
    for (var key in normalSlots) {
      if (!(key in res)) {
        res[key] = true;
      }
    }
    return res;
  }
  function createSymbol(name) {
    return hasSymbol ? Symbol.for(name) : name;
  }
  function set$1(target, key, val) {
    var Vue4 = getVueConstructor();
    var _a = Vue4.util, warn2 = _a.warn, defineReactive = _a.defineReactive;
    if (isUndef(target) || isPrimitive(target)) {
      warn2("Cannot set reactive property on undefined, null, or primitive value: ".concat(target));
    }
    var ob = target.__ob__;
    function ssrMockReactivity() {
      if (ob && isObject(val) && !hasOwn(val, "__ob__")) {
        mockReactivityDeep(val);
      }
    }
    if (isArray(target)) {
      if (isValidArrayIndex(key)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        ssrMockReactivity();
        return val;
      } else if (key === "length" && val !== target.length) {
        target.length = val;
        ob === null || ob === void 0 ? void 0 : ob.dep.notify();
        return val;
      }
    }
    if (key in target && !(key in Object.prototype)) {
      target[key] = val;
      ssrMockReactivity();
      return val;
    }
    if (target._isVue || ob && ob.vmCount) {
      warn2("Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.");
      return val;
    }
    if (!ob) {
      target[key] = val;
      return val;
    }
    defineReactive(ob.value, key, val);
    defineAccessControl(target, key, val);
    ssrMockReactivity();
    ob.dep.notify();
    return val;
  }
  function createRef(options, isReadonly2, isComputed) {
    if (isReadonly2 === void 0) {
      isReadonly2 = false;
    }
    if (isComputed === void 0) {
      isComputed = false;
    }
    var r = new RefImpl(options);
    if (isComputed)
      r.effect = true;
    var sealed = Object.seal(r);
    if (isReadonly2)
      readonlySet.set(sealed, true);
    return sealed;
  }
  function ref(raw) {
    var _a;
    if (isRef(raw)) {
      return raw;
    }
    var value = reactive((_a = {}, _a[RefKey] = raw, _a));
    return createRef({
      get: function() {
        return value[RefKey];
      },
      set: function(v) {
        return value[RefKey] = v;
      }
    });
  }
  function isRef(value) {
    return value instanceof RefImpl;
  }
  function toRefs(obj) {
    if (!isReactive(obj)) {
      warn("toRefs() expects a reactive object but received a plain one.");
    }
    if (!isPlainObject(obj))
      return obj;
    var ret = {};
    for (var key in obj) {
      ret[key] = toRef(obj, key);
    }
    return ret;
  }
  function toRef(object, key) {
    if (!(key in object))
      set$1(object, key, void 0);
    var v = object[key];
    if (isRef(v))
      return v;
    return createRef({
      get: function() {
        return object[key];
      },
      set: function(v2) {
        return object[key] = v2;
      }
    });
  }
  function isRaw(obj) {
    var _a;
    return Boolean(obj && hasOwn(obj, "__ob__") && typeof obj.__ob__ === "object" && ((_a = obj.__ob__) === null || _a === void 0 ? void 0 : _a.__raw__));
  }
  function isReactive(obj) {
    var _a;
    return Boolean(obj && hasOwn(obj, "__ob__") && typeof obj.__ob__ === "object" && !((_a = obj.__ob__) === null || _a === void 0 ? void 0 : _a.__raw__));
  }
  function setupAccessControl(target) {
    if (!isPlainObject(target) || isRaw(target) || isArray(target) || isRef(target) || isComponentInstance(target) || accessModifiedSet.has(target))
      return;
    accessModifiedSet.set(target, true);
    var keys = Object.keys(target);
    for (var i = 0; i < keys.length; i++) {
      defineAccessControl(target, keys[i]);
    }
  }
  function defineAccessControl(target, key, val) {
    if (key === "__ob__")
      return;
    if (isRaw(target[key]))
      return;
    var getter;
    var setter;
    var property = Object.getOwnPropertyDescriptor(target, key);
    if (property) {
      if (property.configurable === false) {
        return;
      }
      getter = property.get;
      setter = property.set;
      if ((!getter || setter) && arguments.length === 2) {
        val = target[key];
      }
    }
    setupAccessControl(val);
    proxy(target, key, {
      get: function getterHandler() {
        var value = getter ? getter.call(target) : val;
        if (key !== RefKey && isRef(value)) {
          return value.value;
        } else {
          return value;
        }
      },
      set: function setterHandler(newVal) {
        if (getter && !setter)
          return;
        if (key !== RefKey && isRef(val) && !isRef(newVal)) {
          val.value = newVal;
        } else if (setter) {
          setter.call(target, newVal);
          val = newVal;
        } else {
          val = newVal;
        }
        setupAccessControl(newVal);
      }
    });
  }
  function observe(obj) {
    var Vue4 = getRegisteredVueOrDefault();
    var observed;
    if (Vue4.observable) {
      observed = Vue4.observable(obj);
    } else {
      var vm = defineComponentInstance(Vue4, {
        data: {
          $$state: obj
        }
      });
      observed = vm._data.$$state;
    }
    if (!hasOwn(observed, "__ob__")) {
      mockReactivityDeep(observed);
    }
    return observed;
  }
  function mockReactivityDeep(obj, seen) {
    var e_1, _a;
    if (seen === void 0) {
      seen = /* @__PURE__ */ new Set();
    }
    if (seen.has(obj) || hasOwn(obj, "__ob__") || !Object.isExtensible(obj))
      return;
    def(obj, "__ob__", mockObserver(obj));
    seen.add(obj);
    try {
      for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var key = _c.value;
        var value = obj[key];
        if (!(isPlainObject(value) || isArray(value)) || isRaw(value) || !Object.isExtensible(value)) {
          continue;
        }
        mockReactivityDeep(value, seen);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  }
  function mockObserver(value) {
    if (value === void 0) {
      value = {};
    }
    return {
      value,
      dep: {
        notify: noopFn,
        depend: noopFn,
        addSub: noopFn,
        removeSub: noopFn
      }
    };
  }
  function createObserver() {
    return observe({}).__ob__;
  }
  function reactive(obj) {
    if (!isObject(obj)) {
      if (true) {
        warn('"reactive()" must be called on an object.');
      }
      return obj;
    }
    if (!(isPlainObject(obj) || isArray(obj)) || isRaw(obj) || !Object.isExtensible(obj)) {
      return obj;
    }
    var observed = observe(obj);
    setupAccessControl(observed);
    return observed;
  }
  function readonly(target) {
    if (!isObject(target)) {
      warn("value cannot be made reactive: ".concat(String(target)));
    } else {
      readonlySet.set(target, true);
    }
    return target;
  }
  function createLifeCycle(lifeCyclehook) {
    return function(callback, target) {
      var instance = getCurrentInstanceForFn(genName(lifeCyclehook), target);
      return instance && injectHookOption(getVueConstructor(), instance, lifeCyclehook, callback);
    };
  }
  function injectHookOption(Vue4, instance, hook, val) {
    var options = instance.proxy.$options;
    var mergeFn = Vue4.config.optionMergeStrategies[hook];
    var wrappedHook = wrapHookCall(instance, val);
    options[hook] = mergeFn(options[hook], wrappedHook);
    return wrappedHook;
  }
  function wrapHookCall(instance, fn) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var prev = getCurrentInstance();
      setCurrentInstance(instance);
      try {
        return fn.apply(void 0, __spreadArray([], __read(args), false));
      } finally {
        setCurrentInstance(prev);
      }
    };
  }
  function flushPreQueue() {
    flushQueue(this, WatcherPreFlushQueueKey);
  }
  function flushPostQueue() {
    flushQueue(this, WatcherPostFlushQueueKey);
  }
  function hasWatchEnv(vm) {
    return vm[WatcherPreFlushQueueKey] !== void 0;
  }
  function installWatchEnv(vm) {
    vm[WatcherPreFlushQueueKey] = [];
    vm[WatcherPostFlushQueueKey] = [];
    vm.$on("hook:beforeUpdate", flushPreQueue);
    vm.$on("hook:updated", flushPostQueue);
  }
  function getWatcherOption(options) {
    return __assign({
      immediate: false,
      deep: false,
      flush: "pre"
    }, options);
  }
  function getWatcherVM() {
    var vm = getCurrentScopeVM();
    if (!vm) {
      if (!fallbackVM) {
        fallbackVM = defineComponentInstance(getVueConstructor());
      }
      vm = fallbackVM;
    } else if (!hasWatchEnv(vm)) {
      installWatchEnv(vm);
    }
    return vm;
  }
  function flushQueue(vm, key) {
    var queue = vm[key];
    for (var index = 0; index < queue.length; index++) {
      queue[index]();
    }
    queue.length = 0;
  }
  function queueFlushJob(vm, fn, mode) {
    var fallbackFlush = function() {
      vm.$nextTick(function() {
        if (vm[WatcherPreFlushQueueKey].length) {
          flushQueue(vm, WatcherPreFlushQueueKey);
        }
        if (vm[WatcherPostFlushQueueKey].length) {
          flushQueue(vm, WatcherPostFlushQueueKey);
        }
      });
    };
    switch (mode) {
      case "pre":
        fallbackFlush();
        vm[WatcherPreFlushQueueKey].push(fn);
        break;
      case "post":
        fallbackFlush();
        vm[WatcherPostFlushQueueKey].push(fn);
        break;
      default:
        assert(false, 'flush must be one of ["post", "pre", "sync"], but got '.concat(mode));
        break;
    }
  }
  function createVueWatcher(vm, getter, callback, options) {
    var index = vm._watchers.length;
    vm.$watch(getter, callback, {
      immediate: options.immediateInvokeCallback,
      deep: options.deep,
      lazy: options.noRun,
      sync: options.sync,
      before: options.before
    });
    return vm._watchers[index];
  }
  function patchWatcherTeardown(watcher, runCleanup) {
    var _teardown = watcher.teardown;
    watcher.teardown = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      _teardown.apply(watcher, args);
      runCleanup();
    };
  }
  function createWatcher(vm, source, cb, options) {
    var _a;
    if (!cb) {
      if (options.immediate !== void 0) {
        warn('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.');
      }
      if (options.deep !== void 0) {
        warn('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.');
      }
    }
    var flushMode = options.flush;
    var isSync = flushMode === "sync";
    var cleanup;
    var registerCleanup = function(fn) {
      cleanup = function() {
        try {
          fn();
        } catch (error) {
          logError(error, vm, "onCleanup()");
        }
      };
    };
    var runCleanup = function() {
      if (cleanup) {
        cleanup();
        cleanup = null;
      }
    };
    var createScheduler = function(fn) {
      if (isSync || vm === fallbackVM) {
        return fn;
      }
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return queueFlushJob(vm, function() {
          fn.apply(void 0, __spreadArray([], __read(args), false));
        }, flushMode);
      };
    };
    if (cb === null) {
      var running_1 = false;
      var getter_1 = function() {
        if (running_1) {
          return;
        }
        try {
          running_1 = true;
          source(registerCleanup);
        } finally {
          running_1 = false;
        }
      };
      var watcher_1 = createVueWatcher(vm, getter_1, noopFn, {
        deep: options.deep || false,
        sync: isSync,
        before: runCleanup
      });
      patchWatcherTeardown(watcher_1, runCleanup);
      watcher_1.lazy = false;
      var originGet = watcher_1.get.bind(watcher_1);
      watcher_1.get = createScheduler(originGet);
      return function() {
        watcher_1.teardown();
      };
    }
    var deep = options.deep;
    var isMultiSource = false;
    var getter;
    if (isRef(source)) {
      getter = function() {
        return source.value;
      };
    } else if (isReactive(source)) {
      getter = function() {
        return source;
      };
      deep = true;
    } else if (isArray(source)) {
      isMultiSource = true;
      getter = function() {
        return source.map(function(s) {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return traverse(s);
          } else if (isFunction(s)) {
            return s();
          } else {
            warn("Invalid watch source: ".concat(JSON.stringify(s), ".\n          A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."), vm);
            return noopFn;
          }
        });
      };
    } else if (isFunction(source)) {
      getter = source;
    } else {
      getter = noopFn;
      warn("Invalid watch source: ".concat(JSON.stringify(source), ".\n      A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."), vm);
    }
    if (deep) {
      var baseGetter_1 = getter;
      getter = function() {
        return traverse(baseGetter_1());
      };
    }
    var applyCb = function(n, o) {
      if (!deep && isMultiSource && n.every(function(v, i) {
        return isSame(v, o[i]);
      }))
        return;
      runCleanup();
      return cb(n, o, registerCleanup);
    };
    var callback = createScheduler(applyCb);
    if (options.immediate) {
      var originalCallback_1 = callback;
      var shiftCallback_1 = function(n, o) {
        shiftCallback_1 = originalCallback_1;
        return applyCb(n, isArray(n) ? [] : o);
      };
      callback = function(n, o) {
        return shiftCallback_1(n, o);
      };
    }
    var stop = vm.$watch(getter, callback, {
      immediate: options.immediate,
      deep,
      sync: isSync
    });
    var watcher = vm._watchers[vm._watchers.length - 1];
    if (isReactive(watcher.value) && ((_a = watcher.value.__ob__) === null || _a === void 0 ? void 0 : _a.dep) && deep) {
      watcher.value.__ob__.dep.addSub({
        update: function() {
          watcher.run();
        }
      });
    }
    patchWatcherTeardown(watcher, runCleanup);
    return function() {
      stop();
    };
  }
  function watch(source, cb, options) {
    var callback = null;
    if (isFunction(cb)) {
      callback = cb;
    } else {
      if (true) {
        warn("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature.");
      }
      options = cb;
      callback = null;
    }
    var opts = getWatcherOption(options);
    var vm = getWatcherVM();
    return createWatcher(vm, source, callback, opts);
  }
  function traverse(value, seen) {
    if (seen === void 0) {
      seen = /* @__PURE__ */ new Set();
    }
    if (!isObject(value) || seen.has(value) || rawSet.has(value)) {
      return value;
    }
    seen.add(value);
    if (isRef(value)) {
      traverse(value.value, seen);
    } else if (isArray(value)) {
      for (var i = 0; i < value.length; i++) {
        traverse(value[i], seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach(function(v) {
        traverse(v, seen);
      });
    } else if (isPlainObject(value)) {
      for (var key in value) {
        traverse(value[key], seen);
      }
    }
    return value;
  }
  function set2(vm, key, value) {
    var state = vm.__composition_api_state__ = vm.__composition_api_state__ || {};
    state[key] = value;
  }
  function get(vm, key) {
    return (vm.__composition_api_state__ || {})[key];
  }
  function asVmProperty(vm, propName, propValue) {
    var props2 = vm.$options.props;
    if (!(propName in vm) && !(props2 && hasOwn(props2, propName))) {
      if (isRef(propValue)) {
        proxy(vm, propName, {
          get: function() {
            return propValue.value;
          },
          set: function(val) {
            propValue.value = val;
          }
        });
      } else {
        proxy(vm, propName, {
          get: function() {
            if (isReactive(propValue)) {
              propValue.__ob__.dep.depend();
            }
            return propValue;
          },
          set: function(val) {
            propValue = val;
          }
        });
      }
      if (true) {
        vm.$nextTick(function() {
          if (Object.keys(vm._data).indexOf(propName) !== -1) {
            return;
          }
          if (isRef(propValue)) {
            proxy(vm._data, propName, {
              get: function() {
                return propValue.value;
              },
              set: function(val) {
                propValue.value = val;
              }
            });
          } else {
            proxy(vm._data, propName, {
              get: function() {
                return propValue;
              },
              set: function(val) {
                propValue = val;
              }
            });
          }
        });
      }
    } else if (true) {
      if (props2 && hasOwn(props2, propName)) {
        warn('The setup binding property "'.concat(propName, '" is already declared as a prop.'), vm);
      } else {
        warn('The setup binding property "'.concat(propName, '" is already declared.'), vm);
      }
    }
  }
  function updateTemplateRef(vm) {
    var rawBindings = vmStateManager.get(vm, "rawBindings") || {};
    if (!rawBindings || !Object.keys(rawBindings).length)
      return;
    var refs = vm.$refs;
    var oldRefKeys = vmStateManager.get(vm, "refs") || [];
    for (var index = 0; index < oldRefKeys.length; index++) {
      var key = oldRefKeys[index];
      var setupValue = rawBindings[key];
      if (!refs[key] && setupValue && isRef(setupValue)) {
        setupValue.value = null;
      }
    }
    var newKeys = Object.keys(refs);
    var validNewKeys = [];
    for (var index = 0; index < newKeys.length; index++) {
      var key = newKeys[index];
      var setupValue = rawBindings[key];
      if (refs[key] && setupValue && isRef(setupValue)) {
        setupValue.value = refs[key];
        validNewKeys.push(key);
      }
    }
    vmStateManager.set(vm, "refs", validNewKeys);
  }
  function afterRender(vm) {
    var stack = [vm._vnode];
    while (stack.length) {
      var vnode = stack.pop();
      if (vnode.context)
        updateTemplateRef(vnode.context);
      if (vnode.children) {
        for (var i = 0; i < vnode.children.length; ++i) {
          stack.push(vnode.children[i]);
        }
      }
    }
  }
  function updateVmAttrs(vm, ctx) {
    var e_1, _a;
    if (!vm) {
      return;
    }
    var attrBindings = vmStateManager.get(vm, "attrBindings");
    if (!attrBindings && !ctx) {
      return;
    }
    if (!attrBindings) {
      var observedData = reactive({});
      attrBindings = { ctx, data: observedData };
      vmStateManager.set(vm, "attrBindings", attrBindings);
      proxy(ctx, "attrs", {
        get: function() {
          return attrBindings === null || attrBindings === void 0 ? void 0 : attrBindings.data;
        },
        set: function() {
          warn("Cannot assign to '$attrs' because it is a read-only property", vm);
        }
      });
    }
    var source = vm.$attrs;
    var _loop_1 = function(attr2) {
      if (!hasOwn(attrBindings.data, attr2)) {
        proxy(attrBindings.data, attr2, {
          get: function() {
            return vm.$attrs[attr2];
          }
        });
      }
    };
    try {
      for (var _b = __values(Object.keys(source)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var attr = _c.value;
        _loop_1(attr);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  }
  function resolveScopedSlots(vm, slotsProxy) {
    var parentVNode = vm.$options._parentVnode;
    if (!parentVNode)
      return;
    var prevSlots = vmStateManager.get(vm, "slots") || [];
    var curSlots = resolveSlots(parentVNode.data.scopedSlots, vm.$slots);
    for (var index = 0; index < prevSlots.length; index++) {
      var key = prevSlots[index];
      if (!curSlots[key]) {
        delete slotsProxy[key];
      }
    }
    var slotNames = Object.keys(curSlots);
    for (var index = 0; index < slotNames.length; index++) {
      var key = slotNames[index];
      if (!slotsProxy[key]) {
        slotsProxy[key] = createSlotProxy(vm, key);
      }
    }
    vmStateManager.set(vm, "slots", slotNames);
  }
  function activateCurrentInstance(instance, fn, onError) {
    var preVm = getCurrentInstance();
    setCurrentInstance(instance);
    try {
      return fn(instance);
    } catch (err) {
      if (onError) {
        onError(err);
      } else {
        throw err;
      }
    } finally {
      setCurrentInstance(preVm);
    }
  }
  function mixin(Vue4) {
    Vue4.mixin({
      beforeCreate: functionApiInit,
      mounted: function() {
        afterRender(this);
      },
      beforeUpdate: function() {
        updateVmAttrs(this);
      },
      updated: function() {
        afterRender(this);
      }
    });
    function functionApiInit() {
      var vm = this;
      var $options = vm.$options;
      var setup2 = $options.setup, render2 = $options.render;
      if (render2) {
        $options.render = function() {
          var _this = this;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return activateCurrentInstance(toVue3ComponentInstance(vm), function() {
            return render2.apply(_this, args);
          });
        };
      }
      if (!setup2) {
        return;
      }
      if (!isFunction(setup2)) {
        if (true) {
          warn('The "setup" option should be a function that returns a object in component definitions.', vm);
        }
        return;
      }
      var data2 = $options.data;
      $options.data = function wrappedData() {
        initSetup(vm, vm.$props);
        return isFunction(data2) ? data2.call(vm, vm) : data2 || {};
      };
    }
    function initSetup(vm, props2) {
      if (props2 === void 0) {
        props2 = {};
      }
      var setup2 = vm.$options.setup;
      var ctx = createSetupContext(vm);
      var instance = toVue3ComponentInstance(vm);
      instance.setupContext = ctx;
      def(props2, "__ob__", createObserver());
      resolveScopedSlots(vm, ctx.slots);
      var binding;
      activateCurrentInstance(instance, function() {
        binding = setup2(props2, ctx);
      });
      if (!binding)
        return;
      if (isFunction(binding)) {
        var bindingFunc_1 = binding;
        vm.$options.render = function() {
          resolveScopedSlots(vm, ctx.slots);
          return activateCurrentInstance(instance, function() {
            return bindingFunc_1();
          });
        };
        return;
      } else if (isObject(binding)) {
        if (isReactive(binding)) {
          binding = toRefs(binding);
        }
        vmStateManager.set(vm, "rawBindings", binding);
        var bindingObj_1 = binding;
        Object.keys(bindingObj_1).forEach(function(name) {
          var bindingValue = bindingObj_1[name];
          if (!isRef(bindingValue)) {
            if (!isReactive(bindingValue)) {
              if (isFunction(bindingValue)) {
                var copy_1 = bindingValue;
                bindingValue = bindingValue.bind(vm);
                Object.keys(copy_1).forEach(function(ele) {
                  bindingValue[ele] = copy_1[ele];
                });
              } else if (!isObject(bindingValue)) {
                bindingValue = ref(bindingValue);
              } else if (hasReactiveArrayChild(bindingValue)) {
                customReactive(bindingValue);
              }
            } else if (isArray(bindingValue)) {
              bindingValue = ref(bindingValue);
            }
          }
          asVmProperty(vm, name, bindingValue);
        });
        return;
      }
      if (true) {
        assert(false, '"setup" must return a "Object" or a "Function", got "'.concat(Object.prototype.toString.call(binding).slice(8, -1), '"'));
      }
    }
    function customReactive(target, seen) {
      if (seen === void 0) {
        seen = /* @__PURE__ */ new Set();
      }
      if (seen.has(target))
        return;
      if (!isPlainObject(target) || isRef(target) || isReactive(target) || isRaw(target))
        return;
      var Vue5 = getVueConstructor();
      var defineReactive = Vue5.util.defineReactive;
      Object.keys(target).forEach(function(k) {
        var val = target[k];
        defineReactive(target, k, val);
        if (val) {
          seen.add(val);
          customReactive(val, seen);
        }
        return;
      });
    }
    function hasReactiveArrayChild(target, visited) {
      if (visited === void 0) {
        visited = /* @__PURE__ */ new Map();
      }
      if (visited.has(target)) {
        return visited.get(target);
      }
      visited.set(target, false);
      if (isArray(target) && isReactive(target)) {
        visited.set(target, true);
        return true;
      }
      if (!isPlainObject(target) || isRaw(target) || isRef(target)) {
        return false;
      }
      return Object.keys(target).some(function(x) {
        return hasReactiveArrayChild(target[x], visited);
      });
    }
    function createSetupContext(vm) {
      var ctx = { slots: {} };
      var propsPlain = [
        "root",
        "parent",
        "refs",
        "listeners",
        "isServer",
        "ssrContext"
      ];
      var methodReturnVoid = ["emit"];
      propsPlain.forEach(function(key) {
        var srcKey = "$".concat(key);
        proxy(ctx, key, {
          get: function() {
            return vm[srcKey];
          },
          set: function() {
            warn("Cannot assign to '".concat(key, "' because it is a read-only property"), vm);
          }
        });
      });
      updateVmAttrs(vm, ctx);
      methodReturnVoid.forEach(function(key) {
        var srcKey = "$".concat(key);
        proxy(ctx, key, {
          get: function() {
            return function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var fn = vm[srcKey];
              fn.apply(vm, args);
            };
          }
        });
      });
      if (false) {
        ctx._vm = vm;
      }
      return ctx;
    }
  }
  function mergeData(from, to) {
    if (!from)
      return to;
    if (!to)
      return from;
    var key;
    var toVal;
    var fromVal;
    var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      key = keys[i];
      if (key === "__ob__")
        continue;
      toVal = to[key];
      fromVal = from[key];
      if (!hasOwn(to, key)) {
        to[key] = fromVal;
      } else if (toVal !== fromVal && isPlainObject(toVal) && !isRef(toVal) && isPlainObject(fromVal) && !isRef(fromVal)) {
        mergeData(fromVal, toVal);
      }
    }
    return to;
  }
  function install(Vue4) {
    if (isVueRegistered(Vue4)) {
      if (true) {
        warn("[vue-composition-api] already installed. Vue.use(VueCompositionAPI) should be called only once.");
      }
      return;
    }
    if (true) {
      if (Vue4.version) {
        if (Vue4.version[0] !== "2" || Vue4.version[1] !== ".") {
          warn("[vue-composition-api] only works with Vue 2, v".concat(Vue4.version, " found."));
        }
      } else {
        warn("[vue-composition-api] no Vue version found");
      }
    }
    Vue4.config.optionMergeStrategies.setup = function(parent, child) {
      return function mergedSetupFn(props2, context) {
        return mergeData(isFunction(parent) ? parent(props2, context) || {} : void 0, isFunction(child) ? child(props2, context) || {} : void 0);
      };
    };
    setVueConstructor(Vue4);
    mixin(Vue4);
  }
  var extendStatics, __assign, activeEffectScope, effectScopeStack, EffectScopeImpl, EffectScope, vueDependency, requiredVue, vueConstructor, currentInstance, currentInstanceTracking, PluginInstalledFlag, instanceMapCache, toString, hasSymbol, noopFn, objectToString, toTypeString, isMap, isSet, MAX_VALID_ARRAY_LENGTH, WatcherPreFlushQueueKey, WatcherPostFlushQueueKey, RefKey, accessModifiedSet, rawSet, readonlySet, RefImpl, genName, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, onErrorCaptured, onActivated, onDeactivated, onServerPrefetch, fallbackVM, EMPTY_OBJ, fallbackCreateElement, createElement, vmStateManager, Plugin;
  var init_vue_composition_api = __esm({
    "node_modules/@vue/composition-api/dist/vue-composition-api.mjs"() {
      extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      __assign = function() {
        __assign = Object.assign || function __assign2(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      effectScopeStack = [];
      EffectScopeImpl = function() {
        function EffectScopeImpl2(vm) {
          this.active = true;
          this.effects = [];
          this.cleanups = [];
          this.vm = vm;
        }
        EffectScopeImpl2.prototype.run = function(fn) {
          if (this.active) {
            try {
              this.on();
              return fn();
            } finally {
              this.off();
            }
          } else if (true) {
            warn$1("cannot run an inactive effect scope.");
          }
          return;
        };
        EffectScopeImpl2.prototype.on = function() {
          if (this.active) {
            effectScopeStack.push(this);
            activeEffectScope = this;
          }
        };
        EffectScopeImpl2.prototype.off = function() {
          if (this.active) {
            effectScopeStack.pop();
            activeEffectScope = effectScopeStack[effectScopeStack.length - 1];
          }
        };
        EffectScopeImpl2.prototype.stop = function() {
          if (this.active) {
            this.vm.$destroy();
            this.effects.forEach(function(e) {
              return e.stop();
            });
            this.cleanups.forEach(function(cleanup) {
              return cleanup();
            });
            this.active = false;
          }
        };
        return EffectScopeImpl2;
      }();
      EffectScope = function(_super) {
        __extends(EffectScope2, _super);
        function EffectScope2(detached) {
          if (detached === void 0) {
            detached = false;
          }
          var _this = this;
          var vm = void 0;
          withCurrentInstanceTrackingDisabled(function() {
            vm = defineComponentInstance(getVueConstructor());
          });
          _this = _super.call(this, vm) || this;
          if (!detached) {
            recordEffectScope(_this);
          }
          return _this;
        }
        return EffectScope2;
      }(EffectScopeImpl);
      vueDependency = void 0;
      try {
        requiredVue = require_vue_runtime_common();
        if (requiredVue && isVue(requiredVue)) {
          vueDependency = requiredVue;
        } else if (requiredVue && "default" in requiredVue && isVue(requiredVue.default)) {
          vueDependency = requiredVue.default;
        }
      } catch (_a) {
      }
      vueConstructor = null;
      currentInstance = null;
      currentInstanceTracking = true;
      PluginInstalledFlag = "__composition_api_installed__";
      instanceMapCache = /* @__PURE__ */ new WeakMap();
      toString = function(x) {
        return Object.prototype.toString.call(x);
      };
      hasSymbol = typeof Symbol !== "undefined" && isNative(Symbol) && typeof Reflect !== "undefined" && isNative(Reflect.ownKeys);
      noopFn = function(_) {
        return _;
      };
      objectToString = Object.prototype.toString;
      toTypeString = function(value) {
        return objectToString.call(value);
      };
      isMap = function(val) {
        return toTypeString(val) === "[object Map]";
      };
      isSet = function(val) {
        return toTypeString(val) === "[object Set]";
      };
      MAX_VALID_ARRAY_LENGTH = 4294967295;
      WatcherPreFlushQueueKey = createSymbol("composition-api.preFlushQueue");
      WatcherPostFlushQueueKey = createSymbol("composition-api.postFlushQueue");
      RefKey = "composition-api.refKey";
      accessModifiedSet = /* @__PURE__ */ new WeakMap();
      rawSet = /* @__PURE__ */ new WeakMap();
      readonlySet = /* @__PURE__ */ new WeakMap();
      RefImpl = function() {
        function RefImpl2(_a) {
          var get2 = _a.get, set3 = _a.set;
          proxy(this, "value", {
            get: get2,
            set: set3
          });
        }
        return RefImpl2;
      }();
      genName = function(name) {
        return "on".concat(name[0].toUpperCase() + name.slice(1));
      };
      onBeforeMount = createLifeCycle("beforeMount");
      onMounted = createLifeCycle("mounted");
      onBeforeUpdate = createLifeCycle("beforeUpdate");
      onUpdated = createLifeCycle("updated");
      onBeforeUnmount = createLifeCycle("beforeDestroy");
      onUnmounted = createLifeCycle("destroyed");
      onErrorCaptured = createLifeCycle("errorCaptured");
      onActivated = createLifeCycle("activated");
      onDeactivated = createLifeCycle("deactivated");
      onServerPrefetch = createLifeCycle("serverPrefetch");
      EMPTY_OBJ = true ? Object.freeze({}) : {};
      createElement = function createElement2() {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var instance = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;
        if (!instance) {
          warn("`createElement()` has been called outside of render function.");
          if (!fallbackCreateElement) {
            fallbackCreateElement = defineComponentInstance(getVueConstructor()).$createElement;
          }
          return fallbackCreateElement.apply(fallbackCreateElement, args);
        }
        return instance.$createElement.apply(instance, args);
      };
      vmStateManager = {
        set: set2,
        get
      };
      Plugin = {
        install: function(Vue4) {
          return install(Vue4);
        }
      };
      if (typeof window !== "undefined" && window.Vue) {
        window.Vue.use(Plugin);
      }
    }
  });

  // node_modules/vue-demi/lib/index.mjs
  function install2(_vue) {
    _vue = _vue || import_vue.default;
    if (_vue && !_vue["__composition_api_installed__"])
      import_vue.default.use(Plugin);
  }
  var import_vue, isVue3, version;
  var init_lib = __esm({
    "node_modules/vue-demi/lib/index.mjs"() {
      import_vue = __toESM(require_vue_runtime_common(), 1);
      init_vue_composition_api();
      init_vue_composition_api();
      install2(import_vue.default);
      isVue3 = false;
      version = import_vue.default.version;
    }
  });

  // node_modules/vue-imask/esm/props.js
  var props;
  var init_props = __esm({
    "node_modules/vue-imask/esm/props.js"() {
      props = {
        mask: {},
        prepare: Function,
        validate: Function,
        commit: Function,
        overwrite: {
          type: Boolean,
          required: false,
          default: void 0
        },
        placeholderChar: String,
        lazy: {
          type: Boolean,
          required: false,
          default: void 0
        },
        definitions: Object,
        blocks: Object,
        pattern: String,
        format: Function,
        parse: Function,
        autofix: {
          type: Boolean,
          required: false,
          default: void 0
        },
        radix: String,
        thousandsSeparator: String,
        mapToRadix: Array,
        scale: Number,
        signed: {
          type: Boolean,
          required: false,
          default: void 0
        },
        normalizeZeros: {
          type: Boolean,
          required: false,
          default: void 0
        },
        padFractionalZeros: {
          type: Boolean,
          required: false,
          default: void 0
        },
        min: [Number, Date],
        max: [Number, Date],
        dispatch: Function
      };
    }
  });

  // node_modules/vue-imask/esm/composable.js
  function useIMask(props2) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, emit = _ref.emit, onAccept = _ref.onAccept, onComplete = _ref.onComplete;
    props2 = isRef(props2) ? props2 : ref(props2);
    var el = ref();
    var mask = ref();
    var masked = ref();
    var unmasked = ref();
    var typed = ref();
    var $el;
    var $masked;
    var $unmasked;
    var $typed;
    function _onAccept2() {
      $typed = typed.value = mask.value.typedValue;
      $unmasked = unmasked.value = mask.value.unmaskedValue;
      $masked = masked.value = mask.value.value;
      if (emit) {
        emit("accept", $masked);
        emit("accept:masked", $masked);
        emit("accept:typed", $typed);
        emit("accept:unmasked", $unmasked);
      }
      if (onAccept)
        onAccept();
    }
    function _onComplete2() {
      if (emit) {
        emit("complete", $masked);
        emit("complete:masked", $masked);
        emit("complete:typed", $typed);
        emit("complete:unmasked", $unmasked);
      }
      if (onComplete)
        onComplete();
    }
    function _initMask2() {
      $el = el.value;
      var $props = props2.value;
      if (!$el || !($props !== null && $props !== void 0 && $props.mask))
        return;
      mask.value = IMask($el, $props).on("accept", _onAccept2).on("complete", _onComplete2);
      _onAccept2();
    }
    function _destroyMask2() {
      if (mask.value) {
        mask.value.destroy();
        mask.value = null;
      }
    }
    onMounted(_initMask2);
    onUnmounted(_destroyMask2);
    watch(unmasked, function() {
      if (mask.value && $unmasked !== unmasked.value) {
        $unmasked = mask.value.unmaskedValue = unmasked.value;
      }
    });
    watch(masked, function() {
      if (mask.value && $masked !== masked.value) {
        $masked = mask.value.value = masked.value;
      }
    });
    watch(typed, function() {
      if (mask.value)
        $typed = mask.value.typedValue = typed.value;
    });
    watch([el, props2], function() {
      var $newEl = el.value;
      var $props = props2.value;
      if (!($props !== null && $props !== void 0 && $props.mask) || $newEl !== $el)
        _destroyMask2();
      if ($newEl) {
        if (!mask.value) {
          _initMask2();
        } else {
          mask.value.updateOptions($props);
        }
      }
    });
    return {
      el,
      mask: readonly(mask),
      masked,
      unmasked,
      typed
    };
  }
  var init_composable = __esm({
    "node_modules/vue-imask/esm/composable.js"() {
      init_lib();
      init_imask();
    }
  });

  // node_modules/vue-imask/esm/component3-composition.js
  function _extractOptionsFromProps(props2) {
    props2 = Object.assign({}, props2);
    Object.keys(props2).filter(function(prop) {
      return props2[prop] === void 0;
    }).forEach(function(undefinedProp) {
      delete props2[undefinedProp];
    });
    VALUE_PROPS.forEach(function(p) {
      return delete props2[p];
    });
    return props2;
  }
  var VALUE_PROPS, Component3;
  var init_component3_composition = __esm({
    "node_modules/vue-imask/esm/component3-composition.js"() {
      init_imask();
      init_lib();
      init_props();
      init_composable();
      VALUE_PROPS = ["typed", "unmasked", "value", "modelValue"];
      Component3 = {
        name: "imask-input",
        inheritAttrs: false,
        setup: function setup(props2, _ref) {
          var attrs = _ref.attrs;
          _ref.slots;
          var emit = _ref.emit;
          var _useIMask = useIMask(_extractOptionsFromProps(props2), {
            emit,
            onAccept: function onAccept() {
              var v = masked.value;
              emit("accept:value", v);
              emit("update:value", v);
              emit("update:masked", v);
              emit("update:modelValue", v);
              emit("update:unmasked", unmasked.value);
              emit("update:typed", typed.value);
            },
            onComplete: function onComplete() {
              emit("complete:value", masked.value);
            }
          }), el = _useIMask.el;
          _useIMask.mask;
          var masked = _useIMask.masked, unmasked = _useIMask.unmasked, typed = _useIMask.typed;
          var pvalue = toRef(props2, "value");
          var pmodelValue = toRef(props2, "modelValue");
          var punmasked = toRef(props2, "unmasked");
          var ptyped = toRef(props2, "typed");
          masked.value = pmodelValue.value || pvalue.value || "";
          unmasked.value = punmasked.value;
          typed.value = ptyped.value;
          watch(pvalue, function(v) {
            return masked.value = v;
          });
          watch(pmodelValue, function(v) {
            return masked.value = v;
          });
          watch(punmasked, function(v) {
            return unmasked.value = v;
          });
          watch(ptyped, function(v) {
            return typed.value = v;
          });
          return function() {
            var data2 = Object.assign({}, attrs, {
              value: props2.value ? props2.value : props2.modelValue,
              ref: el
            });
            if (!props2.mask) {
              data2.onInput = function(event) {
                emit("update:modelValue", event.target.value);
                emit("update:value", event.target.value);
              };
            }
            return createElement("input", data2);
          };
        },
        props: Object.assign({
          modelValue: String,
          value: String,
          unmasked: String,
          typed: {}
        }, props),
        emits: ["update:modelValue", "update:masked", "update:value", "update:unmasked", "update:typed", "accept", "accept:value", "accept:masked", "accept:unmasked", "accept:typed", "complete", "complete:value", "complete:masked", "complete:unmasked", "complete:typed"]
      };
    }
  });

  // node_modules/vue-imask/esm/component2.js
  var Component2;
  var init_component2 = __esm({
    "node_modules/vue-imask/esm/component2.js"() {
      init_imask();
      init_props();
      Component2 = {
        name: "imask-input",
        render: function render(createElement3) {
          var _this = this;
          var data2 = {
            domProps: {
              value: this.maskRef ? this.maskRef.value : this.value
            },
            on: Object.assign({}, this.$listeners)
          };
          if (!this.$props.mask) {
            data2.on.input = function(event) {
              return _this.$emit("input", event.target.value);
            };
          } else {
            delete data2.on.input;
          }
          return createElement3("input", data2);
        },
        mounted: function mounted() {
          if (!this.$props.mask)
            return;
          this._initMask();
        },
        destroyed: function destroyed() {
          this._destroyMask();
        },
        computed: {
          maskOptions: function maskOptions() {
            return this._extractOptionsFromProps(this.$props);
          }
        },
        watch: {
          "$props": {
            handler: function handler(props2) {
              var maskOptions2 = this.maskOptions;
              if (maskOptions2.mask) {
                if (this.maskRef) {
                  this.maskRef.updateOptions(maskOptions2);
                  if ("value" in props2 && (props2.value !== this._maskValue() || typeof props2.value !== "string" && this.maskRef.value === "" && !this.maskRef.el.isActive)) {
                    this._updateValue();
                  }
                } else {
                  this._initMask(maskOptions2);
                  if (props2.value !== this._maskValue())
                    this._onAccept();
                }
              } else {
                this._destroyMask();
                if ("value" in props2)
                  this.$el.value = props2.value;
              }
            },
            deep: true
          }
        },
        methods: {
          _extractOptionsFromProps: function _extractOptionsFromProps2(props2) {
            props2 = Object.assign({}, props2);
            Object.keys(props2).filter(function(prop) {
              return props2[prop] === void 0;
            }).forEach(function(undefinedProp) {
              delete props2[undefinedProp];
            });
            delete props2.value;
            delete props2.unmask;
            return props2;
          },
          _maskValue: function _maskValue() {
            if (this.unmask === "typed")
              return this.maskRef.typedValue;
            if (this.unmask)
              return this.maskRef.unmaskedValue;
            return this.maskRef.value;
          },
          _updateValue: function _updateValue() {
            var value = this.value == null ? "" : this.value;
            if (this.unmask === "typed")
              this.maskRef.typedValue = value;
            else if (this.unmask)
              this.maskRef.unmaskedValue = value;
            else
              this.maskRef.value = value;
          },
          _onAccept: function _onAccept() {
            var val = this._maskValue();
            this.$emit("input", val);
            this.$emit("accept", val);
          },
          _onComplete: function _onComplete() {
            this.$emit("complete", this._maskValue());
          },
          _initMask: function _initMask() {
            var maskOptions2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.maskOptions;
            this.maskRef = IMask(this.$el, maskOptions2).on("accept", this._onAccept.bind(this)).on("complete", this._onComplete.bind(this));
            this._updateValue();
          },
          _destroyMask: function _destroyMask() {
            if (this.maskRef) {
              this.maskRef.destroy();
              delete this.maskRef;
            }
          }
        },
        props: Object.assign({
          value: {},
          unmask: {
            validator: function validator(value) {
              return value === "typed" || typeof value === "boolean";
            }
          }
        }, props)
      };
    }
  });

  // node_modules/vue-imask/esm/component.js
  var component;
  var init_component = __esm({
    "node_modules/vue-imask/esm/component.js"() {
      init_lib();
      init_component3_composition();
      init_component2();
      init_imask();
      init_props();
      init_composable();
      component = isVue3 ? Component3 : Component2;
    }
  });

  // node_modules/vue-imask/esm/_rollupPluginBabelHelpers-cf650413.js
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var init_rollupPluginBabelHelpers_cf650413 = __esm({
    "node_modules/vue-imask/esm/_rollupPluginBabelHelpers-cf650413.js"() {
    }
  });

  // node_modules/vue-imask/esm/directive.js
  function fireEvent(el, eventName, data2) {
    var e = document.createEvent("CustomEvent");
    e.initCustomEvent(eventName, true, true, data2);
    el.dispatchEvent(e);
  }
  function initMask(el, opts) {
    el.maskRef = IMask(el, opts).on("accept", function() {
      return fireEvent(el, "accept", el.maskRef);
    }).on("complete", function() {
      return fireEvent(el, "complete", el.maskRef);
    });
  }
  function destroyMask(el) {
    if (el.maskRef) {
      el.maskRef.destroy();
      delete el.maskRef;
    }
  }
  var _name, directive;
  var init_directive = __esm({
    "node_modules/vue-imask/esm/directive.js"() {
      init_rollupPluginBabelHelpers_cf650413();
      init_imask();
      init_lib();
      directive = (_name = {
        name: "imask"
      }, _defineProperty2(_name, isVue3 ? "beforeMount" : "bind", function(el, _ref) {
        var options = _ref.value;
        if (!options)
          return;
        initMask(el, options);
      }), _defineProperty2(_name, isVue3 ? "updated" : "update", function(el, _ref2) {
        var options = _ref2.value;
        if (options) {
          if (el.maskRef) {
            el.maskRef.updateOptions(options);
            if (el.value !== el.maskRef.value)
              el.maskRef._onChange();
          } else
            initMask(el, options);
        } else {
          destroyMask(el);
        }
      }), _defineProperty2(_name, isVue3 ? "unmounted" : "unbind", function(el) {
        destroyMask(el);
      }), _name);
    }
  });

  // node_modules/vue-imask/esm/index.js
  var init_esm2 = __esm({
    "node_modules/vue-imask/esm/index.js"() {
      init_esm();
      init_imask();
      init_component();
      init_directive();
      init_composable();
      init_props();
      init_lib();
      init_component3_composition();
      init_component2();
      init_rollupPluginBabelHelpers_cf650413();
    }
  });

  // resource/js/components/customers/ModalCustomers.vue
  var ModalCustomers_exports = {};
  __export(ModalCustomers_exports, {
    default: () => ModalCustomers_default
  });
  function __vue_normalize__8(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\customers\\ModalCustomers.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var __vue_script__9, __vue_render__9, __vue_staticRenderFns__9, __vue_inject_styles__9, __vue_scope_id__9, __vue_module_identifier__9, __vue_is_functional_template__9, __vue_component__8, ModalCustomers_default;
  var init_ModalCustomers = __esm({
    "resource/js/components/customers/ModalCustomers.vue"() {
      init_esm2();
      __vue_script__9 = {
        name: "customer-modal",
        props: {
          csrf_token: {
            required: true
          }
        },
        data() {
          return {
            id_customer: void 0,
            name: void 0,
            dni: void 0,
            email: void 0,
            phone: void 0,
            address: void 0,
            credit: void 0,
            edit: false
          };
        },
        components: {
          "imask-input": component
        },
        methods: {
          handleSubmitCustomer() {
            const form_data = new FormData();
            form_data.append("csrf_token", this.csrf_token);
            form_data.append("name", this.name);
            form_data.append("dni", this.dni);
            form_data.append("email", this.email ? this.email : "");
            form_data.append("phone", this.phone ? this.phone : "");
            form_data.append("address", this.address);
            form_data.append("credit", this.credit ? this.credit : "");
            if (this.edit) {
              axios({
                method: "post",
                url: `/customers/edit/${this.id_customer}`,
                headers: {
                  "Content-Type": "multipart/form-data"
                },
                data: form_data
              }).then((response) => {
                const { data: { status, response: resp } } = response;
                if (status) {
                  this.$emit("editData", resp);
                  this.$refs.closeModal.click();
                  this.reset();
                }
              });
            } else {
              axios({
                method: "post",
                url: "/customers/create",
                headers: {
                  "Content-Type": "multipart/form-data"
                },
                data: form_data
              }).then((response) => {
                const { data: { status, response: resp } } = response;
                if (status) {
                  this.$refs.closeModal.click();
                  this.$emit("mutateCustomer", resp);
                  this.reset();
                } else {
                  this.$swal.fire({
                    icon: "error",
                    title: "Error.",
                    text: resp
                  });
                }
              });
            }
          },
          reset() {
            this.id_customer = void 0;
            this.name = void 0;
            this.dni = void 0;
            this.email = void 0;
            this.phone = void 0;
            this.address = void 0;
            this.credit = void 0;
            this.edit = false;
          },
          editCustomer(data_edit) {
            this.edit = true;
            this.id_customer = data_edit.id;
            this.name = data_edit.name;
            this.dni = data_edit.dni;
            this.email = data_edit.email;
            this.phone = data_edit.phone;
            this.address = data_edit.address;
            this.credit = data_edit.credit.toString();
          }
        }
      };
      __vue_render__9 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", {
          staticClass: "modal fade",
          attrs: {
            id: "create-modal-customer",
            tabindex: "-1",
            "aria-labelledby": "CustomerCreateModal",
            "aria-hidden": "true"
          }
        }, [
          _c("div", { staticClass: "modal-dialog" }, [
            _c("div", { staticClass: "modal-content" }, [
              _c("form", {
                attrs: {
                  role: "form",
                  method: "POST",
                  autocomplete: "off",
                  enctype: "multipart/form-data"
                },
                on: {
                  submit: function($event) {
                    $event.preventDefault();
                    return _vm.handleSubmitCustomer.apply(null, arguments);
                  }
                }
              }, [
                _c("div", { staticClass: "modal-header" }, [
                  _c("h5", {
                    staticClass: "modal-title",
                    attrs: { id: "CustomerCreateModal" }
                  }, [_vm._v("Add New Customer")]),
                  _vm._v(" "),
                  _c("button", {
                    staticClass: "btn-close",
                    attrs: {
                      type: "button",
                      "data-bs-dismiss": "modal",
                      "aria-label": "Close"
                    },
                    on: { click: _vm.reset }
                  })
                ]),
                _vm._v(" "),
                _c("div", { staticClass: "modal-body" }, [
                  _c("div", { staticClass: "card-body" }, [
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(0),
                        _vm._v(" "),
                        _c("input", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.name,
                              expression: "name"
                            }
                          ],
                          staticClass: "form-control",
                          attrs: {
                            type: "text",
                            name: "name",
                            id: "name",
                            placeholder: "Name Client",
                            required: "",
                            autocomplete: "off"
                          },
                          domProps: { value: _vm.name },
                          on: {
                            input: function($event) {
                              if ($event.target.composing) {
                                return;
                              }
                              _vm.name = $event.target.value;
                            }
                          }
                        })
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(1),
                        _vm._v(" "),
                        _c("input", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.dni,
                              expression: "dni"
                            }
                          ],
                          staticClass: "form-control",
                          attrs: {
                            type: "number",
                            name: "dni",
                            id: "dni",
                            placeholder: "DNI",
                            required: "",
                            min: "1"
                          },
                          domProps: { value: _vm.dni },
                          on: {
                            input: function($event) {
                              if ($event.target.composing) {
                                return;
                              }
                              _vm.dni = $event.target.value;
                            }
                          }
                        })
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(2),
                        _vm._v(" "),
                        _c("input", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.email,
                              expression: "email"
                            }
                          ],
                          staticClass: "form-control",
                          attrs: {
                            type: "email",
                            name: "email",
                            id: "email",
                            placeholder: "Email Client",
                            autocomplete: "off"
                          },
                          domProps: { value: _vm.email },
                          on: {
                            input: function($event) {
                              if ($event.target.composing) {
                                return;
                              }
                              _vm.email = $event.target.value;
                            }
                          }
                        })
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(3),
                        _vm._v(" "),
                        _c("imask-input", {
                          staticClass: "form-control",
                          attrs: {
                            placeholder: "Phone Client",
                            mask: "+(00)000-000-00-00",
                            autocomplete: "off"
                          },
                          model: {
                            value: _vm.phone,
                            callback: function($$v) {
                              _vm.phone = $$v;
                            },
                            expression: "phone"
                          }
                        })
                      ], 1)
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(4),
                        _vm._v(" "),
                        _c("input", {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.address,
                              expression: "address"
                            }
                          ],
                          staticClass: "form-control",
                          attrs: {
                            type: "text",
                            name: "address",
                            id: "address",
                            placeholder: "Short address",
                            required: "",
                            autocomplete: "off"
                          },
                          domProps: { value: _vm.address },
                          on: {
                            input: function($event) {
                              if ($event.target.composing) {
                                return;
                              }
                              _vm.address = $event.target.value;
                            }
                          }
                        })
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "form-group" }, [
                      _c("div", { staticClass: "input-group input-group-lg" }, [
                        _vm._m(5),
                        _vm._v(" "),
                        _c("imask-input", {
                          staticClass: "form-control",
                          attrs: { placeholder: "Credit Limit", mask: Number },
                          model: {
                            value: _vm.credit,
                            callback: function($$v) {
                              _vm.credit = $$v;
                            },
                            expression: "credit"
                          }
                        })
                      ], 1)
                    ])
                  ])
                ]),
                _vm._v(" "),
                _c("div", { staticClass: "modal-footer" }, [
                  _c("button", {
                    ref: "closeModal",
                    staticClass: "btn btn-secondary",
                    attrs: { type: "button", "data-bs-dismiss": "modal" }
                  }, [_vm._v("\n            Close\n          ")]),
                  _vm._v(" "),
                  _c("button", { staticClass: "btn btn-primary", attrs: { type: "submit" } }, [_vm._v("Save customer")])
                ])
              ])
            ])
          ])
        ]);
      };
      __vue_staticRenderFns__9 = [
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-user" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-key" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-envelope" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-phone" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-address-book" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-wallet" })
          ]);
        }
      ];
      __vue_render__9._withStripped = true;
      __vue_inject_styles__9 = void 0;
      __vue_scope_id__9 = void 0;
      __vue_module_identifier__9 = void 0;
      __vue_is_functional_template__9 = false;
      __vue_component__8 = /* @__PURE__ */ __vue_normalize__8({ render: __vue_render__9, staticRenderFns: __vue_staticRenderFns__9 }, __vue_inject_styles__9, __vue_script__9, __vue_scope_id__9, __vue_is_functional_template__9, __vue_module_identifier__9, false, void 0, void 0, void 0);
      ModalCustomers_default = __vue_component__8;
    }
  });

  // resource/js/components/customers/TableCustomers.vue
  var TableCustomers_exports = {};
  __export(TableCustomers_exports, {
    default: () => TableCustomers_default
  });
  function __vue_normalize__9(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\customers\\TableCustomers.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var import_moment2, __vue_script__10, __vue_render__10, __vue_staticRenderFns__10, __vue_inject_styles__10, __vue_scope_id__10, __vue_module_identifier__10, __vue_is_functional_template__10, __vue_component__9, TableCustomers_default;
  var init_TableCustomers = __esm({
    "resource/js/components/customers/TableCustomers.vue"() {
      init_ModalCustomers();
      import_moment2 = __toESM(require_moment());
      __vue_script__10 = {
        name: "customer-table",
        props: {
          customers: {
            type: String,
            required: true
          },
          csrf_token: {
            type: String,
            required: true
          }
        },
        components: {
          CustomerModal: ModalCustomers_default
        },
        data() {
          return {
            u_search: "",
            customerParser: JSON.parse(this.customers),
            datatable: void 0,
            editB: false
          };
        },
        methods: {
          mountedDatatable() {
            return this.datatable = $("#datatable-customers").DataTable({
              responsive: true,
              destroy: true,
              lengthChange: false,
              autoWidth: false,
              rowReorder: {
                selector: "td:nth-child(2)"
              }
            });
          },
          mutateData(data2) {
            this.customerParser.push(data2);
            new Promise((res) => {
              this.datatable.destroy();
              res(true);
            }).then(() => {
              this.mountedDatatable();
            });
          },
          editData(data2) {
            const customer = this.customerParser.find((u) => u.id === data2.id);
            customer.name = data2.name;
            customer.dni = data2.dni;
            customer.email = data2.email;
            customer.phone = data2.phone;
            customer.address = data2.address;
            customer.credit = data2.credit;
          },
          editCustomer(id) {
            const data2 = this.customerParser.find((u) => u.id === id);
            this.$refs.modal.editCustomer(data2);
            $("#modal-customer-button").click();
          },
          deleteCustomer(id) {
            this.$swal.fire({
              title: "Are you sure?",
              text: "do you want to delete this customer?",
              icon: "warning",
              showCancelButton: true,
              confirmButtonColor: "#3085d6",
              cancelButtonColor: "#d33",
              confirmButtonText: "Yes, delete it!"
            }).then((result) => {
              if (result.isConfirmed) {
                axios({
                  method: "post",
                  url: `/customers/delete/${id}`,
                  data: {
                    csrf_token: this.csrf_token
                  }
                }).then((response) => {
                  const { data: { status } } = response;
                  if (status) {
                    this.$swal.fire("Deleted!", "the customer was deleted.", "success");
                    this.customerParser.splice(this.customerParser.findIndex((u) => u.id === id), 1);
                  }
                });
              }
            });
          },
          formatDate(timestamp) {
            return (0, import_moment2.default)(timestamp).format("l");
          }
        },
        mounted() {
          this.mountedDatatable();
        }
      };
      __vue_render__10 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", { staticClass: "card" }, [
          _vm._m(0),
          _vm._v(" "),
          _c("div", { staticClass: "card-body" }, [
            _c("table", {
              staticClass: "table table-striped",
              attrs: { id: "datatable-customers" }
            }, [
              _vm._m(1),
              _vm._v(" "),
              _c("tbody", _vm._l(_vm.customerParser, function(customer, index) {
                return _c("tr", { key: index }, [
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(index + 1))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(customer.name))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(customer.dni))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(customer.email))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(customer.phone))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(customer.address))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(customer.credit))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(customer.bill))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(customer.purchases))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(customer.last_purchase != null ? _vm.formatDate(this.last_purchase) : ""))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(_vm.formatDate(customer.created_at)))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _c("div", [
                      _c("button", {
                        staticClass: "btn btn-warning edit",
                        on: {
                          click: function($event) {
                            return _vm.editCustomer(customer.id);
                          }
                        }
                      }, [_c("i", { staticClass: "fa fa-pencil" })]),
                      _vm._v(" "),
                      _c("button", {
                        staticClass: "btn btn-danger delete",
                        on: {
                          click: function($event) {
                            return _vm.deleteCustomer(customer.id);
                          }
                        }
                      }, [_c("i", { staticClass: "fa fa-times" })])
                    ])
                  ])
                ]);
              }), 0)
            ])
          ]),
          _vm._v(" "),
          _c("customer-modal", {
            ref: "modal",
            attrs: { csrf_token: _vm.csrf_token },
            on: { mutateCustomer: _vm.mutateData, editData: _vm.editData }
          })
        ], 1);
      };
      __vue_staticRenderFns__10 = [
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("div", { staticClass: "card-header" }, [
            _c("h3", { staticClass: "card-title" }, [_vm._v("List customers")])
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("thead", [
            _c("tr", [
              _c("th", { staticClass: "text-center" }, [_vm._v("#")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Name")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center desktop" }, [_vm._v("DNI")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center desktop" }, [_vm._v("Email")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center desktop" }, [_vm._v("Phone")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center desktop" }, [_vm._v("Address")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Credit")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Bill")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Purchases")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Last Purchase")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Date")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center all" }, [_vm._v("Action")])
            ])
          ]);
        }
      ];
      __vue_render__10._withStripped = true;
      __vue_inject_styles__10 = void 0;
      __vue_scope_id__10 = void 0;
      __vue_module_identifier__10 = void 0;
      __vue_is_functional_template__10 = false;
      __vue_component__9 = /* @__PURE__ */ __vue_normalize__9({ render: __vue_render__10, staticRenderFns: __vue_staticRenderFns__10 }, __vue_inject_styles__10, __vue_script__10, __vue_scope_id__10, __vue_is_functional_template__10, __vue_module_identifier__10, false, void 0, void 0, void 0);
      TableCustomers_default = __vue_component__9;
    }
  });

  // node_modules/vue2-daterange-picker/dist/vue2-daterange-picker.umd.min.js
  var require_vue2_daterange_picker_umd_min = __commonJS({
    "node_modules/vue2-daterange-picker/dist/vue2-daterange-picker.umd.min.js"(exports, module) {
      (function(t, e) {
        typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports["vue2-daterange-picker"] = e() : t["vue2-daterange-picker"] = e();
      })(typeof self !== "undefined" ? self : exports, function() {
        return function(t) {
          var e = {};
          function n(r) {
            if (e[r])
              return e[r].exports;
            var a = e[r] = { i: r, l: false, exports: {} };
            return t[r].call(a.exports, a, a.exports, n), a.l = true, a.exports;
          }
          return n.m = t, n.c = e, n.d = function(t2, e2, r) {
            n.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: r });
          }, n.r = function(t2) {
            typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
          }, n.t = function(t2, e2) {
            if (1 & e2 && (t2 = n(t2)), 8 & e2)
              return t2;
            if (4 & e2 && typeof t2 === "object" && t2 && t2.__esModule)
              return t2;
            var r = /* @__PURE__ */ Object.create(null);
            if (n.r(r), Object.defineProperty(r, "default", { enumerable: true, value: t2 }), 2 & e2 && typeof t2 != "string")
              for (var a in t2)
                n.d(r, a, function(e3) {
                  return t2[e3];
                }.bind(null, a));
            return r;
          }, n.n = function(t2) {
            var e2 = t2 && t2.__esModule ? function() {
              return t2["default"];
            } : function() {
              return t2;
            };
            return n.d(e2, "a", e2), e2;
          }, n.o = function(t2, e2) {
            return Object.prototype.hasOwnProperty.call(t2, e2);
          }, n.p = "", n(n.s = "fb15");
        }({ "00ee": function(t, e, n) {
          var r = n("b622"), a = r("toStringTag"), i = {};
          i[a] = "z", t.exports = String(i) === "[object z]";
        }, "057f": function(t, e, n) {
          var r = n("fc6a"), a = n("241c").f, i = {}.toString, o = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], s = function(t2) {
            try {
              return a(t2);
            } catch (e2) {
              return o.slice();
            }
          };
          t.exports.f = function(t2) {
            return o && i.call(t2) == "[object Window]" ? s(t2) : a(r(t2));
          };
        }, "06cf": function(t, e, n) {
          var r = n("83ab"), a = n("d1e7"), i = n("5c6c"), o = n("fc6a"), s = n("c04e"), c = n("5135"), u = n("0cfb"), l = Object.getOwnPropertyDescriptor;
          e.f = r ? l : function(t2, e2) {
            if (t2 = o(t2), e2 = s(e2, true), u)
              try {
                return l(t2, e2);
              } catch (n2) {
              }
            if (c(t2, e2))
              return i(!a.f.call(t2, e2), t2[e2]);
          };
        }, "0cfb": function(t, e, n) {
          var r = n("83ab"), a = n("d039"), i = n("cc12");
          t.exports = !r && !a(function() {
            return Object.defineProperty(i("div"), "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        }, "0e58": function(t, e, n) {
          "use strict";
          var r = n("beb7"), a = n.n(r);
          a.a;
        }, "14c3": function(t, e, n) {
          var r = n("c6b6"), a = n("9263");
          t.exports = function(t2, e2) {
            var n2 = t2.exec;
            if (typeof n2 === "function") {
              var i = n2.call(t2, e2);
              if (typeof i !== "object")
                throw TypeError("RegExp exec method returned something other than an Object or null");
              return i;
            }
            if (r(t2) !== "RegExp")
              throw TypeError("RegExp#exec called on incompatible receiver");
            return a.call(t2, e2);
          };
        }, "159b": function(t, e, n) {
          var r = n("da84"), a = n("fdbc"), i = n("17c2"), o = n("9112");
          for (var s in a) {
            var c = r[s], u = c && c.prototype;
            if (u && u.forEach !== i)
              try {
                o(u, "forEach", i);
              } catch (l) {
                u.forEach = i;
              }
          }
        }, "17c2": function(t, e, n) {
          "use strict";
          var r = n("b727").forEach, a = n("b301");
          t.exports = a("forEach") ? function(t2) {
            return r(this, t2, arguments.length > 1 ? arguments[1] : void 0);
          } : [].forEach;
        }, "18e6": function(t, e, n) {
        }, "1be4": function(t, e, n) {
          var r = n("d066");
          t.exports = r("document", "documentElement");
        }, "1c0b": function(t, e) {
          t.exports = function(t2) {
            if (typeof t2 != "function")
              throw TypeError(String(t2) + " is not a function");
            return t2;
          };
        }, "1c7e": function(t, e, n) {
          var r = n("b622"), a = r("iterator"), i = false;
          try {
            var o = 0, s = { next: function() {
              return { done: !!o++ };
            }, return: function() {
              i = true;
            } };
            s[a] = function() {
              return this;
            }, Array.from(s, function() {
              throw 2;
            });
          } catch (c) {
          }
          t.exports = function(t2, e2) {
            if (!e2 && !i)
              return false;
            var n2 = false;
            try {
              var r2 = {};
              r2[a] = function() {
                return { next: function() {
                  return { done: n2 = true };
                } };
              }, t2(r2);
            } catch (c) {
            }
            return n2;
          };
        }, "1d80": function(t, e) {
          t.exports = function(t2) {
            if (t2 == void 0)
              throw TypeError("Can't call method on " + t2);
            return t2;
          };
        }, "1dde": function(t, e, n) {
          var r = n("d039"), a = n("b622"), i = n("60ae"), o = a("species");
          t.exports = function(t2) {
            return i >= 51 || !r(function() {
              var e2 = [], n2 = e2.constructor = {};
              return n2[o] = function() {
                return { foo: 1 };
              }, e2[t2](Boolean).foo !== 1;
            });
          };
        }, "23cb": function(t, e, n) {
          var r = n("a691"), a = Math.max, i = Math.min;
          t.exports = function(t2, e2) {
            var n2 = r(t2);
            return n2 < 0 ? a(n2 + e2, 0) : i(n2, e2);
          };
        }, "23e7": function(t, e, n) {
          var r = n("da84"), a = n("06cf").f, i = n("9112"), o = n("6eeb"), s = n("ce4e"), c = n("e893"), u = n("94ca");
          t.exports = function(t2, e2) {
            var n2, l, f, d, h, p, m = t2.target, g = t2.global, v = t2.stat;
            if (l = g ? r : v ? r[m] || s(m, {}) : (r[m] || {}).prototype, l)
              for (f in e2) {
                if (h = e2[f], t2.noTargetGet ? (p = a(l, f), d = p && p.value) : d = l[f], n2 = u(g ? f : m + (v ? "." : "#") + f, t2.forced), !n2 && d !== void 0) {
                  if (typeof h === typeof d)
                    continue;
                  c(h, d);
                }
                (t2.sham || d && d.sham) && i(h, "sham", true), o(l, f, h, t2);
              }
          };
        }, "241c": function(t, e, n) {
          var r = n("ca84"), a = n("7839"), i = a.concat("length", "prototype");
          e.f = Object.getOwnPropertyNames || function(t2) {
            return r(t2, i);
          };
        }, "25f0": function(t, e, n) {
          "use strict";
          var r = n("6eeb"), a = n("825a"), i = n("d039"), o = n("ad6d"), s = "toString", c = RegExp.prototype, u = c[s], l = i(function() {
            return u.call({ source: "a", flags: "b" }) != "/a/b";
          }), f = u.name != s;
          (l || f) && r(RegExp.prototype, s, function() {
            var t2 = a(this), e2 = String(t2.source), n2 = t2.flags, r2 = String(n2 === void 0 && t2 instanceof RegExp && !("flags" in c) ? o.call(t2) : n2);
            return "/" + e2 + "/" + r2;
          }, { unsafe: true });
        }, "35a1": function(t, e, n) {
          var r = n("f5df"), a = n("3f8c"), i = n("b622"), o = i("iterator");
          t.exports = function(t2) {
            if (t2 != void 0)
              return t2[o] || t2["@@iterator"] || a[r(t2)];
          };
        }, "37e8": function(t, e, n) {
          var r = n("83ab"), a = n("9bf2"), i = n("825a"), o = n("df75");
          t.exports = r ? Object.defineProperties : function(t2, e2) {
            i(t2);
            var n2, r2 = o(e2), s = r2.length, c = 0;
            while (s > c)
              a.f(t2, n2 = r2[c++], e2[n2]);
            return t2;
          };
        }, "3bbe": function(t, e, n) {
          var r = n("861d");
          t.exports = function(t2) {
            if (!r(t2) && t2 !== null)
              throw TypeError("Can't set " + String(t2) + " as a prototype");
            return t2;
          };
        }, "3ca3": function(t, e, n) {
          "use strict";
          var r = n("6547").charAt, a = n("69f3"), i = n("7dd0"), o = "String Iterator", s = a.set, c = a.getterFor(o);
          i(String, "String", function(t2) {
            s(this, { type: o, string: String(t2), index: 0 });
          }, function() {
            var t2, e2 = c(this), n2 = e2.string, a2 = e2.index;
            return a2 >= n2.length ? { value: void 0, done: true } : (t2 = r(n2, a2), e2.index += t2.length, { value: t2, done: false });
          });
        }, "3f8c": function(t, e) {
          t.exports = {};
        }, "428f": function(t, e, n) {
          var r = n("da84");
          t.exports = r;
        }, "44ad": function(t, e, n) {
          var r = n("d039"), a = n("c6b6"), i = "".split;
          t.exports = r(function() {
            return !Object("z").propertyIsEnumerable(0);
          }) ? function(t2) {
            return a(t2) == "String" ? i.call(t2, "") : Object(t2);
          } : Object;
        }, "44d2": function(t, e, n) {
          var r = n("b622"), a = n("7c73"), i = n("9112"), o = r("unscopables"), s = Array.prototype;
          s[o] == void 0 && i(s, o, a(null)), t.exports = function(t2) {
            s[o][t2] = true;
          };
        }, "466d": function(t, e, n) {
          "use strict";
          var r = n("d784"), a = n("825a"), i = n("50c4"), o = n("1d80"), s = n("8aa5"), c = n("14c3");
          r("match", 1, function(t2, e2, n2) {
            return [function(e3) {
              var n3 = o(this), r2 = e3 == void 0 ? void 0 : e3[t2];
              return r2 !== void 0 ? r2.call(e3, n3) : new RegExp(e3)[t2](String(n3));
            }, function(t3) {
              var r2 = n2(e2, t3, this);
              if (r2.done)
                return r2.value;
              var o2 = a(t3), u = String(this);
              if (!o2.global)
                return c(o2, u);
              var l = o2.unicode;
              o2.lastIndex = 0;
              var f, d = [], h = 0;
              while ((f = c(o2, u)) !== null) {
                var p = String(f[0]);
                d[h] = p, p === "" && (o2.lastIndex = s(u, i(o2.lastIndex), l)), h++;
              }
              return h === 0 ? null : d;
            }];
          });
        }, 4930: function(t, e, n) {
          var r = n("d039");
          t.exports = !!Object.getOwnPropertySymbols && !r(function() {
            return !String(Symbol());
          });
        }, "4d64": function(t, e, n) {
          var r = n("fc6a"), a = n("50c4"), i = n("23cb"), o = function(t2) {
            return function(e2, n2, o2) {
              var s, c = r(e2), u = a(c.length), l = i(o2, u);
              if (t2 && n2 != n2) {
                while (u > l)
                  if (s = c[l++], s != s)
                    return true;
              } else
                for (; u > l; l++)
                  if ((t2 || l in c) && c[l] === n2)
                    return t2 || l || 0;
              return !t2 && -1;
            };
          };
          t.exports = { includes: o(true), indexOf: o(false) };
        }, "4de4": function(t, e, n) {
          "use strict";
          var r = n("23e7"), a = n("b727").filter, i = n("d039"), o = n("1dde"), s = o("filter"), c = s && !i(function() {
            [].filter.call({ length: -1, 0: 1 }, function(t2) {
              throw t2;
            });
          });
          r({ target: "Array", proto: true, forced: !s || !c }, { filter: function(t2) {
            return a(this, t2, arguments.length > 1 ? arguments[1] : void 0);
          } });
        }, "4df4": function(t, e, n) {
          "use strict";
          var r = n("f8c2"), a = n("7b0b"), i = n("9bdd"), o = n("e95a"), s = n("50c4"), c = n("8418"), u = n("35a1");
          t.exports = function(t2) {
            var e2, n2, l, f, d, h = a(t2), p = typeof this == "function" ? this : Array, m = arguments.length, g = m > 1 ? arguments[1] : void 0, v = g !== void 0, y = 0, b = u(h);
            if (v && (g = r(g, m > 2 ? arguments[2] : void 0, 2)), b == void 0 || p == Array && o(b))
              for (e2 = s(h.length), n2 = new p(e2); e2 > y; y++)
                c(n2, y, v ? g(h[y], y) : h[y]);
            else
              for (f = b.call(h), d = f.next, n2 = new p(); !(l = d.call(f)).done; y++)
                c(n2, y, v ? i(f, g, [l.value, y], true) : l.value);
            return n2.length = y, n2;
          };
        }, "50c4": function(t, e, n) {
          var r = n("a691"), a = Math.min;
          t.exports = function(t2) {
            return t2 > 0 ? a(r(t2), 9007199254740991) : 0;
          };
        }, 5135: function(t, e) {
          var n = {}.hasOwnProperty;
          t.exports = function(t2, e2) {
            return n.call(t2, e2);
          };
        }, 5319: function(t, e, n) {
          "use strict";
          var r = n("d784"), a = n("825a"), i = n("7b0b"), o = n("50c4"), s = n("a691"), c = n("1d80"), u = n("8aa5"), l = n("14c3"), f = Math.max, d = Math.min, h = Math.floor, p = /\$([$&'`]|\d\d?|<[^>]*>)/g, m = /\$([$&'`]|\d\d?)/g, g = function(t2) {
            return t2 === void 0 ? t2 : String(t2);
          };
          r("replace", 2, function(t2, e2, n2) {
            return [function(n3, r3) {
              var a2 = c(this), i2 = n3 == void 0 ? void 0 : n3[t2];
              return i2 !== void 0 ? i2.call(n3, a2, r3) : e2.call(String(a2), n3, r3);
            }, function(t3, i2) {
              var c2 = n2(e2, t3, this, i2);
              if (c2.done)
                return c2.value;
              var h2 = a(t3), p2 = String(this), m2 = typeof i2 === "function";
              m2 || (i2 = String(i2));
              var v = h2.global;
              if (v) {
                var y = h2.unicode;
                h2.lastIndex = 0;
              }
              var b = [];
              while (1) {
                var D = l(h2, p2);
                if (D === null)
                  break;
                if (b.push(D), !v)
                  break;
                var w = String(D[0]);
                w === "" && (h2.lastIndex = u(p2, o(h2.lastIndex), y));
              }
              for (var x = "", S = 0, M = 0; M < b.length; M++) {
                D = b[M];
                for (var k = String(D[0]), _ = f(d(s(D.index), p2.length), 0), O = [], T = 1; T < D.length; T++)
                  O.push(g(D[T]));
                var C = D.groups;
                if (m2) {
                  var P = [k].concat(O, _, p2);
                  C !== void 0 && P.push(C);
                  var j = String(i2.apply(void 0, P));
                } else
                  j = r2(k, p2, _, O, C, i2);
                _ >= S && (x += p2.slice(S, _) + j, S = _ + k.length);
              }
              return x + p2.slice(S);
            }];
            function r2(t3, n3, r3, a2, o2, s2) {
              var c2 = r3 + t3.length, u2 = a2.length, l2 = m;
              return o2 !== void 0 && (o2 = i(o2), l2 = p), e2.call(s2, l2, function(e3, i2) {
                var s3;
                switch (i2.charAt(0)) {
                  case "$":
                    return "$";
                  case "&":
                    return t3;
                  case "`":
                    return n3.slice(0, r3);
                  case "'":
                    return n3.slice(c2);
                  case "<":
                    s3 = o2[i2.slice(1, -1)];
                    break;
                  default:
                    var l3 = +i2;
                    if (l3 === 0)
                      return e3;
                    if (l3 > u2) {
                      var f2 = h(l3 / 10);
                      return f2 === 0 ? e3 : f2 <= u2 ? a2[f2 - 1] === void 0 ? i2.charAt(1) : a2[f2 - 1] + i2.charAt(1) : e3;
                    }
                    s3 = a2[l3 - 1];
                }
                return s3 === void 0 ? "" : s3;
              });
            }
          });
        }, "53ca": function(t, e, n) {
          "use strict";
          n.d(e, "a", function() {
            return a;
          });
          n("a4d3"), n("e01a"), n("d28b"), n("e260"), n("d3b7"), n("3ca3"), n("ddb0");
          function r(t2) {
            return r = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(t3) {
              return typeof t3;
            } : function(t3) {
              return t3 && typeof Symbol === "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
            }, r(t2);
          }
          function a(t2) {
            return a = typeof Symbol === "function" && r(Symbol.iterator) === "symbol" ? function(t3) {
              return r(t3);
            } : function(t3) {
              return t3 && typeof Symbol === "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : r(t3);
            }, a(t2);
          }
        }, 5692: function(t, e, n) {
          var r = n("c430"), a = n("c6cd");
          (t.exports = function(t2, e2) {
            return a[t2] || (a[t2] = e2 !== void 0 ? e2 : {});
          })("versions", []).push({ version: "3.5.0", mode: r ? "pure" : "global", copyright: "\xA9 2019 Denis Pushkarev (zloirock.ru)" });
        }, "56ef": function(t, e, n) {
          var r = n("d066"), a = n("241c"), i = n("7418"), o = n("825a");
          t.exports = r("Reflect", "ownKeys") || function(t2) {
            var e2 = a.f(o(t2)), n2 = i.f;
            return n2 ? e2.concat(n2(t2)) : e2;
          };
        }, 5899: function(t, e) {
          t.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
        }, "58a8": function(t, e, n) {
          var r = n("1d80"), a = n("5899"), i = "[" + a + "]", o = RegExp("^" + i + i + "*"), s = RegExp(i + i + "*$"), c = function(t2) {
            return function(e2) {
              var n2 = String(r(e2));
              return 1 & t2 && (n2 = n2.replace(o, "")), 2 & t2 && (n2 = n2.replace(s, "")), n2;
            };
          };
          t.exports = { start: c(1), end: c(2), trim: c(3) };
        }, "5c6c": function(t, e) {
          t.exports = function(t2, e2) {
            return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e2 };
          };
        }, "60ae": function(t, e, n) {
          var r, a, i = n("da84"), o = n("b39a"), s = i.process, c = s && s.versions, u = c && c.v8;
          u ? (r = u.split("."), a = r[0] + r[1]) : o && (r = o.match(/Edge\/(\d+)/), (!r || r[1] >= 74) && (r = o.match(/Chrome\/(\d+)/), r && (a = r[1]))), t.exports = a && +a;
        }, 6547: function(t, e, n) {
          var r = n("a691"), a = n("1d80"), i = function(t2) {
            return function(e2, n2) {
              var i2, o, s = String(a(e2)), c = r(n2), u = s.length;
              return c < 0 || c >= u ? t2 ? "" : void 0 : (i2 = s.charCodeAt(c), i2 < 55296 || i2 > 56319 || c + 1 === u || (o = s.charCodeAt(c + 1)) < 56320 || o > 57343 ? t2 ? s.charAt(c) : i2 : t2 ? s.slice(c, c + 2) : o - 56320 + (i2 - 55296 << 10) + 65536);
            };
          };
          t.exports = { codeAt: i(false), charAt: i(true) };
        }, "65f0": function(t, e, n) {
          var r = n("861d"), a = n("e8b5"), i = n("b622"), o = i("species");
          t.exports = function(t2, e2) {
            var n2;
            return a(t2) && (n2 = t2.constructor, typeof n2 != "function" || n2 !== Array && !a(n2.prototype) ? r(n2) && (n2 = n2[o], n2 === null && (n2 = void 0)) : n2 = void 0), new (n2 === void 0 ? Array : n2)(e2 === 0 ? 0 : e2);
          };
        }, "69f3": function(t, e, n) {
          var r, a, i, o = n("7f9a"), s = n("da84"), c = n("861d"), u = n("9112"), l = n("5135"), f = n("f772"), d = n("d012"), h = s.WeakMap, p = function(t2) {
            return i(t2) ? a(t2) : r(t2, {});
          }, m = function(t2) {
            return function(e2) {
              var n2;
              if (!c(e2) || (n2 = a(e2)).type !== t2)
                throw TypeError("Incompatible receiver, " + t2 + " required");
              return n2;
            };
          };
          if (o) {
            var g = new h(), v = g.get, y = g.has, b = g.set;
            r = function(t2, e2) {
              return b.call(g, t2, e2), e2;
            }, a = function(t2) {
              return v.call(g, t2) || {};
            }, i = function(t2) {
              return y.call(g, t2);
            };
          } else {
            var D = f("state");
            d[D] = true, r = function(t2, e2) {
              return u(t2, D, e2), e2;
            }, a = function(t2) {
              return l(t2, D) ? t2[D] : {};
            }, i = function(t2) {
              return l(t2, D);
            };
          }
          t.exports = { set: r, get: a, has: i, enforce: p, getterFor: m };
        }, "6eeb": function(t, e, n) {
          var r = n("da84"), a = n("9112"), i = n("5135"), o = n("ce4e"), s = n("8925"), c = n("69f3"), u = c.get, l = c.enforce, f = String(String).split("String");
          (t.exports = function(t2, e2, n2, s2) {
            var c2 = !!s2 && !!s2.unsafe, u2 = !!s2 && !!s2.enumerable, d = !!s2 && !!s2.noTargetGet;
            typeof n2 == "function" && (typeof e2 != "string" || i(n2, "name") || a(n2, "name", e2), l(n2).source = f.join(typeof e2 == "string" ? e2 : "")), t2 !== r ? (c2 ? !d && t2[e2] && (u2 = true) : delete t2[e2], u2 ? t2[e2] = n2 : a(t2, e2, n2)) : u2 ? t2[e2] = n2 : o(e2, n2);
          })(Function.prototype, "toString", function() {
            return typeof this == "function" && u(this).source || s(this);
          });
        }, 7156: function(t, e, n) {
          var r = n("861d"), a = n("d2bb");
          t.exports = function(t2, e2, n2) {
            var i, o;
            return a && typeof (i = e2.constructor) == "function" && i !== n2 && r(o = i.prototype) && o !== n2.prototype && a(t2, o), t2;
          };
        }, 7418: function(t, e) {
          e.f = Object.getOwnPropertySymbols;
        }, "746f": function(t, e, n) {
          var r = n("428f"), a = n("5135"), i = n("c032"), o = n("9bf2").f;
          t.exports = function(t2) {
            var e2 = r.Symbol || (r.Symbol = {});
            a(e2, t2) || o(e2, t2, { value: i.f(t2) });
          };
        }, 7839: function(t, e) {
          t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
        }, "7a50": function(t, e, n) {
          "use strict";
          n.r(e);
          n("a4d3"), n("4de4"), n("d81d"), n("fb6a"), n("e439"), n("dbb4"), n("b64b"), n("159b");
          var r = n("ade3"), a = (n("d3b7"), n("466d"), n("5319"), n("53ca")), i = function() {
            var t2 = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|"[^"]*"|'[^']*'/g, e2 = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, n2 = /[^-+\dA-Z]/g;
            return function(r2, a2, l2, f2) {
              if (arguments.length !== 1 || u(r2) !== "string" || /\d/.test(r2) || (a2 = r2, r2 = void 0), r2 = r2 || new Date(), r2 instanceof Date || (r2 = new Date(r2)), isNaN(r2))
                throw TypeError("Invalid date");
              a2 = String(i.masks[a2] || a2 || i.masks["default"]);
              var d2 = a2.slice(0, 4);
              d2 !== "UTC:" && d2 !== "GMT:" || (a2 = a2.slice(4), l2 = true, d2 === "GMT:" && (f2 = true));
              var h = l2 ? "getUTC" : "get", p = r2[h + "Date"](), m = r2[h + "Day"](), g = r2[h + "Month"](), v = r2[h + "FullYear"](), y = r2[h + "Hours"](), b = r2[h + "Minutes"](), D = r2[h + "Seconds"](), w = r2[h + "Milliseconds"](), x = l2 ? 0 : r2.getTimezoneOffset(), S = s(r2), M = c(r2), k = { d: p, dd: o(p), ddd: i.i18n.dayNames[m], dddd: i.i18n.dayNames[m + 7], m: g + 1, mm: o(g + 1), mmm: i.i18n.monthNames[g], mmmm: i.i18n.monthNames[g + 12], yy: String(v).slice(2), yyyy: v, h: y % 12 || 12, hh: o(y % 12 || 12), H: y, HH: o(y), M: b, MM: o(b), s: D, ss: o(D), l: o(w, 3), L: o(Math.round(w / 10)), t: y < 12 ? i.i18n.timeNames[0] : i.i18n.timeNames[1], tt: y < 12 ? i.i18n.timeNames[2] : i.i18n.timeNames[3], T: y < 12 ? i.i18n.timeNames[4] : i.i18n.timeNames[5], TT: y < 12 ? i.i18n.timeNames[6] : i.i18n.timeNames[7], Z: f2 ? "GMT" : l2 ? "UTC" : (String(r2).match(e2) || [""]).pop().replace(n2, ""), o: (x > 0 ? "-" : "+") + o(100 * Math.floor(Math.abs(x) / 60) + Math.abs(x) % 60, 4), S: ["th", "st", "nd", "rd"][p % 10 > 3 ? 0 : (p % 100 - p % 10 != 10) * p % 10], W: S, N: M };
              return a2.replace(t2, function(t3) {
                return t3 in k ? k[t3] : t3.slice(1, t3.length - 1);
              });
            };
          }();
          function o(t2, e2) {
            t2 = String(t2), e2 = e2 || 2;
            while (t2.length < e2)
              t2 = "0" + t2;
            return t2;
          }
          function s(t2) {
            var e2 = new Date(t2.getFullYear(), t2.getMonth(), t2.getDate());
            e2.setDate(e2.getDate() - (e2.getDay() + 6) % 7 + 3);
            var n2 = new Date(e2.getFullYear(), 0, 4);
            n2.setDate(n2.getDate() - (n2.getDay() + 6) % 7 + 3);
            var r2 = e2.getTimezoneOffset() - n2.getTimezoneOffset();
            e2.setHours(e2.getHours() - r2);
            var a2 = (e2 - n2) / 6048e5;
            return 1 + Math.floor(a2);
          }
          function c(t2) {
            var e2 = t2.getDay();
            return e2 === 0 && (e2 = 7), e2;
          }
          function u(t2) {
            return t2 === null ? "null" : t2 === void 0 ? "undefined" : Object(a["a"])(t2) !== "object" ? Object(a["a"])(t2) : Array.isArray(t2) ? "array" : {}.toString.call(t2).slice(8, -1).toLowerCase();
          }
          function l(t2, e2) {
            var n2 = Object.keys(t2);
            if (Object.getOwnPropertySymbols) {
              var r2 = Object.getOwnPropertySymbols(t2);
              e2 && (r2 = r2.filter(function(e3) {
                return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
              })), n2.push.apply(n2, r2);
            }
            return n2;
          }
          function f(t2) {
            for (var e2 = 1; e2 < arguments.length; e2++) {
              var n2 = arguments[e2] != null ? arguments[e2] : {};
              e2 % 2 ? l(Object(n2), true).forEach(function(e3) {
                Object(r["a"])(t2, e3, n2[e3]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(n2)) : l(Object(n2)).forEach(function(e3) {
                Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(n2, e3));
              });
            }
            return t2;
          }
          i.masks = { default: "ddd mmm dd yyyy HH:MM:ss", shortDate: "m/d/yy", mediumDate: "mmm d, yyyy", longDate: "mmmm d, yyyy", fullDate: "dddd, mmmm d, yyyy", shortTime: "h:MM TT", mediumTime: "h:MM:ss TT", longTime: "h:MM:ss TT Z", isoDate: "yyyy-mm-dd", isoTime: "HH:MM:ss", isoDateTime: "yyyy-mm-dd'T'HH:MM:sso", isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'", expiresHeaderFormat: "ddd, dd mmm yyyy HH:MM:ss Z" }, i.i18n = { dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], timeNames: ["a", "p", "am", "pm", "A", "P", "AM", "PM"] };
          var d = { isSame: function(t2, e2, n2) {
            var r2 = new Date(t2), a2 = new Date(e2);
            return n2 === "date" && (r2.setHours(0, 0, 0, 0), a2.setHours(0, 0, 0, 0)), r2.getTime() === a2.getTime();
          }, daysInMonth: function(t2, e2) {
            return new Date(t2, e2, 0).getDate();
          }, weekNumber: function(t2) {
            return s(t2);
          }, format: function(t2, e2) {
            return i(t2, e2);
          }, nextMonth: function(t2) {
            var e2 = new Date(t2.getTime());
            return e2.setDate(1), e2.setMonth(e2.getMonth() + 1), e2;
          }, prevMonth: function(t2) {
            var e2 = new Date(t2.getTime());
            return e2.setDate(1), e2.setMonth(e2.getMonth() - 1), e2;
          }, validateDateRange: function(t2, e2, n2) {
            var r2 = new Date(n2), a2 = new Date(e2);
            return n2 && t2.getTime() > r2.getTime() ? r2 : e2 && t2.getTime() < a2.getTime() ? a2 : t2;
          }, localeData: function(t2) {
            var e2 = { direction: "ltr", format: "mm/dd/yyyy", separator: " - ", applyLabel: "Apply", cancelLabel: "Cancel", weekLabel: "W", customRangeLabel: "Custom Range", daysOfWeek: i.i18n.dayNames.slice(0, 7).map(function(t3) {
              return t3.substring(0, 2);
            }), monthNames: i.i18n.monthNames.slice(0, 12), firstDay: 0 };
            return f({}, e2, {}, t2);
          }, yearMonth: function(t2) {
            var e2 = t2.getMonth() + 1;
            return t2.getFullYear() + (e2 < 10 ? "0" : "") + e2;
          }, isValidDate: function(t2) {
            return t2 instanceof Date && !isNaN(t2);
          } };
          e["default"] = d;
        }, "7b0b": function(t, e, n) {
          var r = n("1d80");
          t.exports = function(t2) {
            return Object(r(t2));
          };
        }, "7c73": function(t, e, n) {
          var r = n("825a"), a = n("37e8"), i = n("7839"), o = n("d012"), s = n("1be4"), c = n("cc12"), u = n("f772"), l = u("IE_PROTO"), f = "prototype", d = function() {
          }, h = function() {
            var t2, e2 = c("iframe"), n2 = i.length, r2 = "<", a2 = "script", o2 = ">", u2 = "java" + a2 + ":";
            e2.style.display = "none", s.appendChild(e2), e2.src = String(u2), t2 = e2.contentWindow.document, t2.open(), t2.write(r2 + a2 + o2 + "document.F=Object" + r2 + "/" + a2 + o2), t2.close(), h = t2.F;
            while (n2--)
              delete h[f][i[n2]];
            return h();
          };
          t.exports = Object.create || function(t2, e2) {
            var n2;
            return t2 !== null ? (d[f] = r(t2), n2 = new d(), d[f] = null, n2[l] = t2) : n2 = h(), e2 === void 0 ? n2 : a(n2, e2);
          }, o[l] = true;
        }, "7db0": function(t, e, n) {
          "use strict";
          var r = n("23e7"), a = n("b727").find, i = n("44d2"), o = "find", s = true;
          o in [] && Array(1)[o](function() {
            s = false;
          }), r({ target: "Array", proto: true, forced: s }, { find: function(t2) {
            return a(this, t2, arguments.length > 1 ? arguments[1] : void 0);
          } }), i(o);
        }, "7dd0": function(t, e, n) {
          "use strict";
          var r = n("23e7"), a = n("9ed3"), i = n("e163"), o = n("d2bb"), s = n("d44e"), c = n("9112"), u = n("6eeb"), l = n("b622"), f = n("c430"), d = n("3f8c"), h = n("ae93"), p = h.IteratorPrototype, m = h.BUGGY_SAFARI_ITERATORS, g = l("iterator"), v = "keys", y = "values", b = "entries", D = function() {
            return this;
          };
          t.exports = function(t2, e2, n2, l2, h2, w, x) {
            a(n2, e2, l2);
            var S, M, k, _ = function(t3) {
              if (t3 === h2 && j)
                return j;
              if (!m && t3 in C)
                return C[t3];
              switch (t3) {
                case v:
                  return function() {
                    return new n2(this, t3);
                  };
                case y:
                  return function() {
                    return new n2(this, t3);
                  };
                case b:
                  return function() {
                    return new n2(this, t3);
                  };
              }
              return function() {
                return new n2(this);
              };
            }, O = e2 + " Iterator", T = false, C = t2.prototype, P = C[g] || C["@@iterator"] || h2 && C[h2], j = !m && P || _(h2), A = e2 == "Array" && C.entries || P;
            if (A && (S = i(A.call(new t2())), p !== Object.prototype && S.next && (f || i(S) === p || (o ? o(S, p) : typeof S[g] != "function" && c(S, g, D)), s(S, O, true, true), f && (d[O] = D))), h2 == y && P && P.name !== y && (T = true, j = function() {
              return P.call(this);
            }), f && !x || C[g] === j || c(C, g, j), d[e2] = j, h2)
              if (M = { values: _(y), keys: w ? j : _(v), entries: _(b) }, x)
                for (k in M)
                  !m && !T && k in C || u(C, k, M[k]);
              else
                r({ target: e2, proto: true, forced: m || T }, M);
            return M;
          };
        }, "7f9a": function(t, e, n) {
          var r = n("da84"), a = n("8925"), i = r.WeakMap;
          t.exports = typeof i === "function" && /native code/.test(a(i));
        }, "825a": function(t, e, n) {
          var r = n("861d");
          t.exports = function(t2) {
            if (!r(t2))
              throw TypeError(String(t2) + " is not an object");
            return t2;
          };
        }, "83ab": function(t, e, n) {
          var r = n("d039");
          t.exports = !r(function() {
            return Object.defineProperty({}, "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        }, 8418: function(t, e, n) {
          "use strict";
          var r = n("c04e"), a = n("9bf2"), i = n("5c6c");
          t.exports = function(t2, e2, n2) {
            var o = r(e2);
            o in t2 ? a.f(t2, o, i(0, n2)) : t2[o] = n2;
          };
        }, "861d": function(t, e) {
          t.exports = function(t2) {
            return typeof t2 === "object" ? t2 !== null : typeof t2 === "function";
          };
        }, 8925: function(t, e, n) {
          var r = n("c6cd"), a = Function.toString;
          typeof r.inspectSource != "function" && (r.inspectSource = function(t2) {
            return a.call(t2);
          }), t.exports = r.inspectSource;
        }, "8aa5": function(t, e, n) {
          "use strict";
          var r = n("6547").charAt;
          t.exports = function(t2, e2, n2) {
            return e2 + (n2 ? r(t2, e2).length : 1);
          };
        }, "8b2e": function(t, e, n) {
        }, "90e3": function(t, e) {
          var n = 0, r = Math.random();
          t.exports = function(t2) {
            return "Symbol(" + String(t2 === void 0 ? "" : t2) + ")_" + (++n + r).toString(36);
          };
        }, 9112: function(t, e, n) {
          var r = n("83ab"), a = n("9bf2"), i = n("5c6c");
          t.exports = r ? function(t2, e2, n2) {
            return a.f(t2, e2, i(1, n2));
          } : function(t2, e2, n2) {
            return t2[e2] = n2, t2;
          };
        }, 9263: function(t, e, n) {
          "use strict";
          var r = n("ad6d"), a = RegExp.prototype.exec, i = String.prototype.replace, o = a, s = function() {
            var t2 = /a/, e2 = /b*/g;
            return a.call(t2, "a"), a.call(e2, "a"), t2.lastIndex !== 0 || e2.lastIndex !== 0;
          }(), c = /()??/.exec("")[1] !== void 0, u = s || c;
          u && (o = function(t2) {
            var e2, n2, o2, u2, l = this;
            return c && (n2 = new RegExp("^" + l.source + "$(?!\\s)", r.call(l))), s && (e2 = l.lastIndex), o2 = a.call(l, t2), s && o2 && (l.lastIndex = l.global ? o2.index + o2[0].length : e2), c && o2 && o2.length > 1 && i.call(o2[0], n2, function() {
              for (u2 = 1; u2 < arguments.length - 2; u2++)
                arguments[u2] === void 0 && (o2[u2] = void 0);
            }), o2;
          }), t.exports = o;
        }, "94ca": function(t, e, n) {
          var r = n("d039"), a = /#|\.prototype\./, i = function(t2, e2) {
            var n2 = s[o(t2)];
            return n2 == u || n2 != c && (typeof e2 == "function" ? r(e2) : !!e2);
          }, o = i.normalize = function(t2) {
            return String(t2).replace(a, ".").toLowerCase();
          }, s = i.data = {}, c = i.NATIVE = "N", u = i.POLYFILL = "P";
          t.exports = i;
        }, "9bdd": function(t, e, n) {
          var r = n("825a");
          t.exports = function(t2, e2, n2, a) {
            try {
              return a ? e2(r(n2)[0], n2[1]) : e2(n2);
            } catch (o) {
              var i = t2["return"];
              throw i !== void 0 && r(i.call(t2)), o;
            }
          };
        }, "9bf2": function(t, e, n) {
          var r = n("83ab"), a = n("0cfb"), i = n("825a"), o = n("c04e"), s = Object.defineProperty;
          e.f = r ? s : function(t2, e2, n2) {
            if (i(t2), e2 = o(e2, true), i(n2), a)
              try {
                return s(t2, e2, n2);
              } catch (r2) {
              }
            if ("get" in n2 || "set" in n2)
              throw TypeError("Accessors not supported");
            return "value" in n2 && (t2[e2] = n2.value), t2;
          };
        }, "9d0d": function(t, e, n) {
          "use strict";
          var r = n("8b2e"), a = n.n(r);
          a.a;
        }, "9ed3": function(t, e, n) {
          "use strict";
          var r = n("ae93").IteratorPrototype, a = n("7c73"), i = n("5c6c"), o = n("d44e"), s = n("3f8c"), c = function() {
            return this;
          };
          t.exports = function(t2, e2, n2) {
            var u = e2 + " Iterator";
            return t2.prototype = a(r, { next: i(1, n2) }), o(t2, u, false, true), s[u] = c, t2;
          };
        }, a4d3: function(t, e, n) {
          "use strict";
          var r = n("23e7"), a = n("da84"), i = n("d066"), o = n("c430"), s = n("83ab"), c = n("4930"), u = n("fdbf"), l = n("d039"), f = n("5135"), d = n("e8b5"), h = n("861d"), p = n("825a"), m = n("7b0b"), g = n("fc6a"), v = n("c04e"), y = n("5c6c"), b = n("7c73"), D = n("df75"), w = n("241c"), x = n("057f"), S = n("7418"), M = n("06cf"), k = n("9bf2"), _ = n("d1e7"), O = n("9112"), T = n("6eeb"), C = n("5692"), P = n("f772"), j = n("d012"), A = n("90e3"), N = n("b622"), R = n("c032"), $2 = n("746f"), E = n("d44e"), U = n("69f3"), F = n("b727").forEach, I = P("hidden"), L = "Symbol", H = "prototype", B = N("toPrimitive"), Y = U.set, W = U.getterFor(L), V = Object[H], G = a.Symbol, z = i("JSON", "stringify"), J = M.f, Z = k.f, X = x.f, q = _.f, K = C("symbols"), Q = C("op-symbols"), tt = C("string-to-symbol-registry"), et = C("symbol-to-string-registry"), nt = C("wks"), rt = a.QObject, at = !rt || !rt[H] || !rt[H].findChild, it = s && l(function() {
            return b(Z({}, "a", { get: function() {
              return Z(this, "a", { value: 7 }).a;
            } })).a != 7;
          }) ? function(t2, e2, n2) {
            var r2 = J(V, e2);
            r2 && delete V[e2], Z(t2, e2, n2), r2 && t2 !== V && Z(V, e2, r2);
          } : Z, ot = function(t2, e2) {
            var n2 = K[t2] = b(G[H]);
            return Y(n2, { type: L, tag: t2, description: e2 }), s || (n2.description = e2), n2;
          }, st = c && typeof G.iterator == "symbol" ? function(t2) {
            return typeof t2 == "symbol";
          } : function(t2) {
            return Object(t2) instanceof G;
          }, ct = function(t2, e2, n2) {
            t2 === V && ct(Q, e2, n2), p(t2);
            var r2 = v(e2, true);
            return p(n2), f(K, r2) ? (n2.enumerable ? (f(t2, I) && t2[I][r2] && (t2[I][r2] = false), n2 = b(n2, { enumerable: y(0, false) })) : (f(t2, I) || Z(t2, I, y(1, {})), t2[I][r2] = true), it(t2, r2, n2)) : Z(t2, r2, n2);
          }, ut = function(t2, e2) {
            p(t2);
            var n2 = g(e2), r2 = D(n2).concat(pt(n2));
            return F(r2, function(e3) {
              s && !ft.call(n2, e3) || ct(t2, e3, n2[e3]);
            }), t2;
          }, lt = function(t2, e2) {
            return e2 === void 0 ? b(t2) : ut(b(t2), e2);
          }, ft = function(t2) {
            var e2 = v(t2, true), n2 = q.call(this, e2);
            return !(this === V && f(K, e2) && !f(Q, e2)) && (!(n2 || !f(this, e2) || !f(K, e2) || f(this, I) && this[I][e2]) || n2);
          }, dt = function(t2, e2) {
            var n2 = g(t2), r2 = v(e2, true);
            if (n2 !== V || !f(K, r2) || f(Q, r2)) {
              var a2 = J(n2, r2);
              return !a2 || !f(K, r2) || f(n2, I) && n2[I][r2] || (a2.enumerable = true), a2;
            }
          }, ht = function(t2) {
            var e2 = X(g(t2)), n2 = [];
            return F(e2, function(t3) {
              f(K, t3) || f(j, t3) || n2.push(t3);
            }), n2;
          }, pt = function(t2) {
            var e2 = t2 === V, n2 = X(e2 ? Q : g(t2)), r2 = [];
            return F(n2, function(t3) {
              !f(K, t3) || e2 && !f(V, t3) || r2.push(K[t3]);
            }), r2;
          };
          if (c || (G = function() {
            if (this instanceof G)
              throw TypeError("Symbol is not a constructor");
            var t2 = arguments.length && arguments[0] !== void 0 ? String(arguments[0]) : void 0, e2 = A(t2), n2 = function(t3) {
              this === V && n2.call(Q, t3), f(this, I) && f(this[I], e2) && (this[I][e2] = false), it(this, e2, y(1, t3));
            };
            return s && at && it(V, e2, { configurable: true, set: n2 }), ot(e2, t2);
          }, T(G[H], "toString", function() {
            return W(this).tag;
          }), _.f = ft, k.f = ct, M.f = dt, w.f = x.f = ht, S.f = pt, s && (Z(G[H], "description", { configurable: true, get: function() {
            return W(this).description;
          } }), o || T(V, "propertyIsEnumerable", ft, { unsafe: true }))), u || (R.f = function(t2) {
            return ot(N(t2), t2);
          }), r({ global: true, wrap: true, forced: !c, sham: !c }, { Symbol: G }), F(D(nt), function(t2) {
            $2(t2);
          }), r({ target: L, stat: true, forced: !c }, { for: function(t2) {
            var e2 = String(t2);
            if (f(tt, e2))
              return tt[e2];
            var n2 = G(e2);
            return tt[e2] = n2, et[n2] = e2, n2;
          }, keyFor: function(t2) {
            if (!st(t2))
              throw TypeError(t2 + " is not a symbol");
            if (f(et, t2))
              return et[t2];
          }, useSetter: function() {
            at = true;
          }, useSimple: function() {
            at = false;
          } }), r({ target: "Object", stat: true, forced: !c, sham: !s }, { create: lt, defineProperty: ct, defineProperties: ut, getOwnPropertyDescriptor: dt }), r({ target: "Object", stat: true, forced: !c }, { getOwnPropertyNames: ht, getOwnPropertySymbols: pt }), r({ target: "Object", stat: true, forced: l(function() {
            S.f(1);
          }) }, { getOwnPropertySymbols: function(t2) {
            return S.f(m(t2));
          } }), z) {
            var mt = !c || l(function() {
              var t2 = G();
              return z([t2]) != "[null]" || z({ a: t2 }) != "{}" || z(Object(t2)) != "{}";
            });
            r({ target: "JSON", stat: true, forced: mt }, { stringify: function(t2, e2, n2) {
              var r2, a2 = [t2], i2 = 1;
              while (arguments.length > i2)
                a2.push(arguments[i2++]);
              if (r2 = e2, (h(e2) || t2 !== void 0) && !st(t2))
                return d(e2) || (e2 = function(t3, e3) {
                  if (typeof r2 == "function" && (e3 = r2.call(this, t3, e3)), !st(e3))
                    return e3;
                }), a2[1] = e2, z.apply(null, a2);
            } });
          }
          G[H][B] || O(G[H], B, G[H].valueOf), E(G, L), j[I] = true;
        }, a630: function(t, e, n) {
          var r = n("23e7"), a = n("4df4"), i = n("1c7e"), o = !i(function(t2) {
            Array.from(t2);
          });
          r({ target: "Array", stat: true, forced: o }, { from: a });
        }, a691: function(t, e) {
          var n = Math.ceil, r = Math.floor;
          t.exports = function(t2) {
            return isNaN(t2 = +t2) ? 0 : (t2 > 0 ? r : n)(t2);
          };
        }, a6da: function(t, e, n) {
          var r = { "./native": "7a50", "./native.js": "7a50" };
          function a(t2) {
            var e2 = i(t2);
            return n(e2);
          }
          function i(t2) {
            if (!n.o(r, t2)) {
              var e2 = new Error("Cannot find module '" + t2 + "'");
              throw e2.code = "MODULE_NOT_FOUND", e2;
            }
            return r[t2];
          }
          a.keys = function() {
            return Object.keys(r);
          }, a.resolve = i, t.exports = a, a.id = "a6da";
        }, a9e3: function(t, e, n) {
          "use strict";
          var r = n("83ab"), a = n("da84"), i = n("94ca"), o = n("6eeb"), s = n("5135"), c = n("c6b6"), u = n("7156"), l = n("c04e"), f = n("d039"), d = n("7c73"), h = n("241c").f, p = n("06cf").f, m = n("9bf2").f, g = n("58a8").trim, v = "Number", y = a[v], b = y.prototype, D = c(d(b)) == v, w = function(t2) {
            var e2, n2, r2, a2, i2, o2, s2, c2, u2 = l(t2, false);
            if (typeof u2 == "string" && u2.length > 2) {
              if (u2 = g(u2), e2 = u2.charCodeAt(0), e2 === 43 || e2 === 45) {
                if (n2 = u2.charCodeAt(2), n2 === 88 || n2 === 120)
                  return NaN;
              } else if (e2 === 48) {
                switch (u2.charCodeAt(1)) {
                  case 66:
                  case 98:
                    r2 = 2, a2 = 49;
                    break;
                  case 79:
                  case 111:
                    r2 = 8, a2 = 55;
                    break;
                  default:
                    return +u2;
                }
                for (i2 = u2.slice(2), o2 = i2.length, s2 = 0; s2 < o2; s2++)
                  if (c2 = i2.charCodeAt(s2), c2 < 48 || c2 > a2)
                    return NaN;
                return parseInt(i2, r2);
              }
            }
            return +u2;
          };
          if (i(v, !y(" 0o1") || !y("0b1") || y("+0x1"))) {
            for (var x, S = function(t2) {
              var e2 = arguments.length < 1 ? 0 : t2, n2 = this;
              return n2 instanceof S && (D ? f(function() {
                b.valueOf.call(n2);
              }) : c(n2) != v) ? u(new y(w(e2)), n2, S) : w(e2);
            }, M = r ? h(y) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), k = 0; M.length > k; k++)
              s(y, x = M[k]) && !s(S, x) && m(S, x, p(y, x));
            S.prototype = b, b.constructor = S, o(a, v, S);
          }
        }, ad6d: function(t, e, n) {
          "use strict";
          var r = n("825a");
          t.exports = function() {
            var t2 = r(this), e2 = "";
            return t2.global && (e2 += "g"), t2.ignoreCase && (e2 += "i"), t2.multiline && (e2 += "m"), t2.dotAll && (e2 += "s"), t2.unicode && (e2 += "u"), t2.sticky && (e2 += "y"), e2;
          };
        }, ade3: function(t, e, n) {
          "use strict";
          function r(t2, e2, n2) {
            return e2 in t2 ? Object.defineProperty(t2, e2, { value: n2, enumerable: true, configurable: true, writable: true }) : t2[e2] = n2, t2;
          }
          n.d(e, "a", function() {
            return r;
          });
        }, ae93: function(t, e, n) {
          "use strict";
          var r, a, i, o = n("e163"), s = n("9112"), c = n("5135"), u = n("b622"), l = n("c430"), f = u("iterator"), d = false, h = function() {
            return this;
          };
          [].keys && (i = [].keys(), "next" in i ? (a = o(o(i)), a !== Object.prototype && (r = a)) : d = true), r == void 0 && (r = {}), l || c(r, f) || s(r, f, h), t.exports = { IteratorPrototype: r, BUGGY_SAFARI_ITERATORS: d };
        }, b041: function(t, e, n) {
          "use strict";
          var r = n("00ee"), a = n("f5df");
          t.exports = r ? {}.toString : function() {
            return "[object " + a(this) + "]";
          };
        }, b301: function(t, e, n) {
          "use strict";
          var r = n("d039");
          t.exports = function(t2, e2) {
            var n2 = [][t2];
            return !n2 || !r(function() {
              n2.call(null, e2 || function() {
                throw 1;
              }, 1);
            });
          };
        }, b39a: function(t, e, n) {
          var r = n("d066");
          t.exports = r("navigator", "userAgent") || "";
        }, b622: function(t, e, n) {
          var r = n("da84"), a = n("5692"), i = n("5135"), o = n("90e3"), s = n("4930"), c = n("fdbf"), u = a("wks"), l = r.Symbol, f = c ? l : o;
          t.exports = function(t2) {
            return i(u, t2) || (s && i(l, t2) ? u[t2] = l[t2] : u[t2] = f("Symbol." + t2)), u[t2];
          };
        }, b64b: function(t, e, n) {
          var r = n("23e7"), a = n("7b0b"), i = n("df75"), o = n("d039"), s = o(function() {
            i(1);
          });
          r({ target: "Object", stat: true, forced: s }, { keys: function(t2) {
            return i(a(t2));
          } });
        }, b727: function(t, e, n) {
          var r = n("f8c2"), a = n("44ad"), i = n("7b0b"), o = n("50c4"), s = n("65f0"), c = [].push, u = function(t2) {
            var e2 = t2 == 1, n2 = t2 == 2, u2 = t2 == 3, l = t2 == 4, f = t2 == 6, d = t2 == 5 || f;
            return function(h, p, m, g) {
              for (var v, y, b = i(h), D = a(b), w = r(p, m, 3), x = o(D.length), S = 0, M = g || s, k = e2 ? M(h, x) : n2 ? M(h, 0) : void 0; x > S; S++)
                if ((d || S in D) && (v = D[S], y = w(v, S, b), t2)) {
                  if (e2)
                    k[S] = y;
                  else if (y)
                    switch (t2) {
                      case 3:
                        return true;
                      case 5:
                        return v;
                      case 6:
                        return S;
                      case 2:
                        c.call(k, v);
                    }
                  else if (l)
                    return false;
                }
              return f ? -1 : u2 || l ? l : k;
            };
          };
          t.exports = { forEach: u(0), map: u(1), filter: u(2), some: u(3), every: u(4), find: u(5), findIndex: u(6) };
        }, beb7: function(t, e, n) {
        }, c032: function(t, e, n) {
          var r = n("b622");
          e.f = r;
        }, c04e: function(t, e, n) {
          var r = n("861d");
          t.exports = function(t2, e2) {
            if (!r(t2))
              return t2;
            var n2, a;
            if (e2 && typeof (n2 = t2.toString) == "function" && !r(a = n2.call(t2)))
              return a;
            if (typeof (n2 = t2.valueOf) == "function" && !r(a = n2.call(t2)))
              return a;
            if (!e2 && typeof (n2 = t2.toString) == "function" && !r(a = n2.call(t2)))
              return a;
            throw TypeError("Can't convert object to primitive value");
          };
        }, c430: function(t, e) {
          t.exports = false;
        }, c6b6: function(t, e) {
          var n = {}.toString;
          t.exports = function(t2) {
            return n.call(t2).slice(8, -1);
          };
        }, c6cd: function(t, e, n) {
          var r = n("da84"), a = n("ce4e"), i = "__core-js_shared__", o = r[i] || a(i, {});
          t.exports = o;
        }, c8ba: function(t, e) {
          var n;
          n = function() {
            return this;
          }();
          try {
            n = n || new Function("return this")();
          } catch (r) {
            typeof window === "object" && (n = window);
          }
          t.exports = n;
        }, ca84: function(t, e, n) {
          var r = n("5135"), a = n("fc6a"), i = n("4d64").indexOf, o = n("d012");
          t.exports = function(t2, e2) {
            var n2, s = a(t2), c = 0, u = [];
            for (n2 in s)
              !r(o, n2) && r(s, n2) && u.push(n2);
            while (e2.length > c)
              r(s, n2 = e2[c++]) && (~i(u, n2) || u.push(n2));
            return u;
          };
        }, cc12: function(t, e, n) {
          var r = n("da84"), a = n("861d"), i = r.document, o = a(i) && a(i.createElement);
          t.exports = function(t2) {
            return o ? i.createElement(t2) : {};
          };
        }, ce4e: function(t, e, n) {
          var r = n("da84"), a = n("9112");
          t.exports = function(t2, e2) {
            try {
              a(r, t2, e2);
            } catch (n2) {
              r[t2] = e2;
            }
            return e2;
          };
        }, ce5f: function(t, e, n) {
          "use strict";
          var r = n("18e6"), a = n.n(r);
          a.a;
        }, d012: function(t, e) {
          t.exports = {};
        }, d039: function(t, e) {
          t.exports = function(t2) {
            try {
              return !!t2();
            } catch (e2) {
              return true;
            }
          };
        }, d066: function(t, e, n) {
          var r = n("428f"), a = n("da84"), i = function(t2) {
            return typeof t2 == "function" ? t2 : void 0;
          };
          t.exports = function(t2, e2) {
            return arguments.length < 2 ? i(r[t2]) || i(a[t2]) : r[t2] && r[t2][e2] || a[t2] && a[t2][e2];
          };
        }, d1e7: function(t, e, n) {
          "use strict";
          var r = {}.propertyIsEnumerable, a = Object.getOwnPropertyDescriptor, i = a && !r.call({ 1: 2 }, 1);
          e.f = i ? function(t2) {
            var e2 = a(this, t2);
            return !!e2 && e2.enumerable;
          } : r;
        }, d28b: function(t, e, n) {
          var r = n("746f");
          r("iterator");
        }, d2bb: function(t, e, n) {
          var r = n("825a"), a = n("3bbe");
          t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
            var t2, e2 = false, n2 = {};
            try {
              t2 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set, t2.call(n2, []), e2 = n2 instanceof Array;
            } catch (i) {
            }
            return function(n3, i) {
              return r(n3), a(i), e2 ? t2.call(n3, i) : n3.__proto__ = i, n3;
            };
          }() : void 0);
        }, d3b7: function(t, e, n) {
          var r = n("00ee"), a = n("6eeb"), i = n("b041");
          r || a(Object.prototype, "toString", i, { unsafe: true });
        }, d44e: function(t, e, n) {
          var r = n("9bf2").f, a = n("5135"), i = n("b622"), o = i("toStringTag");
          t.exports = function(t2, e2, n2) {
            t2 && !a(t2 = n2 ? t2 : t2.prototype, o) && r(t2, o, { configurable: true, value: e2 });
          };
        }, d784: function(t, e, n) {
          "use strict";
          var r = n("9112"), a = n("6eeb"), i = n("d039"), o = n("b622"), s = n("9263"), c = o("species"), u = !i(function() {
            var t2 = /./;
            return t2.exec = function() {
              var t3 = [];
              return t3.groups = { a: "7" }, t3;
            }, "".replace(t2, "$<a>") !== "7";
          }), l = !i(function() {
            var t2 = /(?:)/, e2 = t2.exec;
            t2.exec = function() {
              return e2.apply(this, arguments);
            };
            var n2 = "ab".split(t2);
            return n2.length !== 2 || n2[0] !== "a" || n2[1] !== "b";
          });
          t.exports = function(t2, e2, n2, f) {
            var d = o(t2), h = !i(function() {
              var e3 = {};
              return e3[d] = function() {
                return 7;
              }, ""[t2](e3) != 7;
            }), p = h && !i(function() {
              var e3 = false, n3 = /a/;
              return t2 === "split" && (n3 = {}, n3.constructor = {}, n3.constructor[c] = function() {
                return n3;
              }, n3.flags = "", n3[d] = /./[d]), n3.exec = function() {
                return e3 = true, null;
              }, n3[d](""), !e3;
            });
            if (!h || !p || t2 === "replace" && !u || t2 === "split" && !l) {
              var m = /./[d], g = n2(d, ""[t2], function(t3, e3, n3, r2, a2) {
                return e3.exec === s ? h && !a2 ? { done: true, value: m.call(e3, n3, r2) } : { done: true, value: t3.call(n3, e3, r2) } : { done: false };
              }), v = g[0], y = g[1];
              a(String.prototype, t2, v), a(RegExp.prototype, d, e2 == 2 ? function(t3, e3) {
                return y.call(t3, this, e3);
              } : function(t3) {
                return y.call(t3, this);
              }), f && r(RegExp.prototype[d], "sham", true);
            }
          };
        }, d81d: function(t, e, n) {
          "use strict";
          var r = n("23e7"), a = n("b727").map, i = n("d039"), o = n("1dde"), s = o("map"), c = s && !i(function() {
            [].map.call({ length: -1, 0: 1 }, function(t2) {
              throw t2;
            });
          });
          r({ target: "Array", proto: true, forced: !s || !c }, { map: function(t2) {
            return a(this, t2, arguments.length > 1 ? arguments[1] : void 0);
          } });
        }, da84: function(t, e, n) {
          (function(e2) {
            var n2 = function(t2) {
              return t2 && t2.Math == Math && t2;
            };
            t.exports = n2(typeof globalThis == "object" && globalThis) || n2(typeof window == "object" && window) || n2(typeof self == "object" && self) || n2(typeof e2 == "object" && e2) || Function("return this")();
          }).call(this, n("c8ba"));
        }, dbb4: function(t, e, n) {
          var r = n("23e7"), a = n("83ab"), i = n("56ef"), o = n("fc6a"), s = n("06cf"), c = n("8418");
          r({ target: "Object", stat: true, sham: !a }, { getOwnPropertyDescriptors: function(t2) {
            var e2, n2, r2 = o(t2), a2 = s.f, u = i(r2), l = {}, f = 0;
            while (u.length > f)
              n2 = a2(r2, e2 = u[f++]), n2 !== void 0 && c(l, e2, n2);
            return l;
          } });
        }, ddb0: function(t, e, n) {
          var r = n("da84"), a = n("fdbc"), i = n("e260"), o = n("9112"), s = n("b622"), c = s("iterator"), u = s("toStringTag"), l = i.values;
          for (var f in a) {
            var d = r[f], h = d && d.prototype;
            if (h) {
              if (h[c] !== l)
                try {
                  o(h, c, l);
                } catch (m) {
                  h[c] = l;
                }
              if (h[u] || o(h, u, f), a[f]) {
                for (var p in i)
                  if (h[p] !== i[p])
                    try {
                      o(h, p, i[p]);
                    } catch (m) {
                      h[p] = i[p];
                    }
              }
            }
          }
        }, df75: function(t, e, n) {
          var r = n("ca84"), a = n("7839");
          t.exports = Object.keys || function(t2) {
            return r(t2, a);
          };
        }, e01a: function(t, e, n) {
          "use strict";
          var r = n("23e7"), a = n("83ab"), i = n("da84"), o = n("5135"), s = n("861d"), c = n("9bf2").f, u = n("e893"), l = i.Symbol;
          if (a && typeof l == "function" && (!("description" in l.prototype) || l().description !== void 0)) {
            var f = {}, d = function() {
              var t2 = arguments.length < 1 || arguments[0] === void 0 ? void 0 : String(arguments[0]), e2 = this instanceof d ? new l(t2) : t2 === void 0 ? l() : l(t2);
              return t2 === "" && (f[e2] = true), e2;
            };
            u(d, l);
            var h = d.prototype = l.prototype;
            h.constructor = d;
            var p = h.toString, m = String(l("test")) == "Symbol(test)", g = /^Symbol\((.*)\)[^)]+$/;
            c(h, "description", { configurable: true, get: function() {
              var t2 = s(this) ? this.valueOf() : this, e2 = p.call(t2);
              if (o(f, t2))
                return "";
              var n2 = m ? e2.slice(7, -1) : e2.replace(g, "$1");
              return n2 === "" ? void 0 : n2;
            } }), r({ global: true, forced: true }, { Symbol: d });
          }
        }, e163: function(t, e, n) {
          var r = n("5135"), a = n("7b0b"), i = n("f772"), o = n("e177"), s = i("IE_PROTO"), c = Object.prototype;
          t.exports = o ? Object.getPrototypeOf : function(t2) {
            return t2 = a(t2), r(t2, s) ? t2[s] : typeof t2.constructor == "function" && t2 instanceof t2.constructor ? t2.constructor.prototype : t2 instanceof Object ? c : null;
          };
        }, e177: function(t, e, n) {
          var r = n("d039");
          t.exports = !r(function() {
            function t2() {
            }
            return t2.prototype.constructor = null, Object.getPrototypeOf(new t2()) !== t2.prototype;
          });
        }, e260: function(t, e, n) {
          "use strict";
          var r = n("fc6a"), a = n("44d2"), i = n("3f8c"), o = n("69f3"), s = n("7dd0"), c = "Array Iterator", u = o.set, l = o.getterFor(c);
          t.exports = s(Array, "Array", function(t2, e2) {
            u(this, { type: c, target: r(t2), index: 0, kind: e2 });
          }, function() {
            var t2 = l(this), e2 = t2.target, n2 = t2.kind, r2 = t2.index++;
            return !e2 || r2 >= e2.length ? (t2.target = void 0, { value: void 0, done: true }) : n2 == "keys" ? { value: r2, done: false } : n2 == "values" ? { value: e2[r2], done: false } : { value: [r2, e2[r2]], done: false };
          }, "values"), i.Arguments = i.Array, a("keys"), a("values"), a("entries");
        }, e439: function(t, e, n) {
          var r = n("23e7"), a = n("d039"), i = n("fc6a"), o = n("06cf").f, s = n("83ab"), c = a(function() {
            o(1);
          }), u = !s || c;
          r({ target: "Object", stat: true, forced: u, sham: !s }, { getOwnPropertyDescriptor: function(t2, e2) {
            return o(i(t2), e2);
          } });
        }, e893: function(t, e, n) {
          var r = n("5135"), a = n("56ef"), i = n("06cf"), o = n("9bf2");
          t.exports = function(t2, e2) {
            for (var n2 = a(e2), s = o.f, c = i.f, u = 0; u < n2.length; u++) {
              var l = n2[u];
              r(t2, l) || s(t2, l, c(e2, l));
            }
          };
        }, e8b5: function(t, e, n) {
          var r = n("c6b6");
          t.exports = Array.isArray || function(t2) {
            return r(t2) == "Array";
          };
        }, e95a: function(t, e, n) {
          var r = n("b622"), a = n("3f8c"), i = r("iterator"), o = Array.prototype;
          t.exports = function(t2) {
            return t2 !== void 0 && (a.Array === t2 || o[i] === t2);
          };
        }, f5df: function(t, e, n) {
          var r = n("00ee"), a = n("c6b6"), i = n("b622"), o = i("toStringTag"), s = a(function() {
            return arguments;
          }()) == "Arguments", c = function(t2, e2) {
            try {
              return t2[e2];
            } catch (n2) {
            }
          };
          t.exports = r ? a : function(t2) {
            var e2, n2, r2;
            return t2 === void 0 ? "Undefined" : t2 === null ? "Null" : typeof (n2 = c(e2 = Object(t2), o)) == "string" ? n2 : s ? a(e2) : (r2 = a(e2)) == "Object" && typeof e2.callee == "function" ? "Arguments" : r2;
          };
        }, f6fd: function(t, e) {
          (function(t2) {
            var e2 = "currentScript", n = t2.getElementsByTagName("script");
            e2 in t2 || Object.defineProperty(t2, e2, { get: function() {
              try {
                throw new Error();
              } catch (r) {
                var t3, e3 = (/.*at [^\(]*\((.*):.+:.+\)$/gi.exec(r.stack) || [false])[1];
                for (t3 in n)
                  if (n[t3].src == e3 || n[t3].readyState == "interactive")
                    return n[t3];
                return null;
              }
            } });
          })(document);
        }, f772: function(t, e, n) {
          var r = n("5692"), a = n("90e3"), i = r("keys");
          t.exports = function(t2) {
            return i[t2] || (i[t2] = a(t2));
          };
        }, f8c2: function(t, e, n) {
          var r = n("1c0b");
          t.exports = function(t2, e2, n2) {
            if (r(t2), e2 === void 0)
              return t2;
            switch (n2) {
              case 0:
                return function() {
                  return t2.call(e2);
                };
              case 1:
                return function(n3) {
                  return t2.call(e2, n3);
                };
              case 2:
                return function(n3, r2) {
                  return t2.call(e2, n3, r2);
                };
              case 3:
                return function(n3, r2, a) {
                  return t2.call(e2, n3, r2, a);
                };
            }
            return function() {
              return t2.apply(e2, arguments);
            };
          };
        }, fb15: function(t, e, n) {
          "use strict";
          var r;
          (n.r(e), typeof window !== "undefined") && (n("f6fd"), (r = window.document.currentScript) && (r = r.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)) && (n.p = r[1]));
          var a = function() {
            var t2 = this, e2 = t2.$createElement, n2 = t2._self._c || e2;
            return n2("div", { staticClass: "vue-daterange-picker", class: { inline: t2.opens === "inline" } }, [n2("div", { ref: "toggle", class: t2.controlContainerClass, on: { click: t2.onClickPicker } }, [t2._t("input", [n2("i", { staticClass: "glyphicon glyphicon-calendar fa fa-calendar" }), t2._v(" "), n2("span", [t2._v(t2._s(t2.rangeText))]), n2("b", { staticClass: "caret" })], { startDate: t2.start, endDate: t2.end, ranges: t2.ranges, rangeText: t2.rangeText })], 2), n2("transition", { attrs: { name: "slide-fade", mode: "out-in" } }, [t2.open || t2.opens === "inline" ? n2("div", { directives: [{ name: "append-to-body", rawName: "v-append-to-body" }], ref: "dropdown", staticClass: "daterangepicker ltr", class: t2.pickerStyles }, [t2._t("header", null, { rangeText: t2.rangeText, locale: t2.locale, clickCancel: t2.clickCancel, clickApply: t2.clickedApply, in_selection: t2.in_selection, autoApply: t2.autoApply }), n2("div", { staticClass: "calendars" }, [t2.showRanges ? t2._t("ranges", [n2("calendar-ranges", { attrs: { "always-show-calendars": t2.alwaysShowCalendars, "locale-data": t2.locale, ranges: t2.ranges, selected: { startDate: t2.start, endDate: t2.end } }, on: { "click-range": t2.clickRange, "show-custom-range": function(e3) {
              t2.showCustomRangeCalendars = true;
            } } })], { startDate: t2.start, endDate: t2.end, ranges: t2.ranges, clickRange: t2.clickRange }) : t2._e(), t2.showCalendars ? n2("div", { staticClass: "calendars-container" }, [n2("div", { staticClass: "drp-calendar col left", class: { single: t2.singleDatePicker } }, [t2._e(), n2("div", { staticClass: "calendar-table" }, [n2("calendar", { attrs: { monthDate: t2.monthDate, "locale-data": t2.locale, start: t2.start, end: t2.end, minDate: t2.min, maxDate: t2.max, "show-dropdowns": t2.showDropdowns, "date-format": t2.dateFormatFn, showWeekNumbers: t2.showWeekNumbers }, on: { "change-month": t2.changeLeftMonth, "date-click": t2.dateClick, "hover-date": t2.hoverDate }, scopedSlots: t2._u([{ key: "date-slot", fn: function(e3) {
              return t2._t("date", null, null, e3);
            } }], null, true) })], 1), t2.timePicker && t2.start ? n2("calendar-time", { attrs: { "miniute-increment": t2.timePickerIncrement, hour24: t2.timePicker24Hour, "second-picker": t2.timePickerSeconds, "current-time": t2.start, readonly: t2.readonly }, on: { update: t2.onUpdateStartTime } }) : t2._e()], 1), t2.singleDatePicker ? t2._e() : n2("div", { staticClass: "drp-calendar col right" }, [t2._e(), n2("div", { staticClass: "calendar-table" }, [n2("calendar", { attrs: { monthDate: t2.nextMonthDate, "locale-data": t2.locale, start: t2.start, end: t2.end, minDate: t2.min, maxDate: t2.max, "show-dropdowns": t2.showDropdowns, "date-format": t2.dateFormatFn, showWeekNumbers: t2.showWeekNumbers }, on: { "change-month": t2.changeRightMonth, "date-click": t2.dateClick, "hover-date": t2.hoverDate }, scopedSlots: t2._u([{ key: "date-slot", fn: function(e3) {
              return t2._t("date", null, null, e3);
            } }], null, true) })], 1), t2.timePicker && t2.end ? n2("calendar-time", { attrs: { "miniute-increment": t2.timePickerIncrement, hour24: t2.timePicker24Hour, "second-picker": t2.timePickerSeconds, "current-time": t2.end, readonly: t2.readonly }, on: { update: t2.onUpdateEndTime } }) : t2._e()], 1)]) : t2._e()], 2), t2._t("footer", [t2.autoApply ? t2._e() : n2("div", { staticClass: "drp-buttons" }, [t2.showCalendars ? n2("span", { staticClass: "drp-selected" }, [t2._v(t2._s(t2.rangeText))]) : t2._e(), t2.readonly ? t2._e() : n2("button", { staticClass: "cancelBtn btn btn-sm btn-secondary", attrs: { type: "button" }, on: { click: t2.clickCancel } }, [t2._v(t2._s(t2.locale.cancelLabel) + " ")]), t2.readonly ? t2._e() : n2("button", { staticClass: "applyBtn btn btn-sm btn-success", attrs: { disabled: t2.in_selection, type: "button" }, on: { click: t2.clickedApply } }, [t2._v(t2._s(t2.locale.applyLabel) + " ")])])], { rangeText: t2.rangeText, locale: t2.locale, clickCancel: t2.clickCancel, clickApply: t2.clickedApply, in_selection: t2.in_selection, autoApply: t2.autoApply })], 2) : t2._e()])], 1);
          }, i = [], o = (n("a4d3"), n("4de4"), n("7db0"), n("a9e3"), n("e439"), n("dbb4"), n("b64b"), n("159b"), n("53ca"));
          function s(t2) {
            if (Array.isArray(t2)) {
              for (var e2 = 0, n2 = new Array(t2.length); e2 < t2.length; e2++)
                n2[e2] = t2[e2];
              return n2;
            }
          }
          n("e01a"), n("d28b"), n("a630"), n("e260"), n("d3b7"), n("25f0"), n("3ca3"), n("ddb0");
          function c(t2) {
            if (Symbol.iterator in Object(t2) || Object.prototype.toString.call(t2) === "[object Arguments]")
              return Array.from(t2);
          }
          function u() {
            throw new TypeError("Invalid attempt to spread non-iterable instance");
          }
          function l(t2) {
            return s(t2) || c(t2) || u();
          }
          var f = n("ade3"), d = function() {
            var t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "native";
            return t2 instanceof Object ? t2 : typeof t2 === "string" || t2 instanceof String ? n("a6da")("./" + t2).default : void 0;
          }, h = { props: { dateUtil: { type: [Object, String], default: "native" } }, beforeCreate: function() {
            this.$dateUtil = d("native");
          } }, p = function() {
            var t2 = this, e2 = t2.$createElement, n2 = t2._self._c || e2;
            return n2("table", { staticClass: "table-condensed" }, [n2("thead", [n2("tr", [n2("th", { staticClass: "prev available", attrs: { tabindex: "0" }, on: { click: t2.prevMonthClick } }, [n2("span")]), t2.showDropdowns ? n2("th", { staticClass: "month", attrs: { colspan: t2.showWeekNumbers ? 6 : 5 } }, [n2("div", { staticClass: "row mx-1" }, [n2("select", { directives: [{ name: "model", rawName: "v-model", value: t2.month, expression: "month" }], staticClass: "monthselect col", on: { change: function(e3) {
              var n3 = Array.prototype.filter.call(e3.target.options, function(t3) {
                return t3.selected;
              }).map(function(t3) {
                var e4 = "_value" in t3 ? t3._value : t3.value;
                return e4;
              });
              t2.month = e3.target.multiple ? n3 : n3[0];
            } } }, t2._l(t2.months, function(e3, r2) {
              return n2("option", { key: r2, attrs: { disabled: !e3.enabled }, domProps: { value: e3.value + 1 } }, [t2._v(t2._s(e3.label))]);
            }), 0), n2("input", { directives: [{ name: "model", rawName: "v-model", value: t2.year, expression: "year" }], ref: "yearSelect", staticClass: "yearselect col", attrs: { type: "number" }, domProps: { value: t2.year }, on: { blur: t2.checkYear, input: function(e3) {
              e3.target.composing || (t2.year = e3.target.value);
            } } })])]) : n2("th", { staticClass: "month", attrs: { colspan: t2.showWeekNumbers ? 6 : 5 } }, [t2._v(t2._s(t2.monthName) + " " + t2._s(t2.year))]), n2("th", { staticClass: "next available", attrs: { tabindex: "0" }, on: { click: t2.nextMonthClick } }, [n2("span")])])]), n2("tbody", [n2("tr", [t2.showWeekNumbers ? n2("th", { staticClass: "week" }, [t2._v(t2._s(t2.locale.weekLabel))]) : t2._e(), t2._l(t2.locale.daysOfWeek, function(e3, r2) {
              return n2("th", { key: r2 }, [t2._v(t2._s(e3))]);
            })], 2), t2._l(t2.calendar, function(e3, r2) {
              return n2("tr", { key: r2 }, [t2.showWeekNumbers && (r2 % 7 || r2 === 0) ? n2("td", { staticClass: "week" }, [t2._v(" " + t2._s(t2.$dateUtil.weekNumber(e3[0])) + " ")]) : t2._e(), t2._l(e3, function(e4, r3) {
                return n2("td", { key: r3, class: t2.dayClass(e4), attrs: { "data-date": e4.toISOString().substring(0, 10) }, on: { click: function(n3) {
                  return t2.$emit("date-click", e4);
                }, mouseover: function(n3) {
                  return t2.$emit("hover-date", e4);
                } } }, [t2._t("date-slot", [t2._v(" " + t2._s(e4.getDate()) + " ")], { date: e4 })], 2);
              })], 2);
            })], 2)]);
          }, m = [], g = (n("d81d"), { mixins: [h], name: "calendar", props: { monthDate: Date, localeData: Object, start: Date, end: Date, minDate: Date, maxDate: Date, showDropdowns: { type: Boolean, default: false }, showWeekNumbers: { type: Boolean, default: false }, dateFormat: { type: Function, default: null } }, data: function() {
            var t2 = this.monthDate || this.start || new Date();
            return { currentMonthDate: t2, year_text: t2.getFullYear() };
          }, methods: { prevMonthClick: function() {
            this.changeMonthDate(this.$dateUtil.prevMonth(this.currentMonthDate));
          }, nextMonthClick: function() {
            this.changeMonthDate(this.$dateUtil.nextMonth(this.currentMonthDate));
          }, changeMonthDate: function(t2) {
            var e2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], n2 = this.$dateUtil.yearMonth(this.currentMonthDate);
            this.currentMonthDate = this.$dateUtil.validateDateRange(t2, this.minDate, this.maxDate), e2 && n2 !== this.$dateUtil.yearMonth(this.currentMonthDate) && this.$emit("change-month", { month: this.currentMonthDate.getMonth() + 1, year: this.currentMonthDate.getFullYear() }), this.checkYear();
          }, dayClass: function(t2) {
            var e2 = new Date(t2);
            e2.setHours(0, 0, 0, 0);
            var n2 = new Date(this.start);
            n2.setHours(0, 0, 0, 0);
            var r2 = new Date(this.end);
            r2.setHours(0, 0, 0, 0);
            var a2 = new Date(e2);
            a2.setHours(23, 59, 59, 999);
            var i2 = { off: t2.getMonth() + 1 !== this.month, weekend: t2.getDay() === 6 || t2.getDay() === 0, today: e2.setHours(0, 0, 0, 0) == new Date().setHours(0, 0, 0, 0), active: e2.setHours(0, 0, 0, 0) == new Date(this.start).setHours(0, 0, 0, 0) || e2.setHours(0, 0, 0, 0) == new Date(this.end).setHours(0, 0, 0, 0), "in-range": e2 >= n2 && e2 <= r2, "start-date": e2.getTime() === n2.getTime(), "end-date": e2.getTime() === r2.getTime(), disabled: this.minDate && a2.getTime() < this.minDate.getTime() || this.maxDate && e2.getTime() > this.maxDate.getTime() };
            return this.dateFormat ? this.dateFormat(i2, t2) : i2;
          }, checkYear: function() {
            var t2 = this;
            this.$refs.yearSelect !== document.activeElement && this.$nextTick(function() {
              t2.year_text = t2.monthDate.getFullYear();
            });
          } }, computed: { monthName: function() {
            return this.locale.monthNames[this.currentMonthDate.getMonth()];
          }, year: { get: function() {
            return this.year_text;
          }, set: function(t2) {
            this.year_text = t2;
            var e2 = this.$dateUtil.validateDateRange(new Date(t2, this.month, 1), this.minDate, this.maxDate);
            this.$dateUtil.isValidDate(e2) && this.$emit("change-month", { month: e2.getMonth(), year: e2.getFullYear() });
          } }, month: { get: function() {
            return this.currentMonthDate.getMonth() + 1;
          }, set: function(t2) {
            var e2 = this.$dateUtil.validateDateRange(new Date(this.year, t2 - 1, 1), this.minDate, this.maxDate);
            this.$emit("change-month", { month: e2.getMonth() + 1, year: e2.getFullYear() });
          } }, calendar: function() {
            for (var t2 = this.month, e2 = this.currentMonthDate.getFullYear(), n2 = new Date(e2, t2 - 1, 1), r2 = this.$dateUtil.prevMonth(n2).getMonth() + 1, a2 = this.$dateUtil.prevMonth(n2).getFullYear(), i2 = new Date(a2, t2 - 1, 0).getDate(), o2 = n2.getDay(), s2 = [], c2 = 0; c2 < 6; c2++)
              s2[c2] = [];
            var u2 = i2 - o2 + this.locale.firstDay + 1;
            u2 > i2 && (u2 -= 7), o2 === this.locale.firstDay && (u2 = i2 - 6);
            for (var l2 = new Date(a2, r2 - 1, u2, 12, 0, 0), f2 = 0, d2 = 0, h2 = 0; f2 < 42; f2++, d2++, l2.setDate(l2.getDate() + 1))
              f2 > 0 && d2 % 7 === 0 && (d2 = 0, h2++), s2[h2][d2] = new Date(l2.getTime());
            return s2;
          }, months: function() {
            var t2 = this;
            return this.locale.monthNames.map(function(e2, n2) {
              return { label: e2, value: n2, enabled: (!t2.maxDate || t2.maxDate >= new Date(t2.year, n2, 1)) && (!t2.minDate || t2.minDate <= new Date(t2.year, n2 + 1, 0)) };
            });
          }, locale: function() {
            return this.$dateUtil.localeData(this.localeData);
          } }, watch: { monthDate: function(t2) {
            this.currentMonthDate.getTime() !== t2.getTime() && this.changeMonthDate(t2, false);
          } } }), v = g;
          n("9d0d");
          function y(t2, e2, n2, r2, a2, i2, o2, s2) {
            var c2, u2 = typeof t2 === "function" ? t2.options : t2;
            if (e2 && (u2.render = e2, u2.staticRenderFns = n2, u2._compiled = true), r2 && (u2.functional = true), i2 && (u2._scopeId = "data-v-" + i2), o2 ? (c2 = function(t3) {
              t3 = t3 || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, t3 || typeof __VUE_SSR_CONTEXT__ === "undefined" || (t3 = __VUE_SSR_CONTEXT__), a2 && a2.call(this, t3), t3 && t3._registeredComponents && t3._registeredComponents.add(o2);
            }, u2._ssrRegister = c2) : a2 && (c2 = s2 ? function() {
              a2.call(this, this.$root.$options.shadowRoot);
            } : a2), c2)
              if (u2.functional) {
                u2._injectStyles = c2;
                var l2 = u2.render;
                u2.render = function(t3, e3) {
                  return c2.call(e3), l2(t3, e3);
                };
              } else {
                var f2 = u2.beforeCreate;
                u2.beforeCreate = f2 ? [].concat(f2, c2) : [c2];
              }
            return { exports: t2, options: u2 };
          }
          var b = y(v, p, m, false, null, "98ac2448", null), D = b.exports, w = function() {
            var t2 = this, e2 = t2.$createElement, n2 = t2._self._c || e2;
            return n2("div", { staticClass: "calendar-time" }, [n2("select", { directives: [{ name: "model", rawName: "v-model", value: t2.hour, expression: "hour" }], staticClass: "hourselect form-control mr-1", attrs: { disabled: t2.readonly }, on: { change: function(e3) {
              var n3 = Array.prototype.filter.call(e3.target.options, function(t3) {
                return t3.selected;
              }).map(function(t3) {
                var e4 = "_value" in t3 ? t3._value : t3.value;
                return e4;
              });
              t2.hour = e3.target.multiple ? n3 : n3[0];
            } } }, t2._l(t2.hours, function(e3) {
              return n2("option", { key: e3, domProps: { value: e3 } }, [t2._v(t2._s(t2._f("formatNumber")(e3)))]);
            }), 0), t2._v(" :"), n2("select", { directives: [{ name: "model", rawName: "v-model", value: t2.minute, expression: "minute" }], staticClass: "minuteselect form-control ml-1", attrs: { disabled: t2.readonly }, on: { change: function(e3) {
              var n3 = Array.prototype.filter.call(e3.target.options, function(t3) {
                return t3.selected;
              }).map(function(t3) {
                var e4 = "_value" in t3 ? t3._value : t3.value;
                return e4;
              });
              t2.minute = e3.target.multiple ? n3 : n3[0];
            } } }, t2._l(t2.minutes, function(e3) {
              return n2("option", { key: e3, domProps: { value: e3 } }, [t2._v(t2._s(t2._f("formatNumber")(e3)))]);
            }), 0), t2.secondPicker ? [t2._v(" :"), n2("select", { directives: [{ name: "model", rawName: "v-model", value: t2.second, expression: "second" }], staticClass: "secondselect form-control ml-1", attrs: { disabled: t2.readonly }, on: { change: function(e3) {
              var n3 = Array.prototype.filter.call(e3.target.options, function(t3) {
                return t3.selected;
              }).map(function(t3) {
                var e4 = "_value" in t3 ? t3._value : t3.value;
                return e4;
              });
              t2.second = e3.target.multiple ? n3 : n3[0];
            } } }, t2._l(60, function(e3) {
              return n2("option", { key: e3 - 1, domProps: { value: e3 - 1 } }, [t2._v(t2._s(t2._f("formatNumber")(e3 - 1)))]);
            }), 0)] : t2._e(), t2.hour24 ? t2._e() : n2("select", { directives: [{ name: "model", rawName: "v-model", value: t2.ampm, expression: "ampm" }], staticClass: "ampmselect", attrs: { disabled: t2.readonly }, on: { change: function(e3) {
              var n3 = Array.prototype.filter.call(e3.target.options, function(t3) {
                return t3.selected;
              }).map(function(t3) {
                var e4 = "_value" in t3 ? t3._value : t3.value;
                return e4;
              });
              t2.ampm = e3.target.multiple ? n3 : n3[0];
            } } }, [n2("option", { attrs: { value: "AM" } }, [t2._v("AM")]), n2("option", { attrs: { value: "PM" } }, [t2._v("PM")])])], 2);
          }, x = [], S = { filters: { formatNumber: function(t2) {
            return t2 < 10 ? "0" + t2.toString() : t2.toString();
          } }, props: { miniuteIncrement: { type: Number, default: 5 }, hour24: { type: Boolean, default: true }, secondPicker: { type: Boolean, default: false }, currentTime: { default: function() {
            return new Date();
          } }, readonly: { type: Boolean, default: false } }, data: function() {
            var t2 = this.currentTime ? this.currentTime : new Date(), e2 = t2.getHours();
            return { hour: this.hour24 ? e2 : e2 % 12 || 12, minute: t2.getMinutes() - t2.getMinutes() % this.miniuteIncrement, second: t2.getSeconds(), ampm: e2 < 12 ? "AM" : "PM" };
          }, computed: { hours: function() {
            for (var t2 = [], e2 = this.hour24 ? 24 : 12, n2 = 0; n2 < e2; n2++)
              t2.push(this.hour24 ? n2 : n2 + 1);
            return t2;
          }, minutes: function() {
            for (var t2 = [], e2 = 60, n2 = 0; n2 < e2; n2 += this.miniuteIncrement)
              t2.push(n2);
            return t2;
          } }, watch: { hour: function() {
            this.onChange();
          }, minute: function() {
            this.onChange();
          }, second: function() {
            this.onChange();
          }, ampm: function() {
            this.onChange();
          } }, methods: { getHour: function() {
            return this.hour24 ? this.hour : this.hour === 12 ? this.ampm === "AM" ? 0 : 12 : this.hour + (this.ampm === "PM" ? 12 : 0);
          }, onChange: function() {
            this.$emit("update", { hours: this.getHour(), minutes: this.minute, seconds: this.second });
          } } }, M = S, k = y(M, w, x, false, null, null, null), _ = k.exports, O = function() {
            var t2 = this, e2 = t2.$createElement, n2 = t2._self._c || e2;
            return n2("div", { staticClass: "ranges" }, [t2.ranges ? n2("ul", [t2._l(t2.listedRanges, function(e3) {
              return n2("li", { key: e3.label, class: t2.range_class(e3), attrs: { "data-range-key": e3.label, tabindex: "0" }, on: { click: function(n3) {
                return t2.clickRange(e3.value);
              } } }, [t2._v(t2._s(e3.label) + " ")]);
            }), t2.showCustomRangeLabel ? n2("li", { class: { active: t2.customRangeActive || !t2.selectedRange }, attrs: { tabindex: "0" }, on: { click: t2.clickCustomRange } }, [t2._v(" " + t2._s(t2.localeData.customRangeLabel) + " ")]) : t2._e()], 2) : t2._e()]);
          }, T = [], C = { mixins: [h], props: { ranges: Object, selected: Object, localeData: Object, alwaysShowCalendars: Boolean }, data: function() {
            return { customRangeActive: false };
          }, methods: { clickRange: function(t2) {
            this.customRangeActive = false, this.$emit("click-range", t2);
          }, clickCustomRange: function() {
            this.customRangeActive = true, this.$emit("show-custom-range");
          }, range_class: function(t2) {
            return { active: t2.selected === true };
          } }, computed: { listedRanges: function() {
            var t2 = this;
            return !!this.ranges && Object.keys(this.ranges).map(function(e2) {
              return { label: e2, value: t2.ranges[e2], selected: t2.$dateUtil.isSame(t2.selected.startDate, t2.ranges[e2][0]) && t2.$dateUtil.isSame(t2.selected.endDate, t2.ranges[e2][1]) };
            });
          }, selectedRange: function() {
            return this.listedRanges.find(function(t2) {
              return t2.selected === true;
            });
          }, showCustomRangeLabel: function() {
            return !this.alwaysShowCalendars;
          } } }, P = C, j = y(P, O, T, false, null, null, null), A = j.exports, N = { inserted: function(t2, e2, n2) {
            var r2 = n2.context;
            if (r2.appendToBody) {
              var a2 = r2.$refs.toggle.getBoundingClientRect(), i2 = a2.height, o2 = a2.top, s2 = a2.left, c2 = a2.width, u2 = a2.right;
              t2.unbindPosition = r2.calculatePosition(t2, r2, { width: c2, top: window.scrollY + o2 + i2, left: window.scrollX + s2, right: u2 }), document.body.appendChild(t2);
            } else
              r2.$el.appendChild(t2);
          }, unbind: function(t2, e2, n2) {
            var r2 = n2.context;
            r2.appendToBody && (t2.unbindPosition && typeof t2.unbindPosition === "function" && t2.unbindPosition(), t2.parentNode && t2.parentNode.removeChild(t2));
          } };
          function R(t2, e2) {
            var n2 = Object.keys(t2);
            if (Object.getOwnPropertySymbols) {
              var r2 = Object.getOwnPropertySymbols(t2);
              e2 && (r2 = r2.filter(function(e3) {
                return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
              })), n2.push.apply(n2, r2);
            }
            return n2;
          }
          function $2(t2) {
            for (var e2 = 1; e2 < arguments.length; e2++) {
              var n2 = arguments[e2] != null ? arguments[e2] : {};
              e2 % 2 ? R(Object(n2), true).forEach(function(e3) {
                Object(f["a"])(t2, e3, n2[e3]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(n2)) : R(Object(n2)).forEach(function(e3) {
                Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(n2, e3));
              });
            }
            return t2;
          }
          var E = { inheritAttrs: false, components: { Calendar: D, CalendarTime: _, CalendarRanges: A }, mixins: [h], directives: { appendToBody: N }, model: { prop: "dateRange", event: "update" }, props: { minDate: { type: [String, Date], default: function() {
            return null;
          } }, maxDate: { type: [String, Date], default: function() {
            return null;
          } }, showWeekNumbers: { type: Boolean, default: false }, linkedCalendars: { type: Boolean, default: true }, singleDatePicker: { type: [Boolean, String], default: false }, showDropdowns: { type: Boolean, default: false }, timePicker: { type: Boolean, default: false }, timePickerIncrement: { type: Number, default: 5 }, timePicker24Hour: { type: Boolean, default: true }, timePickerSeconds: { type: Boolean, default: false }, autoApply: { type: Boolean, default: false }, localeData: { type: Object, default: function() {
            return {};
          } }, dateRange: { type: [Object], default: null, required: true }, ranges: { type: [Object, Boolean], default: function() {
            var t2 = new Date();
            t2.setHours(0, 0, 0, 0);
            var e2 = new Date();
            e2.setHours(11, 59, 59, 999);
            var n2 = new Date();
            n2.setDate(t2.getDate() - 1), n2.setHours(0, 0, 0, 0);
            var r2 = new Date();
            r2.setDate(t2.getDate() - 1), r2.setHours(11, 59, 59, 999);
            var a2 = new Date(t2.getFullYear(), t2.getMonth(), 1), i2 = new Date(t2.getFullYear(), t2.getMonth() + 1, 0, 11, 59, 59, 999);
            return { Today: [t2, e2], Yesterday: [n2, r2], "This month": [a2, i2], "This year": [new Date(t2.getFullYear(), 0, 1), new Date(t2.getFullYear(), 11, 31, 11, 59, 59, 999)], "Last month": [new Date(t2.getFullYear(), t2.getMonth() - 1, 1), new Date(t2.getFullYear(), t2.getMonth(), 0, 11, 59, 59, 999)] };
          } }, opens: { type: String, default: "center" }, dateFormat: Function, alwaysShowCalendars: { type: Boolean, default: true }, disabled: { type: Boolean, default: false }, controlContainerClass: { type: [Object, String], default: "form-control reportrange-text" }, appendToBody: { type: Boolean, default: false }, calculatePosition: { type: Function, default: function(t2, e2, n2) {
            var r2 = n2.width, a2 = n2.top, i2 = n2.left, o2 = n2.right;
            e2.opens === "center" ? t2.style.left = i2 + r2 / 2 + "px" : e2.opens === "left" ? t2.style.right = window.innerWidth - o2 + "px" : e2.opens === "right" && (t2.style.left = i2 + "px"), t2.style.top = a2 + "px";
          } }, closeOnEsc: { type: Boolean, default: true }, readonly: { type: Boolean } }, data: function() {
            var t2 = d(), e2 = { locale: t2.localeData($2({}, this.localeData)) }, n2 = this.dateRange.startDate || null, r2 = this.dateRange.endDate || null;
            if (e2.monthDate = n2 ? new Date(n2) : new Date(), e2.nextMonthDate = t2.nextMonth(e2.monthDate), e2.start = n2 ? new Date(n2) : null, this.singleDatePicker && this.singleDatePicker !== "range" ? e2.end = e2.start : e2.end = r2 ? new Date(r2) : null, e2.in_selection = false, e2.open = false, e2.showCustomRangeCalendars = false, e2.locale.firstDay !== 0) {
              var a2 = e2.locale.firstDay, i2 = l(e2.locale.daysOfWeek);
              while (a2 > 0)
                i2.push(i2.shift()), a2--;
              e2.locale.daysOfWeek = i2;
            }
            return e2;
          }, methods: { selectMonthDate: function() {
            var t2 = this.end || new Date();
            this.singleDatePicker !== false ? this.changeLeftMonth({ year: t2.getFullYear(), month: t2.getMonth() + 1 }) : this.changeRightMonth({ year: t2.getFullYear(), month: t2.getMonth() + 1 });
          }, dateFormatFn: function(t2, e2) {
            var n2 = new Date(e2);
            n2.setHours(0, 0, 0, 0);
            var r2 = new Date(this.start);
            r2.setHours(0, 0, 0, 0);
            var a2 = new Date(this.end);
            return a2.setHours(0, 0, 0, 0), t2["in-range"] = n2 >= r2 && n2 <= a2, this.dateFormat ? this.dateFormat(t2, e2) : t2;
          }, changeLeftMonth: function(t2) {
            var e2 = new Date(t2.year, t2.month - 1, 1);
            this.monthDate = e2, (this.linkedCalendars || this.$dateUtil.yearMonth(this.monthDate) >= this.$dateUtil.yearMonth(this.nextMonthDate)) && (this.nextMonthDate = this.$dateUtil.validateDateRange(this.$dateUtil.nextMonth(e2), this.minDate, this.maxDate), this.singleDatePicker || this.$dateUtil.yearMonth(this.monthDate) !== this.$dateUtil.yearMonth(this.nextMonthDate) || (this.monthDate = this.$dateUtil.validateDateRange(this.$dateUtil.prevMonth(this.monthDate), this.minDate, this.maxDate))), this.$emit("change-month", this.monthDate, 0);
          }, changeRightMonth: function(t2) {
            var e2 = new Date(t2.year, t2.month - 1, 1);
            this.nextMonthDate = e2, (this.linkedCalendars || this.$dateUtil.yearMonth(this.nextMonthDate) <= this.$dateUtil.yearMonth(this.monthDate)) && (this.monthDate = this.$dateUtil.validateDateRange(this.$dateUtil.prevMonth(e2), this.minDate, this.maxDate), this.$dateUtil.yearMonth(this.monthDate) === this.$dateUtil.yearMonth(this.nextMonthDate) && (this.nextMonthDate = this.$dateUtil.validateDateRange(this.$dateUtil.nextMonth(this.nextMonthDate), this.minDate, this.maxDate))), this.$dateUtil.yearMonth(this.monthDate) === this.$dateUtil.yearMonth(this.nextMonthDate) && (this.nextMonthDate = this.$dateUtil.nextMonth(this.nextMonthDate)), this.$emit("change-month", this.nextMonthDate, 1);
          }, normalizeDatetime: function(t2, e2) {
            var n2 = new Date(t2);
            return this.timePicker && e2 && (n2.setHours(e2.getHours()), n2.setMinutes(e2.getMinutes()), n2.setSeconds(e2.getSeconds()), n2.setMilliseconds(e2.getMilliseconds())), n2;
          }, dateClick: function(t2) {
            if (this.readonly)
              return false;
            this.in_selection ? (this.in_selection = false, this.$emit("finish-selection", t2), this.onSelect(), this.autoApply && this.clickedApply()) : (this.start = this.normalizeDatetime(t2, this.start), this.end = this.normalizeDatetime(t2, this.end), this.singleDatePicker && this.singleDatePicker !== "range" ? (this.onSelect(), this.autoApply && this.clickedApply()) : (this.in_selection = this.end, this.$emit("start-selection", this.start)));
          }, hoverDate: function(t2) {
            if (this.readonly)
              return false;
            var e2 = this.normalizeDatetime(t2, this.end), n2 = this.normalizeDatetime(t2, this.start);
            this.in_selection && (this.in_selection <= e2 && (this.end = e2), this.in_selection >= n2 && (this.start = n2)), this.$emit("hover-date", t2);
          }, onClickPicker: function() {
            this.disabled || this.togglePicker(null, true);
          }, togglePicker: function(t2, e2) {
            this.open = typeof t2 === "boolean" ? t2 : !this.open, e2 === true && this.$emit("toggle", this.open, this.togglePicker);
          }, clickedApply: function() {
            this.togglePicker(false, true), this.$emit("update", { startDate: this.start, endDate: this.singleDatePicker && this.singleDatePicker !== "range" ? this.start : this.end });
          }, clickCancel: function() {
            if (this.open) {
              var t2 = this.dateRange.startDate, e2 = this.dateRange.endDate;
              this.start = t2 ? new Date(t2) : null, this.end = e2 ? new Date(e2) : null, this.in_selection = false, this.togglePicker(false, true);
            }
          }, onSelect: function() {
            this.$emit("select", { startDate: this.start, endDate: this.end });
          }, clickAway: function(t2) {
            t2 && t2.target && !this.$el.contains(t2.target) && this.$refs.dropdown && !this.$refs.dropdown.contains(t2.target) && this.clickCancel();
          }, clickRange: function(t2) {
            this.in_selection = false, this.$dateUtil.isValidDate(t2[0]) && this.$dateUtil.isValidDate(t2[1]) ? (this.start = this.$dateUtil.validateDateRange(new Date(t2[0]), this.minDate, this.maxDate), this.end = this.$dateUtil.validateDateRange(new Date(t2[1]), this.minDate, this.maxDate), this.changeLeftMonth({ month: this.start.getMonth() + 1, year: this.start.getFullYear() }), this.linkedCalendars === false && this.changeRightMonth({ month: this.end.getMonth() + 1, year: this.end.getFullYear() })) : (this.start = null, this.end = null), this.onSelect(), this.autoApply && this.clickedApply();
          }, onUpdateStartTime: function(t2) {
            var e2 = new Date(this.start);
            e2.setHours(t2.hours), e2.setMinutes(t2.minutes), e2.setSeconds(t2.seconds), this.start = this.$dateUtil.validateDateRange(e2, this.minDate, this.maxDate), this.autoApply && this.$emit("update", { startDate: this.start, endDate: this.singleDatePicker && this.singleDatePicker !== "range" ? this.start : this.end });
          }, onUpdateEndTime: function(t2) {
            var e2 = new Date(this.end);
            e2.setHours(t2.hours), e2.setMinutes(t2.minutes), e2.setSeconds(t2.seconds), this.end = this.$dateUtil.validateDateRange(e2, this.minDate, this.maxDate), this.autoApply && this.$emit("update", { startDate: this.start, endDate: this.end });
          }, handleEscape: function(t2) {
            this.open && t2.keyCode === 27 && this.closeOnEsc && this.clickCancel();
          } }, computed: { showRanges: function() {
            return this.ranges !== false && !this.readonly;
          }, showCalendars: function() {
            return this.alwaysShowCalendars || this.showCustomRangeCalendars;
          }, startText: function() {
            return this.start === null ? "" : this.$dateUtil.format(this.start, this.locale.format);
          }, endText: function() {
            return this.end === null ? "" : this.$dateUtil.format(this.end, this.locale.format);
          }, rangeText: function() {
            var t2 = this.startText;
            return this.singleDatePicker && this.singleDatePicker !== "range" || (t2 += this.locale.separator + this.endText), t2;
          }, min: function() {
            return this.minDate ? new Date(this.minDate) : null;
          }, max: function() {
            return this.maxDate ? new Date(this.maxDate) : null;
          }, pickerStyles: function() {
            var t2;
            return t2 = { "show-calendar": this.open || this.opens === "inline", "show-ranges": this.showRanges, "show-weeknumbers": this.showWeekNumbers, single: this.singleDatePicker }, Object(f["a"])(t2, "opens" + this.opens, true), Object(f["a"])(t2, "linked", this.linkedCalendars), Object(f["a"])(t2, "hide-calendars", !this.showCalendars), t2;
          }, isClear: function() {
            return !this.dateRange.startDate || !this.dateRange.endDate;
          }, isDirty: function() {
            var t2 = new Date(this.dateRange.startDate), e2 = new Date(this.dateRange.endDate);
            return !this.isClear && (this.start.getTime() !== t2.getTime() || this.end.getTime() !== e2.getTime());
          } }, watch: { minDate: function() {
            this.selectMonthDate();
          }, maxDate: function() {
            this.selectMonthDate();
          }, "dateRange.startDate": function(t2) {
            this.$dateUtil.isValidDate(new Date(t2)) && (this.start = t2 && !this.isClear && this.$dateUtil.isValidDate(new Date(t2)) ? new Date(t2) : null, this.isClear ? (this.start = null, this.end = null) : (this.start = new Date(this.dateRange.startDate), this.end = new Date(this.dateRange.endDate)));
          }, "dateRange.endDate": function(t2) {
            this.$dateUtil.isValidDate(new Date(t2)) && (this.end = t2 && !this.isClear ? new Date(t2) : null, this.isClear ? (this.start = null, this.end = null) : (this.start = new Date(this.dateRange.startDate), this.end = new Date(this.dateRange.endDate)));
          }, open: { handler: function(t2) {
            var e2 = this;
            (typeof document === "undefined" ? "undefined" : Object(o["a"])(document)) === "object" && (this.selectMonthDate(), this.$nextTick(function() {
              t2 ? document.body.addEventListener("click", e2.clickAway) : document.body.removeEventListener("click", e2.clickAway), t2 ? document.addEventListener("keydown", e2.handleEscape) : document.removeEventListener("keydown", e2.handleEscape), !e2.alwaysShowCalendars && e2.ranges && (e2.showCustomRangeCalendars = !Object.keys(e2.ranges).find(function(t3) {
                return e2.$dateUtil.isSame(e2.start, e2.ranges[t3][0], "date") && e2.$dateUtil.isSame(e2.end, e2.ranges[t3][1], "date");
              }));
            }));
          }, immediate: true } } }, U = E, F = (n("0e58"), n("ce5f"), y(U, a, i, false, null, "1ebd09d2", null)), I = F.exports, L = I;
          e["default"] = L;
        }, fb6a: function(t, e, n) {
          "use strict";
          var r = n("23e7"), a = n("861d"), i = n("e8b5"), o = n("23cb"), s = n("50c4"), c = n("fc6a"), u = n("8418"), l = n("1dde"), f = n("b622"), d = f("species"), h = [].slice, p = Math.max;
          r({ target: "Array", proto: true, forced: !l("slice") }, { slice: function(t2, e2) {
            var n2, r2, l2, f2 = c(this), m = s(f2.length), g = o(t2, m), v = o(e2 === void 0 ? m : e2, m);
            if (i(f2) && (n2 = f2.constructor, typeof n2 != "function" || n2 !== Array && !i(n2.prototype) ? a(n2) && (n2 = n2[d], n2 === null && (n2 = void 0)) : n2 = void 0, n2 === Array || n2 === void 0))
              return h.call(f2, g, v);
            for (r2 = new (n2 === void 0 ? Array : n2)(p(v - g, 0)), l2 = 0; g < v; g++, l2++)
              g in f2 && u(r2, l2, f2[g]);
            return r2.length = l2, r2;
          } });
        }, fc6a: function(t, e, n) {
          var r = n("44ad"), a = n("1d80");
          t.exports = function(t2) {
            return r(a(t2));
          };
        }, fdbc: function(t, e) {
          t.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
        }, fdbf: function(t, e, n) {
          var r = n("4930");
          t.exports = r && !Symbol.sham && typeof Symbol() == "symbol";
        } });
      });
    }
  });

  // resource/js/components/sales/TableSales.vue
  var TableSales_exports = {};
  __export(TableSales_exports, {
    default: () => TableSales_default
  });
  function __vue_normalize__10(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\sales\\TableSales.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (true) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  function __vue_create_injector__2() {
    const styles = __vue_create_injector__2.styles || (__vue_create_injector__2.styles = {});
    const isOldIE = typeof navigator !== "undefined" && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]'))
        return;
      const group = isOldIE ? css.media || "default" : id;
      const style = styles[group] || (styles[group] = { ids: [], parts: [], element: void 0 });
      if (!style.ids.includes(id)) {
        let code = css.source;
        let index = style.ids.length;
        style.ids.push(id);
        if (false) {
          code += "\n/*# sourceURL=" + css.map.sources[0] + " */";
          code += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + " */";
        }
        if (isOldIE) {
          style.element = style.element || document.querySelector("style[data-group=" + group + "]");
        }
        if (!style.element) {
          const head = document.head || document.getElementsByTagName("head")[0];
          const el = style.element = document.createElement("style");
          el.type = "text/css";
          if (css.media)
            el.setAttribute("media", css.media);
          if (isOldIE) {
            el.setAttribute("data-group", group);
            el.setAttribute("data-next-index", "0");
          }
          head.appendChild(el);
        }
        if (isOldIE) {
          index = parseInt(style.element.getAttribute("data-next-index"));
          style.element.setAttribute("data-next-index", index + 1);
        }
        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join("\n");
        } else {
          const textNode = document.createTextNode(code);
          const nodes = style.element.childNodes;
          if (nodes[index])
            style.element.removeChild(nodes[index]);
          if (nodes.length)
            style.element.insertBefore(textNode, nodes[index]);
          else
            style.element.appendChild(textNode);
        }
      }
    };
  }
  var import_moment3, import_vue2_daterange_picker, __vue_script__11, __vue_render__11, __vue_staticRenderFns__11, __vue_inject_styles__11, __vue_scope_id__11, __vue_module_identifier__11, __vue_is_functional_template__11, __vue_component__10, TableSales_default;
  var init_TableSales = __esm({
    "resource/js/components/sales/TableSales.vue"() {
      import_moment3 = __toESM(require_moment());
      import_vue2_daterange_picker = __toESM(require_vue2_daterange_picker_umd_min());
      __vue_script__11 = {
        name: "sales-table",
        props: {
          sales: {
            type: String,
            required: true
          },
          csrf_token: {
            type: String,
            required: true
          },
          auth: {
            required: true
          }
        },
        components: {
          DateRangePicker: import_vue2_daterange_picker.default
        },
        data() {
          let last_week = (0, import_moment3.default)().subtract(1, "months").format("Y-MM-DD");
          let today = (0, import_moment3.default)().format("Y-MM-DD");
          return {
            u_search: "",
            salesParser: JSON.parse(this.sales),
            datatable: void 0,
            editB: false,
            dateRange: {
              startDate: last_week,
              endDate: today
            }
          };
        },
        filters: {
          date(val) {
            return val ? (0, import_moment3.default)(val).format("Y-MM-DD") : "";
          },
          formatTotal(val) {
            const formatter = new Intl.NumberFormat("en-US", {
              style: "currency",
              currency: "USD"
            });
            return formatter.format(val);
          }
        },
        computed: {
          authParse() {
            return !this.auth ? false : JSON.parse(this.auth);
          }
        },
        methods: {
          dataProducts(page = 2) {
            axios({
              method: "get",
              url: `/api/products/all/page/${page}`,
              data: {
                csrf_token: this.csrf_token
              }
            }).then((response) => {
              const { data: { products } } = response;
              if (!response.data.status) {
                this.getProduct = false;
                this.mutable_data = void 0;
              }
              if (this.getProduct) {
                this.mutable_data = response.data;
                products.map((value, index) => {
                  this.productsParser.push(value);
                });
              }
            }).then(() => {
              if (this.getProduct) {
                this.dataProducts(this.mutable_data.next_page);
              }
            });
          },
          mountedDatatable() {
            return this.datatable = $("#datatable-products").DataTable({
              responsive: true,
              destroy: true,
              lengthChange: false,
              autoWidth: false,
              rowReorder: {
                selector: "td:nth-child(2)"
              }
            });
          },
          mutateData(data2) {
            this.productsParser.push(data2);
            new Promise((res) => {
              this.datatable.destroy();
              res(true);
            }).then(() => {
              this.mountedDatatable();
            });
          },
          prodPic(image) {
            if (image) {
              return image;
            } else {
              return "/assets/images/products/boxed-bg.jpg";
            }
          },
          editData(data2) {
            const product = this.productsParser.find((u) => u.id === data2.id);
            product.sku = data2.sku;
            product.name = data2.name;
            product.description = data2.description;
            product.image = data2.image;
            product.stock = data2.stock;
            product.cost = data2.cost;
            product.price = data2.price;
          },
          deleteSale(id) {
            this.$swal.fire({
              title: "Are you sure?",
              text: "do you want to delete this sale?",
              icon: "warning",
              showCancelButton: true,
              confirmButtonColor: "#3085d6",
              cancelButtonColor: "#d33",
              confirmButtonText: "Yes, delete it!"
            }).then((result) => {
              if (result.isConfirmed) {
                axios({
                  method: "post",
                  url: `/sales/delete/${id}`,
                  data: {
                    csrf_token: this.csrf_token
                  }
                }).then((response) => {
                  const { data: { status } } = response;
                  if (status) {
                    this.$swal.fire("Deleted!", "the product was deleted.", "success");
                    this.salesParser.splice(this.salesParser.findIndex((u) => u.id === id), 1);
                  }
                });
              }
            });
          },
          formatDate(timestamp) {
            return (0, import_moment3.default)(timestamp).format("l, h:mm a");
          },
          formatInvoce(invoice) {
            let new_invoice = invoice.toString().substr(0, 2) + "-";
            return new_invoice = new_invoice + invoice.toString().substr(2, 4);
          },
          changeDateRange() {
            const start_time = (0, import_moment3.default)(this.dateRange.startDate).format("Y-MM-DD 00:00:00");
            const end_time = (0, import_moment3.default)(this.dateRange.endDate).format("Y-MM-DD 23:59:59");
            axios({
              method: "post",
              url: "/sales/ranges",
              data: {
                csrf_token: this.csrf_token,
                start_date: start_time,
                end_date: end_time
              }
            }).then((response) => {
              const { data: data2 } = response;
              this.salesParser = data2;
              new Promise((res) => {
                this.datatable.destroy();
                res(true);
              }).then(() => {
                this.mountedDatatable();
              });
            });
          }
        },
        mounted() {
          this.mountedDatatable();
        }
      };
      __vue_render__11 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", { staticClass: "card" }, [
          _vm._m(0),
          _vm._v(" "),
          _c("div", { staticClass: "card-body" }, [
            _c("div", { staticClass: "d-flex mb-2 align-items-center" }, [
              _vm._m(1),
              _vm._v(" "),
              _c("date-range-picker", {
                on: { update: _vm.changeDateRange },
                scopedSlots: _vm._u([
                  {
                    key: "input",
                    fn: function(picker) {
                      return [
                        _vm._v("\n        " + _vm._s(_vm._f("date")(picker.startDate)) + " - " + _vm._s(_vm._f("date")(picker.endDate)) + "\n      ")
                      ];
                    }
                  }
                ]),
                model: {
                  value: _vm.dateRange,
                  callback: function($$v) {
                    _vm.dateRange = $$v;
                  },
                  expression: "dateRange"
                }
              })
            ], 1),
            _vm._v(" "),
            _c("table", {
              staticClass: "table table-striped",
              attrs: { id: "datatable-products" }
            }, [
              _vm._m(2),
              _vm._v(" "),
              _c("tbody", _vm._l(_vm.salesParser, function(sale, index) {
                return _c("tr", { key: index }, [
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(index + 1))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(_vm.formatInvoce(sale.id_sale)))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(sale.customer.name))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(sale.seller.name))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(sale.method))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(_vm._f("formatTotal")(sale.total)))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(_vm.formatDate(sale.created_at)))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _c("div", [
                      _c("a", {
                        staticClass: "btn btn-info",
                        attrs: {
                          href: "/sales/print/invoice/" + sale.id,
                          target: "_blank"
                        }
                      }, [_c("i", { staticClass: "fa fa-print" })]),
                      _vm._v(" "),
                      _vm.authParse.id == 1 ? _c("a", {
                        staticClass: "btn btn-warning edit",
                        attrs: { href: "/sales/edit/" + sale.id }
                      }, [_c("i", { staticClass: "fa fa-pencil" })]) : _vm._e(),
                      _vm._v(" "),
                      _c("button", {
                        staticClass: "btn btn-danger delete",
                        on: {
                          click: function($event) {
                            return _vm.deleteSale(sale.id);
                          }
                        }
                      }, [_c("i", { staticClass: "fa fa-times" })])
                    ])
                  ])
                ]);
              }), 0)
            ])
          ])
        ]);
      };
      __vue_staticRenderFns__11 = [
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("div", { staticClass: "card-header" }, [
            _c("h3", { staticClass: "card-title" }, [_vm._v("List sales")])
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("div", { staticClass: "mr-3" }, [
            _c("span", [_vm._v("Select Range Sales:")])
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("thead", [
            _c("tr", [
              _c("th", { staticClass: "text-center" }, [_vm._v("#")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Invoice")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Customer")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Seller")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Method")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Total")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center" }, [_vm._v("Date")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center all" }, [_vm._v("Action")])
            ])
          ]);
        }
      ];
      __vue_render__11._withStripped = true;
      __vue_inject_styles__11 = function(inject2) {
        if (!inject2)
          return;
        inject2("data-v-507ce139_0", { source: "\n.reportrange-text{\n  background-color: #f2f2f2 !important;\n}\n", map: { "version": 3, "sources": ["resource\\js\\components\\sales\\TableSales.vue"], "names": [], "mappings": ";AAiPA;EACA,oCAAA;AACA", "file": "TableSales.vue", "sourcesContent": [`<template>\r
  <div class="card">\r
    <div class="card-header">\r
      <h3 class="card-title">List sales</h3>\r
    </div>\r
    <div class="card-body">\r
      <div class="d-flex mb-2 align-items-center">\r
        <div class="mr-3">\r
          <span>Select Range Sales:</span>\r
        </div>\r
        <date-range-picker\r
        v-model="dateRange"\r
        @update="changeDateRange"\r
        >\r
        <template #input="picker" style="min-width: 350px;">\r
          {{ picker.startDate | date }} - {{ picker.endDate | date }}\r
        </template>\r
      </date-range-picker>\r
      </div>\r
      <table class="table table-striped" id="datatable-products">\r
        <thead>\r
          <tr>\r
            <th class="text-center">#</th>\r
            <th class="text-center">Invoice</th>\r
            <th class="text-center">Customer</th>\r
            <th class="text-center">Seller</th>\r
            <th class="text-center">Method</th>\r
            <th class="text-center">Total</th>\r
            <th class="text-center">Date</th>\r
            <th class="text-center all">Action</th>\r
          </tr>\r
        </thead>\r
        <tbody>\r
          <tr v-for="(sale, index) in salesParser" :key="index">\r
            <td class="text-center align-middle">{{ index + 1}}</td>\r
            <td class="text-center align-middle">{{ formatInvoce(sale.id_sale) }}</td>\r
            <td class="text-center align-middle">{{ sale.customer.name }}</td>\r
            <td class="text-center align-middle">{{ sale.seller.name }}</td>\r
            <td class="text-center align-middle">{{ sale.method }}</td>\r
            <td class="text-center align-middle">{{ sale.total | formatTotal }}</td>\r
            <td class="text-center align-middle">{{ formatDate(sale.created_at) }}</td>\r
            <td class="text-center align-middle">\r
                <div>\r
                    <a :href="\`/sales/print/invoice/\${sale.id}\`" target="_blank" class="btn btn-info"><i class="fa fa-print"></i></a>\r
                    <a :href="\`/sales/edit/\${sale.id}\`" class="btn btn-warning edit" v-if="authParse.id == 1"><i class="fa fa-pencil"></i></a>\r
                    <button class="btn btn-danger delete" @click="deleteSale(sale.id)"><i class="fa fa-times"></i></button>\r
                </div>\r
            </td>\r
          </tr>\r
        </tbody>\r
      </table>\r
    </div>\r
  </div>\r
</template>\r
<script>\r
import moment from 'moment';\r
import DateRangePicker from 'vue2-daterange-picker'\r
export default {\r
    name: 'sales-table',\r
    props: {\r
        sales: {\r
            type: String,\r
            required: true\r
        },\r
        csrf_token: {\r
          type: String,\r
          required: true\r
        },\r
        auth:{\r
          required: true\r
        }\r
    },\r
    components:{\r
      DateRangePicker\r
    },\r
    data(){\r
      let last_week = moment().subtract(1, 'months').format('Y-MM-DD');\r
      let today = moment().format('Y-MM-DD');\r
      return {\r
          u_search: '',\r
          salesParser: JSON.parse(this.sales),\r
          datatable: undefined,\r
          editB: false,\r
          dateRange: {\r
            startDate: last_week,\r
            endDate: today,\r
          }\r
      }\r
    },\r
    filters:{\r
      date (val) {\r
        return val ? moment(val).format('Y-MM-DD') : ''\r
      },\r
      formatTotal(val){\r
        const formatter = new Intl.NumberFormat('en-US', {\r
          style: 'currency',\r
          currency: 'USD',\r
        });\r
        return formatter.format(val);\r
      }\r
    },\r
    computed:{\r
      authParse(){\r
        return !this.auth ? false : JSON.parse(this.auth);\r
      }\r
    },\r
    methods:{\r
      dataProducts(page=2){\r
           axios({\r
             method:'get',\r
             url: \`/api/products/all/page/\${page}\`,\r
             data: {\r
               csrf_token: this.csrf_token,\r
             }\r
           }).then(response => {\r
              const { data: { products } } = response;\r
              if(!response.data.status){\r
                this.getProduct = false;\r
                this.mutable_data = undefined;\r
              }\r
              if(this.getProduct){\r
                this.mutable_data = response.data; \r
                products.map((value, index) => {\r
                  this.productsParser.push(value);\r
               });\r
              }\r
           }).then(() =>{\r
             if(this.getProduct){\r
               this.dataProducts(this.mutable_data.next_page);\r
             }\r
           })\r
        },\r
        mountedDatatable(){\r
          return this.datatable = $('#datatable-products').DataTable({\r
                                          responsive: true,\r
                                          destroy: true,\r
                                          lengthChange: false, \r
                                          autoWidth: false,\r
                                          rowReorder: {\r
                                              selector: 'td:nth-child(2)'\r
                                        }\r
                  \r
          });\r
        },\r
        mutateData(data){\r
          this.productsParser.push(data);\r
          new Promise(res =>{\r
            this.datatable.destroy();\r
            res(true);\r
          }).then( () =>{\r
              this.mountedDatatable();\r
          })\r
        },\r
        prodPic(image){\r
          if(image){\r
            return image;\r
          }else{\r
            return '/assets/images/products/boxed-bg.jpg';\r
          }\r
        },\r
        editData(data){\r
          const product = this.productsParser.find(u => u.id === data.id);\r
          product.sku = data.sku;\r
          product.name = data.name;\r
          product.description = data.description;\r
          product.image = data.image;\r
          product.stock = data.stock;\r
          product.cost = data.cost;\r
          product.price = data.price;\r
        },\r
        deleteSale(id){\r
          this.$swal.fire({\r
            title: 'Are you sure?',\r
            text: "do you want to delete this sale?",\r
            icon: 'warning',\r
            showCancelButton: true,\r
            confirmButtonColor: '#3085d6',\r
            cancelButtonColor: '#d33',\r
            confirmButtonText: 'Yes, delete it!'\r
          }).then((result) => {\r
            if (result.isConfirmed) {\r
              //ajax request delete\r
              axios({\r
                method:'post',\r
                url: \`/sales/delete/\${id}\`,\r
                data: {\r
                  csrf_token: this.csrf_token\r
                }\r
              }).then(response =>{\r
                  const { data: { status } } = response;\r
                  if(status){\r
                    this.$swal.fire(\r
                      'Deleted!',\r
                      'the product was deleted.',\r
                      'success'\r
                    )\r
                    //remove user in dom\r
                    this.salesParser.splice(this.salesParser.findIndex(u => u.id === id), 1);\r
                  }\r
              });\r
            }\r
          })\r
        },\r
        formatDate(timestamp){\r
          return moment(timestamp).format('l, h:mm a');\r
        },\r
        formatInvoce(invoice){\r
          let new_invoice = invoice.toString().substr(0, 2) + '-';\r
          return new_invoice = new_invoice + invoice.toString().substr(2, 4);\r
        },\r
        changeDateRange(){\r
          const start_time = moment(this.dateRange.startDate).format('Y-MM-DD 00:00:00')\r
          const end_time = moment(this.dateRange.endDate).format('Y-MM-DD 23:59:59');\r
          axios({\r
            method:'post',\r
            url: '/sales/ranges',\r
            data: {\r
              csrf_token: this.csrf_token,\r
              start_date: start_time,\r
              end_date: end_time\r
            }\r
          }).then(response =>{\r
            const { data } = response;\r
            this.salesParser = data;\r
            new Promise(res =>{\r
              this.datatable.destroy();\r
              res(true)\r
            }).then(() =>{\r
              this.mountedDatatable();\r
            })\r
\r
          })\r
        }\r
    },\r
    mounted(){\r
      this.mountedDatatable();\r
    }\r
    \r
};\r
<\/script>\r
<style>\r
  .reportrange-text{\r
    background-color: #f2f2f2 !important;\r
  }\r
</style>`] }, media: void 0 });
      };
      __vue_scope_id__11 = void 0;
      __vue_module_identifier__11 = void 0;
      __vue_is_functional_template__11 = false;
      __vue_component__10 = /* @__PURE__ */ __vue_normalize__10({ render: __vue_render__11, staticRenderFns: __vue_staticRenderFns__11 }, __vue_inject_styles__11, __vue_script__11, __vue_scope_id__11, __vue_is_functional_template__11, __vue_module_identifier__11, false, __vue_create_injector__2, void 0, void 0);
      TableSales_default = __vue_component__10;
    }
  });

  // resource/js/components/EventBus.js
  var import_vue2, EventBus;
  var init_EventBus = __esm({
    "resource/js/components/EventBus.js"() {
      import_vue2 = __toESM(require_vue());
      EventBus = new import_vue2.default();
    }
  });

  // resource/js/components/sales/CardAddProduct.vue
  var CardAddProduct_exports = {};
  __export(CardAddProduct_exports, {
    default: () => CardAddProduct_default
  });
  function __vue_normalize__11(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\sales\\CardAddProduct.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var __vue_script__12, __vue_render__12, __vue_staticRenderFns__12, __vue_inject_styles__12, __vue_scope_id__12, __vue_module_identifier__12, __vue_is_functional_template__12, __vue_component__11, CardAddProduct_default;
  var init_CardAddProduct = __esm({
    "resource/js/components/sales/CardAddProduct.vue"() {
      init_EventBus();
      __vue_script__12 = {
        name: "table-add-product",
        props: {
          products: {
            required: true
          },
          id_table: {
            type: String,
            default: "table-products"
          },
          modal: {
            type: Boolean,
            default: false
          }
        },
        data() {
          return {
            productsParse: JSON.parse(this.products),
            datatable: void 0
          };
        },
        methods: {
          handleAdd(event, id) {
            event.target.disabled = true;
            const product = this.productsParse.find((p) => p.id == id);
            EventBus.$emit("add", product);
          },
          handleRemove(id) {
            const button = this.$refs["b-prod-" + id][0];
            button.disabled = false;
          },
          addProductResponsive(data2) {
            this.productsParse = data2;
            new Promise((res) => {
              this.datatable.destroy();
              res(true);
            }).then(() => {
              this.mountedDatatable();
            });
          },
          mountedDatatable() {
            return this.datatable = $(`#${this.id_table}`).DataTable({
              responsive: true,
              destroy: true,
              lengthChange: false,
              autoWidth: false,
              rowReorder: {
                selector: "td:nth-child(2)"
              }
            });
          }
        },
        mounted() {
          this.mountedDatatable();
          EventBus.$on("remove", (data2) => this.handleRemove(data2));
          if (!this.modal) {
            EventBus.$emit("products", this.productsParse);
          }
        }
      };
      __vue_render__12 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", { staticClass: "card border-0 border-top border-4 border-warning" }, [
          _c("div", { staticClass: "card-title" }),
          _vm._v(" "),
          _c("div", { staticClass: "card-body" }, [
            _c("table", {
              staticClass: "table table-striped table-bordered",
              attrs: { id: _vm.id_table }
            }, [
              _vm._m(0),
              _vm._v(" "),
              _c("tbody", _vm._l(_vm.productsParse, function(product, index) {
                return _c("tr", { key: index }, [
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(index + 1))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(product.sku))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(product.name))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(product.description))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _c("button", {
                      staticClass: "btn btn-sm",
                      class: [
                        product.stock >= 10 && "bg-success",
                        product.stock < 10 && "btn-warning",
                        product.stock == 0 && "btn-danger"
                      ],
                      attrs: { type: "button" }
                    }, [_vm._v(_vm._s(product.stock))])
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _vm._v(_vm._s(product.price))
                  ]),
                  _vm._v(" "),
                  _c("td", { staticClass: "text-center align-middle" }, [
                    _c("div", { staticClass: "btn-group" }, [
                      _c("button", {
                        ref: "b-prod-" + product.id,
                        refInFor: true,
                        staticClass: "btn btn-success",
                        attrs: {
                          type: "button",
                          disabled: product.stock == 0 && "disabled"
                        },
                        on: {
                          click: function($event) {
                            return _vm.handleAdd($event, product.id);
                          }
                        }
                      }, [_vm._v("Add")])
                    ])
                  ])
                ]);
              }), 0)
            ])
          ])
        ]);
      };
      __vue_staticRenderFns__12 = [
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("thead", [
            _c("tr", [
              _c("th", { staticClass: "text-center all" }, [_vm._v("#")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center all" }, [_vm._v("SKU")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center all" }, [_vm._v("Name")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center desktop" }, [
                _vm._v("Description")
              ]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center desktop" }, [_vm._v("Stock")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center desktop" }, [_vm._v("Price")]),
              _vm._v(" "),
              _c("th", { staticClass: "text-center all" }, [_vm._v("Action")])
            ])
          ]);
        }
      ];
      __vue_render__12._withStripped = true;
      __vue_inject_styles__12 = void 0;
      __vue_scope_id__12 = void 0;
      __vue_module_identifier__12 = void 0;
      __vue_is_functional_template__12 = false;
      __vue_component__11 = /* @__PURE__ */ __vue_normalize__11({ render: __vue_render__12, staticRenderFns: __vue_staticRenderFns__12 }, __vue_inject_styles__12, __vue_script__12, __vue_scope_id__12, __vue_is_functional_template__12, __vue_module_identifier__12, false, void 0, void 0, void 0);
      CardAddProduct_default = __vue_component__11;
    }
  });

  // resource/js/components/sales/CardCreateSale.vue
  var CardCreateSale_exports = {};
  __export(CardCreateSale_exports, {
    default: () => CardCreateSale_default
  });
  function __vue_normalize__12(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\sales\\CardCreateSale.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (true) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  function __vue_create_injector__3() {
    const styles = __vue_create_injector__3.styles || (__vue_create_injector__3.styles = {});
    const isOldIE = typeof navigator !== "undefined" && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]'))
        return;
      const group = isOldIE ? css.media || "default" : id;
      const style = styles[group] || (styles[group] = { ids: [], parts: [], element: void 0 });
      if (!style.ids.includes(id)) {
        let code = css.source;
        let index = style.ids.length;
        style.ids.push(id);
        if (false) {
          code += "\n/*# sourceURL=" + css.map.sources[0] + " */";
          code += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + " */";
        }
        if (isOldIE) {
          style.element = style.element || document.querySelector("style[data-group=" + group + "]");
        }
        if (!style.element) {
          const head = document.head || document.getElementsByTagName("head")[0];
          const el = style.element = document.createElement("style");
          el.type = "text/css";
          if (css.media)
            el.setAttribute("media", css.media);
          if (isOldIE) {
            el.setAttribute("data-group", group);
            el.setAttribute("data-next-index", "0");
          }
          head.appendChild(el);
        }
        if (isOldIE) {
          index = parseInt(style.element.getAttribute("data-next-index"));
          style.element.setAttribute("data-next-index", index + 1);
        }
        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join("\n");
        } else {
          const textNode = document.createTextNode(code);
          const nodes = style.element.childNodes;
          if (nodes[index])
            style.element.removeChild(nodes[index]);
          if (nodes.length)
            style.element.insertBefore(textNode, nodes[index]);
          else
            style.element.appendChild(textNode);
        }
      }
    };
  }
  var import_numeral, __vue_script__13, __vue_render__13, __vue_staticRenderFns__13, __vue_inject_styles__13, __vue_scope_id__13, __vue_module_identifier__13, __vue_is_functional_template__13, __vue_component__12, CardCreateSale_default;
  var init_CardCreateSale = __esm({
    "resource/js/components/sales/CardCreateSale.vue"() {
      init_EventBus();
      init_ModalCustomers();
      init_esm2();
      init_CardAddProduct();
      import_numeral = __toESM(require_numeral());
      __vue_script__13 = {
        name: "card-create-sale",
        props: {
          auth: {
            required: true
          },
          customers: {
            required: true
          },
          id_sale: {
            required: true
          },
          csrf_token: {
            required: true
          },
          edit: {
            default: false
          },
          _sale: {
            default: void 0
          }
        },
        components: {
          ModalCustomer: ModalCustomers_default,
          "imask-input": component,
          ModalAddProduct: CardAddProduct_default
        },
        data() {
          return {
            authParser: JSON.parse(this.auth),
            customersParser: JSON.parse(this.customers),
            sale: {
              customer: "",
              method: "",
              products: [],
              tax: 0,
              total: 0,
              net: 0,
              id_transaction: ""
            },
            select2: {
              options: []
            }
          };
        },
        computed: {
          verifyMethod() {
            return this.sale.method !== "cash" && this.sale.method !== "";
          },
          SellOrEdit() {
            return this.edit ? "Edit Sale" : "Sell";
          }
        },
        methods: {
          mutateDataCustomer(data2) {
            this.customersParser.push(data2);
            this.select2.options.push({ label: data2.name, code: data2.id });
            this.sale.customer = { label: data2.name, code: data2.id };
          },
          addProductSale(product) {
            product.quantity = 1;
            this.sale.products.push(product);
            this.totalize();
          },
          removeProductSale(id) {
            this.sale.products = this.sale.products.filter((product) => {
              return product.id != id;
            });
            this.totalize();
            EventBus.$emit("remove", id);
          },
          totalize() {
            let total = 0;
            this.sale.products.map((product) => {
              total = total + product.price * product.quantity;
            });
            if (this.sale.tax > 0) {
              this.sale.net = (0, import_numeral.default)(total).format("0,0.00");
              this.sale.total = (0, import_numeral.default)(total * this.sale.tax / 100 + total).format("0,0.00");
            } else {
              this.sale.net = (0, import_numeral.default)(total).format("0,0.00");
              this.sale.total = (0, import_numeral.default)(total).format("0,0.00");
            }
          },
          modifyQuantity(id, event) {
            if (event.target.value > 0) {
              const product = this.sale.products.find((p) => p.id == id);
              product.quantity = parseInt(event.target.value);
              this.totalize();
            }
          },
          numberFormat(price) {
            return (0, import_numeral.default)(price).format("0,0.00");
          },
          sell() {
            if (this.sale.products.length > 0) {
              this.$swal.fire({
                title: "Are you sure to make this sale?",
                text: "Are all the data correct?",
                icon: "warning",
                showCancelButton: true,
                confirmButtonColor: "#3085d6",
                cancelButtonColor: "#d33",
                confirmButtonText: "Yes, sell..."
              }).then((result) => {
                if (result.isConfirmed) {
                  if (this.edit) {
                    axios({
                      method: "post",
                      url: `/sales/edit/${this._sale.id}`,
                      data: {
                        csrf_token: this.csrf_token,
                        id_sale: this.id_sale,
                        user_id: this.authParser.id,
                        customer_id: this.sale.customer.code,
                        tax: this.sale.tax,
                        net: this.sale.net,
                        total: this.sale.total,
                        method: this.sale.method,
                        id_transaction: this.sale.id_transaction,
                        products: JSON.stringify(this.sale.products)
                      }
                    }).then((response) => {
                      const { data: { status, response: resp } } = response;
                      if (status) {
                        this.$swal.fire("Success!", "Your sale has been registered.", "success").then(() => {
                          location.href = "/sales";
                        });
                      } else {
                        this.$swal.fire({
                          icon: "error",
                          title: "Oops...",
                          text: "there was a problem saving this sale"
                        });
                      }
                    });
                  } else {
                    axios({
                      method: "post",
                      url: "/sales/sell",
                      data: {
                        csrf_token: this.csrf_token,
                        id_sale: this.id_sale,
                        user_id: this.authParser.id,
                        customer_id: this.sale.customer.code,
                        tax: this.sale.tax,
                        net: this.sale.net,
                        total: this.sale.total,
                        method: this.sale.method,
                        id_transaction: this.sale.id_transaction,
                        products: JSON.stringify(this.sale.products)
                      }
                    }).then((response) => {
                      const { data: { status, response: resp } } = response;
                      if (status) {
                        this.$swal.fire("Success!", "Your sale has been registered.", "success").then(() => {
                          location.href = "/sales";
                        });
                      } else {
                        this.$swal.fire({
                          icon: "error",
                          title: "Oops...",
                          text: "there was a problem saving this sale"
                        });
                      }
                    });
                  }
                }
              });
            } else {
              this.$swal.fire({
                icon: "error",
                title: "Oops...",
                text: "You cannot sell if you have no products added.!"
              });
            }
          },
          formatInvoce(invoice) {
            let new_invoice = invoice.toString().substr(0, 2) + "-";
            return new_invoice = new_invoice + invoice.toString().substr(2, 4);
          },
          quantityFormat(product) {
            return product?.pivot ? product.pivot.quantity.toString() : "1";
          }
        },
        mounted() {
          this.customersParser.map((customer) => {
            this.select2.options.push({ label: customer.name, code: customer.id });
          });
          EventBus.$on("add", (product) => this.addProductSale(product));
          EventBus.$on("products", (data2) => {
            this.$refs.add_product_responsive.addProductResponsive(data2);
          });
          if (this.edit) {
            this.sale.customer = { label: this._sale.customer.name, code: this._sale.customer.id };
            this.sale.method = this._sale.method;
            this.sale.products = this._sale.products;
            this.sale.tax = this._sale.tax;
            this.sale.total = this._sale.total;
            this.sale.net = this._sale.net;
            this.sale.id_transaction = this._sale.id_transaction;
            this.authParser = this._sale.seller;
          }
        }
      };
      __vue_render__13 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", { staticClass: "card border-0 border-top border-4 border-success" }, [
          _c("div", { staticClass: "card-title" }),
          _vm._v(" "),
          _c("form", {
            attrs: { role: "form", method: "post", autocomplete: "off" },
            on: {
              submit: function($event) {
                $event.preventDefault();
                return _vm.sell.apply(null, arguments);
              }
            }
          }, [
            _c("div", { staticClass: "card-body" }, [
              _c("div", { staticClass: "form-group" }, [
                _c("div", { staticClass: "input-group" }, [
                  _vm._m(0),
                  _vm._v(" "),
                  _c("input", {
                    staticClass: "form-control",
                    attrs: { type: "text", name: "seller", readonly: "" },
                    domProps: { value: _vm.authParser.name }
                  })
                ])
              ]),
              _vm._v(" "),
              _c("div", { staticClass: "form-group" }, [
                _c("div", { staticClass: "input-group" }, [
                  _vm._m(1),
                  _vm._v(" "),
                  _c("input", {
                    staticClass: "form-control",
                    attrs: { type: "text", name: "sale", readonly: "" },
                    domProps: { value: _vm.formatInvoce(_vm.id_sale) }
                  })
                ])
              ]),
              _vm._v(" "),
              _c("div", { staticClass: "form-group" }, [
                _c("div", { staticClass: "input-group" }, [
                  _c("v-select", {
                    attrs: {
                      options: _vm.select2.options,
                      placeholder: "Select Customer"
                    },
                    scopedSlots: _vm._u([
                      {
                        key: "search",
                        fn: function(ref2) {
                          var attributes = ref2.attributes;
                          var events = ref2.events;
                          return [
                            _c("input", _vm._g(_vm._b({
                              staticClass: "vs__search",
                              attrs: { required: !_vm.sale.customer }
                            }, "input", attributes, false), events))
                          ];
                        }
                      }
                    ]),
                    model: {
                      value: _vm.sale.customer,
                      callback: function($$v) {
                        _vm.$set(_vm.sale, "customer", $$v);
                      },
                      expression: "sale.customer"
                    }
                  }),
                  _vm._v(" "),
                  _c("button", {
                    staticClass: "btn btn-success btn-sm",
                    attrs: {
                      type: "button",
                      id: "modal-customer-button",
                      "data-bs-toggle": "modal",
                      "data-bs-target": "#create-modal-customer"
                    }
                  }, [_vm._v("Add client\n                    ")])
                ], 1)
              ]),
              _vm._v(" "),
              _vm._l(_vm.sale.products, function(product, index) {
                return _c("div", { key: index, staticClass: "form-group row" }, [
                  _c("div", { staticClass: "col-6" }, [
                    _c("div", { staticClass: "input-group " }, [
                      _c("button", {
                        staticClass: "btn btn-danger btn-sm",
                        attrs: { type: "button" },
                        on: {
                          click: function($event) {
                            return _vm.removeProductSale(product.id);
                          }
                        }
                      }, [_c("i", { staticClass: "fa fa-times" })]),
                      _vm._v(" "),
                      _c("input", {
                        staticClass: "form-control",
                        attrs: {
                          type: "text",
                          name: "product",
                          placeholder: "Product",
                          required: "",
                          readonly: ""
                        },
                        domProps: { value: product.name }
                      })
                    ])
                  ]),
                  _vm._v(" "),
                  _c("div", { staticClass: "col-3" }, [
                    _c("imask-input", {
                      staticClass: "form-control",
                      attrs: {
                        required: "",
                        name: "quantity_product",
                        mask: Number,
                        min: 1,
                        type: "number",
                        max: product.stock,
                        value: _vm.quantityFormat(product)
                      },
                      on: {
                        change: function($event) {
                          return _vm.modifyQuantity(product.id, $event);
                        }
                      }
                    })
                  ], 1),
                  _vm._v(" "),
                  _c("div", { staticClass: "col-3 px-0 px-md-3" }, [
                    _c("div", { staticClass: "input-group" }, [
                      _vm._m(2, true),
                      _vm._v(" "),
                      _c("input", {
                        staticClass: "form-control",
                        attrs: {
                          type: "text",
                          name: "price",
                          placeholder: "10$",
                          readonly: "",
                          required: ""
                        },
                        domProps: { value: _vm.numberFormat(product.price) }
                      })
                    ])
                  ])
                ]);
              }),
              _vm._v(" "),
              _vm._m(3),
              _vm._v(" "),
              _c("div", { staticClass: "border-top mt-3 row justify-content-end" }, [
                _c("div", { staticClass: "col-sm-8" }, [
                  _c("table", { staticClass: "table table-light" }, [
                    _vm._m(4),
                    _vm._v(" "),
                    _c("tbody", [
                      _c("tr", [
                        _c("td", [
                          _c("div", { staticClass: "input-group" }, [
                            _c("input", {
                              directives: [
                                {
                                  name: "model",
                                  rawName: "v-model",
                                  value: _vm.sale.tax,
                                  expression: "sale.tax"
                                }
                              ],
                              staticClass: "form-control",
                              attrs: {
                                type: "number",
                                name: "tax",
                                min: "0",
                                autocomplete: "off",
                                placeholder: "0",
                                required: ""
                              },
                              domProps: { value: _vm.sale.tax },
                              on: {
                                change: _vm.totalize,
                                input: function($event) {
                                  if ($event.target.composing) {
                                    return;
                                  }
                                  _vm.$set(_vm.sale, "tax", $event.target.value);
                                }
                              }
                            }),
                            _vm._v(" "),
                            _vm._m(5)
                          ])
                        ]),
                        _vm._v(" "),
                        _c("td", [
                          _c("div", { staticClass: "input-group" }, [
                            _c("input", {
                              directives: [
                                {
                                  name: "model",
                                  rawName: "v-model",
                                  value: _vm.sale.net,
                                  expression: "sale.net"
                                }
                              ],
                              staticClass: "form-control",
                              attrs: {
                                type: "text",
                                name: "net",
                                min: "0",
                                autocomplete: "off",
                                placeholder: "0",
                                required: "",
                                readonly: ""
                              },
                              domProps: { value: _vm.sale.net },
                              on: {
                                input: function($event) {
                                  if ($event.target.composing) {
                                    return;
                                  }
                                  _vm.$set(_vm.sale, "net", $event.target.value);
                                }
                              }
                            }),
                            _vm._v(" "),
                            _vm._m(6)
                          ])
                        ]),
                        _vm._v(" "),
                        _c("td", [
                          _c("div", { staticClass: "input-group" }, [
                            _vm._m(7),
                            _vm._v(" "),
                            _c("input", {
                              directives: [
                                {
                                  name: "model",
                                  rawName: "v-model",
                                  value: _vm.sale.total,
                                  expression: "sale.total"
                                }
                              ],
                              staticClass: "form-control",
                              attrs: {
                                type: "text",
                                name: "total_sale",
                                min: "1",
                                autocomplete: "off",
                                placeholder: "0.00",
                                readonly: "",
                                required: ""
                              },
                              domProps: { value: _vm.sale.total },
                              on: {
                                input: function($event) {
                                  if ($event.target.composing) {
                                    return;
                                  }
                                  _vm.$set(_vm.sale, "total", $event.target.value);
                                }
                              }
                            })
                          ])
                        ])
                      ])
                    ])
                  ])
                ])
              ]),
              _vm._v(" "),
              _c("div", { staticClass: "row form-group border-top mt-3 py-4" }, [
                _c("div", { staticClass: "col-6" }, [
                  _c("div", { staticClass: "input-group" }, [
                    _c("select", {
                      directives: [
                        {
                          name: "model",
                          rawName: "v-model",
                          value: _vm.sale.method,
                          expression: "sale.method"
                        }
                      ],
                      staticClass: "form-select",
                      attrs: { name: "method", required: "" },
                      on: {
                        change: function($event) {
                          var $$selectedVal = Array.prototype.filter.call($event.target.options, function(o) {
                            return o.selected;
                          }).map(function(o) {
                            var val = "_value" in o ? o._value : o.value;
                            return val;
                          });
                          _vm.$set(_vm.sale, "method", $event.target.multiple ? $$selectedVal : $$selectedVal[0]);
                        }
                      }
                    }, [
                      _c("option", { attrs: { value: "" } }, [
                        _vm._v("Select the payment method")
                      ]),
                      _vm._v(" "),
                      _c("option", { attrs: { value: "cash" } }, [
                        _vm._v("Cash")
                      ]),
                      _vm._v(" "),
                      _c("option", { attrs: { value: "debit" } }, [
                        _vm._v("Debit")
                      ]),
                      _vm._v(" "),
                      _c("option", { attrs: { value: "credit" } }, [
                        _vm._v("Credit Card")
                      ]),
                      _vm._v(" "),
                      _c("option", { attrs: { value: "wire_transfer" } }, [
                        _vm._v("Wire transfer")
                      ])
                    ])
                  ])
                ]),
                _vm._v(" "),
                _vm.verifyMethod ? _c("div", { staticClass: "col-6" }, [
                  _c("div", { staticClass: "input-group" }, [
                    _c("input", {
                      directives: [
                        {
                          name: "model",
                          rawName: "v-model",
                          value: _vm.sale.id_transaction,
                          expression: "sale.id_transaction"
                        }
                      ],
                      staticClass: "form-control",
                      attrs: {
                        type: "text",
                        name: "id_transaction",
                        placeholder: "ID transaction",
                        required: ""
                      },
                      domProps: { value: _vm.sale.id_transaction },
                      on: {
                        input: function($event) {
                          if ($event.target.composing) {
                            return;
                          }
                          _vm.$set(_vm.sale, "id_transaction", $event.target.value);
                        }
                      }
                    }),
                    _vm._v(" "),
                    _vm._m(8)
                  ])
                ]) : _vm._e()
              ])
            ], 2),
            _vm._v(" "),
            _c("div", { staticClass: "card-footer" }, [
              _c("div", { staticClass: "d-flex justify-content-end" }, [
                _c("button", {
                  staticClass: "btn btn-primary px-3",
                  attrs: { type: "submit" }
                }, [_vm._v(_vm._s(_vm.SellOrEdit))])
              ])
            ])
          ]),
          _vm._v(" "),
          _c("customer-modal", {
            attrs: { csrf_token: _vm.csrf_token },
            on: { mutateCustomer: _vm.mutateDataCustomer }
          }),
          _vm._v(" "),
          _c("div", {
            staticClass: "modal fade",
            attrs: {
              id: "modal-add-product",
              tabindex: "-1",
              "aria-labelledby": "ModalAddProduct",
              "aria-hidden": "true"
            }
          }, [
            _c("div", { staticClass: "modal-dialog" }, [
              _c("div", { staticClass: "modal-content" }, [
                _c("div", { staticClass: "modal-body" }, [
                  _c("table-add-product", {
                    ref: "add_product_responsive",
                    attrs: {
                      products: "[]",
                      id_table: "table-add-responsive",
                      responsive: true
                    }
                  })
                ], 1),
                _vm._v(" "),
                _vm._m(9)
              ])
            ])
          ])
        ], 1);
      };
      __vue_staticRenderFns__13 = [
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-user" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-key" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-usd" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("div", { staticClass: "row" }, [
            _c("div", { staticClass: "col-12" }, [
              _c("div", { staticClass: "d-grid" }, [
                _c("button", {
                  staticClass: "d-block btn btn-outline-success d-lg-none",
                  attrs: {
                    type: "button",
                    id: "modal-customer-button",
                    "data-bs-toggle": "modal",
                    "data-bs-target": "#modal-add-product"
                  }
                }, [_vm._v("Add Product\n                        ")])
              ])
            ])
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("thead", [
            _c("tr", [
              _c("th", [_vm._v("Tax")]),
              _vm._v(" "),
              _c("th", [_vm._v("Subtotal")]),
              _vm._v(" "),
              _c("th", [_vm._v("Total")])
            ])
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-percent" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-usd" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-usd" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("span", { staticClass: "input-group-text" }, [
            _c("i", { staticClass: "fa fa-lock" })
          ]);
        },
        function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("div", { staticClass: "modal-footer" }, [
            _c("button", {
              staticClass: "btn btn-secondary",
              attrs: { type: "button", "data-bs-dismiss": "modal" }
            }, [_vm._v("\n                        Close\n                    ")])
          ]);
        }
      ];
      __vue_render__13._withStripped = true;
      __vue_inject_styles__13 = function(inject2) {
        if (!inject2)
          return;
        inject2("data-v-5deb4561_0", { source: "\n.v-select{\n    position: relative;\n    flex: 1 1 auto;\n}\n@media (max-width: 768px) {\n#modal-customer-button{\n        width: 100%;\n}\n.select2{\n        width: 100% !important;\n}\n}\n", map: { "version": 3, "sources": ["resource\\js\\components\\sales\\CardCreateSale.vue"], "names": [], "mappings": ";AA+YA;IACA,kBAAA;IACA,cAAA;AACA;AACA;AACA;QACA,WAAA;AACA;AACA;QACA,sBAAA;AACA;AACA", "file": "CardCreateSale.vue", "sourcesContent": [`<template>\r
    <div class="card border-0 border-top border-4 border-success">\r
        <div class="card-title"></div>\r
        <form v-on:submit.prevent="sell" role="form" method="post" autocomplete="off">\r
            <div class="card-body">\r
                <div class="form-group">\r
                    <div class="input-group">\r
                        <span class="input-group-text"><i class="fa fa-user"></i></span>\r
                        <input type="text" name="seller" class="form-control" :value="authParser.name" readonly/>\r
                    </div>\r
                </div>\r
                <div class="form-group">\r
                    <div class="input-group">\r
                        <span class="input-group-text"><i class="fa fa-key"></i></span>\r
                        <input type="text" name="sale" class="form-control" :value="formatInvoce(id_sale)" readonly/>\r
                    </div>\r
                </div>\r
                <div class="form-group">\r
                    <div class="input-group">\r
                        <v-select :options="select2.options" v-model="sale.customer" placeholder="Select Customer">\r
                            <template #search="{attributes, events}">\r
                                <input\r
                                class="vs__search"\r
                                :required="!sale.customer"\r
                                v-bind="attributes"\r
                                v-on="events"\r
                                />\r
                            </template>\r
                        </v-select>\r
                        <button \r
                            type="button" \r
                            id="modal-customer-button" \r
                            class="btn btn-success btn-sm" \r
                            data-bs-toggle="modal" \r
                            data-bs-target="#create-modal-customer"\r
                        >Add client\r
                        </button>\r
                    </div>\r
                </div>\r
                <div class="form-group row" v-for="(product, index) in sale.products" :key="index">\r
                    <div class="col-6">\r
                        <div class="input-group ">\r
                            <button class="btn btn-danger btn-sm" type="button" @click="removeProductSale(product.id)"><i class="fa fa-times"></i></button>\r
                            <input type="text" name="product" class="form-control" placeholder="Product" required :value="product.name" readonly>\r
                        </div>\r
                    </div>\r
                    <div class="col-3">\r
                        <imask-input \r
                            required\r
                            name="quantity_product"\r
                            class="form-control" \r
                            :mask="Number"\r
                            :min="1"\r
                            :type="'number'"\r
                            :max="product.stock"\r
                            :value="quantityFormat(product)"\r
                            @change="modifyQuantity(product.id, $event)"\r
                        />\r
                    </div>\r
                    <div class="col-3 px-0 px-md-3">\r
                        <div class="input-group">\r
                            <span class="input-group-text"><i class="fa fa-usd"></i></span>\r
                            <input type="text" name="price" class="form-control" placeholder="10$" readonly required :value="numberFormat(product.price)">\r
                        </div>\r
                    </div>\r
                </div>\r
                <div class="row">\r
                    <div class="col-12">\r
                        <div class="d-grid">\r
                            <button \r
                                type="button" \r
                                id="modal-customer-button" \r
                                class="d-block btn btn-outline-success d-lg-none" \r
                                data-bs-toggle="modal" \r
                                data-bs-target="#modal-add-product"\r
                            >Add Product\r
                            </button>\r
                        </div>\r
                    </div>\r
                </div>\r
                \r
                <div class="border-top mt-3 row justify-content-end">\r
                    <div class="col-sm-8">\r
                        <table class="table table-light">\r
                            <thead>\r
                                <tr>\r
                                    <th>Tax</th>\r
                                    <th>Subtotal</th>\r
                                    <th>Total</th>\r
                                </tr>\r
                            </thead>\r
                            <tbody>\r
                                <tr>\r
                                    <td>\r
                                        <div class="input-group">\r
                                            <input type="number" class="form-control" name="tax" min="0" autocomplete="off" placeholder="0" required v-model="sale.tax" @change="totalize">\r
                                            <span class="input-group-text"><i class="fa fa-percent"></i></span>\r
                                        </div>\r
                                    </td>\r
                                    <td>\r
                                        <div class="input-group">\r
                                            <input type="text" class="form-control" name="net" min="0" autocomplete="off" placeholder="0" required v-model="sale.net" readonly>\r
                                            <span class="input-group-text"><i class="fa fa-usd"></i></span>\r
                                        </div>\r
                                    </td>\r
                                    <td>\r
                                        <div class="input-group">\r
                                            <span class="input-group-text"><i class="fa fa-usd"></i></span>\r
                                            <input type="text" class="form-control" name="total_sale" min="1" autocomplete="off" placeholder="0.00" readonly required v-model="sale.total">\r
                                        </div>\r
                                    </td>\r
                                </tr>\r
                            </tbody>\r
                        </table>\r
                    </div>\r
                </div>\r
                <div class="row form-group border-top mt-3 py-4">\r
                    <div class="col-6">\r
                        <div class="input-group">\r
                            <select class="form-select" name="method" required v-model="sale.method">\r
                                <option value="">Select the payment method</option>\r
                                <option value="cash">Cash</option>\r
                                <option value="debit">Debit</option>\r
                                <option value="credit">Credit Card</option>\r
                                <option value="wire_transfer">Wire transfer</option>\r
                            </select>\r
                        </div>\r
                    </div>\r
                    <div class="col-6" v-if="verifyMethod">\r
                        <div class="input-group">\r
                            <input type="text" name="id_transaction" class="form-control" placeholder="ID transaction" required v-model="sale.id_transaction">\r
                            <span class="input-group-text"><i class="fa fa-lock"></i></span>\r
                        </div>\r
                    </div>\r
                </div>\r
            </div>\r
            <div class="card-footer">\r
                <div class="d-flex justify-content-end">\r
                    <button type="submit" class="btn btn-primary px-3">{{SellOrEdit}}</button>\r
                </div>\r
            </div>\r
        </form>\r
\r
        <customer-modal :csrf_token="csrf_token" @mutateCustomer="mutateDataCustomer"></customer-modal>\r
\r
        <div\r
            class="modal fade"\r
            id="modal-add-product"\r
            tabindex="-1"\r
            aria-labelledby="ModalAddProduct"\r
            aria-hidden="true"\r
        >\r
            <div class="modal-dialog">\r
                <div class="modal-content">\r
                    <div class="modal-body">\r
                        <table-add-product :products="'[]'" id_table="table-add-responsive" :responsive="true" ref="add_product_responsive"></table-add-product>\r
                    </div>\r
\r
                    <div class="modal-footer">\r
                        <button\r
                            type="button"\r
                            class="btn btn-secondary"\r
                            data-bs-dismiss="modal"\r
                        >\r
                            Close\r
                        </button>\r
                </div>\r
\r
                </div>\r
                \r
            </div>\r
        </div>\r
    </div>\r
\r
</template>\r
<script>\r
import { EventBus } from '../EventBus';\r
import ModalCustomer from '../customers/ModalCustomers.vue';\r
import { IMaskComponent } from 'vue-imask';\r
import ModalAddProduct from './CardAddProduct.vue';\r
import numeral from 'numeral';\r
export default {\r
    name: 'card-create-sale',\r
    props:{\r
        auth:{\r
            required: true\r
        },\r
        customers:{\r
            required: true\r
        },\r
        id_sale:{\r
            required: true\r
        },\r
        csrf_token:{\r
            required: true\r
        },\r
        edit: {\r
            default: false\r
        },\r
        _sale:{\r
            default: undefined\r
        }\r
        \r
    },\r
    components:{\r
        ModalCustomer,\r
        'imask-input': IMaskComponent,\r
        ModalAddProduct\r
    },\r
    data(){\r
        return {\r
            authParser: JSON.parse(this.auth),\r
            customersParser: JSON.parse(this.customers),\r
            sale:{\r
                customer: '',\r
                method: '',\r
                products: [],\r
                tax: 0,\r
                total: 0,\r
                net: 0,\r
                id_transaction: '',\r
            },\r
            select2:{\r
                options: []\r
            },\r
        }\r
    },\r
    computed:{\r
        verifyMethod(){\r
            return this.sale.method !== 'cash' && this.sale.method !== '';\r
        },\r
        SellOrEdit(){\r
            return this.edit ?  'Edit Sale' : 'Sell';\r
        }\r
        \r
    },\r
    methods:{\r
        mutateDataCustomer(data){\r
            this.customersParser.push(data);\r
            this.select2.options.push({label: data.name, code: data.id})\r
            this.sale.customer = {label: data.name, code: data.id};\r
        },\r
        addProductSale(product){\r
            product.quantity = 1;\r
            this.sale.products.push(product);\r
            this.totalize();\r
        },\r
        removeProductSale(id){\r
            this.sale.products = this.sale.products.filter(product => { return product.id != id }); \r
            this.totalize();\r
            EventBus.$emit('remove', id);\r
        },\r
        totalize(){\r
            let total = 0;\r
            this.sale.products.map(product => {\r
                total = total + (product.price * product.quantity)\r
            })\r
            if(this.sale.tax > 0){\r
                this.sale.net = numeral(total).format('0,0.00');\r
                this.sale.total = numeral(((total * this.sale.tax) / 100) + total).format('0,0.00');\r
            }else{\r
                this.sale.net = numeral(total).format('0,0.00');\r
                this.sale.total = numeral(total).format('0,0.00');\r
            }\r
        },\r
        modifyQuantity(id, event){\r
            if(event.target.value > 0){\r
                const product = this.sale.products.find(p => p.id == id);\r
                product.quantity = parseInt(event.target.value);\r
                this.totalize();    \r
            }\r
        },\r
        numberFormat(price){\r
            return numeral(price).format('0,0.00')\r
        },\r
        sell(){\r
            if(this.sale.products.length > 0){\r
                this.$swal.fire({\r
                title: 'Are you sure to make this sale?',\r
                text: "Are all the data correct?",\r
                icon: 'warning',\r
                showCancelButton: true,\r
                confirmButtonColor: '#3085d6',\r
                cancelButtonColor: '#d33',\r
                confirmButtonText: 'Yes, sell...'\r
                }).then((result) => {\r
                if (result.isConfirmed) {\r
                    if(this.edit){\r
                        axios({\r
                            method:'post',\r
                            url: \`/sales/edit/\${this._sale.id}\`,\r
                            data: {\r
                                csrf_token: this.csrf_token,\r
                                id_sale: this.id_sale,\r
                                user_id: this.authParser.id,\r
                                customer_id: this.sale.customer.code,\r
                                tax: this.sale.tax,\r
                                net: this.sale.net,\r
                                total: this.sale.total,\r
                                method: this.sale.method,\r
                                id_transaction: this.sale.id_transaction,\r
                                products: JSON.stringify(this.sale.products)\r
                            }\r
                        }).then(response => {\r
                            const { data: { status, response:resp } } = response;\r
                            if(status){\r
                                this.$swal.fire(\r
                                'Success!',\r
                                'Your sale has been registered.',\r
                                'success'\r
                                ).then(() => {\r
                                    location.href = '/sales';\r
                                })\r
                            }else{\r
                                this.$swal.fire({\r
                                    icon: 'error',\r
                                    title: 'Oops...',\r
                                    text: 'there was a problem saving this sale',\r
                                })\r
                            }\r
                        })\r
                    }else{\r
                        axios({\r
                            method:'post',\r
                            url: '/sales/sell',\r
                            data: {\r
                                csrf_token: this.csrf_token,\r
                                id_sale: this.id_sale,\r
                                user_id: this.authParser.id,\r
                                customer_id: this.sale.customer.code,\r
                                tax: this.sale.tax,\r
                                net: this.sale.net,\r
                                total: this.sale.total,\r
                                method: this.sale.method,\r
                                id_transaction: this.sale.id_transaction,\r
                                products: JSON.stringify(this.sale.products)\r
                            }\r
                        }).then(response => {\r
                            const { data: { status, response:resp } } = response;\r
                            if(status){\r
                                this.$swal.fire(\r
                                'Success!',\r
                                'Your sale has been registered.',\r
                                'success'\r
                                ).then(() => {\r
                                    location.href = '/sales';\r
                                })\r
                            }else{\r
                                this.$swal.fire({\r
                                    icon: 'error',\r
                                    title: 'Oops...',\r
                                    text: 'there was a problem saving this sale',\r
                                })\r
                            }\r
                        })\r
                    }\r
                }\r
                })\r
            }else{\r
                this.$swal.fire({\r
                    icon: 'error',\r
                    title: 'Oops...',\r
                    text: 'You cannot sell if you have no products added.!',\r
                    })\r
            }\r
        },\r
        formatInvoce(invoice){\r
          let new_invoice = invoice.toString().substr(0, 2) + '-';\r
          return new_invoice = new_invoice + invoice.toString().substr(2, 4);\r
        },\r
        quantityFormat(product){\r
            return product?.pivot ? product.pivot.quantity.toString() : '1';\r
        }\r
\r
    },\r
    mounted(){\r
         this.customersParser.map((customer) => {\r
            this.select2.options.push({label: customer.name, code: customer.id})\r
        });\r
        EventBus.$on('add', product => this.addProductSale(product));\r
        EventBus.$on('products', data => {\r
            this.$refs.add_product_responsive.addProductResponsive(data);\r
         })\r
\r
        if(this.edit){\r
            this.sale.customer = { label: this._sale.customer.name, code: this._sale.customer.id };\r
            this.sale.method = this._sale.method;\r
            this.sale.products = this._sale.products;\r
            this.sale.tax = this._sale.tax;\r
            this.sale.total = this._sale.total;\r
            this.sale.net = this._sale.net;\r
            this.sale.id_transaction = this._sale.id_transaction;\r
            this.authParser = this._sale.seller;\r
        }\r
    }\r
    \r
}\r
<\/script>\r
<style>\r
    .v-select{\r
        position: relative;\r
        flex: 1 1 auto;\r
    }\r
    @media (max-width: 768px) {\r
        #modal-customer-button{\r
            width: 100%;\r
        }\r
        .select2{\r
            width: 100% !important;\r
        }\r
    }\r
</style>`] }, media: void 0 });
      };
      __vue_scope_id__13 = void 0;
      __vue_module_identifier__13 = void 0;
      __vue_is_functional_template__13 = false;
      __vue_component__12 = /* @__PURE__ */ __vue_normalize__12({ render: __vue_render__13, staticRenderFns: __vue_staticRenderFns__13 }, __vue_inject_styles__13, __vue_script__13, __vue_scope_id__13, __vue_is_functional_template__13, __vue_module_identifier__13, false, __vue_create_injector__3, void 0, void 0);
      CardCreateSale_default = __vue_component__12;
    }
  });

  // node_modules/vue-chartjs/es/mixins/index.js
  function dataHandler(newData, oldData) {
    if (oldData) {
      var chart = this.$data._chart;
      var newDatasetLabels = newData.datasets.map(function(dataset) {
        return dataset.label;
      });
      var oldDatasetLabels = oldData.datasets.map(function(dataset) {
        return dataset.label;
      });
      var oldLabels = JSON.stringify(oldDatasetLabels);
      var newLabels = JSON.stringify(newDatasetLabels);
      if (newLabels === oldLabels && oldData.datasets.length === newData.datasets.length) {
        newData.datasets.forEach(function(dataset, i) {
          var oldDatasetKeys = Object.keys(oldData.datasets[i]);
          var newDatasetKeys = Object.keys(dataset);
          var deletionKeys = oldDatasetKeys.filter(function(key) {
            return key !== "_meta" && newDatasetKeys.indexOf(key) === -1;
          });
          deletionKeys.forEach(function(deletionKey) {
            delete chart.data.datasets[i][deletionKey];
          });
          for (var attribute in dataset) {
            if (dataset.hasOwnProperty(attribute)) {
              chart.data.datasets[i][attribute] = dataset[attribute];
            }
          }
        });
        if (newData.hasOwnProperty("labels")) {
          chart.data.labels = newData.labels;
          this.$emit("labels:update");
        }
        if (newData.hasOwnProperty("xLabels")) {
          chart.data.xLabels = newData.xLabels;
          this.$emit("xlabels:update");
        }
        if (newData.hasOwnProperty("yLabels")) {
          chart.data.yLabels = newData.yLabels;
          this.$emit("ylabels:update");
        }
        chart.update();
        this.$emit("chart:update");
      } else {
        if (chart) {
          chart.destroy();
          this.$emit("chart:destroy");
        }
        this.renderChart(this.chartData, this.options);
        this.$emit("chart:render");
      }
    } else {
      if (this.$data._chart) {
        this.$data._chart.destroy();
        this.$emit("chart:destroy");
      }
      this.renderChart(this.chartData, this.options);
      this.$emit("chart:render");
    }
  }
  var reactiveData, reactiveProp, mixins_default;
  var init_mixins = __esm({
    "node_modules/vue-chartjs/es/mixins/index.js"() {
      reactiveData = {
        data: function data() {
          return {
            chartData: null
          };
        },
        watch: {
          "chartData": dataHandler
        }
      };
      reactiveProp = {
        props: {
          chartData: {
            type: Object,
            required: true,
            default: function _default() {
            }
          }
        },
        watch: {
          "chartData": dataHandler
        }
      };
      mixins_default = {
        reactiveData,
        reactiveProp
      };
    }
  });

  // node_modules/chart.js/dist/Chart.js
  var require_Chart = __commonJS({
    "node_modules/chart.js/dist/Chart.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(function() {
          try {
            return require_moment();
          } catch (e) {
          }
        }()) : typeof define === "function" && define.amd ? define(["require"], function(require2) {
          return factory(function() {
            try {
              return require2("moment");
            } catch (e) {
            }
          }());
        }) : (global2 = global2 || self, global2.Chart = factory(global2.moment));
      })(exports, function(moment5) {
        "use strict";
        moment5 = moment5 && moment5.hasOwnProperty("default") ? moment5["default"] : moment5;
        function createCommonjsModule2(fn, module2) {
          return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
        }
        function getCjsExportFromNamespace(n) {
          return n && n["default"] || n;
        }
        var colorName = {
          "aliceblue": [240, 248, 255],
          "antiquewhite": [250, 235, 215],
          "aqua": [0, 255, 255],
          "aquamarine": [127, 255, 212],
          "azure": [240, 255, 255],
          "beige": [245, 245, 220],
          "bisque": [255, 228, 196],
          "black": [0, 0, 0],
          "blanchedalmond": [255, 235, 205],
          "blue": [0, 0, 255],
          "blueviolet": [138, 43, 226],
          "brown": [165, 42, 42],
          "burlywood": [222, 184, 135],
          "cadetblue": [95, 158, 160],
          "chartreuse": [127, 255, 0],
          "chocolate": [210, 105, 30],
          "coral": [255, 127, 80],
          "cornflowerblue": [100, 149, 237],
          "cornsilk": [255, 248, 220],
          "crimson": [220, 20, 60],
          "cyan": [0, 255, 255],
          "darkblue": [0, 0, 139],
          "darkcyan": [0, 139, 139],
          "darkgoldenrod": [184, 134, 11],
          "darkgray": [169, 169, 169],
          "darkgreen": [0, 100, 0],
          "darkgrey": [169, 169, 169],
          "darkkhaki": [189, 183, 107],
          "darkmagenta": [139, 0, 139],
          "darkolivegreen": [85, 107, 47],
          "darkorange": [255, 140, 0],
          "darkorchid": [153, 50, 204],
          "darkred": [139, 0, 0],
          "darksalmon": [233, 150, 122],
          "darkseagreen": [143, 188, 143],
          "darkslateblue": [72, 61, 139],
          "darkslategray": [47, 79, 79],
          "darkslategrey": [47, 79, 79],
          "darkturquoise": [0, 206, 209],
          "darkviolet": [148, 0, 211],
          "deeppink": [255, 20, 147],
          "deepskyblue": [0, 191, 255],
          "dimgray": [105, 105, 105],
          "dimgrey": [105, 105, 105],
          "dodgerblue": [30, 144, 255],
          "firebrick": [178, 34, 34],
          "floralwhite": [255, 250, 240],
          "forestgreen": [34, 139, 34],
          "fuchsia": [255, 0, 255],
          "gainsboro": [220, 220, 220],
          "ghostwhite": [248, 248, 255],
          "gold": [255, 215, 0],
          "goldenrod": [218, 165, 32],
          "gray": [128, 128, 128],
          "green": [0, 128, 0],
          "greenyellow": [173, 255, 47],
          "grey": [128, 128, 128],
          "honeydew": [240, 255, 240],
          "hotpink": [255, 105, 180],
          "indianred": [205, 92, 92],
          "indigo": [75, 0, 130],
          "ivory": [255, 255, 240],
          "khaki": [240, 230, 140],
          "lavender": [230, 230, 250],
          "lavenderblush": [255, 240, 245],
          "lawngreen": [124, 252, 0],
          "lemonchiffon": [255, 250, 205],
          "lightblue": [173, 216, 230],
          "lightcoral": [240, 128, 128],
          "lightcyan": [224, 255, 255],
          "lightgoldenrodyellow": [250, 250, 210],
          "lightgray": [211, 211, 211],
          "lightgreen": [144, 238, 144],
          "lightgrey": [211, 211, 211],
          "lightpink": [255, 182, 193],
          "lightsalmon": [255, 160, 122],
          "lightseagreen": [32, 178, 170],
          "lightskyblue": [135, 206, 250],
          "lightslategray": [119, 136, 153],
          "lightslategrey": [119, 136, 153],
          "lightsteelblue": [176, 196, 222],
          "lightyellow": [255, 255, 224],
          "lime": [0, 255, 0],
          "limegreen": [50, 205, 50],
          "linen": [250, 240, 230],
          "magenta": [255, 0, 255],
          "maroon": [128, 0, 0],
          "mediumaquamarine": [102, 205, 170],
          "mediumblue": [0, 0, 205],
          "mediumorchid": [186, 85, 211],
          "mediumpurple": [147, 112, 219],
          "mediumseagreen": [60, 179, 113],
          "mediumslateblue": [123, 104, 238],
          "mediumspringgreen": [0, 250, 154],
          "mediumturquoise": [72, 209, 204],
          "mediumvioletred": [199, 21, 133],
          "midnightblue": [25, 25, 112],
          "mintcream": [245, 255, 250],
          "mistyrose": [255, 228, 225],
          "moccasin": [255, 228, 181],
          "navajowhite": [255, 222, 173],
          "navy": [0, 0, 128],
          "oldlace": [253, 245, 230],
          "olive": [128, 128, 0],
          "olivedrab": [107, 142, 35],
          "orange": [255, 165, 0],
          "orangered": [255, 69, 0],
          "orchid": [218, 112, 214],
          "palegoldenrod": [238, 232, 170],
          "palegreen": [152, 251, 152],
          "paleturquoise": [175, 238, 238],
          "palevioletred": [219, 112, 147],
          "papayawhip": [255, 239, 213],
          "peachpuff": [255, 218, 185],
          "peru": [205, 133, 63],
          "pink": [255, 192, 203],
          "plum": [221, 160, 221],
          "powderblue": [176, 224, 230],
          "purple": [128, 0, 128],
          "rebeccapurple": [102, 51, 153],
          "red": [255, 0, 0],
          "rosybrown": [188, 143, 143],
          "royalblue": [65, 105, 225],
          "saddlebrown": [139, 69, 19],
          "salmon": [250, 128, 114],
          "sandybrown": [244, 164, 96],
          "seagreen": [46, 139, 87],
          "seashell": [255, 245, 238],
          "sienna": [160, 82, 45],
          "silver": [192, 192, 192],
          "skyblue": [135, 206, 235],
          "slateblue": [106, 90, 205],
          "slategray": [112, 128, 144],
          "slategrey": [112, 128, 144],
          "snow": [255, 250, 250],
          "springgreen": [0, 255, 127],
          "steelblue": [70, 130, 180],
          "tan": [210, 180, 140],
          "teal": [0, 128, 128],
          "thistle": [216, 191, 216],
          "tomato": [255, 99, 71],
          "turquoise": [64, 224, 208],
          "violet": [238, 130, 238],
          "wheat": [245, 222, 179],
          "white": [255, 255, 255],
          "whitesmoke": [245, 245, 245],
          "yellow": [255, 255, 0],
          "yellowgreen": [154, 205, 50]
        };
        var conversions = createCommonjsModule2(function(module2) {
          var reverseKeywords = {};
          for (var key in colorName) {
            if (colorName.hasOwnProperty(key)) {
              reverseKeywords[colorName[key]] = key;
            }
          }
          var convert2 = module2.exports = {
            rgb: { channels: 3, labels: "rgb" },
            hsl: { channels: 3, labels: "hsl" },
            hsv: { channels: 3, labels: "hsv" },
            hwb: { channels: 3, labels: "hwb" },
            cmyk: { channels: 4, labels: "cmyk" },
            xyz: { channels: 3, labels: "xyz" },
            lab: { channels: 3, labels: "lab" },
            lch: { channels: 3, labels: "lch" },
            hex: { channels: 1, labels: ["hex"] },
            keyword: { channels: 1, labels: ["keyword"] },
            ansi16: { channels: 1, labels: ["ansi16"] },
            ansi256: { channels: 1, labels: ["ansi256"] },
            hcg: { channels: 3, labels: ["h", "c", "g"] },
            apple: { channels: 3, labels: ["r16", "g16", "b16"] },
            gray: { channels: 1, labels: ["gray"] }
          };
          for (var model in convert2) {
            if (convert2.hasOwnProperty(model)) {
              if (!("channels" in convert2[model])) {
                throw new Error("missing channels property: " + model);
              }
              if (!("labels" in convert2[model])) {
                throw new Error("missing channel labels property: " + model);
              }
              if (convert2[model].labels.length !== convert2[model].channels) {
                throw new Error("channel and label counts mismatch: " + model);
              }
              var channels = convert2[model].channels;
              var labels = convert2[model].labels;
              delete convert2[model].channels;
              delete convert2[model].labels;
              Object.defineProperty(convert2[model], "channels", { value: channels });
              Object.defineProperty(convert2[model], "labels", { value: labels });
            }
          }
          convert2.rgb.hsl = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var min = Math.min(r, g, b);
            var max = Math.max(r, g, b);
            var delta = max - min;
            var h;
            var s;
            var l;
            if (max === min) {
              h = 0;
            } else if (r === max) {
              h = (g - b) / delta;
            } else if (g === max) {
              h = 2 + (b - r) / delta;
            } else if (b === max) {
              h = 4 + (r - g) / delta;
            }
            h = Math.min(h * 60, 360);
            if (h < 0) {
              h += 360;
            }
            l = (min + max) / 2;
            if (max === min) {
              s = 0;
            } else if (l <= 0.5) {
              s = delta / (max + min);
            } else {
              s = delta / (2 - max - min);
            }
            return [h, s * 100, l * 100];
          };
          convert2.rgb.hsv = function(rgb) {
            var rdif;
            var gdif;
            var bdif;
            var h;
            var s;
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var v = Math.max(r, g, b);
            var diff = v - Math.min(r, g, b);
            var diffc = function(c) {
              return (v - c) / 6 / diff + 1 / 2;
            };
            if (diff === 0) {
              h = s = 0;
            } else {
              s = diff / v;
              rdif = diffc(r);
              gdif = diffc(g);
              bdif = diffc(b);
              if (r === v) {
                h = bdif - gdif;
              } else if (g === v) {
                h = 1 / 3 + rdif - bdif;
              } else if (b === v) {
                h = 2 / 3 + gdif - rdif;
              }
              if (h < 0) {
                h += 1;
              } else if (h > 1) {
                h -= 1;
              }
            }
            return [
              h * 360,
              s * 100,
              v * 100
            ];
          };
          convert2.rgb.hwb = function(rgb) {
            var r = rgb[0];
            var g = rgb[1];
            var b = rgb[2];
            var h = convert2.rgb.hsl(rgb)[0];
            var w = 1 / 255 * Math.min(r, Math.min(g, b));
            b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
            return [h, w * 100, b * 100];
          };
          convert2.rgb.cmyk = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var c;
            var m;
            var y;
            var k2;
            k2 = Math.min(1 - r, 1 - g, 1 - b);
            c = (1 - r - k2) / (1 - k2) || 0;
            m = (1 - g - k2) / (1 - k2) || 0;
            y = (1 - b - k2) / (1 - k2) || 0;
            return [c * 100, m * 100, y * 100, k2 * 100];
          };
          function comparativeDistance(x, y) {
            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
          }
          convert2.rgb.keyword = function(rgb) {
            var reversed = reverseKeywords[rgb];
            if (reversed) {
              return reversed;
            }
            var currentClosestDistance = Infinity;
            var currentClosestKeyword;
            for (var keyword2 in colorName) {
              if (colorName.hasOwnProperty(keyword2)) {
                var value = colorName[keyword2];
                var distance = comparativeDistance(rgb, value);
                if (distance < currentClosestDistance) {
                  currentClosestDistance = distance;
                  currentClosestKeyword = keyword2;
                }
              }
            }
            return currentClosestKeyword;
          };
          convert2.keyword.rgb = function(keyword2) {
            return colorName[keyword2];
          };
          convert2.rgb.xyz = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
            var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
            var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
            var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
            return [x * 100, y * 100, z * 100];
          };
          convert2.rgb.lab = function(rgb) {
            var xyz = convert2.rgb.xyz(rgb);
            var x = xyz[0];
            var y = xyz[1];
            var z = xyz[2];
            var l;
            var a;
            var b;
            x /= 95.047;
            y /= 100;
            z /= 108.883;
            x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
            y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
            z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
            l = 116 * y - 16;
            a = 500 * (x - y);
            b = 200 * (y - z);
            return [l, a, b];
          };
          convert2.hsl.rgb = function(hsl) {
            var h = hsl[0] / 360;
            var s = hsl[1] / 100;
            var l = hsl[2] / 100;
            var t1;
            var t2;
            var t3;
            var rgb;
            var val;
            if (s === 0) {
              val = l * 255;
              return [val, val, val];
            }
            if (l < 0.5) {
              t2 = l * (1 + s);
            } else {
              t2 = l + s - l * s;
            }
            t1 = 2 * l - t2;
            rgb = [0, 0, 0];
            for (var i = 0; i < 3; i++) {
              t3 = h + 1 / 3 * -(i - 1);
              if (t3 < 0) {
                t3++;
              }
              if (t3 > 1) {
                t3--;
              }
              if (6 * t3 < 1) {
                val = t1 + (t2 - t1) * 6 * t3;
              } else if (2 * t3 < 1) {
                val = t2;
              } else if (3 * t3 < 2) {
                val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
              } else {
                val = t1;
              }
              rgb[i] = val * 255;
            }
            return rgb;
          };
          convert2.hsl.hsv = function(hsl) {
            var h = hsl[0];
            var s = hsl[1] / 100;
            var l = hsl[2] / 100;
            var smin = s;
            var lmin = Math.max(l, 0.01);
            var sv;
            var v;
            l *= 2;
            s *= l <= 1 ? l : 2 - l;
            smin *= lmin <= 1 ? lmin : 2 - lmin;
            v = (l + s) / 2;
            sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
            return [h, sv * 100, v * 100];
          };
          convert2.hsv.rgb = function(hsv) {
            var h = hsv[0] / 60;
            var s = hsv[1] / 100;
            var v = hsv[2] / 100;
            var hi = Math.floor(h) % 6;
            var f = h - Math.floor(h);
            var p = 255 * v * (1 - s);
            var q = 255 * v * (1 - s * f);
            var t = 255 * v * (1 - s * (1 - f));
            v *= 255;
            switch (hi) {
              case 0:
                return [v, t, p];
              case 1:
                return [q, v, p];
              case 2:
                return [p, v, t];
              case 3:
                return [p, q, v];
              case 4:
                return [t, p, v];
              case 5:
                return [v, p, q];
            }
          };
          convert2.hsv.hsl = function(hsv) {
            var h = hsv[0];
            var s = hsv[1] / 100;
            var v = hsv[2] / 100;
            var vmin = Math.max(v, 0.01);
            var lmin;
            var sl;
            var l;
            l = (2 - s) * v;
            lmin = (2 - s) * vmin;
            sl = s * vmin;
            sl /= lmin <= 1 ? lmin : 2 - lmin;
            sl = sl || 0;
            l /= 2;
            return [h, sl * 100, l * 100];
          };
          convert2.hwb.rgb = function(hwb) {
            var h = hwb[0] / 360;
            var wh = hwb[1] / 100;
            var bl = hwb[2] / 100;
            var ratio = wh + bl;
            var i;
            var v;
            var f;
            var n;
            if (ratio > 1) {
              wh /= ratio;
              bl /= ratio;
            }
            i = Math.floor(6 * h);
            v = 1 - bl;
            f = 6 * h - i;
            if ((i & 1) !== 0) {
              f = 1 - f;
            }
            n = wh + f * (v - wh);
            var r;
            var g;
            var b;
            switch (i) {
              default:
              case 6:
              case 0:
                r = v;
                g = n;
                b = wh;
                break;
              case 1:
                r = n;
                g = v;
                b = wh;
                break;
              case 2:
                r = wh;
                g = v;
                b = n;
                break;
              case 3:
                r = wh;
                g = n;
                b = v;
                break;
              case 4:
                r = n;
                g = wh;
                b = v;
                break;
              case 5:
                r = v;
                g = wh;
                b = n;
                break;
            }
            return [r * 255, g * 255, b * 255];
          };
          convert2.cmyk.rgb = function(cmyk) {
            var c = cmyk[0] / 100;
            var m = cmyk[1] / 100;
            var y = cmyk[2] / 100;
            var k2 = cmyk[3] / 100;
            var r;
            var g;
            var b;
            r = 1 - Math.min(1, c * (1 - k2) + k2);
            g = 1 - Math.min(1, m * (1 - k2) + k2);
            b = 1 - Math.min(1, y * (1 - k2) + k2);
            return [r * 255, g * 255, b * 255];
          };
          convert2.xyz.rgb = function(xyz) {
            var x = xyz[0] / 100;
            var y = xyz[1] / 100;
            var z = xyz[2] / 100;
            var r;
            var g;
            var b;
            r = x * 3.2406 + y * -1.5372 + z * -0.4986;
            g = x * -0.9689 + y * 1.8758 + z * 0.0415;
            b = x * 0.0557 + y * -0.204 + z * 1.057;
            r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
            g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
            b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
            r = Math.min(Math.max(0, r), 1);
            g = Math.min(Math.max(0, g), 1);
            b = Math.min(Math.max(0, b), 1);
            return [r * 255, g * 255, b * 255];
          };
          convert2.xyz.lab = function(xyz) {
            var x = xyz[0];
            var y = xyz[1];
            var z = xyz[2];
            var l;
            var a;
            var b;
            x /= 95.047;
            y /= 100;
            z /= 108.883;
            x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
            y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
            z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
            l = 116 * y - 16;
            a = 500 * (x - y);
            b = 200 * (y - z);
            return [l, a, b];
          };
          convert2.lab.xyz = function(lab) {
            var l = lab[0];
            var a = lab[1];
            var b = lab[2];
            var x;
            var y;
            var z;
            y = (l + 16) / 116;
            x = a / 500 + y;
            z = y - b / 200;
            var y2 = Math.pow(y, 3);
            var x2 = Math.pow(x, 3);
            var z2 = Math.pow(z, 3);
            y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
            x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
            z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
            x *= 95.047;
            y *= 100;
            z *= 108.883;
            return [x, y, z];
          };
          convert2.lab.lch = function(lab) {
            var l = lab[0];
            var a = lab[1];
            var b = lab[2];
            var hr;
            var h;
            var c;
            hr = Math.atan2(b, a);
            h = hr * 360 / 2 / Math.PI;
            if (h < 0) {
              h += 360;
            }
            c = Math.sqrt(a * a + b * b);
            return [l, c, h];
          };
          convert2.lch.lab = function(lch) {
            var l = lch[0];
            var c = lch[1];
            var h = lch[2];
            var a;
            var b;
            var hr;
            hr = h / 360 * 2 * Math.PI;
            a = c * Math.cos(hr);
            b = c * Math.sin(hr);
            return [l, a, b];
          };
          convert2.rgb.ansi16 = function(args) {
            var r = args[0];
            var g = args[1];
            var b = args[2];
            var value = 1 in arguments ? arguments[1] : convert2.rgb.hsv(args)[2];
            value = Math.round(value / 50);
            if (value === 0) {
              return 30;
            }
            var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
            if (value === 2) {
              ansi += 60;
            }
            return ansi;
          };
          convert2.hsv.ansi16 = function(args) {
            return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
          };
          convert2.rgb.ansi256 = function(args) {
            var r = args[0];
            var g = args[1];
            var b = args[2];
            if (r === g && g === b) {
              if (r < 8) {
                return 16;
              }
              if (r > 248) {
                return 231;
              }
              return Math.round((r - 8) / 247 * 24) + 232;
            }
            var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
            return ansi;
          };
          convert2.ansi16.rgb = function(args) {
            var color = args % 10;
            if (color === 0 || color === 7) {
              if (args > 50) {
                color += 3.5;
              }
              color = color / 10.5 * 255;
              return [color, color, color];
            }
            var mult = (~~(args > 50) + 1) * 0.5;
            var r = (color & 1) * mult * 255;
            var g = (color >> 1 & 1) * mult * 255;
            var b = (color >> 2 & 1) * mult * 255;
            return [r, g, b];
          };
          convert2.ansi256.rgb = function(args) {
            if (args >= 232) {
              var c = (args - 232) * 10 + 8;
              return [c, c, c];
            }
            args -= 16;
            var rem;
            var r = Math.floor(args / 36) / 5 * 255;
            var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
            var b = rem % 6 / 5 * 255;
            return [r, g, b];
          };
          convert2.rgb.hex = function(args) {
            var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
            var string = integer.toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          };
          convert2.hex.rgb = function(args) {
            var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
            if (!match) {
              return [0, 0, 0];
            }
            var colorString2 = match[0];
            if (match[0].length === 3) {
              colorString2 = colorString2.split("").map(function(char) {
                return char + char;
              }).join("");
            }
            var integer = parseInt(colorString2, 16);
            var r = integer >> 16 & 255;
            var g = integer >> 8 & 255;
            var b = integer & 255;
            return [r, g, b];
          };
          convert2.rgb.hcg = function(rgb) {
            var r = rgb[0] / 255;
            var g = rgb[1] / 255;
            var b = rgb[2] / 255;
            var max = Math.max(Math.max(r, g), b);
            var min = Math.min(Math.min(r, g), b);
            var chroma = max - min;
            var grayscale;
            var hue;
            if (chroma < 1) {
              grayscale = min / (1 - chroma);
            } else {
              grayscale = 0;
            }
            if (chroma <= 0) {
              hue = 0;
            } else if (max === r) {
              hue = (g - b) / chroma % 6;
            } else if (max === g) {
              hue = 2 + (b - r) / chroma;
            } else {
              hue = 4 + (r - g) / chroma + 4;
            }
            hue /= 6;
            hue %= 1;
            return [hue * 360, chroma * 100, grayscale * 100];
          };
          convert2.hsl.hcg = function(hsl) {
            var s = hsl[1] / 100;
            var l = hsl[2] / 100;
            var c = 1;
            var f = 0;
            if (l < 0.5) {
              c = 2 * s * l;
            } else {
              c = 2 * s * (1 - l);
            }
            if (c < 1) {
              f = (l - 0.5 * c) / (1 - c);
            }
            return [hsl[0], c * 100, f * 100];
          };
          convert2.hsv.hcg = function(hsv) {
            var s = hsv[1] / 100;
            var v = hsv[2] / 100;
            var c = s * v;
            var f = 0;
            if (c < 1) {
              f = (v - c) / (1 - c);
            }
            return [hsv[0], c * 100, f * 100];
          };
          convert2.hcg.rgb = function(hcg) {
            var h = hcg[0] / 360;
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            if (c === 0) {
              return [g * 255, g * 255, g * 255];
            }
            var pure = [0, 0, 0];
            var hi = h % 1 * 6;
            var v = hi % 1;
            var w = 1 - v;
            var mg = 0;
            switch (Math.floor(hi)) {
              case 0:
                pure[0] = 1;
                pure[1] = v;
                pure[2] = 0;
                break;
              case 1:
                pure[0] = w;
                pure[1] = 1;
                pure[2] = 0;
                break;
              case 2:
                pure[0] = 0;
                pure[1] = 1;
                pure[2] = v;
                break;
              case 3:
                pure[0] = 0;
                pure[1] = w;
                pure[2] = 1;
                break;
              case 4:
                pure[0] = v;
                pure[1] = 0;
                pure[2] = 1;
                break;
              default:
                pure[0] = 1;
                pure[1] = 0;
                pure[2] = w;
            }
            mg = (1 - c) * g;
            return [
              (c * pure[0] + mg) * 255,
              (c * pure[1] + mg) * 255,
              (c * pure[2] + mg) * 255
            ];
          };
          convert2.hcg.hsv = function(hcg) {
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            var v = c + g * (1 - c);
            var f = 0;
            if (v > 0) {
              f = c / v;
            }
            return [hcg[0], f * 100, v * 100];
          };
          convert2.hcg.hsl = function(hcg) {
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            var l = g * (1 - c) + 0.5 * c;
            var s = 0;
            if (l > 0 && l < 0.5) {
              s = c / (2 * l);
            } else if (l >= 0.5 && l < 1) {
              s = c / (2 * (1 - l));
            }
            return [hcg[0], s * 100, l * 100];
          };
          convert2.hcg.hwb = function(hcg) {
            var c = hcg[1] / 100;
            var g = hcg[2] / 100;
            var v = c + g * (1 - c);
            return [hcg[0], (v - c) * 100, (1 - v) * 100];
          };
          convert2.hwb.hcg = function(hwb) {
            var w = hwb[1] / 100;
            var b = hwb[2] / 100;
            var v = 1 - b;
            var c = v - w;
            var g = 0;
            if (c < 1) {
              g = (v - c) / (1 - c);
            }
            return [hwb[0], c * 100, g * 100];
          };
          convert2.apple.rgb = function(apple) {
            return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
          };
          convert2.rgb.apple = function(rgb) {
            return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
          };
          convert2.gray.rgb = function(args) {
            return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
          };
          convert2.gray.hsl = convert2.gray.hsv = function(args) {
            return [0, 0, args[0]];
          };
          convert2.gray.hwb = function(gray) {
            return [0, 100, gray[0]];
          };
          convert2.gray.cmyk = function(gray) {
            return [0, 0, 0, gray[0]];
          };
          convert2.gray.lab = function(gray) {
            return [gray[0], 0, 0];
          };
          convert2.gray.hex = function(gray) {
            var val = Math.round(gray[0] / 100 * 255) & 255;
            var integer = (val << 16) + (val << 8) + val;
            var string = integer.toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          };
          convert2.rgb.gray = function(rgb) {
            var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
            return [val / 255 * 100];
          };
        });
        var conversions_1 = conversions.rgb;
        var conversions_2 = conversions.hsl;
        var conversions_3 = conversions.hsv;
        var conversions_4 = conversions.hwb;
        var conversions_5 = conversions.cmyk;
        var conversions_6 = conversions.xyz;
        var conversions_7 = conversions.lab;
        var conversions_8 = conversions.lch;
        var conversions_9 = conversions.hex;
        var conversions_10 = conversions.keyword;
        var conversions_11 = conversions.ansi16;
        var conversions_12 = conversions.ansi256;
        var conversions_13 = conversions.hcg;
        var conversions_14 = conversions.apple;
        var conversions_15 = conversions.gray;
        function buildGraph() {
          var graph = {};
          var models2 = Object.keys(conversions);
          for (var len = models2.length, i = 0; i < len; i++) {
            graph[models2[i]] = {
              distance: -1,
              parent: null
            };
          }
          return graph;
        }
        function deriveBFS(fromModel) {
          var graph = buildGraph();
          var queue = [fromModel];
          graph[fromModel].distance = 0;
          while (queue.length) {
            var current = queue.pop();
            var adjacents = Object.keys(conversions[current]);
            for (var len = adjacents.length, i = 0; i < len; i++) {
              var adjacent = adjacents[i];
              var node = graph[adjacent];
              if (node.distance === -1) {
                node.distance = graph[current].distance + 1;
                node.parent = current;
                queue.unshift(adjacent);
              }
            }
          }
          return graph;
        }
        function link(from, to) {
          return function(args) {
            return to(from(args));
          };
        }
        function wrapConversion(toModel, graph) {
          var path = [graph[toModel].parent, toModel];
          var fn = conversions[graph[toModel].parent][toModel];
          var cur = graph[toModel].parent;
          while (graph[cur].parent) {
            path.unshift(graph[cur].parent);
            fn = link(conversions[graph[cur].parent][cur], fn);
            cur = graph[cur].parent;
          }
          fn.conversion = path;
          return fn;
        }
        var route = function(fromModel) {
          var graph = deriveBFS(fromModel);
          var conversion = {};
          var models2 = Object.keys(graph);
          for (var len = models2.length, i = 0; i < len; i++) {
            var toModel = models2[i];
            var node = graph[toModel];
            if (node.parent === null) {
              continue;
            }
            conversion[toModel] = wrapConversion(toModel, graph);
          }
          return conversion;
        };
        var convert = {};
        var models = Object.keys(conversions);
        function wrapRaw(fn) {
          var wrappedFn = function(args) {
            if (args === void 0 || args === null) {
              return args;
            }
            if (arguments.length > 1) {
              args = Array.prototype.slice.call(arguments);
            }
            return fn(args);
          };
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        function wrapRounded(fn) {
          var wrappedFn = function(args) {
            if (args === void 0 || args === null) {
              return args;
            }
            if (arguments.length > 1) {
              args = Array.prototype.slice.call(arguments);
            }
            var result = fn(args);
            if (typeof result === "object") {
              for (var len = result.length, i = 0; i < len; i++) {
                result[i] = Math.round(result[i]);
              }
            }
            return result;
          };
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        models.forEach(function(fromModel) {
          convert[fromModel] = {};
          Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
          Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
          var routes = route(fromModel);
          var routeModels = Object.keys(routes);
          routeModels.forEach(function(toModel) {
            var fn = routes[toModel];
            convert[fromModel][toModel] = wrapRounded(fn);
            convert[fromModel][toModel].raw = wrapRaw(fn);
          });
        });
        var colorConvert = convert;
        var colorName$1 = {
          "aliceblue": [240, 248, 255],
          "antiquewhite": [250, 235, 215],
          "aqua": [0, 255, 255],
          "aquamarine": [127, 255, 212],
          "azure": [240, 255, 255],
          "beige": [245, 245, 220],
          "bisque": [255, 228, 196],
          "black": [0, 0, 0],
          "blanchedalmond": [255, 235, 205],
          "blue": [0, 0, 255],
          "blueviolet": [138, 43, 226],
          "brown": [165, 42, 42],
          "burlywood": [222, 184, 135],
          "cadetblue": [95, 158, 160],
          "chartreuse": [127, 255, 0],
          "chocolate": [210, 105, 30],
          "coral": [255, 127, 80],
          "cornflowerblue": [100, 149, 237],
          "cornsilk": [255, 248, 220],
          "crimson": [220, 20, 60],
          "cyan": [0, 255, 255],
          "darkblue": [0, 0, 139],
          "darkcyan": [0, 139, 139],
          "darkgoldenrod": [184, 134, 11],
          "darkgray": [169, 169, 169],
          "darkgreen": [0, 100, 0],
          "darkgrey": [169, 169, 169],
          "darkkhaki": [189, 183, 107],
          "darkmagenta": [139, 0, 139],
          "darkolivegreen": [85, 107, 47],
          "darkorange": [255, 140, 0],
          "darkorchid": [153, 50, 204],
          "darkred": [139, 0, 0],
          "darksalmon": [233, 150, 122],
          "darkseagreen": [143, 188, 143],
          "darkslateblue": [72, 61, 139],
          "darkslategray": [47, 79, 79],
          "darkslategrey": [47, 79, 79],
          "darkturquoise": [0, 206, 209],
          "darkviolet": [148, 0, 211],
          "deeppink": [255, 20, 147],
          "deepskyblue": [0, 191, 255],
          "dimgray": [105, 105, 105],
          "dimgrey": [105, 105, 105],
          "dodgerblue": [30, 144, 255],
          "firebrick": [178, 34, 34],
          "floralwhite": [255, 250, 240],
          "forestgreen": [34, 139, 34],
          "fuchsia": [255, 0, 255],
          "gainsboro": [220, 220, 220],
          "ghostwhite": [248, 248, 255],
          "gold": [255, 215, 0],
          "goldenrod": [218, 165, 32],
          "gray": [128, 128, 128],
          "green": [0, 128, 0],
          "greenyellow": [173, 255, 47],
          "grey": [128, 128, 128],
          "honeydew": [240, 255, 240],
          "hotpink": [255, 105, 180],
          "indianred": [205, 92, 92],
          "indigo": [75, 0, 130],
          "ivory": [255, 255, 240],
          "khaki": [240, 230, 140],
          "lavender": [230, 230, 250],
          "lavenderblush": [255, 240, 245],
          "lawngreen": [124, 252, 0],
          "lemonchiffon": [255, 250, 205],
          "lightblue": [173, 216, 230],
          "lightcoral": [240, 128, 128],
          "lightcyan": [224, 255, 255],
          "lightgoldenrodyellow": [250, 250, 210],
          "lightgray": [211, 211, 211],
          "lightgreen": [144, 238, 144],
          "lightgrey": [211, 211, 211],
          "lightpink": [255, 182, 193],
          "lightsalmon": [255, 160, 122],
          "lightseagreen": [32, 178, 170],
          "lightskyblue": [135, 206, 250],
          "lightslategray": [119, 136, 153],
          "lightslategrey": [119, 136, 153],
          "lightsteelblue": [176, 196, 222],
          "lightyellow": [255, 255, 224],
          "lime": [0, 255, 0],
          "limegreen": [50, 205, 50],
          "linen": [250, 240, 230],
          "magenta": [255, 0, 255],
          "maroon": [128, 0, 0],
          "mediumaquamarine": [102, 205, 170],
          "mediumblue": [0, 0, 205],
          "mediumorchid": [186, 85, 211],
          "mediumpurple": [147, 112, 219],
          "mediumseagreen": [60, 179, 113],
          "mediumslateblue": [123, 104, 238],
          "mediumspringgreen": [0, 250, 154],
          "mediumturquoise": [72, 209, 204],
          "mediumvioletred": [199, 21, 133],
          "midnightblue": [25, 25, 112],
          "mintcream": [245, 255, 250],
          "mistyrose": [255, 228, 225],
          "moccasin": [255, 228, 181],
          "navajowhite": [255, 222, 173],
          "navy": [0, 0, 128],
          "oldlace": [253, 245, 230],
          "olive": [128, 128, 0],
          "olivedrab": [107, 142, 35],
          "orange": [255, 165, 0],
          "orangered": [255, 69, 0],
          "orchid": [218, 112, 214],
          "palegoldenrod": [238, 232, 170],
          "palegreen": [152, 251, 152],
          "paleturquoise": [175, 238, 238],
          "palevioletred": [219, 112, 147],
          "papayawhip": [255, 239, 213],
          "peachpuff": [255, 218, 185],
          "peru": [205, 133, 63],
          "pink": [255, 192, 203],
          "plum": [221, 160, 221],
          "powderblue": [176, 224, 230],
          "purple": [128, 0, 128],
          "rebeccapurple": [102, 51, 153],
          "red": [255, 0, 0],
          "rosybrown": [188, 143, 143],
          "royalblue": [65, 105, 225],
          "saddlebrown": [139, 69, 19],
          "salmon": [250, 128, 114],
          "sandybrown": [244, 164, 96],
          "seagreen": [46, 139, 87],
          "seashell": [255, 245, 238],
          "sienna": [160, 82, 45],
          "silver": [192, 192, 192],
          "skyblue": [135, 206, 235],
          "slateblue": [106, 90, 205],
          "slategray": [112, 128, 144],
          "slategrey": [112, 128, 144],
          "snow": [255, 250, 250],
          "springgreen": [0, 255, 127],
          "steelblue": [70, 130, 180],
          "tan": [210, 180, 140],
          "teal": [0, 128, 128],
          "thistle": [216, 191, 216],
          "tomato": [255, 99, 71],
          "turquoise": [64, 224, 208],
          "violet": [238, 130, 238],
          "wheat": [245, 222, 179],
          "white": [255, 255, 255],
          "whitesmoke": [245, 245, 245],
          "yellow": [255, 255, 0],
          "yellowgreen": [154, 205, 50]
        };
        var colorString = {
          getRgba,
          getHsla,
          getRgb,
          getHsl,
          getHwb,
          getAlpha,
          hexString,
          rgbString,
          rgbaString,
          percentString,
          percentaString,
          hslString,
          hslaString,
          hwbString,
          keyword
        };
        function getRgba(string) {
          if (!string) {
            return;
          }
          var abbr = /^#([a-fA-F0-9]{3,4})$/i, hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i, rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, keyword2 = /(\w+)/;
          var rgb = [0, 0, 0], a = 1, match = string.match(abbr), hexAlpha = "";
          if (match) {
            match = match[1];
            hexAlpha = match[3];
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = parseInt(match[i] + match[i], 16);
            }
            if (hexAlpha) {
              a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
            }
          } else if (match = string.match(hex)) {
            hexAlpha = match[2];
            match = match[1];
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
            }
            if (hexAlpha) {
              a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
            }
          } else if (match = string.match(rgba)) {
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = parseInt(match[i + 1]);
            }
            a = parseFloat(match[4]);
          } else if (match = string.match(per)) {
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
            }
            a = parseFloat(match[4]);
          } else if (match = string.match(keyword2)) {
            if (match[1] == "transparent") {
              return [0, 0, 0, 0];
            }
            rgb = colorName$1[match[1]];
            if (!rgb) {
              return;
            }
          }
          for (var i = 0; i < rgb.length; i++) {
            rgb[i] = scale(rgb[i], 0, 255);
          }
          if (!a && a != 0) {
            a = 1;
          } else {
            a = scale(a, 0, 1);
          }
          rgb[3] = a;
          return rgb;
        }
        function getHsla(string) {
          if (!string) {
            return;
          }
          var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
          var match = string.match(hsl);
          if (match) {
            var alpha = parseFloat(match[4]);
            var h = scale(parseInt(match[1]), 0, 360), s = scale(parseFloat(match[2]), 0, 100), l = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
            return [h, s, l, a];
          }
        }
        function getHwb(string) {
          if (!string) {
            return;
          }
          var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
          var match = string.match(hwb);
          if (match) {
            var alpha = parseFloat(match[4]);
            var h = scale(parseInt(match[1]), 0, 360), w = scale(parseFloat(match[2]), 0, 100), b = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
            return [h, w, b, a];
          }
        }
        function getRgb(string) {
          var rgba = getRgba(string);
          return rgba && rgba.slice(0, 3);
        }
        function getHsl(string) {
          var hsla = getHsla(string);
          return hsla && hsla.slice(0, 3);
        }
        function getAlpha(string) {
          var vals = getRgba(string);
          if (vals) {
            return vals[3];
          } else if (vals = getHsla(string)) {
            return vals[3];
          } else if (vals = getHwb(string)) {
            return vals[3];
          }
        }
        function hexString(rgba, a) {
          var a = a !== void 0 && rgba.length === 3 ? a : rgba[3];
          return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
        }
        function rgbString(rgba, alpha) {
          if (alpha < 1 || rgba[3] && rgba[3] < 1) {
            return rgbaString(rgba, alpha);
          }
          return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
        }
        function rgbaString(rgba, alpha) {
          if (alpha === void 0) {
            alpha = rgba[3] !== void 0 ? rgba[3] : 1;
          }
          return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
        }
        function percentString(rgba, alpha) {
          if (alpha < 1 || rgba[3] && rgba[3] < 1) {
            return percentaString(rgba, alpha);
          }
          var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
          return "rgb(" + r + "%, " + g + "%, " + b + "%)";
        }
        function percentaString(rgba, alpha) {
          var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
          return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
        }
        function hslString(hsla, alpha) {
          if (alpha < 1 || hsla[3] && hsla[3] < 1) {
            return hslaString(hsla, alpha);
          }
          return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
        }
        function hslaString(hsla, alpha) {
          if (alpha === void 0) {
            alpha = hsla[3] !== void 0 ? hsla[3] : 1;
          }
          return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
        }
        function hwbString(hwb, alpha) {
          if (alpha === void 0) {
            alpha = hwb[3] !== void 0 ? hwb[3] : 1;
          }
          return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== void 0 && alpha !== 1 ? ", " + alpha : "") + ")";
        }
        function keyword(rgb) {
          return reverseNames[rgb.slice(0, 3)];
        }
        function scale(num, min, max) {
          return Math.min(Math.max(min, num), max);
        }
        function hexDouble(num) {
          var str = num.toString(16).toUpperCase();
          return str.length < 2 ? "0" + str : str;
        }
        var reverseNames = {};
        for (var name in colorName$1) {
          reverseNames[colorName$1[name]] = name;
        }
        var Color = function(obj) {
          if (obj instanceof Color) {
            return obj;
          }
          if (!(this instanceof Color)) {
            return new Color(obj);
          }
          this.valid = false;
          this.values = {
            rgb: [0, 0, 0],
            hsl: [0, 0, 0],
            hsv: [0, 0, 0],
            hwb: [0, 0, 0],
            cmyk: [0, 0, 0, 0],
            alpha: 1
          };
          var vals;
          if (typeof obj === "string") {
            vals = colorString.getRgba(obj);
            if (vals) {
              this.setValues("rgb", vals);
            } else if (vals = colorString.getHsla(obj)) {
              this.setValues("hsl", vals);
            } else if (vals = colorString.getHwb(obj)) {
              this.setValues("hwb", vals);
            }
          } else if (typeof obj === "object") {
            vals = obj;
            if (vals.r !== void 0 || vals.red !== void 0) {
              this.setValues("rgb", vals);
            } else if (vals.l !== void 0 || vals.lightness !== void 0) {
              this.setValues("hsl", vals);
            } else if (vals.v !== void 0 || vals.value !== void 0) {
              this.setValues("hsv", vals);
            } else if (vals.w !== void 0 || vals.whiteness !== void 0) {
              this.setValues("hwb", vals);
            } else if (vals.c !== void 0 || vals.cyan !== void 0) {
              this.setValues("cmyk", vals);
            }
          }
        };
        Color.prototype = {
          isValid: function() {
            return this.valid;
          },
          rgb: function() {
            return this.setSpace("rgb", arguments);
          },
          hsl: function() {
            return this.setSpace("hsl", arguments);
          },
          hsv: function() {
            return this.setSpace("hsv", arguments);
          },
          hwb: function() {
            return this.setSpace("hwb", arguments);
          },
          cmyk: function() {
            return this.setSpace("cmyk", arguments);
          },
          rgbArray: function() {
            return this.values.rgb;
          },
          hslArray: function() {
            return this.values.hsl;
          },
          hsvArray: function() {
            return this.values.hsv;
          },
          hwbArray: function() {
            var values = this.values;
            if (values.alpha !== 1) {
              return values.hwb.concat([values.alpha]);
            }
            return values.hwb;
          },
          cmykArray: function() {
            return this.values.cmyk;
          },
          rgbaArray: function() {
            var values = this.values;
            return values.rgb.concat([values.alpha]);
          },
          hslaArray: function() {
            var values = this.values;
            return values.hsl.concat([values.alpha]);
          },
          alpha: function(val) {
            if (val === void 0) {
              return this.values.alpha;
            }
            this.setValues("alpha", val);
            return this;
          },
          red: function(val) {
            return this.setChannel("rgb", 0, val);
          },
          green: function(val) {
            return this.setChannel("rgb", 1, val);
          },
          blue: function(val) {
            return this.setChannel("rgb", 2, val);
          },
          hue: function(val) {
            if (val) {
              val %= 360;
              val = val < 0 ? 360 + val : val;
            }
            return this.setChannel("hsl", 0, val);
          },
          saturation: function(val) {
            return this.setChannel("hsl", 1, val);
          },
          lightness: function(val) {
            return this.setChannel("hsl", 2, val);
          },
          saturationv: function(val) {
            return this.setChannel("hsv", 1, val);
          },
          whiteness: function(val) {
            return this.setChannel("hwb", 1, val);
          },
          blackness: function(val) {
            return this.setChannel("hwb", 2, val);
          },
          value: function(val) {
            return this.setChannel("hsv", 2, val);
          },
          cyan: function(val) {
            return this.setChannel("cmyk", 0, val);
          },
          magenta: function(val) {
            return this.setChannel("cmyk", 1, val);
          },
          yellow: function(val) {
            return this.setChannel("cmyk", 2, val);
          },
          black: function(val) {
            return this.setChannel("cmyk", 3, val);
          },
          hexString: function() {
            return colorString.hexString(this.values.rgb);
          },
          rgbString: function() {
            return colorString.rgbString(this.values.rgb, this.values.alpha);
          },
          rgbaString: function() {
            return colorString.rgbaString(this.values.rgb, this.values.alpha);
          },
          percentString: function() {
            return colorString.percentString(this.values.rgb, this.values.alpha);
          },
          hslString: function() {
            return colorString.hslString(this.values.hsl, this.values.alpha);
          },
          hslaString: function() {
            return colorString.hslaString(this.values.hsl, this.values.alpha);
          },
          hwbString: function() {
            return colorString.hwbString(this.values.hwb, this.values.alpha);
          },
          keyword: function() {
            return colorString.keyword(this.values.rgb, this.values.alpha);
          },
          rgbNumber: function() {
            var rgb = this.values.rgb;
            return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
          },
          luminosity: function() {
            var rgb = this.values.rgb;
            var lum = [];
            for (var i = 0; i < rgb.length; i++) {
              var chan = rgb[i] / 255;
              lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
          },
          contrast: function(color2) {
            var lum1 = this.luminosity();
            var lum2 = color2.luminosity();
            if (lum1 > lum2) {
              return (lum1 + 0.05) / (lum2 + 0.05);
            }
            return (lum2 + 0.05) / (lum1 + 0.05);
          },
          level: function(color2) {
            var contrastRatio = this.contrast(color2);
            if (contrastRatio >= 7.1) {
              return "AAA";
            }
            return contrastRatio >= 4.5 ? "AA" : "";
          },
          dark: function() {
            var rgb = this.values.rgb;
            var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
            return yiq < 128;
          },
          light: function() {
            return !this.dark();
          },
          negate: function() {
            var rgb = [];
            for (var i = 0; i < 3; i++) {
              rgb[i] = 255 - this.values.rgb[i];
            }
            this.setValues("rgb", rgb);
            return this;
          },
          lighten: function(ratio) {
            var hsl = this.values.hsl;
            hsl[2] += hsl[2] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          darken: function(ratio) {
            var hsl = this.values.hsl;
            hsl[2] -= hsl[2] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          saturate: function(ratio) {
            var hsl = this.values.hsl;
            hsl[1] += hsl[1] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          desaturate: function(ratio) {
            var hsl = this.values.hsl;
            hsl[1] -= hsl[1] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          whiten: function(ratio) {
            var hwb = this.values.hwb;
            hwb[1] += hwb[1] * ratio;
            this.setValues("hwb", hwb);
            return this;
          },
          blacken: function(ratio) {
            var hwb = this.values.hwb;
            hwb[2] += hwb[2] * ratio;
            this.setValues("hwb", hwb);
            return this;
          },
          greyscale: function() {
            var rgb = this.values.rgb;
            var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
            this.setValues("rgb", [val, val, val]);
            return this;
          },
          clearer: function(ratio) {
            var alpha = this.values.alpha;
            this.setValues("alpha", alpha - alpha * ratio);
            return this;
          },
          opaquer: function(ratio) {
            var alpha = this.values.alpha;
            this.setValues("alpha", alpha + alpha * ratio);
            return this;
          },
          rotate: function(degrees) {
            var hsl = this.values.hsl;
            var hue = (hsl[0] + degrees) % 360;
            hsl[0] = hue < 0 ? 360 + hue : hue;
            this.setValues("hsl", hsl);
            return this;
          },
          mix: function(mixinColor, weight) {
            var color1 = this;
            var color2 = mixinColor;
            var p = weight === void 0 ? 0.5 : weight;
            var w = 2 * p - 1;
            var a = color1.alpha() - color2.alpha();
            var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
            var w2 = 1 - w1;
            return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
          },
          toJSON: function() {
            return this.rgb();
          },
          clone: function() {
            var result = new Color();
            var source = this.values;
            var target = result.values;
            var value, type;
            for (var prop in source) {
              if (source.hasOwnProperty(prop)) {
                value = source[prop];
                type = {}.toString.call(value);
                if (type === "[object Array]") {
                  target[prop] = value.slice(0);
                } else if (type === "[object Number]") {
                  target[prop] = value;
                } else {
                  console.error("unexpected color value:", value);
                }
              }
            }
            return result;
          }
        };
        Color.prototype.spaces = {
          rgb: ["red", "green", "blue"],
          hsl: ["hue", "saturation", "lightness"],
          hsv: ["hue", "saturation", "value"],
          hwb: ["hue", "whiteness", "blackness"],
          cmyk: ["cyan", "magenta", "yellow", "black"]
        };
        Color.prototype.maxes = {
          rgb: [255, 255, 255],
          hsl: [360, 100, 100],
          hsv: [360, 100, 100],
          hwb: [360, 100, 100],
          cmyk: [100, 100, 100, 100]
        };
        Color.prototype.getValues = function(space) {
          var values = this.values;
          var vals = {};
          for (var i = 0; i < space.length; i++) {
            vals[space.charAt(i)] = values[space][i];
          }
          if (values.alpha !== 1) {
            vals.a = values.alpha;
          }
          return vals;
        };
        Color.prototype.setValues = function(space, vals) {
          var values = this.values;
          var spaces = this.spaces;
          var maxes = this.maxes;
          var alpha = 1;
          var i;
          this.valid = true;
          if (space === "alpha") {
            alpha = vals;
          } else if (vals.length) {
            values[space] = vals.slice(0, space.length);
            alpha = vals[space.length];
          } else if (vals[space.charAt(0)] !== void 0) {
            for (i = 0; i < space.length; i++) {
              values[space][i] = vals[space.charAt(i)];
            }
            alpha = vals.a;
          } else if (vals[spaces[space][0]] !== void 0) {
            var chans = spaces[space];
            for (i = 0; i < space.length; i++) {
              values[space][i] = vals[chans[i]];
            }
            alpha = vals.alpha;
          }
          values.alpha = Math.max(0, Math.min(1, alpha === void 0 ? values.alpha : alpha));
          if (space === "alpha") {
            return false;
          }
          var capped;
          for (i = 0; i < space.length; i++) {
            capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
            values[space][i] = Math.round(capped);
          }
          for (var sname in spaces) {
            if (sname !== space) {
              values[sname] = colorConvert[space][sname](values[space]);
            }
          }
          return true;
        };
        Color.prototype.setSpace = function(space, args) {
          var vals = args[0];
          if (vals === void 0) {
            return this.getValues(space);
          }
          if (typeof vals === "number") {
            vals = Array.prototype.slice.call(args);
          }
          this.setValues(space, vals);
          return this;
        };
        Color.prototype.setChannel = function(space, index, val) {
          var svalues = this.values[space];
          if (val === void 0) {
            return svalues[index];
          } else if (val === svalues[index]) {
            return this;
          }
          svalues[index] = val;
          this.setValues(space, svalues);
          return this;
        };
        if (typeof window !== "undefined") {
          window.Color = Color;
        }
        var chartjsColor = Color;
        function isValidKey(key) {
          return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
        }
        var helpers = {
          noop: function() {
          },
          uid: function() {
            var id = 0;
            return function() {
              return id++;
            };
          }(),
          isNullOrUndef: function(value) {
            return value === null || typeof value === "undefined";
          },
          isArray: function(value) {
            if (Array.isArray && Array.isArray(value)) {
              return true;
            }
            var type = Object.prototype.toString.call(value);
            if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
              return true;
            }
            return false;
          },
          isObject: function(value) {
            return value !== null && Object.prototype.toString.call(value) === "[object Object]";
          },
          isFinite: function(value) {
            return (typeof value === "number" || value instanceof Number) && isFinite(value);
          },
          valueOrDefault: function(value, defaultValue) {
            return typeof value === "undefined" ? defaultValue : value;
          },
          valueAtIndexOrDefault: function(value, index, defaultValue) {
            return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
          },
          callback: function(fn, args, thisArg) {
            if (fn && typeof fn.call === "function") {
              return fn.apply(thisArg, args);
            }
          },
          each: function(loopable, fn, thisArg, reverse) {
            var i, len, keys;
            if (helpers.isArray(loopable)) {
              len = loopable.length;
              if (reverse) {
                for (i = len - 1; i >= 0; i--) {
                  fn.call(thisArg, loopable[i], i);
                }
              } else {
                for (i = 0; i < len; i++) {
                  fn.call(thisArg, loopable[i], i);
                }
              }
            } else if (helpers.isObject(loopable)) {
              keys = Object.keys(loopable);
              len = keys.length;
              for (i = 0; i < len; i++) {
                fn.call(thisArg, loopable[keys[i]], keys[i]);
              }
            }
          },
          arrayEquals: function(a0, a1) {
            var i, ilen, v0, v1;
            if (!a0 || !a1 || a0.length !== a1.length) {
              return false;
            }
            for (i = 0, ilen = a0.length; i < ilen; ++i) {
              v0 = a0[i];
              v1 = a1[i];
              if (v0 instanceof Array && v1 instanceof Array) {
                if (!helpers.arrayEquals(v0, v1)) {
                  return false;
                }
              } else if (v0 !== v1) {
                return false;
              }
            }
            return true;
          },
          clone: function(source) {
            if (helpers.isArray(source)) {
              return source.map(helpers.clone);
            }
            if (helpers.isObject(source)) {
              var target = Object.create(source);
              var keys = Object.keys(source);
              var klen = keys.length;
              var k2 = 0;
              for (; k2 < klen; ++k2) {
                target[keys[k2]] = helpers.clone(source[keys[k2]]);
              }
              return target;
            }
            return source;
          },
          _merger: function(key, target, source, options2) {
            if (!isValidKey(key)) {
              return;
            }
            var tval = target[key];
            var sval = source[key];
            if (helpers.isObject(tval) && helpers.isObject(sval)) {
              helpers.merge(tval, sval, options2);
            } else {
              target[key] = helpers.clone(sval);
            }
          },
          _mergerIf: function(key, target, source) {
            if (!isValidKey(key)) {
              return;
            }
            var tval = target[key];
            var sval = source[key];
            if (helpers.isObject(tval) && helpers.isObject(sval)) {
              helpers.mergeIf(tval, sval);
            } else if (!target.hasOwnProperty(key)) {
              target[key] = helpers.clone(sval);
            }
          },
          merge: function(target, source, options2) {
            var sources = helpers.isArray(source) ? source : [source];
            var ilen = sources.length;
            var merge, i, keys, klen, k2;
            if (!helpers.isObject(target)) {
              return target;
            }
            options2 = options2 || {};
            merge = options2.merger || helpers._merger;
            for (i = 0; i < ilen; ++i) {
              source = sources[i];
              if (!helpers.isObject(source)) {
                continue;
              }
              keys = Object.keys(source);
              for (k2 = 0, klen = keys.length; k2 < klen; ++k2) {
                merge(keys[k2], target, source, options2);
              }
            }
            return target;
          },
          mergeIf: function(target, source) {
            return helpers.merge(target, source, { merger: helpers._mergerIf });
          },
          extend: Object.assign || function(target) {
            return helpers.merge(target, [].slice.call(arguments, 1), {
              merger: function(key, dst, src2) {
                dst[key] = src2[key];
              }
            });
          },
          inherits: function(extensions) {
            var me = this;
            var ChartElement = extensions && extensions.hasOwnProperty("constructor") ? extensions.constructor : function() {
              return me.apply(this, arguments);
            };
            var Surrogate = function() {
              this.constructor = ChartElement;
            };
            Surrogate.prototype = me.prototype;
            ChartElement.prototype = new Surrogate();
            ChartElement.extend = helpers.inherits;
            if (extensions) {
              helpers.extend(ChartElement.prototype, extensions);
            }
            ChartElement.__super__ = me.prototype;
            return ChartElement;
          },
          _deprecated: function(scope, value, previous, current) {
            if (value !== void 0) {
              console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
            }
          }
        };
        var helpers_core = helpers;
        helpers.callCallback = helpers.callback;
        helpers.indexOf = function(array, item, fromIndex) {
          return Array.prototype.indexOf.call(array, item, fromIndex);
        };
        helpers.getValueOrDefault = helpers.valueOrDefault;
        helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
        var effects = {
          linear: function(t) {
            return t;
          },
          easeInQuad: function(t) {
            return t * t;
          },
          easeOutQuad: function(t) {
            return -t * (t - 2);
          },
          easeInOutQuad: function(t) {
            if ((t /= 0.5) < 1) {
              return 0.5 * t * t;
            }
            return -0.5 * (--t * (t - 2) - 1);
          },
          easeInCubic: function(t) {
            return t * t * t;
          },
          easeOutCubic: function(t) {
            return (t = t - 1) * t * t + 1;
          },
          easeInOutCubic: function(t) {
            if ((t /= 0.5) < 1) {
              return 0.5 * t * t * t;
            }
            return 0.5 * ((t -= 2) * t * t + 2);
          },
          easeInQuart: function(t) {
            return t * t * t * t;
          },
          easeOutQuart: function(t) {
            return -((t = t - 1) * t * t * t - 1);
          },
          easeInOutQuart: function(t) {
            if ((t /= 0.5) < 1) {
              return 0.5 * t * t * t * t;
            }
            return -0.5 * ((t -= 2) * t * t * t - 2);
          },
          easeInQuint: function(t) {
            return t * t * t * t * t;
          },
          easeOutQuint: function(t) {
            return (t = t - 1) * t * t * t * t + 1;
          },
          easeInOutQuint: function(t) {
            if ((t /= 0.5) < 1) {
              return 0.5 * t * t * t * t * t;
            }
            return 0.5 * ((t -= 2) * t * t * t * t + 2);
          },
          easeInSine: function(t) {
            return -Math.cos(t * (Math.PI / 2)) + 1;
          },
          easeOutSine: function(t) {
            return Math.sin(t * (Math.PI / 2));
          },
          easeInOutSine: function(t) {
            return -0.5 * (Math.cos(Math.PI * t) - 1);
          },
          easeInExpo: function(t) {
            return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
          },
          easeOutExpo: function(t) {
            return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
          },
          easeInOutExpo: function(t) {
            if (t === 0) {
              return 0;
            }
            if (t === 1) {
              return 1;
            }
            if ((t /= 0.5) < 1) {
              return 0.5 * Math.pow(2, 10 * (t - 1));
            }
            return 0.5 * (-Math.pow(2, -10 * --t) + 2);
          },
          easeInCirc: function(t) {
            if (t >= 1) {
              return t;
            }
            return -(Math.sqrt(1 - t * t) - 1);
          },
          easeOutCirc: function(t) {
            return Math.sqrt(1 - (t = t - 1) * t);
          },
          easeInOutCirc: function(t) {
            if ((t /= 0.5) < 1) {
              return -0.5 * (Math.sqrt(1 - t * t) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
          },
          easeInElastic: function(t) {
            var s = 1.70158;
            var p = 0;
            var a = 1;
            if (t === 0) {
              return 0;
            }
            if (t === 1) {
              return 1;
            }
            if (!p) {
              p = 0.3;
            }
            if (a < 1) {
              a = 1;
              s = p / 4;
            } else {
              s = p / (2 * Math.PI) * Math.asin(1 / a);
            }
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
          },
          easeOutElastic: function(t) {
            var s = 1.70158;
            var p = 0;
            var a = 1;
            if (t === 0) {
              return 0;
            }
            if (t === 1) {
              return 1;
            }
            if (!p) {
              p = 0.3;
            }
            if (a < 1) {
              a = 1;
              s = p / 4;
            } else {
              s = p / (2 * Math.PI) * Math.asin(1 / a);
            }
            return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
          },
          easeInOutElastic: function(t) {
            var s = 1.70158;
            var p = 0;
            var a = 1;
            if (t === 0) {
              return 0;
            }
            if ((t /= 0.5) === 2) {
              return 1;
            }
            if (!p) {
              p = 0.45;
            }
            if (a < 1) {
              a = 1;
              s = p / 4;
            } else {
              s = p / (2 * Math.PI) * Math.asin(1 / a);
            }
            if (t < 1) {
              return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
            }
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
          },
          easeInBack: function(t) {
            var s = 1.70158;
            return t * t * ((s + 1) * t - s);
          },
          easeOutBack: function(t) {
            var s = 1.70158;
            return (t = t - 1) * t * ((s + 1) * t + s) + 1;
          },
          easeInOutBack: function(t) {
            var s = 1.70158;
            if ((t /= 0.5) < 1) {
              return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
            }
            return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
          },
          easeInBounce: function(t) {
            return 1 - effects.easeOutBounce(1 - t);
          },
          easeOutBounce: function(t) {
            if (t < 1 / 2.75) {
              return 7.5625 * t * t;
            }
            if (t < 2 / 2.75) {
              return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
            }
            if (t < 2.5 / 2.75) {
              return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
            }
            return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
          },
          easeInOutBounce: function(t) {
            if (t < 0.5) {
              return effects.easeInBounce(t * 2) * 0.5;
            }
            return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
          }
        };
        var helpers_easing = {
          effects
        };
        helpers_core.easingEffects = effects;
        var PI = Math.PI;
        var RAD_PER_DEG = PI / 180;
        var DOUBLE_PI = PI * 2;
        var HALF_PI = PI / 2;
        var QUARTER_PI = PI / 4;
        var TWO_THIRDS_PI = PI * 2 / 3;
        var exports$1 = {
          clear: function(chart) {
            chart.ctx.clearRect(0, 0, chart.width, chart.height);
          },
          roundedRect: function(ctx, x, y, width, height, radius) {
            if (radius) {
              var r = Math.min(radius, height / 2, width / 2);
              var left = x + r;
              var top = y + r;
              var right = x + width - r;
              var bottom = y + height - r;
              ctx.moveTo(x, top);
              if (left < right && top < bottom) {
                ctx.arc(left, top, r, -PI, -HALF_PI);
                ctx.arc(right, top, r, -HALF_PI, 0);
                ctx.arc(right, bottom, r, 0, HALF_PI);
                ctx.arc(left, bottom, r, HALF_PI, PI);
              } else if (left < right) {
                ctx.moveTo(left, y);
                ctx.arc(right, top, r, -HALF_PI, HALF_PI);
                ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
              } else if (top < bottom) {
                ctx.arc(left, top, r, -PI, 0);
                ctx.arc(left, bottom, r, 0, PI);
              } else {
                ctx.arc(left, top, r, -PI, PI);
              }
              ctx.closePath();
              ctx.moveTo(x, y);
            } else {
              ctx.rect(x, y, width, height);
            }
          },
          drawPoint: function(ctx, style, radius, x, y, rotation) {
            var type, xOffset, yOffset, size, cornerRadius;
            var rad = (rotation || 0) * RAD_PER_DEG;
            if (style && typeof style === "object") {
              type = style.toString();
              if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rad);
                ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
                ctx.restore();
                return;
              }
            }
            if (isNaN(radius) || radius <= 0) {
              return;
            }
            ctx.beginPath();
            switch (style) {
              default:
                ctx.arc(x, y, radius, 0, DOUBLE_PI);
                ctx.closePath();
                break;
              case "triangle":
                ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                ctx.closePath();
                break;
              case "rectRounded":
                cornerRadius = radius * 0.516;
                size = radius - cornerRadius;
                xOffset = Math.cos(rad + QUARTER_PI) * size;
                yOffset = Math.sin(rad + QUARTER_PI) * size;
                ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
                ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
                ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
                ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
                ctx.closePath();
                break;
              case "rect":
                if (!rotation) {
                  size = Math.SQRT1_2 * radius;
                  ctx.rect(x - size, y - size, 2 * size, 2 * size);
                  break;
                }
                rad += QUARTER_PI;
              case "rectRot":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + yOffset, y - xOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                ctx.closePath();
                break;
              case "crossRot":
                rad += QUARTER_PI;
              case "cross":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.moveTo(x + yOffset, y - xOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                break;
              case "star":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.moveTo(x + yOffset, y - xOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                rad += QUARTER_PI;
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.moveTo(x + yOffset, y - xOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                break;
              case "line":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                break;
              case "dash":
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
                break;
            }
            ctx.fill();
            ctx.stroke();
          },
          _isPointInArea: function(point, area) {
            var epsilon = 1e-6;
            return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
          },
          clipArea: function(ctx, area) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
            ctx.clip();
          },
          unclipArea: function(ctx) {
            ctx.restore();
          },
          lineTo: function(ctx, previous, target, flip) {
            var stepped = target.steppedLine;
            if (stepped) {
              if (stepped === "middle") {
                var midpoint = (previous.x + target.x) / 2;
                ctx.lineTo(midpoint, flip ? target.y : previous.y);
                ctx.lineTo(midpoint, flip ? previous.y : target.y);
              } else if (stepped === "after" && !flip || stepped !== "after" && flip) {
                ctx.lineTo(previous.x, target.y);
              } else {
                ctx.lineTo(target.x, previous.y);
              }
              ctx.lineTo(target.x, target.y);
              return;
            }
            if (!target.tension) {
              ctx.lineTo(target.x, target.y);
              return;
            }
            ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
          }
        };
        var helpers_canvas = exports$1;
        helpers_core.clear = exports$1.clear;
        helpers_core.drawRoundedRectangle = function(ctx) {
          ctx.beginPath();
          exports$1.roundedRect.apply(exports$1, arguments);
        };
        var defaults = {
          _set: function(scope, values) {
            return helpers_core.merge(this[scope] || (this[scope] = {}), values);
          }
        };
        defaults._set("global", {
          defaultColor: "rgba(0,0,0,0.1)",
          defaultFontColor: "#666",
          defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
          defaultFontSize: 12,
          defaultFontStyle: "normal",
          defaultLineHeight: 1.2,
          showLines: true
        });
        var core_defaults = defaults;
        var valueOrDefault = helpers_core.valueOrDefault;
        function toFontString(font) {
          if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
            return null;
          }
          return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
        }
        var helpers_options = {
          toLineHeight: function(value, size) {
            var matches = ("" + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
            if (!matches || matches[1] === "normal") {
              return size * 1.2;
            }
            value = +matches[2];
            switch (matches[3]) {
              case "px":
                return value;
              case "%":
                value /= 100;
                break;
            }
            return size * value;
          },
          toPadding: function(value) {
            var t, r, b, l;
            if (helpers_core.isObject(value)) {
              t = +value.top || 0;
              r = +value.right || 0;
              b = +value.bottom || 0;
              l = +value.left || 0;
            } else {
              t = r = b = l = +value || 0;
            }
            return {
              top: t,
              right: r,
              bottom: b,
              left: l,
              height: t + b,
              width: l + r
            };
          },
          _parseFont: function(options2) {
            var globalDefaults = core_defaults.global;
            var size = valueOrDefault(options2.fontSize, globalDefaults.defaultFontSize);
            var font = {
              family: valueOrDefault(options2.fontFamily, globalDefaults.defaultFontFamily),
              lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options2.lineHeight, globalDefaults.defaultLineHeight), size),
              size,
              style: valueOrDefault(options2.fontStyle, globalDefaults.defaultFontStyle),
              weight: null,
              string: ""
            };
            font.string = toFontString(font);
            return font;
          },
          resolve: function(inputs, context, index, info) {
            var cacheable = true;
            var i, ilen, value;
            for (i = 0, ilen = inputs.length; i < ilen; ++i) {
              value = inputs[i];
              if (value === void 0) {
                continue;
              }
              if (context !== void 0 && typeof value === "function") {
                value = value(context);
                cacheable = false;
              }
              if (index !== void 0 && helpers_core.isArray(value)) {
                value = value[index];
                cacheable = false;
              }
              if (value !== void 0) {
                if (info && !cacheable) {
                  info.cacheable = false;
                }
                return value;
              }
            }
          }
        };
        var exports$2 = {
          _factorize: function(value) {
            var result = [];
            var sqrt = Math.sqrt(value);
            var i;
            for (i = 1; i < sqrt; i++) {
              if (value % i === 0) {
                result.push(i);
                result.push(value / i);
              }
            }
            if (sqrt === (sqrt | 0)) {
              result.push(sqrt);
            }
            result.sort(function(a, b) {
              return a - b;
            }).pop();
            return result;
          },
          log10: Math.log10 || function(x) {
            var exponent = Math.log(x) * Math.LOG10E;
            var powerOf10 = Math.round(exponent);
            var isPowerOf10 = x === Math.pow(10, powerOf10);
            return isPowerOf10 ? powerOf10 : exponent;
          }
        };
        var helpers_math = exports$2;
        helpers_core.log10 = exports$2.log10;
        var getRtlAdapter = function(rectX, width) {
          return {
            x: function(x) {
              return rectX + rectX + width - x;
            },
            setWidth: function(w) {
              width = w;
            },
            textAlign: function(align) {
              if (align === "center") {
                return align;
              }
              return align === "right" ? "left" : "right";
            },
            xPlus: function(x, value) {
              return x - value;
            },
            leftForLtr: function(x, itemWidth) {
              return x - itemWidth;
            }
          };
        };
        var getLtrAdapter = function() {
          return {
            x: function(x) {
              return x;
            },
            setWidth: function(w) {
            },
            textAlign: function(align) {
              return align;
            },
            xPlus: function(x, value) {
              return x + value;
            },
            leftForLtr: function(x, _itemWidth) {
              return x;
            }
          };
        };
        var getAdapter = function(rtl2, rectX, width) {
          return rtl2 ? getRtlAdapter(rectX, width) : getLtrAdapter();
        };
        var overrideTextDirection = function(ctx, direction) {
          var style, original;
          if (direction === "ltr" || direction === "rtl") {
            style = ctx.canvas.style;
            original = [
              style.getPropertyValue("direction"),
              style.getPropertyPriority("direction")
            ];
            style.setProperty("direction", direction, "important");
            ctx.prevTextDirection = original;
          }
        };
        var restoreTextDirection = function(ctx) {
          var original = ctx.prevTextDirection;
          if (original !== void 0) {
            delete ctx.prevTextDirection;
            ctx.canvas.style.setProperty("direction", original[0], original[1]);
          }
        };
        var helpers_rtl = {
          getRtlAdapter: getAdapter,
          overrideTextDirection,
          restoreTextDirection
        };
        var helpers$1 = helpers_core;
        var easing = helpers_easing;
        var canvas = helpers_canvas;
        var options = helpers_options;
        var math = helpers_math;
        var rtl = helpers_rtl;
        helpers$1.easing = easing;
        helpers$1.canvas = canvas;
        helpers$1.options = options;
        helpers$1.math = math;
        helpers$1.rtl = rtl;
        function interpolate(start, view, model, ease) {
          var keys = Object.keys(model);
          var i, ilen, key, actual, origin, target, type, c0, c1;
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            target = model[key];
            if (!view.hasOwnProperty(key)) {
              view[key] = target;
            }
            actual = view[key];
            if (actual === target || key[0] === "_") {
              continue;
            }
            if (!start.hasOwnProperty(key)) {
              start[key] = actual;
            }
            origin = start[key];
            type = typeof target;
            if (type === typeof origin) {
              if (type === "string") {
                c0 = chartjsColor(origin);
                if (c0.valid) {
                  c1 = chartjsColor(target);
                  if (c1.valid) {
                    view[key] = c1.mix(c0, ease).rgbString();
                    continue;
                  }
                }
              } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
                view[key] = origin + (target - origin) * ease;
                continue;
              }
            }
            view[key] = target;
          }
        }
        var Element2 = function(configuration) {
          helpers$1.extend(this, configuration);
          this.initialize.apply(this, arguments);
        };
        helpers$1.extend(Element2.prototype, {
          _type: void 0,
          initialize: function() {
            this.hidden = false;
          },
          pivot: function() {
            var me = this;
            if (!me._view) {
              me._view = helpers$1.extend({}, me._model);
            }
            me._start = {};
            return me;
          },
          transition: function(ease) {
            var me = this;
            var model = me._model;
            var start = me._start;
            var view = me._view;
            if (!model || ease === 1) {
              me._view = helpers$1.extend({}, model);
              me._start = null;
              return me;
            }
            if (!view) {
              view = me._view = {};
            }
            if (!start) {
              start = me._start = {};
            }
            interpolate(start, view, model, ease);
            return me;
          },
          tooltipPosition: function() {
            return {
              x: this._model.x,
              y: this._model.y
            };
          },
          hasValue: function() {
            return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
          }
        });
        Element2.extend = helpers$1.inherits;
        var core_element = Element2;
        var exports$3 = core_element.extend({
          chart: null,
          currentStep: 0,
          numSteps: 60,
          easing: "",
          render: null,
          onAnimationProgress: null,
          onAnimationComplete: null
        });
        var core_animation = exports$3;
        Object.defineProperty(exports$3.prototype, "animationObject", {
          get: function() {
            return this;
          }
        });
        Object.defineProperty(exports$3.prototype, "chartInstance", {
          get: function() {
            return this.chart;
          },
          set: function(value) {
            this.chart = value;
          }
        });
        core_defaults._set("global", {
          animation: {
            duration: 1e3,
            easing: "easeOutQuart",
            onProgress: helpers$1.noop,
            onComplete: helpers$1.noop
          }
        });
        var core_animations = {
          animations: [],
          request: null,
          addAnimation: function(chart, animation, duration, lazy) {
            var animations = this.animations;
            var i, ilen;
            animation.chart = chart;
            animation.startTime = Date.now();
            animation.duration = duration;
            if (!lazy) {
              chart.animating = true;
            }
            for (i = 0, ilen = animations.length; i < ilen; ++i) {
              if (animations[i].chart === chart) {
                animations[i] = animation;
                return;
              }
            }
            animations.push(animation);
            if (animations.length === 1) {
              this.requestAnimationFrame();
            }
          },
          cancelAnimation: function(chart) {
            var index = helpers$1.findIndex(this.animations, function(animation) {
              return animation.chart === chart;
            });
            if (index !== -1) {
              this.animations.splice(index, 1);
              chart.animating = false;
            }
          },
          requestAnimationFrame: function() {
            var me = this;
            if (me.request === null) {
              me.request = helpers$1.requestAnimFrame.call(window, function() {
                me.request = null;
                me.startDigest();
              });
            }
          },
          startDigest: function() {
            var me = this;
            me.advance();
            if (me.animations.length > 0) {
              me.requestAnimationFrame();
            }
          },
          advance: function() {
            var animations = this.animations;
            var animation, chart, numSteps, nextStep;
            var i = 0;
            while (i < animations.length) {
              animation = animations[i];
              chart = animation.chart;
              numSteps = animation.numSteps;
              nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
              animation.currentStep = Math.min(nextStep, numSteps);
              helpers$1.callback(animation.render, [chart, animation], chart);
              helpers$1.callback(animation.onAnimationProgress, [animation], chart);
              if (animation.currentStep >= numSteps) {
                helpers$1.callback(animation.onAnimationComplete, [animation], chart);
                chart.animating = false;
                animations.splice(i, 1);
              } else {
                ++i;
              }
            }
          }
        };
        var resolve = helpers$1.options.resolve;
        var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
        function listenArrayEvents(array, listener) {
          if (array._chartjs) {
            array._chartjs.listeners.push(listener);
            return;
          }
          Object.defineProperty(array, "_chartjs", {
            configurable: true,
            enumerable: false,
            value: {
              listeners: [listener]
            }
          });
          arrayEvents.forEach(function(key) {
            var method = "onData" + key.charAt(0).toUpperCase() + key.slice(1);
            var base = array[key];
            Object.defineProperty(array, key, {
              configurable: true,
              enumerable: false,
              value: function() {
                var args = Array.prototype.slice.call(arguments);
                var res = base.apply(this, args);
                helpers$1.each(array._chartjs.listeners, function(object) {
                  if (typeof object[method] === "function") {
                    object[method].apply(object, args);
                  }
                });
                return res;
              }
            });
          });
        }
        function unlistenArrayEvents(array, listener) {
          var stub = array._chartjs;
          if (!stub) {
            return;
          }
          var listeners = stub.listeners;
          var index = listeners.indexOf(listener);
          if (index !== -1) {
            listeners.splice(index, 1);
          }
          if (listeners.length > 0) {
            return;
          }
          arrayEvents.forEach(function(key) {
            delete array[key];
          });
          delete array._chartjs;
        }
        var DatasetController = function(chart, datasetIndex) {
          this.initialize(chart, datasetIndex);
        };
        helpers$1.extend(DatasetController.prototype, {
          datasetElementType: null,
          dataElementType: null,
          _datasetElementOptions: [
            "backgroundColor",
            "borderCapStyle",
            "borderColor",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "borderWidth"
          ],
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "pointStyle"
          ],
          initialize: function(chart, datasetIndex) {
            var me = this;
            me.chart = chart;
            me.index = datasetIndex;
            me.linkScales();
            me.addElements();
            me._type = me.getMeta().type;
          },
          updateIndex: function(datasetIndex) {
            this.index = datasetIndex;
          },
          linkScales: function() {
            var me = this;
            var meta = me.getMeta();
            var chart = me.chart;
            var scales2 = chart.scales;
            var dataset = me.getDataset();
            var scalesOpts = chart.options.scales;
            if (meta.xAxisID === null || !(meta.xAxisID in scales2) || dataset.xAxisID) {
              meta.xAxisID = dataset.xAxisID || scalesOpts.xAxes[0].id;
            }
            if (meta.yAxisID === null || !(meta.yAxisID in scales2) || dataset.yAxisID) {
              meta.yAxisID = dataset.yAxisID || scalesOpts.yAxes[0].id;
            }
          },
          getDataset: function() {
            return this.chart.data.datasets[this.index];
          },
          getMeta: function() {
            return this.chart.getDatasetMeta(this.index);
          },
          getScaleForId: function(scaleID) {
            return this.chart.scales[scaleID];
          },
          _getValueScaleId: function() {
            return this.getMeta().yAxisID;
          },
          _getIndexScaleId: function() {
            return this.getMeta().xAxisID;
          },
          _getValueScale: function() {
            return this.getScaleForId(this._getValueScaleId());
          },
          _getIndexScale: function() {
            return this.getScaleForId(this._getIndexScaleId());
          },
          reset: function() {
            this._update(true);
          },
          destroy: function() {
            if (this._data) {
              unlistenArrayEvents(this._data, this);
            }
          },
          createMetaDataset: function() {
            var me = this;
            var type = me.datasetElementType;
            return type && new type({
              _chart: me.chart,
              _datasetIndex: me.index
            });
          },
          createMetaData: function(index) {
            var me = this;
            var type = me.dataElementType;
            return type && new type({
              _chart: me.chart,
              _datasetIndex: me.index,
              _index: index
            });
          },
          addElements: function() {
            var me = this;
            var meta = me.getMeta();
            var data2 = me.getDataset().data || [];
            var metaData = meta.data;
            var i, ilen;
            for (i = 0, ilen = data2.length; i < ilen; ++i) {
              metaData[i] = metaData[i] || me.createMetaData(i);
            }
            meta.dataset = meta.dataset || me.createMetaDataset();
          },
          addElementAndReset: function(index) {
            var element = this.createMetaData(index);
            this.getMeta().data.splice(index, 0, element);
            this.updateElement(element, index, true);
          },
          buildOrUpdateElements: function() {
            var me = this;
            var dataset = me.getDataset();
            var data2 = dataset.data || (dataset.data = []);
            if (me._data !== data2) {
              if (me._data) {
                unlistenArrayEvents(me._data, me);
              }
              if (data2 && Object.isExtensible(data2)) {
                listenArrayEvents(data2, me);
              }
              me._data = data2;
            }
            me.resyncElements();
          },
          _configure: function() {
            var me = this;
            me._config = helpers$1.merge(/* @__PURE__ */ Object.create(null), [
              me.chart.options.datasets[me._type],
              me.getDataset()
            ], {
              merger: function(key, target, source) {
                if (key !== "_meta" && key !== "data") {
                  helpers$1._merger(key, target, source);
                }
              }
            });
          },
          _update: function(reset) {
            var me = this;
            me._configure();
            me._cachedDataOpts = null;
            me.update(reset);
          },
          update: helpers$1.noop,
          transition: function(easingValue) {
            var meta = this.getMeta();
            var elements2 = meta.data || [];
            var ilen = elements2.length;
            var i = 0;
            for (; i < ilen; ++i) {
              elements2[i].transition(easingValue);
            }
            if (meta.dataset) {
              meta.dataset.transition(easingValue);
            }
          },
          draw: function() {
            var meta = this.getMeta();
            var elements2 = meta.data || [];
            var ilen = elements2.length;
            var i = 0;
            if (meta.dataset) {
              meta.dataset.draw();
            }
            for (; i < ilen; ++i) {
              elements2[i].draw();
            }
          },
          getStyle: function(index) {
            var me = this;
            var meta = me.getMeta();
            var dataset = meta.dataset;
            var style;
            me._configure();
            if (dataset && index === void 0) {
              style = me._resolveDatasetElementOptions(dataset || {});
            } else {
              index = index || 0;
              style = me._resolveDataElementOptions(meta.data[index] || {}, index);
            }
            if (style.fill === false || style.fill === null) {
              style.backgroundColor = style.borderColor;
            }
            return style;
          },
          _resolveDatasetElementOptions: function(element, hover) {
            var me = this;
            var chart = me.chart;
            var datasetOpts = me._config;
            var custom = element.custom || {};
            var options2 = chart.options.elements[me.datasetElementType.prototype._type] || {};
            var elementOptions = me._datasetElementOptions;
            var values = {};
            var i, ilen, key, readKey;
            var context = {
              chart,
              dataset: me.getDataset(),
              datasetIndex: me.index,
              hover
            };
            for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
              key = elementOptions[i];
              readKey = hover ? "hover" + key.charAt(0).toUpperCase() + key.slice(1) : key;
              values[key] = resolve([
                custom[readKey],
                datasetOpts[readKey],
                options2[readKey]
              ], context);
            }
            return values;
          },
          _resolveDataElementOptions: function(element, index) {
            var me = this;
            var custom = element && element.custom;
            var cached = me._cachedDataOpts;
            if (cached && !custom) {
              return cached;
            }
            var chart = me.chart;
            var datasetOpts = me._config;
            var options2 = chart.options.elements[me.dataElementType.prototype._type] || {};
            var elementOptions = me._dataElementOptions;
            var values = {};
            var context = {
              chart,
              dataIndex: index,
              dataset: me.getDataset(),
              datasetIndex: me.index
            };
            var info = { cacheable: !custom };
            var keys, i, ilen, key;
            custom = custom || {};
            if (helpers$1.isArray(elementOptions)) {
              for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
                key = elementOptions[i];
                values[key] = resolve([
                  custom[key],
                  datasetOpts[key],
                  options2[key]
                ], context, index, info);
              }
            } else {
              keys = Object.keys(elementOptions);
              for (i = 0, ilen = keys.length; i < ilen; ++i) {
                key = keys[i];
                values[key] = resolve([
                  custom[key],
                  datasetOpts[elementOptions[key]],
                  datasetOpts[key],
                  options2[key]
                ], context, index, info);
              }
            }
            if (info.cacheable) {
              me._cachedDataOpts = Object.freeze(values);
            }
            return values;
          },
          removeHoverStyle: function(element) {
            helpers$1.merge(element._model, element.$previousStyle || {});
            delete element.$previousStyle;
          },
          setHoverStyle: function(element) {
            var dataset = this.chart.data.datasets[element._datasetIndex];
            var index = element._index;
            var custom = element.custom || {};
            var model = element._model;
            var getHoverColor = helpers$1.getHoverColor;
            element.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], void 0, index);
            model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], void 0, index);
            model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], void 0, index);
          },
          _removeDatasetHoverStyle: function() {
            var element = this.getMeta().dataset;
            if (element) {
              this.removeHoverStyle(element);
            }
          },
          _setDatasetHoverStyle: function() {
            var element = this.getMeta().dataset;
            var prev = {};
            var i, ilen, key, keys, hoverOptions, model;
            if (!element) {
              return;
            }
            model = element._model;
            hoverOptions = this._resolveDatasetElementOptions(element, true);
            keys = Object.keys(hoverOptions);
            for (i = 0, ilen = keys.length; i < ilen; ++i) {
              key = keys[i];
              prev[key] = model[key];
              model[key] = hoverOptions[key];
            }
            element.$previousStyle = prev;
          },
          resyncElements: function() {
            var me = this;
            var meta = me.getMeta();
            var data2 = me.getDataset().data;
            var numMeta = meta.data.length;
            var numData = data2.length;
            if (numData < numMeta) {
              meta.data.splice(numData, numMeta - numData);
            } else if (numData > numMeta) {
              me.insertElements(numMeta, numData - numMeta);
            }
          },
          insertElements: function(start, count) {
            for (var i = 0; i < count; ++i) {
              this.addElementAndReset(start + i);
            }
          },
          onDataPush: function() {
            var count = arguments.length;
            this.insertElements(this.getDataset().data.length - count, count);
          },
          onDataPop: function() {
            this.getMeta().data.pop();
          },
          onDataShift: function() {
            this.getMeta().data.shift();
          },
          onDataSplice: function(start, count) {
            this.getMeta().data.splice(start, count);
            this.insertElements(start, arguments.length - 2);
          },
          onDataUnshift: function() {
            this.insertElements(0, arguments.length);
          }
        });
        DatasetController.extend = helpers$1.inherits;
        var core_datasetController = DatasetController;
        var TAU = Math.PI * 2;
        core_defaults._set("global", {
          elements: {
            arc: {
              backgroundColor: core_defaults.global.defaultColor,
              borderColor: "#fff",
              borderWidth: 2,
              borderAlign: "center"
            }
          }
        });
        function clipArc(ctx, arc) {
          var startAngle = arc.startAngle;
          var endAngle = arc.endAngle;
          var pixelMargin = arc.pixelMargin;
          var angleMargin = pixelMargin / arc.outerRadius;
          var x = arc.x;
          var y = arc.y;
          ctx.beginPath();
          ctx.arc(x, y, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);
          if (arc.innerRadius > pixelMargin) {
            angleMargin = pixelMargin / arc.innerRadius;
            ctx.arc(x, y, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin, true);
          } else {
            ctx.arc(x, y, pixelMargin, endAngle + Math.PI / 2, startAngle - Math.PI / 2);
          }
          ctx.closePath();
          ctx.clip();
        }
        function drawFullCircleBorders(ctx, vm, arc, inner) {
          var endAngle = arc.endAngle;
          var i;
          if (inner) {
            arc.endAngle = arc.startAngle + TAU;
            clipArc(ctx, arc);
            arc.endAngle = endAngle;
            if (arc.endAngle === arc.startAngle && arc.fullCircles) {
              arc.endAngle += TAU;
              arc.fullCircles--;
            }
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);
          for (i = 0; i < arc.fullCircles; ++i) {
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);
          for (i = 0; i < arc.fullCircles; ++i) {
            ctx.stroke();
          }
        }
        function drawBorder(ctx, vm, arc) {
          var inner = vm.borderAlign === "inner";
          if (inner) {
            ctx.lineWidth = vm.borderWidth * 2;
            ctx.lineJoin = "round";
          } else {
            ctx.lineWidth = vm.borderWidth;
            ctx.lineJoin = "bevel";
          }
          if (arc.fullCircles) {
            drawFullCircleBorders(ctx, vm, arc, inner);
          }
          if (inner) {
            clipArc(ctx, arc);
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);
          ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
          ctx.closePath();
          ctx.stroke();
        }
        var element_arc = core_element.extend({
          _type: "arc",
          inLabelRange: function(mouseX) {
            var vm = this._view;
            if (vm) {
              return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
            }
            return false;
          },
          inRange: function(chartX, chartY) {
            var vm = this._view;
            if (vm) {
              var pointRelativePosition = helpers$1.getAngleFromPoint(vm, { x: chartX, y: chartY });
              var angle = pointRelativePosition.angle;
              var distance = pointRelativePosition.distance;
              var startAngle = vm.startAngle;
              var endAngle = vm.endAngle;
              while (endAngle < startAngle) {
                endAngle += TAU;
              }
              while (angle > endAngle) {
                angle -= TAU;
              }
              while (angle < startAngle) {
                angle += TAU;
              }
              var betweenAngles = angle >= startAngle && angle <= endAngle;
              var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
              return betweenAngles && withinRadius;
            }
            return false;
          },
          getCenterPoint: function() {
            var vm = this._view;
            var halfAngle = (vm.startAngle + vm.endAngle) / 2;
            var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
            return {
              x: vm.x + Math.cos(halfAngle) * halfRadius,
              y: vm.y + Math.sin(halfAngle) * halfRadius
            };
          },
          getArea: function() {
            var vm = this._view;
            return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
          },
          tooltipPosition: function() {
            var vm = this._view;
            var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
            var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
            return {
              x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
              y: vm.y + Math.sin(centreAngle) * rangeFromCentre
            };
          },
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var pixelMargin = vm.borderAlign === "inner" ? 0.33 : 0;
            var arc = {
              x: vm.x,
              y: vm.y,
              innerRadius: vm.innerRadius,
              outerRadius: Math.max(vm.outerRadius - pixelMargin, 0),
              pixelMargin,
              startAngle: vm.startAngle,
              endAngle: vm.endAngle,
              fullCircles: Math.floor(vm.circumference / TAU)
            };
            var i;
            ctx.save();
            ctx.fillStyle = vm.backgroundColor;
            ctx.strokeStyle = vm.borderColor;
            if (arc.fullCircles) {
              arc.endAngle = arc.startAngle + TAU;
              ctx.beginPath();
              ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
              ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
              ctx.closePath();
              for (i = 0; i < arc.fullCircles; ++i) {
                ctx.fill();
              }
              arc.endAngle = arc.startAngle + vm.circumference % TAU;
            }
            ctx.beginPath();
            ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
            ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
            ctx.closePath();
            ctx.fill();
            if (vm.borderWidth) {
              drawBorder(ctx, vm, arc);
            }
            ctx.restore();
          }
        });
        var valueOrDefault$1 = helpers$1.valueOrDefault;
        var defaultColor = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            line: {
              tension: 0.4,
              backgroundColor: defaultColor,
              borderWidth: 3,
              borderColor: defaultColor,
              borderCapStyle: "butt",
              borderDash: [],
              borderDashOffset: 0,
              borderJoinStyle: "miter",
              capBezierPoints: true,
              fill: true
            }
          }
        });
        var element_line = core_element.extend({
          _type: "line",
          draw: function() {
            var me = this;
            var vm = me._view;
            var ctx = me._chart.ctx;
            var spanGaps = vm.spanGaps;
            var points = me._children.slice();
            var globalDefaults = core_defaults.global;
            var globalOptionLineElements = globalDefaults.elements.line;
            var lastDrawnIndex = -1;
            var closePath = me._loop;
            var index, previous, currentVM;
            if (!points.length) {
              return;
            }
            if (me._loop) {
              for (index = 0; index < points.length; ++index) {
                previous = helpers$1.previousItem(points, index);
                if (!points[index]._view.skip && previous._view.skip) {
                  points = points.slice(index).concat(points.slice(0, index));
                  closePath = spanGaps;
                  break;
                }
              }
              if (closePath) {
                points.push(points[0]);
              }
            }
            ctx.save();
            ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
            if (ctx.setLineDash) {
              ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
            }
            ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
            ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
            ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
            ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
            ctx.beginPath();
            currentVM = points[0]._view;
            if (!currentVM.skip) {
              ctx.moveTo(currentVM.x, currentVM.y);
              lastDrawnIndex = 0;
            }
            for (index = 1; index < points.length; ++index) {
              currentVM = points[index]._view;
              previous = lastDrawnIndex === -1 ? helpers$1.previousItem(points, index) : points[lastDrawnIndex];
              if (!currentVM.skip) {
                if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
                  ctx.moveTo(currentVM.x, currentVM.y);
                } else {
                  helpers$1.canvas.lineTo(ctx, previous._view, currentVM);
                }
                lastDrawnIndex = index;
              }
            }
            if (closePath) {
              ctx.closePath();
            }
            ctx.stroke();
            ctx.restore();
          }
        });
        var valueOrDefault$2 = helpers$1.valueOrDefault;
        var defaultColor$1 = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            point: {
              radius: 3,
              pointStyle: "circle",
              backgroundColor: defaultColor$1,
              borderColor: defaultColor$1,
              borderWidth: 1,
              hitRadius: 1,
              hoverRadius: 4,
              hoverBorderWidth: 1
            }
          }
        });
        function xRange(mouseX) {
          var vm = this._view;
          return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
        }
        function yRange(mouseY) {
          var vm = this._view;
          return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
        }
        var element_point = core_element.extend({
          _type: "point",
          inRange: function(mouseX, mouseY) {
            var vm = this._view;
            return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
          },
          inLabelRange: xRange,
          inXRange: xRange,
          inYRange: yRange,
          getCenterPoint: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y
            };
          },
          getArea: function() {
            return Math.PI * Math.pow(this._view.radius, 2);
          },
          tooltipPosition: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y,
              padding: vm.radius + vm.borderWidth
            };
          },
          draw: function(chartArea) {
            var vm = this._view;
            var ctx = this._chart.ctx;
            var pointStyle = vm.pointStyle;
            var rotation = vm.rotation;
            var radius = vm.radius;
            var x = vm.x;
            var y = vm.y;
            var globalDefaults = core_defaults.global;
            var defaultColor2 = globalDefaults.defaultColor;
            if (vm.skip) {
              return;
            }
            if (chartArea === void 0 || helpers$1.canvas._isPointInArea(vm, chartArea)) {
              ctx.strokeStyle = vm.borderColor || defaultColor2;
              ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
              ctx.fillStyle = vm.backgroundColor || defaultColor2;
              helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
            }
          }
        });
        var defaultColor$2 = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            rectangle: {
              backgroundColor: defaultColor$2,
              borderColor: defaultColor$2,
              borderSkipped: "bottom",
              borderWidth: 0
            }
          }
        });
        function isVertical(vm) {
          return vm && vm.width !== void 0;
        }
        function getBarBounds(vm) {
          var x1, x2, y1, y2, half;
          if (isVertical(vm)) {
            half = vm.width / 2;
            x1 = vm.x - half;
            x2 = vm.x + half;
            y1 = Math.min(vm.y, vm.base);
            y2 = Math.max(vm.y, vm.base);
          } else {
            half = vm.height / 2;
            x1 = Math.min(vm.x, vm.base);
            x2 = Math.max(vm.x, vm.base);
            y1 = vm.y - half;
            y2 = vm.y + half;
          }
          return {
            left: x1,
            top: y1,
            right: x2,
            bottom: y2
          };
        }
        function swap(orig, v1, v2) {
          return orig === v1 ? v2 : orig === v2 ? v1 : orig;
        }
        function parseBorderSkipped(vm) {
          var edge = vm.borderSkipped;
          var res = {};
          if (!edge) {
            return res;
          }
          if (vm.horizontal) {
            if (vm.base > vm.x) {
              edge = swap(edge, "left", "right");
            }
          } else if (vm.base < vm.y) {
            edge = swap(edge, "bottom", "top");
          }
          res[edge] = true;
          return res;
        }
        function parseBorderWidth(vm, maxW, maxH) {
          var value = vm.borderWidth;
          var skip2 = parseBorderSkipped(vm);
          var t, r, b, l;
          if (helpers$1.isObject(value)) {
            t = +value.top || 0;
            r = +value.right || 0;
            b = +value.bottom || 0;
            l = +value.left || 0;
          } else {
            t = r = b = l = +value || 0;
          }
          return {
            t: skip2.top || t < 0 ? 0 : t > maxH ? maxH : t,
            r: skip2.right || r < 0 ? 0 : r > maxW ? maxW : r,
            b: skip2.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
            l: skip2.left || l < 0 ? 0 : l > maxW ? maxW : l
          };
        }
        function boundingRects(vm) {
          var bounds = getBarBounds(vm);
          var width = bounds.right - bounds.left;
          var height = bounds.bottom - bounds.top;
          var border = parseBorderWidth(vm, width / 2, height / 2);
          return {
            outer: {
              x: bounds.left,
              y: bounds.top,
              w: width,
              h: height
            },
            inner: {
              x: bounds.left + border.l,
              y: bounds.top + border.t,
              w: width - border.l - border.r,
              h: height - border.t - border.b
            }
          };
        }
        function inRange(vm, x, y) {
          var skipX = x === null;
          var skipY = y === null;
          var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
          return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
        }
        var element_rectangle = core_element.extend({
          _type: "rectangle",
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var rects = boundingRects(vm);
            var outer = rects.outer;
            var inner = rects.inner;
            ctx.fillStyle = vm.backgroundColor;
            ctx.fillRect(outer.x, outer.y, outer.w, outer.h);
            if (outer.w === inner.w && outer.h === inner.h) {
              return;
            }
            ctx.save();
            ctx.beginPath();
            ctx.rect(outer.x, outer.y, outer.w, outer.h);
            ctx.clip();
            ctx.fillStyle = vm.borderColor;
            ctx.rect(inner.x, inner.y, inner.w, inner.h);
            ctx.fill("evenodd");
            ctx.restore();
          },
          height: function() {
            var vm = this._view;
            return vm.base - vm.y;
          },
          inRange: function(mouseX, mouseY) {
            return inRange(this._view, mouseX, mouseY);
          },
          inLabelRange: function(mouseX, mouseY) {
            var vm = this._view;
            return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
          },
          inXRange: function(mouseX) {
            return inRange(this._view, mouseX, null);
          },
          inYRange: function(mouseY) {
            return inRange(this._view, null, mouseY);
          },
          getCenterPoint: function() {
            var vm = this._view;
            var x, y;
            if (isVertical(vm)) {
              x = vm.x;
              y = (vm.y + vm.base) / 2;
            } else {
              x = (vm.x + vm.base) / 2;
              y = vm.y;
            }
            return { x, y };
          },
          getArea: function() {
            var vm = this._view;
            return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
          },
          tooltipPosition: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y
            };
          }
        });
        var elements = {};
        var Arc = element_arc;
        var Line2 = element_line;
        var Point = element_point;
        var Rectangle = element_rectangle;
        elements.Arc = Arc;
        elements.Line = Line2;
        elements.Point = Point;
        elements.Rectangle = Rectangle;
        var deprecated = helpers$1._deprecated;
        var valueOrDefault$3 = helpers$1.valueOrDefault;
        core_defaults._set("bar", {
          hover: {
            mode: "label"
          },
          scales: {
            xAxes: [{
              type: "category",
              offset: true,
              gridLines: {
                offsetGridLines: true
              }
            }],
            yAxes: [{
              type: "linear"
            }]
          }
        });
        core_defaults._set("global", {
          datasets: {
            bar: {
              categoryPercentage: 0.8,
              barPercentage: 0.9
            }
          }
        });
        function computeMinSampleSize(scale2, pixels) {
          var min = scale2._length;
          var prev, curr, i, ilen;
          for (i = 1, ilen = pixels.length; i < ilen; ++i) {
            min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
          }
          for (i = 0, ilen = scale2.getTicks().length; i < ilen; ++i) {
            curr = scale2.getPixelForTick(i);
            min = i > 0 ? Math.min(min, Math.abs(curr - prev)) : min;
            prev = curr;
          }
          return min;
        }
        function computeFitCategoryTraits(index, ruler, options2) {
          var thickness = options2.barThickness;
          var count = ruler.stackCount;
          var curr = ruler.pixels[index];
          var min = helpers$1.isNullOrUndef(thickness) ? computeMinSampleSize(ruler.scale, ruler.pixels) : -1;
          var size, ratio;
          if (helpers$1.isNullOrUndef(thickness)) {
            size = min * options2.categoryPercentage;
            ratio = options2.barPercentage;
          } else {
            size = thickness * count;
            ratio = 1;
          }
          return {
            chunk: size / count,
            ratio,
            start: curr - size / 2
          };
        }
        function computeFlexCategoryTraits(index, ruler, options2) {
          var pixels = ruler.pixels;
          var curr = pixels[index];
          var prev = index > 0 ? pixels[index - 1] : null;
          var next = index < pixels.length - 1 ? pixels[index + 1] : null;
          var percent = options2.categoryPercentage;
          var start, size;
          if (prev === null) {
            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
          }
          if (next === null) {
            next = curr + curr - prev;
          }
          start = curr - (curr - Math.min(prev, next)) / 2 * percent;
          size = Math.abs(next - prev) / 2 * percent;
          return {
            chunk: size / ruler.stackCount,
            ratio: options2.barPercentage,
            start
          };
        }
        var controller_bar = core_datasetController.extend({
          dataElementType: elements.Rectangle,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderSkipped",
            "borderWidth",
            "barPercentage",
            "barThickness",
            "categoryPercentage",
            "maxBarThickness",
            "minBarLength"
          ],
          initialize: function() {
            var me = this;
            var meta, scaleOpts;
            core_datasetController.prototype.initialize.apply(me, arguments);
            meta = me.getMeta();
            meta.stack = me.getDataset().stack;
            meta.bar = true;
            scaleOpts = me._getIndexScale().options;
            deprecated("bar chart", scaleOpts.barPercentage, "scales.[x/y]Axes.barPercentage", "dataset.barPercentage");
            deprecated("bar chart", scaleOpts.barThickness, "scales.[x/y]Axes.barThickness", "dataset.barThickness");
            deprecated("bar chart", scaleOpts.categoryPercentage, "scales.[x/y]Axes.categoryPercentage", "dataset.categoryPercentage");
            deprecated("bar chart", me._getValueScale().options.minBarLength, "scales.[x/y]Axes.minBarLength", "dataset.minBarLength");
            deprecated("bar chart", scaleOpts.maxBarThickness, "scales.[x/y]Axes.maxBarThickness", "dataset.maxBarThickness");
          },
          update: function(reset) {
            var me = this;
            var rects = me.getMeta().data;
            var i, ilen;
            me._ruler = me.getRuler();
            for (i = 0, ilen = rects.length; i < ilen; ++i) {
              me.updateElement(rects[i], i, reset);
            }
          },
          updateElement: function(rectangle, index, reset) {
            var me = this;
            var meta = me.getMeta();
            var dataset = me.getDataset();
            var options2 = me._resolveDataElementOptions(rectangle, index);
            rectangle._xScale = me.getScaleForId(meta.xAxisID);
            rectangle._yScale = me.getScaleForId(meta.yAxisID);
            rectangle._datasetIndex = me.index;
            rectangle._index = index;
            rectangle._model = {
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderSkipped: options2.borderSkipped,
              borderWidth: options2.borderWidth,
              datasetLabel: dataset.label,
              label: me.chart.data.labels[index]
            };
            if (helpers$1.isArray(dataset.data[index])) {
              rectangle._model.borderSkipped = null;
            }
            me._updateElementGeometry(rectangle, index, reset, options2);
            rectangle.pivot();
          },
          _updateElementGeometry: function(rectangle, index, reset, options2) {
            var me = this;
            var model = rectangle._model;
            var vscale = me._getValueScale();
            var base = vscale.getBasePixel();
            var horizontal = vscale.isHorizontal();
            var ruler = me._ruler || me.getRuler();
            var vpixels = me.calculateBarValuePixels(me.index, index, options2);
            var ipixels = me.calculateBarIndexPixels(me.index, index, ruler, options2);
            model.horizontal = horizontal;
            model.base = reset ? base : vpixels.base;
            model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
            model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
            model.height = horizontal ? ipixels.size : void 0;
            model.width = horizontal ? void 0 : ipixels.size;
          },
          _getStacks: function(last) {
            var me = this;
            var scale2 = me._getIndexScale();
            var metasets = scale2._getMatchingVisibleMetas(me._type);
            var stacked = scale2.options.stacked;
            var ilen = metasets.length;
            var stacks = [];
            var i, meta;
            for (i = 0; i < ilen; ++i) {
              meta = metasets[i];
              if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
                stacks.push(meta.stack);
              }
              if (meta.index === last) {
                break;
              }
            }
            return stacks;
          },
          getStackCount: function() {
            return this._getStacks().length;
          },
          getStackIndex: function(datasetIndex, name2) {
            var stacks = this._getStacks(datasetIndex);
            var index = name2 !== void 0 ? stacks.indexOf(name2) : -1;
            return index === -1 ? stacks.length - 1 : index;
          },
          getRuler: function() {
            var me = this;
            var scale2 = me._getIndexScale();
            var pixels = [];
            var i, ilen;
            for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
              pixels.push(scale2.getPixelForValue(null, i, me.index));
            }
            return {
              pixels,
              start: scale2._startPixel,
              end: scale2._endPixel,
              stackCount: me.getStackCount(),
              scale: scale2
            };
          },
          calculateBarValuePixels: function(datasetIndex, index, options2) {
            var me = this;
            var chart = me.chart;
            var scale2 = me._getValueScale();
            var isHorizontal = scale2.isHorizontal();
            var datasets = chart.data.datasets;
            var metasets = scale2._getMatchingVisibleMetas(me._type);
            var value = scale2._parseValue(datasets[datasetIndex].data[index]);
            var minBarLength = options2.minBarLength;
            var stacked = scale2.options.stacked;
            var stack = me.getMeta().stack;
            var start = value.start === void 0 ? 0 : value.max >= 0 && value.min >= 0 ? value.min : value.max;
            var length = value.start === void 0 ? value.end : value.max >= 0 && value.min >= 0 ? value.max - value.min : value.min - value.max;
            var ilen = metasets.length;
            var i, imeta, ivalue, base, head, size, stackLength;
            if (stacked || stacked === void 0 && stack !== void 0) {
              for (i = 0; i < ilen; ++i) {
                imeta = metasets[i];
                if (imeta.index === datasetIndex) {
                  break;
                }
                if (imeta.stack === stack) {
                  stackLength = scale2._parseValue(datasets[imeta.index].data[index]);
                  ivalue = stackLength.start === void 0 ? stackLength.end : stackLength.min >= 0 && stackLength.max >= 0 ? stackLength.max : stackLength.min;
                  if (value.min < 0 && ivalue < 0 || value.max >= 0 && ivalue > 0) {
                    start += ivalue;
                  }
                }
              }
            }
            base = scale2.getPixelForValue(start);
            head = scale2.getPixelForValue(start + length);
            size = head - base;
            if (minBarLength !== void 0 && Math.abs(size) < minBarLength) {
              size = minBarLength;
              if (length >= 0 && !isHorizontal || length < 0 && isHorizontal) {
                head = base - minBarLength;
              } else {
                head = base + minBarLength;
              }
            }
            return {
              size,
              base,
              head,
              center: head + size / 2
            };
          },
          calculateBarIndexPixels: function(datasetIndex, index, ruler, options2) {
            var me = this;
            var range = options2.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options2) : computeFitCategoryTraits(index, ruler, options2);
            var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
            var center = range.start + range.chunk * stackIndex + range.chunk / 2;
            var size = Math.min(valueOrDefault$3(options2.maxBarThickness, Infinity), range.chunk * range.ratio);
            return {
              base: center - size / 2,
              head: center + size / 2,
              center,
              size
            };
          },
          draw: function() {
            var me = this;
            var chart = me.chart;
            var scale2 = me._getValueScale();
            var rects = me.getMeta().data;
            var dataset = me.getDataset();
            var ilen = rects.length;
            var i = 0;
            helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);
            for (; i < ilen; ++i) {
              var val = scale2._parseValue(dataset.data[i]);
              if (!isNaN(val.min) && !isNaN(val.max)) {
                rects[i].draw();
              }
            }
            helpers$1.canvas.unclipArea(chart.ctx);
          },
          _resolveDataElementOptions: function() {
            var me = this;
            var values = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments));
            var indexOpts = me._getIndexScale().options;
            var valueOpts = me._getValueScale().options;
            values.barPercentage = valueOrDefault$3(indexOpts.barPercentage, values.barPercentage);
            values.barThickness = valueOrDefault$3(indexOpts.barThickness, values.barThickness);
            values.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage, values.categoryPercentage);
            values.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness, values.maxBarThickness);
            values.minBarLength = valueOrDefault$3(valueOpts.minBarLength, values.minBarLength);
            return values;
          }
        });
        var valueOrDefault$4 = helpers$1.valueOrDefault;
        var resolve$1 = helpers$1.options.resolve;
        core_defaults._set("bubble", {
          hover: {
            mode: "single"
          },
          scales: {
            xAxes: [{
              type: "linear",
              position: "bottom",
              id: "x-axis-0"
            }],
            yAxes: [{
              type: "linear",
              position: "left",
              id: "y-axis-0"
            }]
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item, data2) {
                var datasetLabel = data2.datasets[item.datasetIndex].label || "";
                var dataPoint = data2.datasets[item.datasetIndex].data[item.index];
                return datasetLabel + ": (" + item.xLabel + ", " + item.yLabel + ", " + dataPoint.r + ")";
              }
            }
          }
        });
        var controller_bubble = core_datasetController.extend({
          dataElementType: elements.Point,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth",
            "hoverRadius",
            "hitRadius",
            "pointStyle",
            "rotation"
          ],
          update: function(reset) {
            var me = this;
            var meta = me.getMeta();
            var points = meta.data;
            helpers$1.each(points, function(point, index) {
              me.updateElement(point, index, reset);
            });
          },
          updateElement: function(point, index, reset) {
            var me = this;
            var meta = me.getMeta();
            var custom = point.custom || {};
            var xScale = me.getScaleForId(meta.xAxisID);
            var yScale = me.getScaleForId(meta.yAxisID);
            var options2 = me._resolveDataElementOptions(point, index);
            var data2 = me.getDataset().data[index];
            var dsIndex = me.index;
            var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data2 === "object" ? data2 : NaN, index, dsIndex);
            var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data2, index, dsIndex);
            point._xScale = xScale;
            point._yScale = yScale;
            point._options = options2;
            point._datasetIndex = dsIndex;
            point._index = index;
            point._model = {
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              hitRadius: options2.hitRadius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              radius: reset ? 0 : options2.radius,
              skip: custom.skip || isNaN(x) || isNaN(y),
              x,
              y
            };
            point.pivot();
          },
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$4(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$4(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$4(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = options2.radius + options2.hoverRadius;
          },
          _resolveDataElementOptions: function(point, index) {
            var me = this;
            var chart = me.chart;
            var dataset = me.getDataset();
            var custom = point.custom || {};
            var data2 = dataset.data[index] || {};
            var values = core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments);
            var context = {
              chart,
              dataIndex: index,
              dataset,
              datasetIndex: me.index
            };
            if (me._cachedDataOpts === values) {
              values = helpers$1.extend({}, values);
            }
            values.radius = resolve$1([
              custom.radius,
              data2.r,
              me._config.radius,
              chart.options.elements.point.radius
            ], context, index);
            return values;
          }
        });
        var valueOrDefault$5 = helpers$1.valueOrDefault;
        var PI$1 = Math.PI;
        var DOUBLE_PI$1 = PI$1 * 2;
        var HALF_PI$1 = PI$1 / 2;
        core_defaults._set("doughnut", {
          animation: {
            animateRotate: true,
            animateScale: false
          },
          hover: {
            mode: "single"
          },
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var data2 = chart.data;
            var datasets = data2.datasets;
            var labels = data2.labels;
            var i, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            if (datasets.length) {
              for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
                listItem = list.appendChild(document.createElement("li"));
                listItemSpan = listItem.appendChild(document.createElement("span"));
                listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
                if (labels[i]) {
                  listItem.appendChild(document.createTextNode(labels[i]));
                }
              }
            }
            return list.outerHTML;
          },
          legend: {
            labels: {
              generateLabels: function(chart) {
                var data2 = chart.data;
                if (data2.labels.length && data2.datasets.length) {
                  return data2.labels.map(function(label, i) {
                    var meta = chart.getDatasetMeta(0);
                    var style = meta.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      hidden: isNaN(data2.datasets[0].data[i]) || meta.data[i].hidden,
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick: function(e, legendItem) {
              var index = legendItem.index;
              var chart = this.chart;
              var i, ilen, meta;
              for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                meta = chart.getDatasetMeta(i);
                if (meta.data[index]) {
                  meta.data[index].hidden = !meta.data[index].hidden;
                }
              }
              chart.update();
            }
          },
          cutoutPercentage: 50,
          rotation: -HALF_PI$1,
          circumference: DOUBLE_PI$1,
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(tooltipItem, data2) {
                var dataLabel = data2.labels[tooltipItem.index];
                var value = ": " + data2.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
                if (helpers$1.isArray(dataLabel)) {
                  dataLabel = dataLabel.slice();
                  dataLabel[0] += value;
                } else {
                  dataLabel += value;
                }
                return dataLabel;
              }
            }
          }
        });
        var controller_doughnut = core_datasetController.extend({
          dataElementType: elements.Arc,
          linkScales: helpers$1.noop,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "borderAlign",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth"
          ],
          getRingIndex: function(datasetIndex) {
            var ringIndex = 0;
            for (var j = 0; j < datasetIndex; ++j) {
              if (this.chart.isDatasetVisible(j)) {
                ++ringIndex;
              }
            }
            return ringIndex;
          },
          update: function(reset) {
            var me = this;
            var chart = me.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var ratioX = 1;
            var ratioY = 1;
            var offsetX = 0;
            var offsetY = 0;
            var meta = me.getMeta();
            var arcs = meta.data;
            var cutout = opts.cutoutPercentage / 100 || 0;
            var circumference = opts.circumference;
            var chartWeight = me._getRingWeight(me.index);
            var maxWidth, maxHeight, i, ilen;
            if (circumference < DOUBLE_PI$1) {
              var startAngle = opts.rotation % DOUBLE_PI$1;
              startAngle += startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;
              var endAngle = startAngle + circumference;
              var startX = Math.cos(startAngle);
              var startY = Math.sin(startAngle);
              var endX = Math.cos(endAngle);
              var endY = Math.sin(endAngle);
              var contains0 = startAngle <= 0 && endAngle >= 0 || endAngle >= DOUBLE_PI$1;
              var contains90 = startAngle <= HALF_PI$1 && endAngle >= HALF_PI$1 || endAngle >= DOUBLE_PI$1 + HALF_PI$1;
              var contains180 = startAngle === -PI$1 || endAngle >= PI$1;
              var contains270 = startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1 || endAngle >= PI$1 + HALF_PI$1;
              var minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);
              var minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);
              var maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);
              var maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);
              ratioX = (maxX - minX) / 2;
              ratioY = (maxY - minY) / 2;
              offsetX = -(maxX + minX) / 2;
              offsetY = -(maxY + minY) / 2;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
            }
            chart.borderWidth = me.getMaxBorderWidth();
            maxWidth = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;
            maxHeight = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;
            chart.outerRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
            chart.innerRadius = Math.max(chart.outerRadius * cutout, 0);
            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
            chart.offsetX = offsetX * chart.outerRadius;
            chart.offsetY = offsetY * chart.outerRadius;
            meta.total = me.calculateTotal();
            me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
            me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              me.updateElement(arcs[i], i, reset);
            }
          },
          updateElement: function(arc, index, reset) {
            var me = this;
            var chart = me.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var animationOpts = opts.animation;
            var centerX = (chartArea.left + chartArea.right) / 2;
            var centerY = (chartArea.top + chartArea.bottom) / 2;
            var startAngle = opts.rotation;
            var endAngle = opts.rotation;
            var dataset = me.getDataset();
            var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / DOUBLE_PI$1);
            var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
            var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
            var options2 = arc._options || {};
            helpers$1.extend(arc, {
              _datasetIndex: me.index,
              _index: index,
              _model: {
                backgroundColor: options2.backgroundColor,
                borderColor: options2.borderColor,
                borderWidth: options2.borderWidth,
                borderAlign: options2.borderAlign,
                x: centerX + chart.offsetX,
                y: centerY + chart.offsetY,
                startAngle,
                endAngle,
                circumference,
                outerRadius,
                innerRadius,
                label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
              }
            });
            var model = arc._model;
            if (!reset || !animationOpts.animateRotate) {
              if (index === 0) {
                model.startAngle = opts.rotation;
              } else {
                model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
              }
              model.endAngle = model.startAngle + model.circumference;
            }
            arc.pivot();
          },
          calculateTotal: function() {
            var dataset = this.getDataset();
            var meta = this.getMeta();
            var total = 0;
            var value;
            helpers$1.each(meta.data, function(element, index) {
              value = dataset.data[index];
              if (!isNaN(value) && !element.hidden) {
                total += Math.abs(value);
              }
            });
            return total;
          },
          calculateCircumference: function(value) {
            var total = this.getMeta().total;
            if (total > 0 && !isNaN(value)) {
              return DOUBLE_PI$1 * (Math.abs(value) / total);
            }
            return 0;
          },
          getMaxBorderWidth: function(arcs) {
            var me = this;
            var max = 0;
            var chart = me.chart;
            var i, ilen, meta, arc, controller, options2, borderWidth, hoverWidth;
            if (!arcs) {
              for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
                if (chart.isDatasetVisible(i)) {
                  meta = chart.getDatasetMeta(i);
                  arcs = meta.data;
                  if (i !== me.index) {
                    controller = meta.controller;
                  }
                  break;
                }
              }
            }
            if (!arcs) {
              return 0;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              arc = arcs[i];
              if (controller) {
                controller._configure();
                options2 = controller._resolveDataElementOptions(arc, i);
              } else {
                options2 = arc._options;
              }
              if (options2.borderAlign !== "inner") {
                borderWidth = options2.borderWidth;
                hoverWidth = options2.hoverBorderWidth;
                max = borderWidth > max ? borderWidth : max;
                max = hoverWidth > max ? hoverWidth : max;
              }
            }
            return max;
          },
          setHoverStyle: function(arc) {
            var model = arc._model;
            var options2 = arc._options;
            var getHoverColor = helpers$1.getHoverColor;
            arc.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = valueOrDefault$5(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$5(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$5(options2.hoverBorderWidth, options2.borderWidth);
          },
          _getRingWeightOffset: function(datasetIndex) {
            var ringWeightOffset = 0;
            for (var i = 0; i < datasetIndex; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                ringWeightOffset += this._getRingWeight(i);
              }
            }
            return ringWeightOffset;
          },
          _getRingWeight: function(dataSetIndex) {
            return Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
          },
          _getVisibleDatasetWeightTotal: function() {
            return this._getRingWeightOffset(this.chart.data.datasets.length);
          }
        });
        core_defaults._set("horizontalBar", {
          hover: {
            mode: "index",
            axis: "y"
          },
          scales: {
            xAxes: [{
              type: "linear",
              position: "bottom"
            }],
            yAxes: [{
              type: "category",
              position: "left",
              offset: true,
              gridLines: {
                offsetGridLines: true
              }
            }]
          },
          elements: {
            rectangle: {
              borderSkipped: "left"
            }
          },
          tooltips: {
            mode: "index",
            axis: "y"
          }
        });
        core_defaults._set("global", {
          datasets: {
            horizontalBar: {
              categoryPercentage: 0.8,
              barPercentage: 0.9
            }
          }
        });
        var controller_horizontalBar = controller_bar.extend({
          _getValueScaleId: function() {
            return this.getMeta().xAxisID;
          },
          _getIndexScaleId: function() {
            return this.getMeta().yAxisID;
          }
        });
        var valueOrDefault$6 = helpers$1.valueOrDefault;
        var resolve$2 = helpers$1.options.resolve;
        var isPointInArea = helpers$1.canvas._isPointInArea;
        core_defaults._set("line", {
          showLines: true,
          spanGaps: false,
          hover: {
            mode: "label"
          },
          scales: {
            xAxes: [{
              type: "category",
              id: "x-axis-0"
            }],
            yAxes: [{
              type: "linear",
              id: "y-axis-0"
            }]
          }
        });
        function scaleClip(scale2, halfBorderWidth) {
          var tickOpts = scale2 && scale2.options.ticks || {};
          var reverse = tickOpts.reverse;
          var min = tickOpts.min === void 0 ? halfBorderWidth : 0;
          var max = tickOpts.max === void 0 ? halfBorderWidth : 0;
          return {
            start: reverse ? max : min,
            end: reverse ? min : max
          };
        }
        function defaultClip(xScale, yScale, borderWidth) {
          var halfBorderWidth = borderWidth / 2;
          var x = scaleClip(xScale, halfBorderWidth);
          var y = scaleClip(yScale, halfBorderWidth);
          return {
            top: y.end,
            right: x.end,
            bottom: y.start,
            left: x.start
          };
        }
        function toClip(value) {
          var t, r, b, l;
          if (helpers$1.isObject(value)) {
            t = value.top;
            r = value.right;
            b = value.bottom;
            l = value.left;
          } else {
            t = r = b = l = value;
          }
          return {
            top: t,
            right: r,
            bottom: b,
            left: l
          };
        }
        var controller_line = core_datasetController.extend({
          datasetElementType: elements.Line,
          dataElementType: elements.Point,
          _datasetElementOptions: [
            "backgroundColor",
            "borderCapStyle",
            "borderColor",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "borderWidth",
            "cubicInterpolationMode",
            "fill"
          ],
          _dataElementOptions: {
            backgroundColor: "pointBackgroundColor",
            borderColor: "pointBorderColor",
            borderWidth: "pointBorderWidth",
            hitRadius: "pointHitRadius",
            hoverBackgroundColor: "pointHoverBackgroundColor",
            hoverBorderColor: "pointHoverBorderColor",
            hoverBorderWidth: "pointHoverBorderWidth",
            hoverRadius: "pointHoverRadius",
            pointStyle: "pointStyle",
            radius: "pointRadius",
            rotation: "pointRotation"
          },
          update: function(reset) {
            var me = this;
            var meta = me.getMeta();
            var line = meta.dataset;
            var points = meta.data || [];
            var options2 = me.chart.options;
            var config = me._config;
            var showLine = me._showLine = valueOrDefault$6(config.showLine, options2.showLines);
            var i, ilen;
            me._xScale = me.getScaleForId(meta.xAxisID);
            me._yScale = me.getScaleForId(meta.yAxisID);
            if (showLine) {
              if (config.tension !== void 0 && config.lineTension === void 0) {
                config.lineTension = config.tension;
              }
              line._scale = me._yScale;
              line._datasetIndex = me.index;
              line._children = points;
              line._model = me._resolveDatasetElementOptions(line);
              line.pivot();
            }
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              me.updateElement(points[i], i, reset);
            }
            if (showLine && line._model.tension !== 0) {
              me.updateBezierControlPoints();
            }
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              points[i].pivot();
            }
          },
          updateElement: function(point, index, reset) {
            var me = this;
            var meta = me.getMeta();
            var custom = point.custom || {};
            var dataset = me.getDataset();
            var datasetIndex = me.index;
            var value = dataset.data[index];
            var xScale = me._xScale;
            var yScale = me._yScale;
            var lineModel = meta.dataset._model;
            var x, y;
            var options2 = me._resolveDataElementOptions(point, index);
            x = xScale.getPixelForValue(typeof value === "object" ? value : NaN, index, datasetIndex);
            y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);
            point._xScale = xScale;
            point._yScale = yScale;
            point._options = options2;
            point._datasetIndex = datasetIndex;
            point._index = index;
            point._model = {
              x,
              y,
              skip: custom.skip || isNaN(x) || isNaN(y),
              radius: options2.radius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
              steppedLine: lineModel ? lineModel.steppedLine : false,
              hitRadius: options2.hitRadius
            };
          },
          _resolveDatasetElementOptions: function(element) {
            var me = this;
            var config = me._config;
            var custom = element.custom || {};
            var options2 = me.chart.options;
            var lineOptions = options2.elements.line;
            var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);
            values.spanGaps = valueOrDefault$6(config.spanGaps, options2.spanGaps);
            values.tension = valueOrDefault$6(config.lineTension, lineOptions.tension);
            values.steppedLine = resolve$2([custom.steppedLine, config.steppedLine, lineOptions.stepped]);
            values.clip = toClip(valueOrDefault$6(config.clip, defaultClip(me._xScale, me._yScale, values.borderWidth)));
            return values;
          },
          calculatePointY: function(value, index, datasetIndex) {
            var me = this;
            var chart = me.chart;
            var yScale = me._yScale;
            var sumPos = 0;
            var sumNeg = 0;
            var i, ds, dsMeta, stackedRightValue, rightValue, metasets, ilen;
            if (yScale.options.stacked) {
              rightValue = +yScale.getRightValue(value);
              metasets = chart._getSortedVisibleDatasetMetas();
              ilen = metasets.length;
              for (i = 0; i < ilen; ++i) {
                dsMeta = metasets[i];
                if (dsMeta.index === datasetIndex) {
                  break;
                }
                ds = chart.data.datasets[dsMeta.index];
                if (dsMeta.type === "line" && dsMeta.yAxisID === yScale.id) {
                  stackedRightValue = +yScale.getRightValue(ds.data[index]);
                  if (stackedRightValue < 0) {
                    sumNeg += stackedRightValue || 0;
                  } else {
                    sumPos += stackedRightValue || 0;
                  }
                }
              }
              if (rightValue < 0) {
                return yScale.getPixelForValue(sumNeg + rightValue);
              }
              return yScale.getPixelForValue(sumPos + rightValue);
            }
            return yScale.getPixelForValue(value);
          },
          updateBezierControlPoints: function() {
            var me = this;
            var chart = me.chart;
            var meta = me.getMeta();
            var lineModel = meta.dataset._model;
            var area = chart.chartArea;
            var points = meta.data || [];
            var i, ilen, model, controlPoints;
            if (lineModel.spanGaps) {
              points = points.filter(function(pt) {
                return !pt._model.skip;
              });
            }
            function capControlPoint(pt, min, max) {
              return Math.max(Math.min(pt, max), min);
            }
            if (lineModel.cubicInterpolationMode === "monotone") {
              helpers$1.splineCurveMonotone(points);
            } else {
              for (i = 0, ilen = points.length; i < ilen; ++i) {
                model = points[i]._model;
                controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);
                model.controlPointPreviousX = controlPoints.previous.x;
                model.controlPointPreviousY = controlPoints.previous.y;
                model.controlPointNextX = controlPoints.next.x;
                model.controlPointNextY = controlPoints.next.y;
              }
            }
            if (chart.options.elements.line.capBezierPoints) {
              for (i = 0, ilen = points.length; i < ilen; ++i) {
                model = points[i]._model;
                if (isPointInArea(model, area)) {
                  if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
                    model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                    model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
                  }
                  if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
                    model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                    model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
                  }
                }
              }
            }
          },
          draw: function() {
            var me = this;
            var chart = me.chart;
            var meta = me.getMeta();
            var points = meta.data || [];
            var area = chart.chartArea;
            var canvas2 = chart.canvas;
            var i = 0;
            var ilen = points.length;
            var clip;
            if (me._showLine) {
              clip = meta.dataset._model.clip;
              helpers$1.canvas.clipArea(chart.ctx, {
                left: clip.left === false ? 0 : area.left - clip.left,
                right: clip.right === false ? canvas2.width : area.right + clip.right,
                top: clip.top === false ? 0 : area.top - clip.top,
                bottom: clip.bottom === false ? canvas2.height : area.bottom + clip.bottom
              });
              meta.dataset.draw();
              helpers$1.canvas.unclipArea(chart.ctx);
            }
            for (; i < ilen; ++i) {
              points[i].draw(area);
            }
          },
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$6(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$6(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$6(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = valueOrDefault$6(options2.hoverRadius, options2.radius);
          }
        });
        var resolve$3 = helpers$1.options.resolve;
        core_defaults._set("polarArea", {
          scale: {
            type: "radialLinear",
            angleLines: {
              display: false
            },
            gridLines: {
              circular: true
            },
            pointLabels: {
              display: false
            },
            ticks: {
              beginAtZero: true
            }
          },
          animation: {
            animateRotate: true,
            animateScale: true
          },
          startAngle: -0.5 * Math.PI,
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var data2 = chart.data;
            var datasets = data2.datasets;
            var labels = data2.labels;
            var i, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            if (datasets.length) {
              for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
                listItem = list.appendChild(document.createElement("li"));
                listItemSpan = listItem.appendChild(document.createElement("span"));
                listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
                if (labels[i]) {
                  listItem.appendChild(document.createTextNode(labels[i]));
                }
              }
            }
            return list.outerHTML;
          },
          legend: {
            labels: {
              generateLabels: function(chart) {
                var data2 = chart.data;
                if (data2.labels.length && data2.datasets.length) {
                  return data2.labels.map(function(label, i) {
                    var meta = chart.getDatasetMeta(0);
                    var style = meta.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      hidden: isNaN(data2.datasets[0].data[i]) || meta.data[i].hidden,
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick: function(e, legendItem) {
              var index = legendItem.index;
              var chart = this.chart;
              var i, ilen, meta;
              for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                meta = chart.getDatasetMeta(i);
                meta.data[index].hidden = !meta.data[index].hidden;
              }
              chart.update();
            }
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item, data2) {
                return data2.labels[item.index] + ": " + item.yLabel;
              }
            }
          }
        });
        var controller_polarArea = core_datasetController.extend({
          dataElementType: elements.Arc,
          linkScales: helpers$1.noop,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "borderAlign",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth"
          ],
          _getIndexScaleId: function() {
            return this.chart.scale.id;
          },
          _getValueScaleId: function() {
            return this.chart.scale.id;
          },
          update: function(reset) {
            var me = this;
            var dataset = me.getDataset();
            var meta = me.getMeta();
            var start = me.chart.options.startAngle || 0;
            var starts = me._starts = [];
            var angles = me._angles = [];
            var arcs = meta.data;
            var i, ilen, angle;
            me._updateRadius();
            meta.count = me.countVisibleElements();
            for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
              starts[i] = start;
              angle = me._computeAngle(i);
              angles[i] = angle;
              start += angle;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
              me.updateElement(arcs[i], i, reset);
            }
          },
          _updateRadius: function() {
            var me = this;
            var chart = me.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
            chart.outerRadius = Math.max(minSize / 2, 0);
            chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
            me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
            me.innerRadius = me.outerRadius - chart.radiusLength;
          },
          updateElement: function(arc, index, reset) {
            var me = this;
            var chart = me.chart;
            var dataset = me.getDataset();
            var opts = chart.options;
            var animationOpts = opts.animation;
            var scale2 = chart.scale;
            var labels = chart.data.labels;
            var centerX = scale2.xCenter;
            var centerY = scale2.yCenter;
            var datasetStartAngle = opts.startAngle;
            var distance = arc.hidden ? 0 : scale2.getDistanceFromCenterForValue(dataset.data[index]);
            var startAngle = me._starts[index];
            var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
            var resetRadius = animationOpts.animateScale ? 0 : scale2.getDistanceFromCenterForValue(dataset.data[index]);
            var options2 = arc._options || {};
            helpers$1.extend(arc, {
              _datasetIndex: me.index,
              _index: index,
              _scale: scale2,
              _model: {
                backgroundColor: options2.backgroundColor,
                borderColor: options2.borderColor,
                borderWidth: options2.borderWidth,
                borderAlign: options2.borderAlign,
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius: reset ? resetRadius : distance,
                startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
                endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
                label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
              }
            });
            arc.pivot();
          },
          countVisibleElements: function() {
            var dataset = this.getDataset();
            var meta = this.getMeta();
            var count = 0;
            helpers$1.each(meta.data, function(element, index) {
              if (!isNaN(dataset.data[index]) && !element.hidden) {
                count++;
              }
            });
            return count;
          },
          setHoverStyle: function(arc) {
            var model = arc._model;
            var options2 = arc._options;
            var getHoverColor = helpers$1.getHoverColor;
            var valueOrDefault2 = helpers$1.valueOrDefault;
            arc.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = valueOrDefault2(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault2(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault2(options2.hoverBorderWidth, options2.borderWidth);
          },
          _computeAngle: function(index) {
            var me = this;
            var count = this.getMeta().count;
            var dataset = me.getDataset();
            var meta = me.getMeta();
            if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
              return 0;
            }
            var context = {
              chart: me.chart,
              dataIndex: index,
              dataset,
              datasetIndex: me.index
            };
            return resolve$3([
              me.chart.options.elements.arc.angle,
              2 * Math.PI / count
            ], context, index);
          }
        });
        core_defaults._set("pie", helpers$1.clone(core_defaults.doughnut));
        core_defaults._set("pie", {
          cutoutPercentage: 0
        });
        var controller_pie = controller_doughnut;
        var valueOrDefault$7 = helpers$1.valueOrDefault;
        core_defaults._set("radar", {
          spanGaps: false,
          scale: {
            type: "radialLinear"
          },
          elements: {
            line: {
              fill: "start",
              tension: 0
            }
          }
        });
        var controller_radar = core_datasetController.extend({
          datasetElementType: elements.Line,
          dataElementType: elements.Point,
          linkScales: helpers$1.noop,
          _datasetElementOptions: [
            "backgroundColor",
            "borderWidth",
            "borderColor",
            "borderCapStyle",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "fill"
          ],
          _dataElementOptions: {
            backgroundColor: "pointBackgroundColor",
            borderColor: "pointBorderColor",
            borderWidth: "pointBorderWidth",
            hitRadius: "pointHitRadius",
            hoverBackgroundColor: "pointHoverBackgroundColor",
            hoverBorderColor: "pointHoverBorderColor",
            hoverBorderWidth: "pointHoverBorderWidth",
            hoverRadius: "pointHoverRadius",
            pointStyle: "pointStyle",
            radius: "pointRadius",
            rotation: "pointRotation"
          },
          _getIndexScaleId: function() {
            return this.chart.scale.id;
          },
          _getValueScaleId: function() {
            return this.chart.scale.id;
          },
          update: function(reset) {
            var me = this;
            var meta = me.getMeta();
            var line = meta.dataset;
            var points = meta.data || [];
            var scale2 = me.chart.scale;
            var config = me._config;
            var i, ilen;
            if (config.tension !== void 0 && config.lineTension === void 0) {
              config.lineTension = config.tension;
            }
            line._scale = scale2;
            line._datasetIndex = me.index;
            line._children = points;
            line._loop = true;
            line._model = me._resolveDatasetElementOptions(line);
            line.pivot();
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              me.updateElement(points[i], i, reset);
            }
            me.updateBezierControlPoints();
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              points[i].pivot();
            }
          },
          updateElement: function(point, index, reset) {
            var me = this;
            var custom = point.custom || {};
            var dataset = me.getDataset();
            var scale2 = me.chart.scale;
            var pointPosition = scale2.getPointPositionForValue(index, dataset.data[index]);
            var options2 = me._resolveDataElementOptions(point, index);
            var lineModel = me.getMeta().dataset._model;
            var x = reset ? scale2.xCenter : pointPosition.x;
            var y = reset ? scale2.yCenter : pointPosition.y;
            point._scale = scale2;
            point._options = options2;
            point._datasetIndex = me.index;
            point._index = index;
            point._model = {
              x,
              y,
              skip: custom.skip || isNaN(x) || isNaN(y),
              radius: options2.radius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              tension: valueOrDefault$7(custom.tension, lineModel ? lineModel.tension : 0),
              hitRadius: options2.hitRadius
            };
          },
          _resolveDatasetElementOptions: function() {
            var me = this;
            var config = me._config;
            var options2 = me.chart.options;
            var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);
            values.spanGaps = valueOrDefault$7(config.spanGaps, options2.spanGaps);
            values.tension = valueOrDefault$7(config.lineTension, options2.elements.line.tension);
            return values;
          },
          updateBezierControlPoints: function() {
            var me = this;
            var meta = me.getMeta();
            var area = me.chart.chartArea;
            var points = meta.data || [];
            var i, ilen, model, controlPoints;
            if (meta.dataset._model.spanGaps) {
              points = points.filter(function(pt) {
                return !pt._model.skip;
              });
            }
            function capControlPoint(pt, min, max) {
              return Math.max(Math.min(pt, max), min);
            }
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              model = points[i]._model;
              controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension);
              model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
              model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
              model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
              model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
            }
          },
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$7(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$7(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$7(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = valueOrDefault$7(options2.hoverRadius, options2.radius);
          }
        });
        core_defaults._set("scatter", {
          hover: {
            mode: "single"
          },
          scales: {
            xAxes: [{
              id: "x-axis-1",
              type: "linear",
              position: "bottom"
            }],
            yAxes: [{
              id: "y-axis-1",
              type: "linear",
              position: "left"
            }]
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item) {
                return "(" + item.xLabel + ", " + item.yLabel + ")";
              }
            }
          }
        });
        core_defaults._set("global", {
          datasets: {
            scatter: {
              showLine: false
            }
          }
        });
        var controller_scatter = controller_line;
        var controllers = {
          bar: controller_bar,
          bubble: controller_bubble,
          doughnut: controller_doughnut,
          horizontalBar: controller_horizontalBar,
          line: controller_line,
          polarArea: controller_polarArea,
          pie: controller_pie,
          radar: controller_radar,
          scatter: controller_scatter
        };
        function getRelativePosition(e, chart) {
          if (e.native) {
            return {
              x: e.x,
              y: e.y
            };
          }
          return helpers$1.getRelativePosition(e, chart);
        }
        function parseVisibleItems(chart, handler2) {
          var metasets = chart._getSortedVisibleDatasetMetas();
          var metadata, i, j, ilen, jlen, element;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            metadata = metasets[i].data;
            for (j = 0, jlen = metadata.length; j < jlen; ++j) {
              element = metadata[j];
              if (!element._view.skip) {
                handler2(element);
              }
            }
          }
        }
        function getIntersectItems(chart, position) {
          var elements2 = [];
          parseVisibleItems(chart, function(element) {
            if (element.inRange(position.x, position.y)) {
              elements2.push(element);
            }
          });
          return elements2;
        }
        function getNearestItems(chart, position, intersect, distanceMetric) {
          var minDistance = Number.POSITIVE_INFINITY;
          var nearestItems = [];
          parseVisibleItems(chart, function(element) {
            if (intersect && !element.inRange(position.x, position.y)) {
              return;
            }
            var center = element.getCenterPoint();
            var distance = distanceMetric(position, center);
            if (distance < minDistance) {
              nearestItems = [element];
              minDistance = distance;
            } else if (distance === minDistance) {
              nearestItems.push(element);
            }
          });
          return nearestItems;
        }
        function getDistanceMetricForAxis(axis) {
          var useX = axis.indexOf("x") !== -1;
          var useY = axis.indexOf("y") !== -1;
          return function(pt1, pt2) {
            var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
            var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
          };
        }
        function indexMode(chart, e, options2) {
          var position = getRelativePosition(e, chart);
          options2.axis = options2.axis || "x";
          var distanceMetric = getDistanceMetricForAxis(options2.axis);
          var items = options2.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
          var elements2 = [];
          if (!items.length) {
            return [];
          }
          chart._getSortedVisibleDatasetMetas().forEach(function(meta) {
            var element = meta.data[items[0]._index];
            if (element && !element._view.skip) {
              elements2.push(element);
            }
          });
          return elements2;
        }
        var core_interaction = {
          modes: {
            single: function(chart, e) {
              var position = getRelativePosition(e, chart);
              var elements2 = [];
              parseVisibleItems(chart, function(element) {
                if (element.inRange(position.x, position.y)) {
                  elements2.push(element);
                  return elements2;
                }
              });
              return elements2.slice(0, 1);
            },
            label: indexMode,
            index: indexMode,
            dataset: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              options2.axis = options2.axis || "xy";
              var distanceMetric = getDistanceMetricForAxis(options2.axis);
              var items = options2.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
              if (items.length > 0) {
                items = chart.getDatasetMeta(items[0]._datasetIndex).data;
              }
              return items;
            },
            "x-axis": function(chart, e) {
              return indexMode(chart, e, { intersect: false });
            },
            point: function(chart, e) {
              var position = getRelativePosition(e, chart);
              return getIntersectItems(chart, position);
            },
            nearest: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              options2.axis = options2.axis || "xy";
              var distanceMetric = getDistanceMetricForAxis(options2.axis);
              return getNearestItems(chart, position, options2.intersect, distanceMetric);
            },
            x: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              var items = [];
              var intersectsItem = false;
              parseVisibleItems(chart, function(element) {
                if (element.inXRange(position.x)) {
                  items.push(element);
                }
                if (element.inRange(position.x, position.y)) {
                  intersectsItem = true;
                }
              });
              if (options2.intersect && !intersectsItem) {
                items = [];
              }
              return items;
            },
            y: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              var items = [];
              var intersectsItem = false;
              parseVisibleItems(chart, function(element) {
                if (element.inYRange(position.y)) {
                  items.push(element);
                }
                if (element.inRange(position.x, position.y)) {
                  intersectsItem = true;
                }
              });
              if (options2.intersect && !intersectsItem) {
                items = [];
              }
              return items;
            }
          }
        };
        var extend = helpers$1.extend;
        function filterByPosition(array, position) {
          return helpers$1.where(array, function(v) {
            return v.pos === position;
          });
        }
        function sortByWeight(array, reverse) {
          return array.sort(function(a, b) {
            var v0 = reverse ? b : a;
            var v1 = reverse ? a : b;
            return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
          });
        }
        function wrapBoxes(boxes) {
          var layoutBoxes = [];
          var i, ilen, box;
          for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
            box = boxes[i];
            layoutBoxes.push({
              index: i,
              box,
              pos: box.position,
              horizontal: box.isHorizontal(),
              weight: box.weight
            });
          }
          return layoutBoxes;
        }
        function setLayoutDims(layouts, params) {
          var i, ilen, layout;
          for (i = 0, ilen = layouts.length; i < ilen; ++i) {
            layout = layouts[i];
            layout.width = layout.horizontal ? layout.box.fullWidth && params.availableWidth : params.vBoxMaxWidth;
            layout.height = layout.horizontal && params.hBoxMaxHeight;
          }
        }
        function buildLayoutBoxes(boxes) {
          var layoutBoxes = wrapBoxes(boxes);
          var left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
          var right = sortByWeight(filterByPosition(layoutBoxes, "right"));
          var top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
          var bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
          return {
            leftAndTop: left.concat(top),
            rightAndBottom: right.concat(bottom),
            chartArea: filterByPosition(layoutBoxes, "chartArea"),
            vertical: left.concat(right),
            horizontal: top.concat(bottom)
          };
        }
        function getCombinedMax(maxPadding, chartArea, a, b) {
          return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
        }
        function updateDims(chartArea, params, layout) {
          var box = layout.box;
          var maxPadding = chartArea.maxPadding;
          var newWidth, newHeight;
          if (layout.size) {
            chartArea[layout.pos] -= layout.size;
          }
          layout.size = layout.horizontal ? box.height : box.width;
          chartArea[layout.pos] += layout.size;
          if (box.getPadding) {
            var boxPadding = box.getPadding();
            maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
            maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
            maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
            maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
          }
          newWidth = params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right");
          newHeight = params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom");
          if (newWidth !== chartArea.w || newHeight !== chartArea.h) {
            chartArea.w = newWidth;
            chartArea.h = newHeight;
            var sizes = layout.horizontal ? [newWidth, chartArea.w] : [newHeight, chartArea.h];
            return sizes[0] !== sizes[1] && (!isNaN(sizes[0]) || !isNaN(sizes[1]));
          }
        }
        function handleMaxPadding(chartArea) {
          var maxPadding = chartArea.maxPadding;
          function updatePos(pos) {
            var change = Math.max(maxPadding[pos] - chartArea[pos], 0);
            chartArea[pos] += change;
            return change;
          }
          chartArea.y += updatePos("top");
          chartArea.x += updatePos("left");
          updatePos("right");
          updatePos("bottom");
        }
        function getMargins(horizontal, chartArea) {
          var maxPadding = chartArea.maxPadding;
          function marginForPositions(positions) {
            var margin = { left: 0, top: 0, right: 0, bottom: 0 };
            positions.forEach(function(pos) {
              margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
            });
            return margin;
          }
          return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
        }
        function fitBoxes(boxes, chartArea, params) {
          var refitBoxes = [];
          var i, ilen, layout, box, refit, changed;
          for (i = 0, ilen = boxes.length; i < ilen; ++i) {
            layout = boxes[i];
            box = layout.box;
            box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
            if (updateDims(chartArea, params, layout)) {
              changed = true;
              if (refitBoxes.length) {
                refit = true;
              }
            }
            if (!box.fullWidth) {
              refitBoxes.push(layout);
            }
          }
          return refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;
        }
        function placeBoxes(boxes, chartArea, params) {
          var userPadding = params.padding;
          var x = chartArea.x;
          var y = chartArea.y;
          var i, ilen, layout, box;
          for (i = 0, ilen = boxes.length; i < ilen; ++i) {
            layout = boxes[i];
            box = layout.box;
            if (layout.horizontal) {
              box.left = box.fullWidth ? userPadding.left : chartArea.left;
              box.right = box.fullWidth ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;
              box.top = y;
              box.bottom = y + box.height;
              box.width = box.right - box.left;
              y = box.bottom;
            } else {
              box.left = x;
              box.right = x + box.width;
              box.top = chartArea.top;
              box.bottom = chartArea.top + chartArea.h;
              box.height = box.bottom - box.top;
              x = box.right;
            }
          }
          chartArea.x = x;
          chartArea.y = y;
        }
        core_defaults._set("global", {
          layout: {
            padding: {
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
            }
          }
        });
        var core_layouts = {
          defaults: {},
          addBox: function(chart, item) {
            if (!chart.boxes) {
              chart.boxes = [];
            }
            item.fullWidth = item.fullWidth || false;
            item.position = item.position || "top";
            item.weight = item.weight || 0;
            item._layers = item._layers || function() {
              return [{
                z: 0,
                draw: function() {
                  item.draw.apply(item, arguments);
                }
              }];
            };
            chart.boxes.push(item);
          },
          removeBox: function(chart, layoutItem) {
            var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
            if (index !== -1) {
              chart.boxes.splice(index, 1);
            }
          },
          configure: function(chart, item, options2) {
            var props2 = ["fullWidth", "position", "weight"];
            var ilen = props2.length;
            var i = 0;
            var prop;
            for (; i < ilen; ++i) {
              prop = props2[i];
              if (options2.hasOwnProperty(prop)) {
                item[prop] = options2[prop];
              }
            }
          },
          update: function(chart, width, height) {
            if (!chart) {
              return;
            }
            var layoutOptions = chart.options.layout || {};
            var padding = helpers$1.options.toPadding(layoutOptions.padding);
            var availableWidth = width - padding.width;
            var availableHeight = height - padding.height;
            var boxes = buildLayoutBoxes(chart.boxes);
            var verticalBoxes = boxes.vertical;
            var horizontalBoxes = boxes.horizontal;
            var params = Object.freeze({
              outerWidth: width,
              outerHeight: height,
              padding,
              availableWidth,
              vBoxMaxWidth: availableWidth / 2 / verticalBoxes.length,
              hBoxMaxHeight: availableHeight / 2
            });
            var chartArea = extend({
              maxPadding: extend({}, padding),
              w: availableWidth,
              h: availableHeight,
              x: padding.left,
              y: padding.top
            }, padding);
            setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
            fitBoxes(verticalBoxes, chartArea, params);
            if (fitBoxes(horizontalBoxes, chartArea, params)) {
              fitBoxes(verticalBoxes, chartArea, params);
            }
            handleMaxPadding(chartArea);
            placeBoxes(boxes.leftAndTop, chartArea, params);
            chartArea.x += chartArea.w;
            chartArea.y += chartArea.h;
            placeBoxes(boxes.rightAndBottom, chartArea, params);
            chart.chartArea = {
              left: chartArea.left,
              top: chartArea.top,
              right: chartArea.left + chartArea.w,
              bottom: chartArea.top + chartArea.h
            };
            helpers$1.each(boxes.chartArea, function(layout) {
              var box = layout.box;
              extend(box, chart.chartArea);
              box.update(chartArea.w, chartArea.h);
            });
          }
        };
        var platform_basic = {
          acquireContext: function(item) {
            if (item && item.canvas) {
              item = item.canvas;
            }
            return item && item.getContext("2d") || null;
          }
        };
        var platform_dom = "/*\r\n * DOM element rendering detection\r\n * https://davidwalsh.name/detect-node-insertion\r\n */\r\n@keyframes chartjs-render-animation {\r\n	from { opacity: 0.99; }\r\n	to { opacity: 1; }\r\n}\r\n\r\n.chartjs-render-monitor {\r\n	animation: chartjs-render-animation 0.001s;\r\n}\r\n\r\n/*\r\n * DOM element resizing detection\r\n * https://github.com/marcj/css-element-queries\r\n */\r\n.chartjs-size-monitor,\r\n.chartjs-size-monitor-expand,\r\n.chartjs-size-monitor-shrink {\r\n	position: absolute;\r\n	direction: ltr;\r\n	left: 0;\r\n	top: 0;\r\n	right: 0;\r\n	bottom: 0;\r\n	overflow: hidden;\r\n	pointer-events: none;\r\n	visibility: hidden;\r\n	z-index: -1;\r\n}\r\n\r\n.chartjs-size-monitor-expand > div {\r\n	position: absolute;\r\n	width: 1000000px;\r\n	height: 1000000px;\r\n	left: 0;\r\n	top: 0;\r\n}\r\n\r\n.chartjs-size-monitor-shrink > div {\r\n	position: absolute;\r\n	width: 200%;\r\n	height: 200%;\r\n	left: 0;\r\n	top: 0;\r\n}\r\n";
        var platform_dom$1 = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          "default": platform_dom
        });
        var stylesheet = getCjsExportFromNamespace(platform_dom$1);
        var EXPANDO_KEY = "$chartjs";
        var CSS_PREFIX = "chartjs-";
        var CSS_SIZE_MONITOR = CSS_PREFIX + "size-monitor";
        var CSS_RENDER_MONITOR = CSS_PREFIX + "render-monitor";
        var CSS_RENDER_ANIMATION = CSS_PREFIX + "render-animation";
        var ANIMATION_START_EVENTS = ["animationstart", "webkitAnimationStart"];
        var EVENT_TYPES = {
          touchstart: "mousedown",
          touchmove: "mousemove",
          touchend: "mouseup",
          pointerenter: "mouseenter",
          pointerdown: "mousedown",
          pointermove: "mousemove",
          pointerup: "mouseup",
          pointerleave: "mouseout",
          pointerout: "mouseout"
        };
        function readUsedSize(element, property) {
          var value = helpers$1.getStyle(element, property);
          var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
          return matches ? Number(matches[1]) : void 0;
        }
        function initCanvas(canvas2, config) {
          var style = canvas2.style;
          var renderHeight = canvas2.getAttribute("height");
          var renderWidth = canvas2.getAttribute("width");
          canvas2[EXPANDO_KEY] = {
            initial: {
              height: renderHeight,
              width: renderWidth,
              style: {
                display: style.display,
                height: style.height,
                width: style.width
              }
            }
          };
          style.display = style.display || "block";
          if (renderWidth === null || renderWidth === "") {
            var displayWidth = readUsedSize(canvas2, "width");
            if (displayWidth !== void 0) {
              canvas2.width = displayWidth;
            }
          }
          if (renderHeight === null || renderHeight === "") {
            if (canvas2.style.height === "") {
              canvas2.height = canvas2.width / (config.options.aspectRatio || 2);
            } else {
              var displayHeight = readUsedSize(canvas2, "height");
              if (displayWidth !== void 0) {
                canvas2.height = displayHeight;
              }
            }
          }
          return canvas2;
        }
        var supportsEventListenerOptions = function() {
          var supports = false;
          try {
            var options2 = Object.defineProperty({}, "passive", {
              get: function() {
                supports = true;
              }
            });
            window.addEventListener("e", null, options2);
          } catch (e) {
          }
          return supports;
        }();
        var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
        function addListener(node, type, listener) {
          node.addEventListener(type, listener, eventListenerOptions);
        }
        function removeListener(node, type, listener) {
          node.removeEventListener(type, listener, eventListenerOptions);
        }
        function createEvent(type, chart, x, y, nativeEvent) {
          return {
            type,
            chart,
            native: nativeEvent || null,
            x: x !== void 0 ? x : null,
            y: y !== void 0 ? y : null
          };
        }
        function fromNativeEvent(event, chart) {
          var type = EVENT_TYPES[event.type] || event.type;
          var pos = helpers$1.getRelativePosition(event, chart);
          return createEvent(type, chart, pos.x, pos.y, event);
        }
        function throttled(fn, thisArg) {
          var ticking = false;
          var args = [];
          return function() {
            args = Array.prototype.slice.call(arguments);
            thisArg = thisArg || this;
            if (!ticking) {
              ticking = true;
              helpers$1.requestAnimFrame.call(window, function() {
                ticking = false;
                fn.apply(thisArg, args);
              });
            }
          };
        }
        function createDiv(cls) {
          var el = document.createElement("div");
          el.className = cls || "";
          return el;
        }
        function createResizer(handler2) {
          var maxSize = 1e6;
          var resizer = createDiv(CSS_SIZE_MONITOR);
          var expand = createDiv(CSS_SIZE_MONITOR + "-expand");
          var shrink = createDiv(CSS_SIZE_MONITOR + "-shrink");
          expand.appendChild(createDiv());
          shrink.appendChild(createDiv());
          resizer.appendChild(expand);
          resizer.appendChild(shrink);
          resizer._reset = function() {
            expand.scrollLeft = maxSize;
            expand.scrollTop = maxSize;
            shrink.scrollLeft = maxSize;
            shrink.scrollTop = maxSize;
          };
          var onScroll = function() {
            resizer._reset();
            handler2();
          };
          addListener(expand, "scroll", onScroll.bind(expand, "expand"));
          addListener(shrink, "scroll", onScroll.bind(shrink, "shrink"));
          return resizer;
        }
        function watchForRender(node, handler2) {
          var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
          var proxy2 = expando.renderProxy = function(e) {
            if (e.animationName === CSS_RENDER_ANIMATION) {
              handler2();
            }
          };
          helpers$1.each(ANIMATION_START_EVENTS, function(type) {
            addListener(node, type, proxy2);
          });
          expando.reflow = !!node.offsetParent;
          node.classList.add(CSS_RENDER_MONITOR);
        }
        function unwatchForRender(node) {
          var expando = node[EXPANDO_KEY] || {};
          var proxy2 = expando.renderProxy;
          if (proxy2) {
            helpers$1.each(ANIMATION_START_EVENTS, function(type) {
              removeListener(node, type, proxy2);
            });
            delete expando.renderProxy;
          }
          node.classList.remove(CSS_RENDER_MONITOR);
        }
        function addResizeListener(node, listener, chart) {
          var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
          var resizer = expando.resizer = createResizer(throttled(function() {
            if (expando.resizer) {
              var container = chart.options.maintainAspectRatio && node.parentNode;
              var w = container ? container.clientWidth : 0;
              listener(createEvent("resize", chart));
              if (container && container.clientWidth < w && chart.canvas) {
                listener(createEvent("resize", chart));
              }
            }
          }));
          watchForRender(node, function() {
            if (expando.resizer) {
              var container = node.parentNode;
              if (container && container !== resizer.parentNode) {
                container.insertBefore(resizer, container.firstChild);
              }
              resizer._reset();
            }
          });
        }
        function removeResizeListener(node) {
          var expando = node[EXPANDO_KEY] || {};
          var resizer = expando.resizer;
          delete expando.resizer;
          unwatchForRender(node);
          if (resizer && resizer.parentNode) {
            resizer.parentNode.removeChild(resizer);
          }
        }
        function injectCSS(rootNode, css) {
          var expando = rootNode[EXPANDO_KEY] || (rootNode[EXPANDO_KEY] = {});
          if (!expando.containsStyles) {
            expando.containsStyles = true;
            css = "/* Chart.js */\n" + css;
            var style = document.createElement("style");
            style.setAttribute("type", "text/css");
            style.appendChild(document.createTextNode(css));
            rootNode.appendChild(style);
          }
        }
        var platform_dom$2 = {
          disableCSSInjection: false,
          _enabled: typeof window !== "undefined" && typeof document !== "undefined",
          _ensureLoaded: function(canvas2) {
            if (!this.disableCSSInjection) {
              var root = canvas2.getRootNode ? canvas2.getRootNode() : document;
              var targetNode = root.host ? root : document.head;
              injectCSS(targetNode, stylesheet);
            }
          },
          acquireContext: function(item, config) {
            if (typeof item === "string") {
              item = document.getElementById(item);
            } else if (item.length) {
              item = item[0];
            }
            if (item && item.canvas) {
              item = item.canvas;
            }
            var context = item && item.getContext && item.getContext("2d");
            if (context && context.canvas === item) {
              this._ensureLoaded(item);
              initCanvas(item, config);
              return context;
            }
            return null;
          },
          releaseContext: function(context) {
            var canvas2 = context.canvas;
            if (!canvas2[EXPANDO_KEY]) {
              return;
            }
            var initial = canvas2[EXPANDO_KEY].initial;
            ["height", "width"].forEach(function(prop) {
              var value = initial[prop];
              if (helpers$1.isNullOrUndef(value)) {
                canvas2.removeAttribute(prop);
              } else {
                canvas2.setAttribute(prop, value);
              }
            });
            helpers$1.each(initial.style || {}, function(value, key) {
              canvas2.style[key] = value;
            });
            canvas2.width = canvas2.width;
            delete canvas2[EXPANDO_KEY];
          },
          addEventListener: function(chart, type, listener) {
            var canvas2 = chart.canvas;
            if (type === "resize") {
              addResizeListener(canvas2, listener, chart);
              return;
            }
            var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
            var proxies = expando.proxies || (expando.proxies = {});
            var proxy2 = proxies[chart.id + "_" + type] = function(event) {
              listener(fromNativeEvent(event, chart));
            };
            addListener(canvas2, type, proxy2);
          },
          removeEventListener: function(chart, type, listener) {
            var canvas2 = chart.canvas;
            if (type === "resize") {
              removeResizeListener(canvas2);
              return;
            }
            var expando = listener[EXPANDO_KEY] || {};
            var proxies = expando.proxies || {};
            var proxy2 = proxies[chart.id + "_" + type];
            if (!proxy2) {
              return;
            }
            removeListener(canvas2, type, proxy2);
          }
        };
        helpers$1.addEvent = addListener;
        helpers$1.removeEvent = removeListener;
        var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
        var platform = helpers$1.extend({
          initialize: function() {
          },
          acquireContext: function() {
          },
          releaseContext: function() {
          },
          addEventListener: function() {
          },
          removeEventListener: function() {
          }
        }, implementation);
        core_defaults._set("global", {
          plugins: {}
        });
        var core_plugins = {
          _plugins: [],
          _cacheId: 0,
          register: function(plugins2) {
            var p = this._plugins;
            [].concat(plugins2).forEach(function(plugin) {
              if (p.indexOf(plugin) === -1) {
                p.push(plugin);
              }
            });
            this._cacheId++;
          },
          unregister: function(plugins2) {
            var p = this._plugins;
            [].concat(plugins2).forEach(function(plugin) {
              var idx = p.indexOf(plugin);
              if (idx !== -1) {
                p.splice(idx, 1);
              }
            });
            this._cacheId++;
          },
          clear: function() {
            this._plugins = [];
            this._cacheId++;
          },
          count: function() {
            return this._plugins.length;
          },
          getAll: function() {
            return this._plugins;
          },
          notify: function(chart, hook, args) {
            var descriptors = this.descriptors(chart);
            var ilen = descriptors.length;
            var i, descriptor, plugin, params, method;
            for (i = 0; i < ilen; ++i) {
              descriptor = descriptors[i];
              plugin = descriptor.plugin;
              method = plugin[hook];
              if (typeof method === "function") {
                params = [chart].concat(args || []);
                params.push(descriptor.options);
                if (method.apply(plugin, params) === false) {
                  return false;
                }
              }
            }
            return true;
          },
          descriptors: function(chart) {
            var cache = chart.$plugins || (chart.$plugins = {});
            if (cache.id === this._cacheId) {
              return cache.descriptors;
            }
            var plugins2 = [];
            var descriptors = [];
            var config = chart && chart.config || {};
            var options2 = config.options && config.options.plugins || {};
            this._plugins.concat(config.plugins || []).forEach(function(plugin) {
              var idx = plugins2.indexOf(plugin);
              if (idx !== -1) {
                return;
              }
              var id = plugin.id;
              var opts = options2[id];
              if (opts === false) {
                return;
              }
              if (opts === true) {
                opts = helpers$1.clone(core_defaults.global.plugins[id]);
              }
              plugins2.push(plugin);
              descriptors.push({
                plugin,
                options: opts || {}
              });
            });
            cache.descriptors = descriptors;
            cache.id = this._cacheId;
            return descriptors;
          },
          _invalidate: function(chart) {
            delete chart.$plugins;
          }
        };
        var core_scaleService = {
          constructors: {},
          defaults: {},
          registerScaleType: function(type, scaleConstructor, scaleDefaults) {
            this.constructors[type] = scaleConstructor;
            this.defaults[type] = helpers$1.clone(scaleDefaults);
          },
          getScaleConstructor: function(type) {
            return this.constructors.hasOwnProperty(type) ? this.constructors[type] : void 0;
          },
          getScaleDefaults: function(type) {
            return this.defaults.hasOwnProperty(type) ? helpers$1.merge(/* @__PURE__ */ Object.create(null), [core_defaults.scale, this.defaults[type]]) : {};
          },
          updateScaleDefaults: function(type, additions) {
            var me = this;
            if (me.defaults.hasOwnProperty(type)) {
              me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
            }
          },
          addScalesToLayout: function(chart) {
            helpers$1.each(chart.scales, function(scale2) {
              scale2.fullWidth = scale2.options.fullWidth;
              scale2.position = scale2.options.position;
              scale2.weight = scale2.options.weight;
              core_layouts.addBox(chart, scale2);
            });
          }
        };
        var valueOrDefault$8 = helpers$1.valueOrDefault;
        var getRtlHelper = helpers$1.rtl.getRtlAdapter;
        core_defaults._set("global", {
          tooltips: {
            enabled: true,
            custom: null,
            mode: "nearest",
            position: "average",
            intersect: true,
            backgroundColor: "rgba(0,0,0,0.8)",
            titleFontStyle: "bold",
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleFontColor: "#fff",
            titleAlign: "left",
            bodySpacing: 2,
            bodyFontColor: "#fff",
            bodyAlign: "left",
            footerFontStyle: "bold",
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFontColor: "#fff",
            footerAlign: "left",
            yPadding: 6,
            xPadding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            multiKeyBackground: "#fff",
            displayColors: true,
            borderColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            callbacks: {
              beforeTitle: helpers$1.noop,
              title: function(tooltipItems, data2) {
                var title2 = "";
                var labels = data2.labels;
                var labelCount = labels ? labels.length : 0;
                if (tooltipItems.length > 0) {
                  var item = tooltipItems[0];
                  if (item.label) {
                    title2 = item.label;
                  } else if (item.xLabel) {
                    title2 = item.xLabel;
                  } else if (labelCount > 0 && item.index < labelCount) {
                    title2 = labels[item.index];
                  }
                }
                return title2;
              },
              afterTitle: helpers$1.noop,
              beforeBody: helpers$1.noop,
              beforeLabel: helpers$1.noop,
              label: function(tooltipItem, data2) {
                var label = data2.datasets[tooltipItem.datasetIndex].label || "";
                if (label) {
                  label += ": ";
                }
                if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
                  label += tooltipItem.value;
                } else {
                  label += tooltipItem.yLabel;
                }
                return label;
              },
              labelColor: function(tooltipItem, chart) {
                var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
                var activeElement = meta.data[tooltipItem.index];
                var view = activeElement._view;
                return {
                  borderColor: view.borderColor,
                  backgroundColor: view.backgroundColor
                };
              },
              labelTextColor: function() {
                return this._options.bodyFontColor;
              },
              afterLabel: helpers$1.noop,
              afterBody: helpers$1.noop,
              beforeFooter: helpers$1.noop,
              footer: helpers$1.noop,
              afterFooter: helpers$1.noop
            }
          }
        });
        var positioners = {
          average: function(elements2) {
            if (!elements2.length) {
              return false;
            }
            var i, len;
            var x = 0;
            var y = 0;
            var count = 0;
            for (i = 0, len = elements2.length; i < len; ++i) {
              var el = elements2[i];
              if (el && el.hasValue()) {
                var pos = el.tooltipPosition();
                x += pos.x;
                y += pos.y;
                ++count;
              }
            }
            return {
              x: x / count,
              y: y / count
            };
          },
          nearest: function(elements2, eventPosition) {
            var x = eventPosition.x;
            var y = eventPosition.y;
            var minDistance = Number.POSITIVE_INFINITY;
            var i, len, nearestElement;
            for (i = 0, len = elements2.length; i < len; ++i) {
              var el = elements2[i];
              if (el && el.hasValue()) {
                var center = el.getCenterPoint();
                var d = helpers$1.distanceBetweenPoints(eventPosition, center);
                if (d < minDistance) {
                  minDistance = d;
                  nearestElement = el;
                }
              }
            }
            if (nearestElement) {
              var tp = nearestElement.tooltipPosition();
              x = tp.x;
              y = tp.y;
            }
            return {
              x,
              y
            };
          }
        };
        function pushOrConcat(base, toPush) {
          if (toPush) {
            if (helpers$1.isArray(toPush)) {
              Array.prototype.push.apply(base, toPush);
            } else {
              base.push(toPush);
            }
          }
          return base;
        }
        function splitNewlines(str) {
          if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
            return str.split("\n");
          }
          return str;
        }
        function createTooltipItem(element) {
          var xScale = element._xScale;
          var yScale = element._yScale || element._scale;
          var index = element._index;
          var datasetIndex = element._datasetIndex;
          var controller = element._chart.getDatasetMeta(datasetIndex).controller;
          var indexScale = controller._getIndexScale();
          var valueScale = controller._getValueScale();
          return {
            xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : "",
            yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : "",
            label: indexScale ? "" + indexScale.getLabelForIndex(index, datasetIndex) : "",
            value: valueScale ? "" + valueScale.getLabelForIndex(index, datasetIndex) : "",
            index,
            datasetIndex,
            x: element._model.x,
            y: element._model.y
          };
        }
        function getBaseModel(tooltipOpts) {
          var globalDefaults = core_defaults.global;
          return {
            xPadding: tooltipOpts.xPadding,
            yPadding: tooltipOpts.yPadding,
            xAlign: tooltipOpts.xAlign,
            yAlign: tooltipOpts.yAlign,
            rtl: tooltipOpts.rtl,
            textDirection: tooltipOpts.textDirection,
            bodyFontColor: tooltipOpts.bodyFontColor,
            _bodyFontFamily: valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
            _bodyFontStyle: valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
            _bodyAlign: tooltipOpts.bodyAlign,
            bodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
            bodySpacing: tooltipOpts.bodySpacing,
            titleFontColor: tooltipOpts.titleFontColor,
            _titleFontFamily: valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
            _titleFontStyle: valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
            titleFontSize: valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
            _titleAlign: tooltipOpts.titleAlign,
            titleSpacing: tooltipOpts.titleSpacing,
            titleMarginBottom: tooltipOpts.titleMarginBottom,
            footerFontColor: tooltipOpts.footerFontColor,
            _footerFontFamily: valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
            _footerFontStyle: valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
            footerFontSize: valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
            _footerAlign: tooltipOpts.footerAlign,
            footerSpacing: tooltipOpts.footerSpacing,
            footerMarginTop: tooltipOpts.footerMarginTop,
            caretSize: tooltipOpts.caretSize,
            cornerRadius: tooltipOpts.cornerRadius,
            backgroundColor: tooltipOpts.backgroundColor,
            opacity: 0,
            legendColorBackground: tooltipOpts.multiKeyBackground,
            displayColors: tooltipOpts.displayColors,
            borderColor: tooltipOpts.borderColor,
            borderWidth: tooltipOpts.borderWidth
          };
        }
        function getTooltipSize(tooltip, model) {
          var ctx = tooltip._chart.ctx;
          var height = model.yPadding * 2;
          var width = 0;
          var body = model.body;
          var combinedBodyLength = body.reduce(function(count, bodyItem) {
            return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
          }, 0);
          combinedBodyLength += model.beforeBody.length + model.afterBody.length;
          var titleLineCount = model.title.length;
          var footerLineCount = model.footer.length;
          var titleFontSize = model.titleFontSize;
          var bodyFontSize = model.bodyFontSize;
          var footerFontSize = model.footerFontSize;
          height += titleLineCount * titleFontSize;
          height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0;
          height += titleLineCount ? model.titleMarginBottom : 0;
          height += combinedBodyLength * bodyFontSize;
          height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0;
          height += footerLineCount ? model.footerMarginTop : 0;
          height += footerLineCount * footerFontSize;
          height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0;
          var widthPadding = 0;
          var maxLineWidth = function(line) {
            width = Math.max(width, ctx.measureText(line).width + widthPadding);
          };
          ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
          helpers$1.each(model.title, maxLineWidth);
          ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
          helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
          widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
          helpers$1.each(body, function(bodyItem) {
            helpers$1.each(bodyItem.before, maxLineWidth);
            helpers$1.each(bodyItem.lines, maxLineWidth);
            helpers$1.each(bodyItem.after, maxLineWidth);
          });
          widthPadding = 0;
          ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
          helpers$1.each(model.footer, maxLineWidth);
          width += 2 * model.xPadding;
          return {
            width,
            height
          };
        }
        function determineAlignment(tooltip, size) {
          var model = tooltip._model;
          var chart = tooltip._chart;
          var chartArea = tooltip._chart.chartArea;
          var xAlign = "center";
          var yAlign = "center";
          if (model.y < size.height) {
            yAlign = "top";
          } else if (model.y > chart.height - size.height) {
            yAlign = "bottom";
          }
          var lf, rf;
          var olf, orf;
          var yf;
          var midX = (chartArea.left + chartArea.right) / 2;
          var midY = (chartArea.top + chartArea.bottom) / 2;
          if (yAlign === "center") {
            lf = function(x) {
              return x <= midX;
            };
            rf = function(x) {
              return x > midX;
            };
          } else {
            lf = function(x) {
              return x <= size.width / 2;
            };
            rf = function(x) {
              return x >= chart.width - size.width / 2;
            };
          }
          olf = function(x) {
            return x + size.width + model.caretSize + model.caretPadding > chart.width;
          };
          orf = function(x) {
            return x - size.width - model.caretSize - model.caretPadding < 0;
          };
          yf = function(y) {
            return y <= midY ? "top" : "bottom";
          };
          if (lf(model.x)) {
            xAlign = "left";
            if (olf(model.x)) {
              xAlign = "center";
              yAlign = yf(model.y);
            }
          } else if (rf(model.x)) {
            xAlign = "right";
            if (orf(model.x)) {
              xAlign = "center";
              yAlign = yf(model.y);
            }
          }
          var opts = tooltip._options;
          return {
            xAlign: opts.xAlign ? opts.xAlign : xAlign,
            yAlign: opts.yAlign ? opts.yAlign : yAlign
          };
        }
        function getBackgroundPoint(vm, size, alignment, chart) {
          var x = vm.x;
          var y = vm.y;
          var caretSize = vm.caretSize;
          var caretPadding = vm.caretPadding;
          var cornerRadius = vm.cornerRadius;
          var xAlign = alignment.xAlign;
          var yAlign = alignment.yAlign;
          var paddingAndSize = caretSize + caretPadding;
          var radiusAndPadding = cornerRadius + caretPadding;
          if (xAlign === "right") {
            x -= size.width;
          } else if (xAlign === "center") {
            x -= size.width / 2;
            if (x + size.width > chart.width) {
              x = chart.width - size.width;
            }
            if (x < 0) {
              x = 0;
            }
          }
          if (yAlign === "top") {
            y += paddingAndSize;
          } else if (yAlign === "bottom") {
            y -= size.height + paddingAndSize;
          } else {
            y -= size.height / 2;
          }
          if (yAlign === "center") {
            if (xAlign === "left") {
              x += paddingAndSize;
            } else if (xAlign === "right") {
              x -= paddingAndSize;
            }
          } else if (xAlign === "left") {
            x -= radiusAndPadding;
          } else if (xAlign === "right") {
            x += radiusAndPadding;
          }
          return {
            x,
            y
          };
        }
        function getAlignedX(vm, align) {
          return align === "center" ? vm.x + vm.width / 2 : align === "right" ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
        }
        function getBeforeAfterBodyLines(callback) {
          return pushOrConcat([], splitNewlines(callback));
        }
        var exports$4 = core_element.extend({
          initialize: function() {
            this._model = getBaseModel(this._options);
            this._lastActive = [];
          },
          getTitle: function() {
            var me = this;
            var opts = me._options;
            var callbacks = opts.callbacks;
            var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
            var title2 = callbacks.title.apply(me, arguments);
            var afterTitle = callbacks.afterTitle.apply(me, arguments);
            var lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeTitle));
            lines = pushOrConcat(lines, splitNewlines(title2));
            lines = pushOrConcat(lines, splitNewlines(afterTitle));
            return lines;
          },
          getBeforeBody: function() {
            return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
          },
          getBody: function(tooltipItems, data2) {
            var me = this;
            var callbacks = me._options.callbacks;
            var bodyItems = [];
            helpers$1.each(tooltipItems, function(tooltipItem) {
              var bodyItem = {
                before: [],
                lines: [],
                after: []
              };
              pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data2)));
              pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data2));
              pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data2)));
              bodyItems.push(bodyItem);
            });
            return bodyItems;
          },
          getAfterBody: function() {
            return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
          },
          getFooter: function() {
            var me = this;
            var callbacks = me._options.callbacks;
            var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
            var footer = callbacks.footer.apply(me, arguments);
            var afterFooter = callbacks.afterFooter.apply(me, arguments);
            var lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeFooter));
            lines = pushOrConcat(lines, splitNewlines(footer));
            lines = pushOrConcat(lines, splitNewlines(afterFooter));
            return lines;
          },
          update: function(changed) {
            var me = this;
            var opts = me._options;
            var existingModel = me._model;
            var model = me._model = getBaseModel(opts);
            var active = me._active;
            var data2 = me._data;
            var alignment = {
              xAlign: existingModel.xAlign,
              yAlign: existingModel.yAlign
            };
            var backgroundPoint = {
              x: existingModel.x,
              y: existingModel.y
            };
            var tooltipSize = {
              width: existingModel.width,
              height: existingModel.height
            };
            var tooltipPosition = {
              x: existingModel.caretX,
              y: existingModel.caretY
            };
            var i, len;
            if (active.length) {
              model.opacity = 1;
              var labelColors = [];
              var labelTextColors = [];
              tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
              var tooltipItems = [];
              for (i = 0, len = active.length; i < len; ++i) {
                tooltipItems.push(createTooltipItem(active[i]));
              }
              if (opts.filter) {
                tooltipItems = tooltipItems.filter(function(a) {
                  return opts.filter(a, data2);
                });
              }
              if (opts.itemSort) {
                tooltipItems = tooltipItems.sort(function(a, b) {
                  return opts.itemSort(a, b, data2);
                });
              }
              helpers$1.each(tooltipItems, function(tooltipItem) {
                labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
                labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
              });
              model.title = me.getTitle(tooltipItems, data2);
              model.beforeBody = me.getBeforeBody(tooltipItems, data2);
              model.body = me.getBody(tooltipItems, data2);
              model.afterBody = me.getAfterBody(tooltipItems, data2);
              model.footer = me.getFooter(tooltipItems, data2);
              model.x = tooltipPosition.x;
              model.y = tooltipPosition.y;
              model.caretPadding = opts.caretPadding;
              model.labelColors = labelColors;
              model.labelTextColors = labelTextColors;
              model.dataPoints = tooltipItems;
              tooltipSize = getTooltipSize(this, model);
              alignment = determineAlignment(this, tooltipSize);
              backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
            } else {
              model.opacity = 0;
            }
            model.xAlign = alignment.xAlign;
            model.yAlign = alignment.yAlign;
            model.x = backgroundPoint.x;
            model.y = backgroundPoint.y;
            model.width = tooltipSize.width;
            model.height = tooltipSize.height;
            model.caretX = tooltipPosition.x;
            model.caretY = tooltipPosition.y;
            me._model = model;
            if (changed && opts.custom) {
              opts.custom.call(me, model);
            }
            return me;
          },
          drawCaret: function(tooltipPoint, size) {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
            ctx.lineTo(caretPosition.x1, caretPosition.y1);
            ctx.lineTo(caretPosition.x2, caretPosition.y2);
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
          },
          getCaretPosition: function(tooltipPoint, size, vm) {
            var x1, x2, x3, y1, y2, y3;
            var caretSize = vm.caretSize;
            var cornerRadius = vm.cornerRadius;
            var xAlign = vm.xAlign;
            var yAlign = vm.yAlign;
            var ptX = tooltipPoint.x;
            var ptY = tooltipPoint.y;
            var width = size.width;
            var height = size.height;
            if (yAlign === "center") {
              y2 = ptY + height / 2;
              if (xAlign === "left") {
                x1 = ptX;
                x2 = x1 - caretSize;
                x3 = x1;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
              } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                x3 = x1;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
              }
            } else {
              if (xAlign === "left") {
                x2 = ptX + cornerRadius + caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else if (xAlign === "right") {
                x2 = ptX + width - cornerRadius - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else {
                x2 = vm.caretX;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              }
              if (yAlign === "top") {
                y1 = ptY;
                y2 = y1 - caretSize;
                y3 = y1;
              } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                y3 = y1;
                var tmp = x3;
                x3 = x1;
                x1 = tmp;
              }
            }
            return { x1, x2, x3, y1, y2, y3 };
          },
          drawTitle: function(pt, vm, ctx) {
            var title2 = vm.title;
            var length = title2.length;
            var titleFontSize, titleSpacing, i;
            if (length) {
              var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
              pt.x = getAlignedX(vm, vm._titleAlign);
              ctx.textAlign = rtlHelper.textAlign(vm._titleAlign);
              ctx.textBaseline = "middle";
              titleFontSize = vm.titleFontSize;
              titleSpacing = vm.titleSpacing;
              ctx.fillStyle = vm.titleFontColor;
              ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
              for (i = 0; i < length; ++i) {
                ctx.fillText(title2[i], rtlHelper.x(pt.x), pt.y + titleFontSize / 2);
                pt.y += titleFontSize + titleSpacing;
                if (i + 1 === length) {
                  pt.y += vm.titleMarginBottom - titleSpacing;
                }
              }
            }
          },
          drawBody: function(pt, vm, ctx) {
            var bodyFontSize = vm.bodyFontSize;
            var bodySpacing = vm.bodySpacing;
            var bodyAlign = vm._bodyAlign;
            var body = vm.body;
            var drawColorBoxes = vm.displayColors;
            var xLinePadding = 0;
            var colorX = drawColorBoxes ? getAlignedX(vm, "left") : 0;
            var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
            var fillLineOfText = function(line) {
              ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);
              pt.y += bodyFontSize + bodySpacing;
            };
            var bodyItem, textColor, labelColors, lines, i, j, ilen, jlen;
            var bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
            ctx.textAlign = bodyAlign;
            ctx.textBaseline = "middle";
            ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
            pt.x = getAlignedX(vm, bodyAlignForCalculation);
            ctx.fillStyle = vm.bodyFontColor;
            helpers$1.each(vm.beforeBody, fillLineOfText);
            xLinePadding = drawColorBoxes && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0;
            for (i = 0, ilen = body.length; i < ilen; ++i) {
              bodyItem = body[i];
              textColor = vm.labelTextColors[i];
              labelColors = vm.labelColors[i];
              ctx.fillStyle = textColor;
              helpers$1.each(bodyItem.before, fillLineOfText);
              lines = bodyItem.lines;
              for (j = 0, jlen = lines.length; j < jlen; ++j) {
                if (drawColorBoxes) {
                  var rtlColorX = rtlHelper.x(colorX);
                  ctx.fillStyle = vm.legendColorBackground;
                  ctx.fillRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
                  ctx.lineWidth = 1;
                  ctx.strokeStyle = labelColors.borderColor;
                  ctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
                  ctx.fillStyle = labelColors.backgroundColor;
                  ctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                  ctx.fillStyle = textColor;
                }
                fillLineOfText(lines[j]);
              }
              helpers$1.each(bodyItem.after, fillLineOfText);
            }
            xLinePadding = 0;
            helpers$1.each(vm.afterBody, fillLineOfText);
            pt.y -= bodySpacing;
          },
          drawFooter: function(pt, vm, ctx) {
            var footer = vm.footer;
            var length = footer.length;
            var footerFontSize, i;
            if (length) {
              var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
              pt.x = getAlignedX(vm, vm._footerAlign);
              pt.y += vm.footerMarginTop;
              ctx.textAlign = rtlHelper.textAlign(vm._footerAlign);
              ctx.textBaseline = "middle";
              footerFontSize = vm.footerFontSize;
              ctx.fillStyle = vm.footerFontColor;
              ctx.font = helpers$1.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
              for (i = 0; i < length; ++i) {
                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFontSize / 2);
                pt.y += footerFontSize + vm.footerSpacing;
              }
            }
          },
          drawBackground: function(pt, vm, ctx, tooltipSize) {
            ctx.fillStyle = vm.backgroundColor;
            ctx.strokeStyle = vm.borderColor;
            ctx.lineWidth = vm.borderWidth;
            var xAlign = vm.xAlign;
            var yAlign = vm.yAlign;
            var x = pt.x;
            var y = pt.y;
            var width = tooltipSize.width;
            var height = tooltipSize.height;
            var radius = vm.cornerRadius;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            if (yAlign === "top") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            if (yAlign === "center" && xAlign === "right") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            if (yAlign === "bottom") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            if (yAlign === "center" && xAlign === "left") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
            if (vm.borderWidth > 0) {
              ctx.stroke();
            }
          },
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            if (vm.opacity === 0) {
              return;
            }
            var tooltipSize = {
              width: vm.width,
              height: vm.height
            };
            var pt = {
              x: vm.x,
              y: vm.y
            };
            var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;
            var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;
            if (this._options.enabled && hasTooltipContent) {
              ctx.save();
              ctx.globalAlpha = opacity;
              this.drawBackground(pt, vm, ctx, tooltipSize);
              pt.y += vm.yPadding;
              helpers$1.rtl.overrideTextDirection(ctx, vm.textDirection);
              this.drawTitle(pt, vm, ctx);
              this.drawBody(pt, vm, ctx);
              this.drawFooter(pt, vm, ctx);
              helpers$1.rtl.restoreTextDirection(ctx, vm.textDirection);
              ctx.restore();
            }
          },
          handleEvent: function(e) {
            var me = this;
            var options2 = me._options;
            var changed = false;
            me._lastActive = me._lastActive || [];
            if (e.type === "mouseout") {
              me._active = [];
            } else {
              me._active = me._chart.getElementsAtEventForMode(e, options2.mode, options2);
              if (options2.reverse) {
                me._active.reverse();
              }
            }
            changed = !helpers$1.arrayEquals(me._active, me._lastActive);
            if (changed) {
              me._lastActive = me._active;
              if (options2.enabled || options2.custom) {
                me._eventPosition = {
                  x: e.x,
                  y: e.y
                };
                me.update(true);
                me.pivot();
              }
            }
            return changed;
          }
        });
        var positioners_1 = positioners;
        var core_tooltip = exports$4;
        core_tooltip.positioners = positioners_1;
        var valueOrDefault$9 = helpers$1.valueOrDefault;
        core_defaults._set("global", {
          elements: {},
          events: [
            "mousemove",
            "mouseout",
            "click",
            "touchstart",
            "touchmove"
          ],
          hover: {
            onHover: null,
            mode: "nearest",
            intersect: true,
            animationDuration: 400
          },
          onClick: null,
          maintainAspectRatio: true,
          responsive: true,
          responsiveAnimationDuration: 0
        });
        function mergeScaleConfig() {
          return helpers$1.merge(/* @__PURE__ */ Object.create(null), [].slice.call(arguments), {
            merger: function(key, target, source, options2) {
              if (key === "xAxes" || key === "yAxes") {
                var slen = source[key].length;
                var i, type, scale2;
                if (!target[key]) {
                  target[key] = [];
                }
                for (i = 0; i < slen; ++i) {
                  scale2 = source[key][i];
                  type = valueOrDefault$9(scale2.type, key === "xAxes" ? "category" : "linear");
                  if (i >= target[key].length) {
                    target[key].push({});
                  }
                  if (!target[key][i].type || scale2.type && scale2.type !== target[key][i].type) {
                    helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale2]);
                  } else {
                    helpers$1.merge(target[key][i], scale2);
                  }
                }
              } else {
                helpers$1._merger(key, target, source, options2);
              }
            }
          });
        }
        function mergeConfig() {
          return helpers$1.merge(/* @__PURE__ */ Object.create(null), [].slice.call(arguments), {
            merger: function(key, target, source, options2) {
              var tval = target[key] || /* @__PURE__ */ Object.create(null);
              var sval = source[key];
              if (key === "scales") {
                target[key] = mergeScaleConfig(tval, sval);
              } else if (key === "scale") {
                target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
              } else {
                helpers$1._merger(key, target, source, options2);
              }
            }
          });
        }
        function initConfig(config) {
          config = config || /* @__PURE__ */ Object.create(null);
          var data2 = config.data = config.data || {};
          data2.datasets = data2.datasets || [];
          data2.labels = data2.labels || [];
          config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});
          return config;
        }
        function updateConfig(chart) {
          var newOptions = chart.options;
          helpers$1.each(chart.scales, function(scale2) {
            core_layouts.removeBox(chart, scale2);
          });
          newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);
          chart.options = chart.config.options = newOptions;
          chart.ensureScalesHaveIDs();
          chart.buildOrUpdateScales();
          chart.tooltip._options = newOptions.tooltips;
          chart.tooltip.initialize();
        }
        function nextAvailableScaleId(axesOpts, prefix, index) {
          var id;
          var hasId = function(obj) {
            return obj.id === id;
          };
          do {
            id = prefix + index++;
          } while (helpers$1.findIndex(axesOpts, hasId) >= 0);
          return id;
        }
        function positionIsHorizontal(position) {
          return position === "top" || position === "bottom";
        }
        function compare2Level(l1, l2) {
          return function(a, b) {
            return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
          };
        }
        var Chart2 = function(item, config) {
          this.construct(item, config);
          return this;
        };
        helpers$1.extend(Chart2.prototype, {
          construct: function(item, config) {
            var me = this;
            config = initConfig(config);
            var context = platform.acquireContext(item, config);
            var canvas2 = context && context.canvas;
            var height = canvas2 && canvas2.height;
            var width = canvas2 && canvas2.width;
            me.id = helpers$1.uid();
            me.ctx = context;
            me.canvas = canvas2;
            me.config = config;
            me.width = width;
            me.height = height;
            me.aspectRatio = height ? width / height : null;
            me.options = config.options;
            me._bufferedRender = false;
            me._layers = [];
            me.chart = me;
            me.controller = me;
            Chart2.instances[me.id] = me;
            Object.defineProperty(me, "data", {
              get: function() {
                return me.config.data;
              },
              set: function(value) {
                me.config.data = value;
              }
            });
            if (!context || !canvas2) {
              console.error("Failed to create chart: can't acquire context from the given item");
              return;
            }
            me.initialize();
            me.update();
          },
          initialize: function() {
            var me = this;
            core_plugins.notify(me, "beforeInit");
            helpers$1.retinaScale(me, me.options.devicePixelRatio);
            me.bindEvents();
            if (me.options.responsive) {
              me.resize(true);
            }
            me.initToolTip();
            core_plugins.notify(me, "afterInit");
            return me;
          },
          clear: function() {
            helpers$1.canvas.clear(this);
            return this;
          },
          stop: function() {
            core_animations.cancelAnimation(this);
            return this;
          },
          resize: function(silent) {
            var me = this;
            var options2 = me.options;
            var canvas2 = me.canvas;
            var aspectRatio = options2.maintainAspectRatio && me.aspectRatio || null;
            var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas2)));
            var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas2)));
            if (me.width === newWidth && me.height === newHeight) {
              return;
            }
            canvas2.width = me.width = newWidth;
            canvas2.height = me.height = newHeight;
            canvas2.style.width = newWidth + "px";
            canvas2.style.height = newHeight + "px";
            helpers$1.retinaScale(me, options2.devicePixelRatio);
            if (!silent) {
              var newSize = { width: newWidth, height: newHeight };
              core_plugins.notify(me, "resize", [newSize]);
              if (options2.onResize) {
                options2.onResize(me, newSize);
              }
              me.stop();
              me.update({
                duration: options2.responsiveAnimationDuration
              });
            }
          },
          ensureScalesHaveIDs: function() {
            var options2 = this.options;
            var scalesOptions = options2.scales || {};
            var scaleOptions = options2.scale;
            helpers$1.each(scalesOptions.xAxes, function(xAxisOptions, index) {
              if (!xAxisOptions.id) {
                xAxisOptions.id = nextAvailableScaleId(scalesOptions.xAxes, "x-axis-", index);
              }
            });
            helpers$1.each(scalesOptions.yAxes, function(yAxisOptions, index) {
              if (!yAxisOptions.id) {
                yAxisOptions.id = nextAvailableScaleId(scalesOptions.yAxes, "y-axis-", index);
              }
            });
            if (scaleOptions) {
              scaleOptions.id = scaleOptions.id || "scale";
            }
          },
          buildOrUpdateScales: function() {
            var me = this;
            var options2 = me.options;
            var scales2 = me.scales || {};
            var items = [];
            var updated = Object.keys(scales2).reduce(function(obj, id) {
              obj[id] = false;
              return obj;
            }, {});
            if (options2.scales) {
              items = items.concat((options2.scales.xAxes || []).map(function(xAxisOptions) {
                return { options: xAxisOptions, dtype: "category", dposition: "bottom" };
              }), (options2.scales.yAxes || []).map(function(yAxisOptions) {
                return { options: yAxisOptions, dtype: "linear", dposition: "left" };
              }));
            }
            if (options2.scale) {
              items.push({
                options: options2.scale,
                dtype: "radialLinear",
                isDefault: true,
                dposition: "chartArea"
              });
            }
            helpers$1.each(items, function(item) {
              var scaleOptions = item.options;
              var id = scaleOptions.id;
              var scaleType = valueOrDefault$9(scaleOptions.type, item.dtype);
              if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
                scaleOptions.position = item.dposition;
              }
              updated[id] = true;
              var scale2 = null;
              if (id in scales2 && scales2[id].type === scaleType) {
                scale2 = scales2[id];
                scale2.options = scaleOptions;
                scale2.ctx = me.ctx;
                scale2.chart = me;
              } else {
                var scaleClass = core_scaleService.getScaleConstructor(scaleType);
                if (!scaleClass) {
                  return;
                }
                scale2 = new scaleClass({
                  id,
                  type: scaleType,
                  options: scaleOptions,
                  ctx: me.ctx,
                  chart: me
                });
                scales2[scale2.id] = scale2;
              }
              scale2.mergeTicksOptions();
              if (item.isDefault) {
                me.scale = scale2;
              }
            });
            helpers$1.each(updated, function(hasUpdated, id) {
              if (!hasUpdated) {
                delete scales2[id];
              }
            });
            me.scales = scales2;
            core_scaleService.addScalesToLayout(this);
          },
          buildOrUpdateControllers: function() {
            var me = this;
            var newControllers = [];
            var datasets = me.data.datasets;
            var i, ilen;
            for (i = 0, ilen = datasets.length; i < ilen; i++) {
              var dataset = datasets[i];
              var meta = me.getDatasetMeta(i);
              var type = dataset.type || me.config.type;
              if (meta.type && meta.type !== type) {
                me.destroyDatasetMeta(i);
                meta = me.getDatasetMeta(i);
              }
              meta.type = type;
              meta.order = dataset.order || 0;
              meta.index = i;
              if (meta.controller) {
                meta.controller.updateIndex(i);
                meta.controller.linkScales();
              } else {
                var ControllerClass = controllers[meta.type];
                if (ControllerClass === void 0) {
                  throw new Error('"' + meta.type + '" is not a chart type.');
                }
                meta.controller = new ControllerClass(me, i);
                newControllers.push(meta.controller);
              }
            }
            return newControllers;
          },
          resetElements: function() {
            var me = this;
            helpers$1.each(me.data.datasets, function(dataset, datasetIndex) {
              me.getDatasetMeta(datasetIndex).controller.reset();
            }, me);
          },
          reset: function() {
            this.resetElements();
            this.tooltip.initialize();
          },
          update: function(config) {
            var me = this;
            var i, ilen;
            if (!config || typeof config !== "object") {
              config = {
                duration: config,
                lazy: arguments[1]
              };
            }
            updateConfig(me);
            core_plugins._invalidate(me);
            if (core_plugins.notify(me, "beforeUpdate") === false) {
              return;
            }
            me.tooltip._data = me.data;
            var newControllers = me.buildOrUpdateControllers();
            for (i = 0, ilen = me.data.datasets.length; i < ilen; i++) {
              me.getDatasetMeta(i).controller.buildOrUpdateElements();
            }
            me.updateLayout();
            if (me.options.animation && me.options.animation.duration) {
              helpers$1.each(newControllers, function(controller) {
                controller.reset();
              });
            }
            me.updateDatasets();
            me.tooltip.initialize();
            me.lastActive = [];
            core_plugins.notify(me, "afterUpdate");
            me._layers.sort(compare2Level("z", "_idx"));
            if (me._bufferedRender) {
              me._bufferedRequest = {
                duration: config.duration,
                easing: config.easing,
                lazy: config.lazy
              };
            } else {
              me.render(config);
            }
          },
          updateLayout: function() {
            var me = this;
            if (core_plugins.notify(me, "beforeLayout") === false) {
              return;
            }
            core_layouts.update(this, this.width, this.height);
            me._layers = [];
            helpers$1.each(me.boxes, function(box) {
              if (box._configure) {
                box._configure();
              }
              me._layers.push.apply(me._layers, box._layers());
            }, me);
            me._layers.forEach(function(item, index) {
              item._idx = index;
            });
            core_plugins.notify(me, "afterScaleUpdate");
            core_plugins.notify(me, "afterLayout");
          },
          updateDatasets: function() {
            var me = this;
            if (core_plugins.notify(me, "beforeDatasetsUpdate") === false) {
              return;
            }
            for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
              me.updateDataset(i);
            }
            core_plugins.notify(me, "afterDatasetsUpdate");
          },
          updateDataset: function(index) {
            var me = this;
            var meta = me.getDatasetMeta(index);
            var args = {
              meta,
              index
            };
            if (core_plugins.notify(me, "beforeDatasetUpdate", [args]) === false) {
              return;
            }
            meta.controller._update();
            core_plugins.notify(me, "afterDatasetUpdate", [args]);
          },
          render: function(config) {
            var me = this;
            if (!config || typeof config !== "object") {
              config = {
                duration: config,
                lazy: arguments[1]
              };
            }
            var animationOptions = me.options.animation;
            var duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);
            var lazy = config.lazy;
            if (core_plugins.notify(me, "beforeRender") === false) {
              return;
            }
            var onComplete = function(animation2) {
              core_plugins.notify(me, "afterRender");
              helpers$1.callback(animationOptions && animationOptions.onComplete, [animation2], me);
            };
            if (animationOptions && duration) {
              var animation = new core_animation({
                numSteps: duration / 16.66,
                easing: config.easing || animationOptions.easing,
                render: function(chart, animationObject) {
                  var easingFunction = helpers$1.easing.effects[animationObject.easing];
                  var currentStep = animationObject.currentStep;
                  var stepDecimal = currentStep / animationObject.numSteps;
                  chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
                },
                onAnimationProgress: animationOptions.onProgress,
                onAnimationComplete: onComplete
              });
              core_animations.addAnimation(me, animation, duration, lazy);
            } else {
              me.draw();
              onComplete(new core_animation({ numSteps: 0, chart: me }));
            }
            return me;
          },
          draw: function(easingValue) {
            var me = this;
            var i, layers;
            me.clear();
            if (helpers$1.isNullOrUndef(easingValue)) {
              easingValue = 1;
            }
            me.transition(easingValue);
            if (me.width <= 0 || me.height <= 0) {
              return;
            }
            if (core_plugins.notify(me, "beforeDraw", [easingValue]) === false) {
              return;
            }
            layers = me._layers;
            for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
              layers[i].draw(me.chartArea);
            }
            me.drawDatasets(easingValue);
            for (; i < layers.length; ++i) {
              layers[i].draw(me.chartArea);
            }
            me._drawTooltip(easingValue);
            core_plugins.notify(me, "afterDraw", [easingValue]);
          },
          transition: function(easingValue) {
            var me = this;
            for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
              if (me.isDatasetVisible(i)) {
                me.getDatasetMeta(i).controller.transition(easingValue);
              }
            }
            me.tooltip.transition(easingValue);
          },
          _getSortedDatasetMetas: function(filterVisible) {
            var me = this;
            var datasets = me.data.datasets || [];
            var result = [];
            var i, ilen;
            for (i = 0, ilen = datasets.length; i < ilen; ++i) {
              if (!filterVisible || me.isDatasetVisible(i)) {
                result.push(me.getDatasetMeta(i));
              }
            }
            result.sort(compare2Level("order", "index"));
            return result;
          },
          _getSortedVisibleDatasetMetas: function() {
            return this._getSortedDatasetMetas(true);
          },
          drawDatasets: function(easingValue) {
            var me = this;
            var metasets, i;
            if (core_plugins.notify(me, "beforeDatasetsDraw", [easingValue]) === false) {
              return;
            }
            metasets = me._getSortedVisibleDatasetMetas();
            for (i = metasets.length - 1; i >= 0; --i) {
              me.drawDataset(metasets[i], easingValue);
            }
            core_plugins.notify(me, "afterDatasetsDraw", [easingValue]);
          },
          drawDataset: function(meta, easingValue) {
            var me = this;
            var args = {
              meta,
              index: meta.index,
              easingValue
            };
            if (core_plugins.notify(me, "beforeDatasetDraw", [args]) === false) {
              return;
            }
            meta.controller.draw(easingValue);
            core_plugins.notify(me, "afterDatasetDraw", [args]);
          },
          _drawTooltip: function(easingValue) {
            var me = this;
            var tooltip = me.tooltip;
            var args = {
              tooltip,
              easingValue
            };
            if (core_plugins.notify(me, "beforeTooltipDraw", [args]) === false) {
              return;
            }
            tooltip.draw();
            core_plugins.notify(me, "afterTooltipDraw", [args]);
          },
          getElementAtEvent: function(e) {
            return core_interaction.modes.single(this, e);
          },
          getElementsAtEvent: function(e) {
            return core_interaction.modes.label(this, e, { intersect: true });
          },
          getElementsAtXAxis: function(e) {
            return core_interaction.modes["x-axis"](this, e, { intersect: true });
          },
          getElementsAtEventForMode: function(e, mode, options2) {
            var method = core_interaction.modes[mode];
            if (typeof method === "function") {
              return method(this, e, options2);
            }
            return [];
          },
          getDatasetAtEvent: function(e) {
            return core_interaction.modes.dataset(this, e, { intersect: true });
          },
          getDatasetMeta: function(datasetIndex) {
            var me = this;
            var dataset = me.data.datasets[datasetIndex];
            if (!dataset._meta) {
              dataset._meta = {};
            }
            var meta = dataset._meta[me.id];
            if (!meta) {
              meta = dataset._meta[me.id] = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset.order || 0,
                index: datasetIndex
              };
            }
            return meta;
          },
          getVisibleDatasetCount: function() {
            var count = 0;
            for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              if (this.isDatasetVisible(i)) {
                count++;
              }
            }
            return count;
          },
          isDatasetVisible: function(datasetIndex) {
            var meta = this.getDatasetMeta(datasetIndex);
            return typeof meta.hidden === "boolean" ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
          },
          generateLegend: function() {
            return this.options.legendCallback(this);
          },
          destroyDatasetMeta: function(datasetIndex) {
            var id = this.id;
            var dataset = this.data.datasets[datasetIndex];
            var meta = dataset._meta && dataset._meta[id];
            if (meta) {
              meta.controller.destroy();
              delete dataset._meta[id];
            }
          },
          destroy: function() {
            var me = this;
            var canvas2 = me.canvas;
            var i, ilen;
            me.stop();
            for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
              me.destroyDatasetMeta(i);
            }
            if (canvas2) {
              me.unbindEvents();
              helpers$1.canvas.clear(me);
              platform.releaseContext(me.ctx);
              me.canvas = null;
              me.ctx = null;
            }
            core_plugins.notify(me, "destroy");
            delete Chart2.instances[me.id];
          },
          toBase64Image: function() {
            return this.canvas.toDataURL.apply(this.canvas, arguments);
          },
          initToolTip: function() {
            var me = this;
            me.tooltip = new core_tooltip({
              _chart: me,
              _chartInstance: me,
              _data: me.data,
              _options: me.options.tooltips
            }, me);
          },
          bindEvents: function() {
            var me = this;
            var listeners = me._listeners = {};
            var listener = function() {
              me.eventHandler.apply(me, arguments);
            };
            helpers$1.each(me.options.events, function(type) {
              platform.addEventListener(me, type, listener);
              listeners[type] = listener;
            });
            if (me.options.responsive) {
              listener = function() {
                me.resize();
              };
              platform.addEventListener(me, "resize", listener);
              listeners.resize = listener;
            }
          },
          unbindEvents: function() {
            var me = this;
            var listeners = me._listeners;
            if (!listeners) {
              return;
            }
            delete me._listeners;
            helpers$1.each(listeners, function(listener, type) {
              platform.removeEventListener(me, type, listener);
            });
          },
          updateHoverStyle: function(elements2, mode, enabled) {
            var prefix = enabled ? "set" : "remove";
            var element, i, ilen;
            for (i = 0, ilen = elements2.length; i < ilen; ++i) {
              element = elements2[i];
              if (element) {
                this.getDatasetMeta(element._datasetIndex).controller[prefix + "HoverStyle"](element);
              }
            }
            if (mode === "dataset") {
              this.getDatasetMeta(elements2[0]._datasetIndex).controller["_" + prefix + "DatasetHoverStyle"]();
            }
          },
          eventHandler: function(e) {
            var me = this;
            var tooltip = me.tooltip;
            if (core_plugins.notify(me, "beforeEvent", [e]) === false) {
              return;
            }
            me._bufferedRender = true;
            me._bufferedRequest = null;
            var changed = me.handleEvent(e);
            if (tooltip) {
              changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
            }
            core_plugins.notify(me, "afterEvent", [e]);
            var bufferedRequest = me._bufferedRequest;
            if (bufferedRequest) {
              me.render(bufferedRequest);
            } else if (changed && !me.animating) {
              me.stop();
              me.render({
                duration: me.options.hover.animationDuration,
                lazy: true
              });
            }
            me._bufferedRender = false;
            me._bufferedRequest = null;
            return me;
          },
          handleEvent: function(e) {
            var me = this;
            var options2 = me.options || {};
            var hoverOptions = options2.hover;
            var changed = false;
            me.lastActive = me.lastActive || [];
            if (e.type === "mouseout") {
              me.active = [];
            } else {
              me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
            }
            helpers$1.callback(options2.onHover || options2.hover.onHover, [e.native, me.active], me);
            if (e.type === "mouseup" || e.type === "click") {
              if (options2.onClick) {
                options2.onClick.call(me, e.native, me.active);
              }
            }
            if (me.lastActive.length) {
              me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
            }
            if (me.active.length && hoverOptions.mode) {
              me.updateHoverStyle(me.active, hoverOptions.mode, true);
            }
            changed = !helpers$1.arrayEquals(me.active, me.lastActive);
            me.lastActive = me.active;
            return changed;
          }
        });
        Chart2.instances = {};
        var core_controller = Chart2;
        Chart2.Controller = Chart2;
        Chart2.types = {};
        helpers$1.configMerge = mergeConfig;
        helpers$1.scaleMerge = mergeScaleConfig;
        var core_helpers = function() {
          helpers$1.where = function(collection, filterCallback) {
            if (helpers$1.isArray(collection) && Array.prototype.filter) {
              return collection.filter(filterCallback);
            }
            var filtered = [];
            helpers$1.each(collection, function(item) {
              if (filterCallback(item)) {
                filtered.push(item);
              }
            });
            return filtered;
          };
          helpers$1.findIndex = Array.prototype.findIndex ? function(array, callback, scope) {
            return array.findIndex(callback, scope);
          } : function(array, callback, scope) {
            scope = scope === void 0 ? array : scope;
            for (var i = 0, ilen = array.length; i < ilen; ++i) {
              if (callback.call(scope, array[i], i, array)) {
                return i;
              }
            }
            return -1;
          };
          helpers$1.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
            if (helpers$1.isNullOrUndef(startIndex)) {
              startIndex = -1;
            }
            for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
              var currentItem = arrayToSearch[i];
              if (filterCallback(currentItem)) {
                return currentItem;
              }
            }
          };
          helpers$1.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
            if (helpers$1.isNullOrUndef(startIndex)) {
              startIndex = arrayToSearch.length;
            }
            for (var i = startIndex - 1; i >= 0; i--) {
              var currentItem = arrayToSearch[i];
              if (filterCallback(currentItem)) {
                return currentItem;
              }
            }
          };
          helpers$1.isNumber = function(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
          };
          helpers$1.almostEquals = function(x, y, epsilon) {
            return Math.abs(x - y) < epsilon;
          };
          helpers$1.almostWhole = function(x, epsilon) {
            var rounded = Math.round(x);
            return rounded - epsilon <= x && rounded + epsilon >= x;
          };
          helpers$1.max = function(array) {
            return array.reduce(function(max, value) {
              if (!isNaN(value)) {
                return Math.max(max, value);
              }
              return max;
            }, Number.NEGATIVE_INFINITY);
          };
          helpers$1.min = function(array) {
            return array.reduce(function(min, value) {
              if (!isNaN(value)) {
                return Math.min(min, value);
              }
              return min;
            }, Number.POSITIVE_INFINITY);
          };
          helpers$1.sign = Math.sign ? function(x) {
            return Math.sign(x);
          } : function(x) {
            x = +x;
            if (x === 0 || isNaN(x)) {
              return x;
            }
            return x > 0 ? 1 : -1;
          };
          helpers$1.toRadians = function(degrees) {
            return degrees * (Math.PI / 180);
          };
          helpers$1.toDegrees = function(radians) {
            return radians * (180 / Math.PI);
          };
          helpers$1._decimalPlaces = function(x) {
            if (!helpers$1.isFinite(x)) {
              return;
            }
            var e = 1;
            var p = 0;
            while (Math.round(x * e) / e !== x) {
              e *= 10;
              p++;
            }
            return p;
          };
          helpers$1.getAngleFromPoint = function(centrePoint, anglePoint) {
            var distanceFromXCenter = anglePoint.x - centrePoint.x;
            var distanceFromYCenter = anglePoint.y - centrePoint.y;
            var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
            var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
            if (angle < -0.5 * Math.PI) {
              angle += 2 * Math.PI;
            }
            return {
              angle,
              distance: radialDistanceFromCenter
            };
          };
          helpers$1.distanceBetweenPoints = function(pt1, pt2) {
            return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
          };
          helpers$1.aliasPixel = function(pixelWidth) {
            return pixelWidth % 2 === 0 ? 0 : 0.5;
          };
          helpers$1._alignPixel = function(chart, pixel, width) {
            var devicePixelRatio = chart.currentDevicePixelRatio;
            var halfWidth = width / 2;
            return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
          };
          helpers$1.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
            var previous = firstPoint.skip ? middlePoint : firstPoint;
            var current = middlePoint;
            var next = afterPoint.skip ? middlePoint : afterPoint;
            var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
            var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
            var s01 = d01 / (d01 + d12);
            var s12 = d12 / (d01 + d12);
            s01 = isNaN(s01) ? 0 : s01;
            s12 = isNaN(s12) ? 0 : s12;
            var fa = t * s01;
            var fb = t * s12;
            return {
              previous: {
                x: current.x - fa * (next.x - previous.x),
                y: current.y - fa * (next.y - previous.y)
              },
              next: {
                x: current.x + fb * (next.x - previous.x),
                y: current.y + fb * (next.y - previous.y)
              }
            };
          };
          helpers$1.EPSILON = Number.EPSILON || 1e-14;
          helpers$1.splineCurveMonotone = function(points) {
            var pointsWithTangents = (points || []).map(function(point) {
              return {
                model: point._model,
                deltaK: 0,
                mK: 0
              };
            });
            var pointsLen = pointsWithTangents.length;
            var i, pointBefore, pointCurrent, pointAfter;
            for (i = 0; i < pointsLen; ++i) {
              pointCurrent = pointsWithTangents[i];
              if (pointCurrent.model.skip) {
                continue;
              }
              pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
              pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
              if (pointAfter && !pointAfter.model.skip) {
                var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;
                pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
              }
              if (!pointBefore || pointBefore.model.skip) {
                pointCurrent.mK = pointCurrent.deltaK;
              } else if (!pointAfter || pointAfter.model.skip) {
                pointCurrent.mK = pointBefore.deltaK;
              } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
                pointCurrent.mK = 0;
              } else {
                pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
              }
            }
            var alphaK, betaK, tauK, squaredMagnitude;
            for (i = 0; i < pointsLen - 1; ++i) {
              pointCurrent = pointsWithTangents[i];
              pointAfter = pointsWithTangents[i + 1];
              if (pointCurrent.model.skip || pointAfter.model.skip) {
                continue;
              }
              if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
                pointCurrent.mK = pointAfter.mK = 0;
                continue;
              }
              alphaK = pointCurrent.mK / pointCurrent.deltaK;
              betaK = pointAfter.mK / pointCurrent.deltaK;
              squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
              if (squaredMagnitude <= 9) {
                continue;
              }
              tauK = 3 / Math.sqrt(squaredMagnitude);
              pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
              pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
            }
            var deltaX;
            for (i = 0; i < pointsLen; ++i) {
              pointCurrent = pointsWithTangents[i];
              if (pointCurrent.model.skip) {
                continue;
              }
              pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
              pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
              if (pointBefore && !pointBefore.model.skip) {
                deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
                pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
                pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
              }
              if (pointAfter && !pointAfter.model.skip) {
                deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
                pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
                pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
              }
            }
          };
          helpers$1.nextItem = function(collection, index, loop) {
            if (loop) {
              return index >= collection.length - 1 ? collection[0] : collection[index + 1];
            }
            return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
          };
          helpers$1.previousItem = function(collection, index, loop) {
            if (loop) {
              return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
            }
            return index <= 0 ? collection[0] : collection[index - 1];
          };
          helpers$1.niceNum = function(range, round) {
            var exponent = Math.floor(helpers$1.log10(range));
            var fraction = range / Math.pow(10, exponent);
            var niceFraction;
            if (round) {
              if (fraction < 1.5) {
                niceFraction = 1;
              } else if (fraction < 3) {
                niceFraction = 2;
              } else if (fraction < 7) {
                niceFraction = 5;
              } else {
                niceFraction = 10;
              }
            } else if (fraction <= 1) {
              niceFraction = 1;
            } else if (fraction <= 2) {
              niceFraction = 2;
            } else if (fraction <= 5) {
              niceFraction = 5;
            } else {
              niceFraction = 10;
            }
            return niceFraction * Math.pow(10, exponent);
          };
          helpers$1.requestAnimFrame = function() {
            if (typeof window === "undefined") {
              return function(callback) {
                callback();
              };
            }
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
              return window.setTimeout(callback, 1e3 / 60);
            };
          }();
          helpers$1.getRelativePosition = function(evt, chart) {
            var mouseX, mouseY;
            var e = evt.originalEvent || evt;
            var canvas2 = evt.target || evt.srcElement;
            var boundingRect = canvas2.getBoundingClientRect();
            var touches = e.touches;
            if (touches && touches.length > 0) {
              mouseX = touches[0].clientX;
              mouseY = touches[0].clientY;
            } else {
              mouseX = e.clientX;
              mouseY = e.clientY;
            }
            var paddingLeft = parseFloat(helpers$1.getStyle(canvas2, "padding-left"));
            var paddingTop = parseFloat(helpers$1.getStyle(canvas2, "padding-top"));
            var paddingRight = parseFloat(helpers$1.getStyle(canvas2, "padding-right"));
            var paddingBottom = parseFloat(helpers$1.getStyle(canvas2, "padding-bottom"));
            var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
            var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
            mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas2.width / chart.currentDevicePixelRatio);
            mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas2.height / chart.currentDevicePixelRatio);
            return {
              x: mouseX,
              y: mouseY
            };
          };
          function parseMaxStyle(styleValue, node, parentProperty) {
            var valueInPixels;
            if (typeof styleValue === "string") {
              valueInPixels = parseInt(styleValue, 10);
              if (styleValue.indexOf("%") !== -1) {
                valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
              }
            } else {
              valueInPixels = styleValue;
            }
            return valueInPixels;
          }
          function isConstrainedValue(value) {
            return value !== void 0 && value !== null && value !== "none";
          }
          function getConstraintDimension(domNode, maxStyle, percentageProperty) {
            var view = document.defaultView;
            var parentNode = helpers$1._getParentNode(domNode);
            var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
            var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
            var hasCNode = isConstrainedValue(constrainedNode);
            var hasCContainer = isConstrainedValue(constrainedContainer);
            var infinity = Number.POSITIVE_INFINITY;
            if (hasCNode || hasCContainer) {
              return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
            }
            return "none";
          }
          helpers$1.getConstraintWidth = function(domNode) {
            return getConstraintDimension(domNode, "max-width", "clientWidth");
          };
          helpers$1.getConstraintHeight = function(domNode) {
            return getConstraintDimension(domNode, "max-height", "clientHeight");
          };
          helpers$1._calculatePadding = function(container, padding, parentDimension) {
            padding = helpers$1.getStyle(container, padding);
            return padding.indexOf("%") > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
          };
          helpers$1._getParentNode = function(domNode) {
            var parent = domNode.parentNode;
            if (parent && parent.toString() === "[object ShadowRoot]") {
              parent = parent.host;
            }
            return parent;
          };
          helpers$1.getMaximumWidth = function(domNode) {
            var container = helpers$1._getParentNode(domNode);
            if (!container) {
              return domNode.clientWidth;
            }
            var clientWidth = container.clientWidth;
            var paddingLeft = helpers$1._calculatePadding(container, "padding-left", clientWidth);
            var paddingRight = helpers$1._calculatePadding(container, "padding-right", clientWidth);
            var w = clientWidth - paddingLeft - paddingRight;
            var cw = helpers$1.getConstraintWidth(domNode);
            return isNaN(cw) ? w : Math.min(w, cw);
          };
          helpers$1.getMaximumHeight = function(domNode) {
            var container = helpers$1._getParentNode(domNode);
            if (!container) {
              return domNode.clientHeight;
            }
            var clientHeight = container.clientHeight;
            var paddingTop = helpers$1._calculatePadding(container, "padding-top", clientHeight);
            var paddingBottom = helpers$1._calculatePadding(container, "padding-bottom", clientHeight);
            var h = clientHeight - paddingTop - paddingBottom;
            var ch = helpers$1.getConstraintHeight(domNode);
            return isNaN(ch) ? h : Math.min(h, ch);
          };
          helpers$1.getStyle = function(el, property) {
            return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
          };
          helpers$1.retinaScale = function(chart, forceRatio) {
            var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== "undefined" && window.devicePixelRatio || 1;
            if (pixelRatio === 1) {
              return;
            }
            var canvas2 = chart.canvas;
            var height = chart.height;
            var width = chart.width;
            canvas2.height = height * pixelRatio;
            canvas2.width = width * pixelRatio;
            chart.ctx.scale(pixelRatio, pixelRatio);
            if (!canvas2.style.height && !canvas2.style.width) {
              canvas2.style.height = height + "px";
              canvas2.style.width = width + "px";
            }
          };
          helpers$1.fontString = function(pixelSize, fontStyle, fontFamily) {
            return fontStyle + " " + pixelSize + "px " + fontFamily;
          };
          helpers$1.longestText = function(ctx, font, arrayOfThings, cache) {
            cache = cache || {};
            var data2 = cache.data = cache.data || {};
            var gc = cache.garbageCollect = cache.garbageCollect || [];
            if (cache.font !== font) {
              data2 = cache.data = {};
              gc = cache.garbageCollect = [];
              cache.font = font;
            }
            ctx.font = font;
            var longest = 0;
            var ilen = arrayOfThings.length;
            var i, j, jlen, thing, nestedThing;
            for (i = 0; i < ilen; i++) {
              thing = arrayOfThings[i];
              if (thing !== void 0 && thing !== null && helpers$1.isArray(thing) !== true) {
                longest = helpers$1.measureText(ctx, data2, gc, longest, thing);
              } else if (helpers$1.isArray(thing)) {
                for (j = 0, jlen = thing.length; j < jlen; j++) {
                  nestedThing = thing[j];
                  if (nestedThing !== void 0 && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                    longest = helpers$1.measureText(ctx, data2, gc, longest, nestedThing);
                  }
                }
              }
            }
            var gcLen = gc.length / 2;
            if (gcLen > arrayOfThings.length) {
              for (i = 0; i < gcLen; i++) {
                delete data2[gc[i]];
              }
              gc.splice(0, gcLen);
            }
            return longest;
          };
          helpers$1.measureText = function(ctx, data2, gc, longest, string) {
            var textWidth = data2[string];
            if (!textWidth) {
              textWidth = data2[string] = ctx.measureText(string).width;
              gc.push(string);
            }
            if (textWidth > longest) {
              longest = textWidth;
            }
            return longest;
          };
          helpers$1.numberOfLabelLines = function(arrayOfThings) {
            var numberOfLines = 1;
            helpers$1.each(arrayOfThings, function(thing) {
              if (helpers$1.isArray(thing)) {
                if (thing.length > numberOfLines) {
                  numberOfLines = thing.length;
                }
              }
            });
            return numberOfLines;
          };
          helpers$1.color = !chartjsColor ? function(value) {
            console.error("Color.js not found!");
            return value;
          } : function(value) {
            if (value instanceof CanvasGradient) {
              value = core_defaults.global.defaultColor;
            }
            return chartjsColor(value);
          };
          helpers$1.getHoverColor = function(colorValue) {
            return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
          };
        };
        function abstract() {
          throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided.");
        }
        function DateAdapter(options2) {
          this.options = options2 || {};
        }
        helpers$1.extend(DateAdapter.prototype, {
          formats: abstract,
          parse: abstract,
          format: abstract,
          add: abstract,
          diff: abstract,
          startOf: abstract,
          endOf: abstract,
          _create: function(value) {
            return value;
          }
        });
        DateAdapter.override = function(members) {
          helpers$1.extend(DateAdapter.prototype, members);
        };
        var _date = DateAdapter;
        var core_adapters = {
          _date
        };
        var core_ticks = {
          formatters: {
            values: function(value) {
              return helpers$1.isArray(value) ? value : "" + value;
            },
            linear: function(tickValue, index, ticks) {
              var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
              if (Math.abs(delta) > 1) {
                if (tickValue !== Math.floor(tickValue)) {
                  delta = tickValue - Math.floor(tickValue);
                }
              }
              var logDelta = helpers$1.log10(Math.abs(delta));
              var tickString = "";
              if (tickValue !== 0) {
                var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));
                if (maxTick < 1e-4) {
                  var logTick = helpers$1.log10(Math.abs(tickValue));
                  var numExponential = Math.floor(logTick) - Math.floor(logDelta);
                  numExponential = Math.max(Math.min(numExponential, 20), 0);
                  tickString = tickValue.toExponential(numExponential);
                } else {
                  var numDecimal = -1 * Math.floor(logDelta);
                  numDecimal = Math.max(Math.min(numDecimal, 20), 0);
                  tickString = tickValue.toFixed(numDecimal);
                }
              } else {
                tickString = "0";
              }
              return tickString;
            },
            logarithmic: function(tickValue, index, ticks) {
              var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));
              if (tickValue === 0) {
                return "0";
              } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
                return tickValue.toExponential();
              }
              return "";
            }
          }
        };
        var isArray2 = helpers$1.isArray;
        var isNullOrUndef = helpers$1.isNullOrUndef;
        var valueOrDefault$a = helpers$1.valueOrDefault;
        var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;
        core_defaults._set("scale", {
          display: true,
          position: "left",
          offset: false,
          gridLines: {
            display: true,
            color: "rgba(0,0,0,0.1)",
            lineWidth: 1,
            drawBorder: true,
            drawOnChartArea: true,
            drawTicks: true,
            tickMarkLength: 10,
            zeroLineWidth: 1,
            zeroLineColor: "rgba(0,0,0,0.25)",
            zeroLineBorderDash: [],
            zeroLineBorderDashOffset: 0,
            offsetGridLines: false,
            borderDash: [],
            borderDashOffset: 0
          },
          scaleLabel: {
            display: false,
            labelString: "",
            padding: {
              top: 4,
              bottom: 4
            }
          },
          ticks: {
            beginAtZero: false,
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            padding: 0,
            reverse: false,
            display: true,
            autoSkip: true,
            autoSkipPadding: 0,
            labelOffset: 0,
            callback: core_ticks.formatters.values,
            minor: {},
            major: {}
          }
        });
        function sample(arr, numItems) {
          var result = [];
          var increment = arr.length / numItems;
          var i = 0;
          var len = arr.length;
          for (; i < len; i += increment) {
            result.push(arr[Math.floor(i)]);
          }
          return result;
        }
        function getPixelForGridLine(scale2, index, offsetGridLines) {
          var length = scale2.getTicks().length;
          var validIndex = Math.min(index, length - 1);
          var lineValue = scale2.getPixelForTick(validIndex);
          var start = scale2._startPixel;
          var end = scale2._endPixel;
          var epsilon = 1e-6;
          var offset;
          if (offsetGridLines) {
            if (length === 1) {
              offset = Math.max(lineValue - start, end - lineValue);
            } else if (index === 0) {
              offset = (scale2.getPixelForTick(1) - lineValue) / 2;
            } else {
              offset = (lineValue - scale2.getPixelForTick(validIndex - 1)) / 2;
            }
            lineValue += validIndex < index ? offset : -offset;
            if (lineValue < start - epsilon || lineValue > end + epsilon) {
              return;
            }
          }
          return lineValue;
        }
        function garbageCollect(caches, length) {
          helpers$1.each(caches, function(cache) {
            var gc = cache.gc;
            var gcLen = gc.length / 2;
            var i;
            if (gcLen > length) {
              for (i = 0; i < gcLen; ++i) {
                delete cache.data[gc[i]];
              }
              gc.splice(0, gcLen);
            }
          });
        }
        function computeLabelSizes(ctx, tickFonts, ticks, caches) {
          var length = ticks.length;
          var widths = [];
          var heights = [];
          var offsets = [];
          var widestLabelSize = 0;
          var highestLabelSize = 0;
          var i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel, widest, highest;
          for (i = 0; i < length; ++i) {
            label = ticks[i].label;
            tickFont = ticks[i].major ? tickFonts.major : tickFonts.minor;
            ctx.font = fontString = tickFont.string;
            cache = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
            lineHeight = tickFont.lineHeight;
            width = height = 0;
            if (!isNullOrUndef(label) && !isArray2(label)) {
              width = helpers$1.measureText(ctx, cache.data, cache.gc, width, label);
              height = lineHeight;
            } else if (isArray2(label)) {
              for (j = 0, jlen = label.length; j < jlen; ++j) {
                nestedLabel = label[j];
                if (!isNullOrUndef(nestedLabel) && !isArray2(nestedLabel)) {
                  width = helpers$1.measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                  height += lineHeight;
                }
              }
            }
            widths.push(width);
            heights.push(height);
            offsets.push(lineHeight / 2);
            widestLabelSize = Math.max(width, widestLabelSize);
            highestLabelSize = Math.max(height, highestLabelSize);
          }
          garbageCollect(caches, length);
          widest = widths.indexOf(widestLabelSize);
          highest = heights.indexOf(highestLabelSize);
          function valueAt(idx) {
            return {
              width: widths[idx] || 0,
              height: heights[idx] || 0,
              offset: offsets[idx] || 0
            };
          }
          return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest)
          };
        }
        function getTickMarkLength(options2) {
          return options2.drawTicks ? options2.tickMarkLength : 0;
        }
        function getScaleLabelHeight(options2) {
          var font, padding;
          if (!options2.display) {
            return 0;
          }
          font = helpers$1.options._parseFont(options2);
          padding = helpers$1.options.toPadding(options2.padding);
          return font.lineHeight + padding.height;
        }
        function parseFontOptions(options2, nestedOpts) {
          return helpers$1.extend(helpers$1.options._parseFont({
            fontFamily: valueOrDefault$a(nestedOpts.fontFamily, options2.fontFamily),
            fontSize: valueOrDefault$a(nestedOpts.fontSize, options2.fontSize),
            fontStyle: valueOrDefault$a(nestedOpts.fontStyle, options2.fontStyle),
            lineHeight: valueOrDefault$a(nestedOpts.lineHeight, options2.lineHeight)
          }), {
            color: helpers$1.options.resolve([nestedOpts.fontColor, options2.fontColor, core_defaults.global.defaultFontColor])
          });
        }
        function parseTickFontOptions(options2) {
          var minor = parseFontOptions(options2, options2.minor);
          var major = options2.major.enabled ? parseFontOptions(options2, options2.major) : minor;
          return { minor, major };
        }
        function nonSkipped(ticksToFilter) {
          var filtered = [];
          var item, index, len;
          for (index = 0, len = ticksToFilter.length; index < len; ++index) {
            item = ticksToFilter[index];
            if (typeof item._index !== "undefined") {
              filtered.push(item);
            }
          }
          return filtered;
        }
        function getEvenSpacing(arr) {
          var len = arr.length;
          var i, diff;
          if (len < 2) {
            return false;
          }
          for (diff = arr[0], i = 1; i < len; ++i) {
            if (arr[i] - arr[i - 1] !== diff) {
              return false;
            }
          }
          return diff;
        }
        function calculateSpacing(majorIndices, ticks, axisLength, ticksLimit) {
          var evenMajorSpacing = getEvenSpacing(majorIndices);
          var spacing = (ticks.length - 1) / ticksLimit;
          var factors, factor, i, ilen;
          if (!evenMajorSpacing) {
            return Math.max(spacing, 1);
          }
          factors = helpers$1.math._factorize(evenMajorSpacing);
          for (i = 0, ilen = factors.length - 1; i < ilen; i++) {
            factor = factors[i];
            if (factor > spacing) {
              return factor;
            }
          }
          return Math.max(spacing, 1);
        }
        function getMajorIndices(ticks) {
          var result = [];
          var i, ilen;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            if (ticks[i].major) {
              result.push(i);
            }
          }
          return result;
        }
        function skipMajors(ticks, majorIndices, spacing) {
          var count = 0;
          var next = majorIndices[0];
          var i, tick;
          spacing = Math.ceil(spacing);
          for (i = 0; i < ticks.length; i++) {
            tick = ticks[i];
            if (i === next) {
              tick._index = i;
              count++;
              next = majorIndices[count * spacing];
            } else {
              delete tick.label;
            }
          }
        }
        function skip(ticks, spacing, majorStart, majorEnd) {
          var start = valueOrDefault$a(majorStart, 0);
          var end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);
          var count = 0;
          var length, i, tick, next;
          spacing = Math.ceil(spacing);
          if (majorEnd) {
            length = majorEnd - majorStart;
            spacing = length / Math.floor(length / spacing);
          }
          next = start;
          while (next < 0) {
            count++;
            next = Math.round(start + count * spacing);
          }
          for (i = Math.max(start, 0); i < end; i++) {
            tick = ticks[i];
            if (i === next) {
              tick._index = i;
              count++;
              next = Math.round(start + count * spacing);
            } else {
              delete tick.label;
            }
          }
        }
        var Scale = core_element.extend({
          zeroLineIndex: 0,
          getPadding: function() {
            var me = this;
            return {
              left: me.paddingLeft || 0,
              top: me.paddingTop || 0,
              right: me.paddingRight || 0,
              bottom: me.paddingBottom || 0
            };
          },
          getTicks: function() {
            return this._ticks;
          },
          _getLabels: function() {
            var data2 = this.chart.data;
            return this.options.labels || (this.isHorizontal() ? data2.xLabels : data2.yLabels) || data2.labels || [];
          },
          mergeTicksOptions: function() {
          },
          beforeUpdate: function() {
            helpers$1.callback(this.options.beforeUpdate, [this]);
          },
          update: function(maxWidth, maxHeight, margins) {
            var me = this;
            var tickOpts = me.options.ticks;
            var sampleSize = tickOpts.sampleSize;
            var i, ilen, labels, ticks, samplingEnabled;
            me.beforeUpdate();
            me.maxWidth = maxWidth;
            me.maxHeight = maxHeight;
            me.margins = helpers$1.extend({
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }, margins);
            me._ticks = null;
            me.ticks = null;
            me._labelSizes = null;
            me._maxLabelLines = 0;
            me.longestLabelWidth = 0;
            me.longestTextCache = me.longestTextCache || {};
            me._gridLineItems = null;
            me._labelItems = null;
            me.beforeSetDimensions();
            me.setDimensions();
            me.afterSetDimensions();
            me.beforeDataLimits();
            me.determineDataLimits();
            me.afterDataLimits();
            me.beforeBuildTicks();
            ticks = me.buildTicks() || [];
            ticks = me.afterBuildTicks(ticks) || ticks;
            if ((!ticks || !ticks.length) && me.ticks) {
              ticks = [];
              for (i = 0, ilen = me.ticks.length; i < ilen; ++i) {
                ticks.push({
                  value: me.ticks[i],
                  major: false
                });
              }
            }
            me._ticks = ticks;
            samplingEnabled = sampleSize < ticks.length;
            labels = me._convertTicksToLabels(samplingEnabled ? sample(ticks, sampleSize) : ticks);
            me._configure();
            me.beforeCalculateTickRotation();
            me.calculateTickRotation();
            me.afterCalculateTickRotation();
            me.beforeFit();
            me.fit();
            me.afterFit();
            me._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto") ? me._autoSkip(ticks) : ticks;
            if (samplingEnabled) {
              labels = me._convertTicksToLabels(me._ticksToDraw);
            }
            me.ticks = labels;
            me.afterUpdate();
            return me.minSize;
          },
          _configure: function() {
            var me = this;
            var reversePixels = me.options.ticks.reverse;
            var startPixel, endPixel;
            if (me.isHorizontal()) {
              startPixel = me.left;
              endPixel = me.right;
            } else {
              startPixel = me.top;
              endPixel = me.bottom;
              reversePixels = !reversePixels;
            }
            me._startPixel = startPixel;
            me._endPixel = endPixel;
            me._reversePixels = reversePixels;
            me._length = endPixel - startPixel;
          },
          afterUpdate: function() {
            helpers$1.callback(this.options.afterUpdate, [this]);
          },
          beforeSetDimensions: function() {
            helpers$1.callback(this.options.beforeSetDimensions, [this]);
          },
          setDimensions: function() {
            var me = this;
            if (me.isHorizontal()) {
              me.width = me.maxWidth;
              me.left = 0;
              me.right = me.width;
            } else {
              me.height = me.maxHeight;
              me.top = 0;
              me.bottom = me.height;
            }
            me.paddingLeft = 0;
            me.paddingTop = 0;
            me.paddingRight = 0;
            me.paddingBottom = 0;
          },
          afterSetDimensions: function() {
            helpers$1.callback(this.options.afterSetDimensions, [this]);
          },
          beforeDataLimits: function() {
            helpers$1.callback(this.options.beforeDataLimits, [this]);
          },
          determineDataLimits: helpers$1.noop,
          afterDataLimits: function() {
            helpers$1.callback(this.options.afterDataLimits, [this]);
          },
          beforeBuildTicks: function() {
            helpers$1.callback(this.options.beforeBuildTicks, [this]);
          },
          buildTicks: helpers$1.noop,
          afterBuildTicks: function(ticks) {
            var me = this;
            if (isArray2(ticks) && ticks.length) {
              return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
            }
            me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
            return ticks;
          },
          beforeTickToLabelConversion: function() {
            helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
          },
          convertTicksToLabels: function() {
            var me = this;
            var tickOpts = me.options.ticks;
            me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
          },
          afterTickToLabelConversion: function() {
            helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
          },
          beforeCalculateTickRotation: function() {
            helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
          },
          calculateTickRotation: function() {
            var me = this;
            var options2 = me.options;
            var tickOpts = options2.ticks;
            var numTicks = me.getTicks().length;
            var minRotation = tickOpts.minRotation || 0;
            var maxRotation = tickOpts.maxRotation;
            var labelRotation = minRotation;
            var labelSizes, maxLabelWidth, maxLabelHeight, maxWidth, tickWidth, maxHeight, maxLabelDiagonal;
            if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {
              me.labelRotation = minRotation;
              return;
            }
            labelSizes = me._getLabelSizes();
            maxLabelWidth = labelSizes.widest.width;
            maxLabelHeight = labelSizes.highest.height - labelSizes.highest.offset;
            maxWidth = Math.min(me.maxWidth, me.chart.width - maxLabelWidth);
            tickWidth = options2.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);
            if (maxLabelWidth + 6 > tickWidth) {
              tickWidth = maxWidth / (numTicks - (options2.offset ? 0.5 : 1));
              maxHeight = me.maxHeight - getTickMarkLength(options2.gridLines) - tickOpts.padding - getScaleLabelHeight(options2.scaleLabel);
              maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
              labelRotation = helpers$1.toDegrees(Math.min(Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)), Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)));
              labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
            }
            me.labelRotation = labelRotation;
          },
          afterCalculateTickRotation: function() {
            helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
          },
          beforeFit: function() {
            helpers$1.callback(this.options.beforeFit, [this]);
          },
          fit: function() {
            var me = this;
            var minSize = me.minSize = {
              width: 0,
              height: 0
            };
            var chart = me.chart;
            var opts = me.options;
            var tickOpts = opts.ticks;
            var scaleLabelOpts = opts.scaleLabel;
            var gridLineOpts = opts.gridLines;
            var display = me._isVisible();
            var isBottom = opts.position === "bottom";
            var isHorizontal = me.isHorizontal();
            if (isHorizontal) {
              minSize.width = me.maxWidth;
            } else if (display) {
              minSize.width = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
            }
            if (!isHorizontal) {
              minSize.height = me.maxHeight;
            } else if (display) {
              minSize.height = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
            }
            if (tickOpts.display && display) {
              var tickFonts = parseTickFontOptions(tickOpts);
              var labelSizes = me._getLabelSizes();
              var firstLabelSize = labelSizes.first;
              var lastLabelSize = labelSizes.last;
              var widestLabelSize = labelSizes.widest;
              var highestLabelSize = labelSizes.highest;
              var lineSpace = tickFonts.minor.lineHeight * 0.4;
              var tickPadding = tickOpts.padding;
              if (isHorizontal) {
                var isRotated = me.labelRotation !== 0;
                var angleRadians = helpers$1.toRadians(me.labelRotation);
                var cosRotation = Math.cos(angleRadians);
                var sinRotation = Math.sin(angleRadians);
                var labelHeight = sinRotation * widestLabelSize.width + cosRotation * (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0)) + (isRotated ? 0 : lineSpace);
                minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
                var offsetLeft = me.getPixelForTick(0) - me.left;
                var offsetRight = me.right - me.getPixelForTick(me.getTicks().length - 1);
                var paddingLeft, paddingRight;
                if (isRotated) {
                  paddingLeft = isBottom ? cosRotation * firstLabelSize.width + sinRotation * firstLabelSize.offset : sinRotation * (firstLabelSize.height - firstLabelSize.offset);
                  paddingRight = isBottom ? sinRotation * (lastLabelSize.height - lastLabelSize.offset) : cosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;
                } else {
                  paddingLeft = firstLabelSize.width / 2;
                  paddingRight = lastLabelSize.width / 2;
                }
                me.paddingLeft = Math.max((paddingLeft - offsetLeft) * me.width / (me.width - offsetLeft), 0) + 3;
                me.paddingRight = Math.max((paddingRight - offsetRight) * me.width / (me.width - offsetRight), 0) + 3;
              } else {
                var labelWidth = tickOpts.mirror ? 0 : widestLabelSize.width + tickPadding + lineSpace;
                minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth);
                me.paddingTop = firstLabelSize.height / 2;
                me.paddingBottom = lastLabelSize.height / 2;
              }
            }
            me.handleMargins();
            if (isHorizontal) {
              me.width = me._length = chart.width - me.margins.left - me.margins.right;
              me.height = minSize.height;
            } else {
              me.width = minSize.width;
              me.height = me._length = chart.height - me.margins.top - me.margins.bottom;
            }
          },
          handleMargins: function() {
            var me = this;
            if (me.margins) {
              me.margins.left = Math.max(me.paddingLeft, me.margins.left);
              me.margins.top = Math.max(me.paddingTop, me.margins.top);
              me.margins.right = Math.max(me.paddingRight, me.margins.right);
              me.margins.bottom = Math.max(me.paddingBottom, me.margins.bottom);
            }
          },
          afterFit: function() {
            helpers$1.callback(this.options.afterFit, [this]);
          },
          isHorizontal: function() {
            var pos = this.options.position;
            return pos === "top" || pos === "bottom";
          },
          isFullWidth: function() {
            return this.options.fullWidth;
          },
          getRightValue: function(rawValue) {
            if (isNullOrUndef(rawValue)) {
              return NaN;
            }
            if ((typeof rawValue === "number" || rawValue instanceof Number) && !isFinite(rawValue)) {
              return NaN;
            }
            if (rawValue) {
              if (this.isHorizontal()) {
                if (rawValue.x !== void 0) {
                  return this.getRightValue(rawValue.x);
                }
              } else if (rawValue.y !== void 0) {
                return this.getRightValue(rawValue.y);
              }
            }
            return rawValue;
          },
          _convertTicksToLabels: function(ticks) {
            var me = this;
            var labels, i, ilen;
            me.ticks = ticks.map(function(tick) {
              return tick.value;
            });
            me.beforeTickToLabelConversion();
            labels = me.convertTicksToLabels(ticks) || me.ticks;
            me.afterTickToLabelConversion();
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              ticks[i].label = labels[i];
            }
            return labels;
          },
          _getLabelSizes: function() {
            var me = this;
            var labelSizes = me._labelSizes;
            if (!labelSizes) {
              me._labelSizes = labelSizes = computeLabelSizes(me.ctx, parseTickFontOptions(me.options.ticks), me.getTicks(), me.longestTextCache);
              me.longestLabelWidth = labelSizes.widest.width;
            }
            return labelSizes;
          },
          _parseValue: function(value) {
            var start, end, min, max;
            if (isArray2(value)) {
              start = +this.getRightValue(value[0]);
              end = +this.getRightValue(value[1]);
              min = Math.min(start, end);
              max = Math.max(start, end);
            } else {
              value = +this.getRightValue(value);
              start = void 0;
              end = value;
              min = value;
              max = value;
            }
            return {
              min,
              max,
              start,
              end
            };
          },
          _getScaleLabel: function(rawValue) {
            var v = this._parseValue(rawValue);
            if (v.start !== void 0) {
              return "[" + v.start + ", " + v.end + "]";
            }
            return +this.getRightValue(rawValue);
          },
          getLabelForIndex: helpers$1.noop,
          getPixelForValue: helpers$1.noop,
          getValueForPixel: helpers$1.noop,
          getPixelForTick: function(index) {
            var me = this;
            var offset = me.options.offset;
            var numTicks = me._ticks.length;
            var tickWidth = 1 / Math.max(numTicks - (offset ? 0 : 1), 1);
            return index < 0 || index > numTicks - 1 ? null : me.getPixelForDecimal(index * tickWidth + (offset ? tickWidth / 2 : 0));
          },
          getPixelForDecimal: function(decimal) {
            var me = this;
            if (me._reversePixels) {
              decimal = 1 - decimal;
            }
            return me._startPixel + decimal * me._length;
          },
          getDecimalForPixel: function(pixel) {
            var decimal = (pixel - this._startPixel) / this._length;
            return this._reversePixels ? 1 - decimal : decimal;
          },
          getBasePixel: function() {
            return this.getPixelForValue(this.getBaseValue());
          },
          getBaseValue: function() {
            var me = this;
            var min = me.min;
            var max = me.max;
            return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
          },
          _autoSkip: function(ticks) {
            var me = this;
            var tickOpts = me.options.ticks;
            var axisLength = me._length;
            var ticksLimit = tickOpts.maxTicksLimit || axisLength / me._tickSize() + 1;
            var majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
            var numMajorIndices = majorIndices.length;
            var first = majorIndices[0];
            var last = majorIndices[numMajorIndices - 1];
            var i, ilen, spacing, avgMajorSpacing;
            if (numMajorIndices > ticksLimit) {
              skipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);
              return nonSkipped(ticks);
            }
            spacing = calculateSpacing(majorIndices, ticks, axisLength, ticksLimit);
            if (numMajorIndices > 0) {
              for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
                skip(ticks, spacing, majorIndices[i], majorIndices[i + 1]);
              }
              avgMajorSpacing = numMajorIndices > 1 ? (last - first) / (numMajorIndices - 1) : null;
              skip(ticks, spacing, helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
              skip(ticks, spacing, last, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
              return nonSkipped(ticks);
            }
            skip(ticks, spacing);
            return nonSkipped(ticks);
          },
          _tickSize: function() {
            var me = this;
            var optionTicks = me.options.ticks;
            var rot = helpers$1.toRadians(me.labelRotation);
            var cos = Math.abs(Math.cos(rot));
            var sin = Math.abs(Math.sin(rot));
            var labelSizes = me._getLabelSizes();
            var padding = optionTicks.autoSkipPadding || 0;
            var w = labelSizes ? labelSizes.widest.width + padding : 0;
            var h = labelSizes ? labelSizes.highest.height + padding : 0;
            return me.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
          },
          _isVisible: function() {
            var me = this;
            var chart = me.chart;
            var display = me.options.display;
            var i, ilen, meta;
            if (display !== "auto") {
              return !!display;
            }
            for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
              if (chart.isDatasetVisible(i)) {
                meta = chart.getDatasetMeta(i);
                if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
                  return true;
                }
              }
            }
            return false;
          },
          _computeGridLineItems: function(chartArea) {
            var me = this;
            var chart = me.chart;
            var options2 = me.options;
            var gridLines = options2.gridLines;
            var position = options2.position;
            var offsetGridLines = gridLines.offsetGridLines;
            var isHorizontal = me.isHorizontal();
            var ticks = me._ticksToDraw;
            var ticksLength = ticks.length + (offsetGridLines ? 1 : 0);
            var tl = getTickMarkLength(gridLines);
            var items = [];
            var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
            var axisHalfWidth = axisWidth / 2;
            var alignPixel = helpers$1._alignPixel;
            var alignBorderValue = function(pixel) {
              return alignPixel(chart, pixel, axisWidth);
            };
            var borderValue, i, tick, lineValue, alignedLineValue;
            var tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;
            if (position === "top") {
              borderValue = alignBorderValue(me.bottom);
              ty1 = me.bottom - tl;
              ty2 = borderValue - axisHalfWidth;
              y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
              y2 = chartArea.bottom;
            } else if (position === "bottom") {
              borderValue = alignBorderValue(me.top);
              y1 = chartArea.top;
              y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
              ty1 = borderValue + axisHalfWidth;
              ty2 = me.top + tl;
            } else if (position === "left") {
              borderValue = alignBorderValue(me.right);
              tx1 = me.right - tl;
              tx2 = borderValue - axisHalfWidth;
              x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
              x2 = chartArea.right;
            } else {
              borderValue = alignBorderValue(me.left);
              x1 = chartArea.left;
              x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
              tx1 = borderValue + axisHalfWidth;
              tx2 = me.left + tl;
            }
            for (i = 0; i < ticksLength; ++i) {
              tick = ticks[i] || {};
              if (isNullOrUndef(tick.label) && i < ticks.length) {
                continue;
              }
              if (i === me.zeroLineIndex && options2.offset === offsetGridLines) {
                lineWidth = gridLines.zeroLineWidth;
                lineColor = gridLines.zeroLineColor;
                borderDash = gridLines.zeroLineBorderDash || [];
                borderDashOffset = gridLines.zeroLineBorderDashOffset || 0;
              } else {
                lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i, 1);
                lineColor = valueAtIndexOrDefault(gridLines.color, i, "rgba(0,0,0,0.1)");
                borderDash = gridLines.borderDash || [];
                borderDashOffset = gridLines.borderDashOffset || 0;
              }
              lineValue = getPixelForGridLine(me, tick._index || i, offsetGridLines);
              if (lineValue === void 0) {
                continue;
              }
              alignedLineValue = alignPixel(chart, lineValue, lineWidth);
              if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
              } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
              }
              items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset
              });
            }
            items.ticksLength = ticksLength;
            items.borderValue = borderValue;
            return items;
          },
          _computeLabelItems: function() {
            var me = this;
            var options2 = me.options;
            var optionTicks = options2.ticks;
            var position = options2.position;
            var isMirrored = optionTicks.mirror;
            var isHorizontal = me.isHorizontal();
            var ticks = me._ticksToDraw;
            var fonts = parseTickFontOptions(optionTicks);
            var tickPadding = optionTicks.padding;
            var tl = getTickMarkLength(options2.gridLines);
            var rotation = -helpers$1.toRadians(me.labelRotation);
            var items = [];
            var i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
            if (position === "top") {
              y = me.bottom - tl - tickPadding;
              textAlign = !rotation ? "center" : "left";
            } else if (position === "bottom") {
              y = me.top + tl + tickPadding;
              textAlign = !rotation ? "center" : "right";
            } else if (position === "left") {
              x = me.right - (isMirrored ? 0 : tl) - tickPadding;
              textAlign = isMirrored ? "left" : "right";
            } else {
              x = me.left + (isMirrored ? 0 : tl) + tickPadding;
              textAlign = isMirrored ? "right" : "left";
            }
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              label = tick.label;
              if (isNullOrUndef(label)) {
                continue;
              }
              pixel = me.getPixelForTick(tick._index || i) + optionTicks.labelOffset;
              font = tick.major ? fonts.major : fonts.minor;
              lineHeight = font.lineHeight;
              lineCount = isArray2(label) ? label.length : 1;
              if (isHorizontal) {
                x = pixel;
                textOffset = position === "top" ? ((!rotation ? 0.5 : 1) - lineCount) * lineHeight : (!rotation ? 0.5 : 0) * lineHeight;
              } else {
                y = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
              }
              items.push({
                x,
                y,
                rotation,
                label,
                font,
                textOffset,
                textAlign
              });
            }
            return items;
          },
          _drawGrid: function(chartArea) {
            var me = this;
            var gridLines = me.options.gridLines;
            if (!gridLines.display) {
              return;
            }
            var ctx = me.ctx;
            var chart = me.chart;
            var alignPixel = helpers$1._alignPixel;
            var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
            var items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));
            var width, color, i, ilen, item;
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              item = items[i];
              width = item.width;
              color = item.color;
              if (width && color) {
                ctx.save();
                ctx.lineWidth = width;
                ctx.strokeStyle = color;
                if (ctx.setLineDash) {
                  ctx.setLineDash(item.borderDash);
                  ctx.lineDashOffset = item.borderDashOffset;
                }
                ctx.beginPath();
                if (gridLines.drawTicks) {
                  ctx.moveTo(item.tx1, item.ty1);
                  ctx.lineTo(item.tx2, item.ty2);
                }
                if (gridLines.drawOnChartArea) {
                  ctx.moveTo(item.x1, item.y1);
                  ctx.lineTo(item.x2, item.y2);
                }
                ctx.stroke();
                ctx.restore();
              }
            }
            if (axisWidth) {
              var firstLineWidth = axisWidth;
              var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, items.ticksLength - 1, 1);
              var borderValue = items.borderValue;
              var x1, x2, y1, y2;
              if (me.isHorizontal()) {
                x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
                x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
                y1 = y2 = borderValue;
              } else {
                y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
                y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
                x1 = x2 = borderValue;
              }
              ctx.lineWidth = axisWidth;
              ctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
            }
          },
          _drawLabels: function() {
            var me = this;
            var optionTicks = me.options.ticks;
            if (!optionTicks.display) {
              return;
            }
            var ctx = me.ctx;
            var items = me._labelItems || (me._labelItems = me._computeLabelItems());
            var i, j, ilen, jlen, item, tickFont, label, y;
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              item = items[i];
              tickFont = item.font;
              ctx.save();
              ctx.translate(item.x, item.y);
              ctx.rotate(item.rotation);
              ctx.font = tickFont.string;
              ctx.fillStyle = tickFont.color;
              ctx.textBaseline = "middle";
              ctx.textAlign = item.textAlign;
              label = item.label;
              y = item.textOffset;
              if (isArray2(label)) {
                for (j = 0, jlen = label.length; j < jlen; ++j) {
                  ctx.fillText("" + label[j], 0, y);
                  y += tickFont.lineHeight;
                }
              } else {
                ctx.fillText(label, 0, y);
              }
              ctx.restore();
            }
          },
          _drawTitle: function() {
            var me = this;
            var ctx = me.ctx;
            var options2 = me.options;
            var scaleLabel = options2.scaleLabel;
            if (!scaleLabel.display) {
              return;
            }
            var scaleLabelFontColor = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);
            var scaleLabelFont = helpers$1.options._parseFont(scaleLabel);
            var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
            var halfLineHeight = scaleLabelFont.lineHeight / 2;
            var position = options2.position;
            var rotation = 0;
            var scaleLabelX, scaleLabelY;
            if (me.isHorizontal()) {
              scaleLabelX = me.left + me.width / 2;
              scaleLabelY = position === "bottom" ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
            } else {
              var isLeft = position === "left";
              scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
              scaleLabelY = me.top + me.height / 2;
              rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
            }
            ctx.save();
            ctx.translate(scaleLabelX, scaleLabelY);
            ctx.rotate(rotation);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = scaleLabelFontColor;
            ctx.font = scaleLabelFont.string;
            ctx.fillText(scaleLabel.labelString, 0, 0);
            ctx.restore();
          },
          draw: function(chartArea) {
            var me = this;
            if (!me._isVisible()) {
              return;
            }
            me._drawGrid(chartArea);
            me._drawTitle();
            me._drawLabels();
          },
          _layers: function() {
            var me = this;
            var opts = me.options;
            var tz = opts.ticks && opts.ticks.z || 0;
            var gz = opts.gridLines && opts.gridLines.z || 0;
            if (!me._isVisible() || tz === gz || me.draw !== me._draw) {
              return [{
                z: tz,
                draw: function() {
                  me.draw.apply(me, arguments);
                }
              }];
            }
            return [{
              z: gz,
              draw: function() {
                me._drawGrid.apply(me, arguments);
                me._drawTitle.apply(me, arguments);
              }
            }, {
              z: tz,
              draw: function() {
                me._drawLabels.apply(me, arguments);
              }
            }];
          },
          _getMatchingVisibleMetas: function(type) {
            var me = this;
            var isHorizontal = me.isHorizontal();
            return me.chart._getSortedVisibleDatasetMetas().filter(function(meta) {
              return (!type || meta.type === type) && (isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id);
            });
          }
        });
        Scale.prototype._draw = Scale.prototype.draw;
        var core_scale = Scale;
        var isNullOrUndef$1 = helpers$1.isNullOrUndef;
        var defaultConfig = {
          position: "bottom"
        };
        var scale_category = core_scale.extend({
          determineDataLimits: function() {
            var me = this;
            var labels = me._getLabels();
            var ticksOpts = me.options.ticks;
            var min = ticksOpts.min;
            var max = ticksOpts.max;
            var minIndex = 0;
            var maxIndex = labels.length - 1;
            var findIndex;
            if (min !== void 0) {
              findIndex = labels.indexOf(min);
              if (findIndex >= 0) {
                minIndex = findIndex;
              }
            }
            if (max !== void 0) {
              findIndex = labels.indexOf(max);
              if (findIndex >= 0) {
                maxIndex = findIndex;
              }
            }
            me.minIndex = minIndex;
            me.maxIndex = maxIndex;
            me.min = labels[minIndex];
            me.max = labels[maxIndex];
          },
          buildTicks: function() {
            var me = this;
            var labels = me._getLabels();
            var minIndex = me.minIndex;
            var maxIndex = me.maxIndex;
            me.ticks = minIndex === 0 && maxIndex === labels.length - 1 ? labels : labels.slice(minIndex, maxIndex + 1);
          },
          getLabelForIndex: function(index, datasetIndex) {
            var me = this;
            var chart = me.chart;
            if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
              return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
            }
            return me._getLabels()[index];
          },
          _configure: function() {
            var me = this;
            var offset = me.options.offset;
            var ticks = me.ticks;
            core_scale.prototype._configure.call(me);
            if (!me.isHorizontal()) {
              me._reversePixels = !me._reversePixels;
            }
            if (!ticks) {
              return;
            }
            me._startValue = me.minIndex - (offset ? 0.5 : 0);
            me._valueRange = Math.max(ticks.length - (offset ? 0 : 1), 1);
          },
          getPixelForValue: function(value, index, datasetIndex) {
            var me = this;
            var valueCategory, labels, idx;
            if (!isNullOrUndef$1(index) && !isNullOrUndef$1(datasetIndex)) {
              value = me.chart.data.datasets[datasetIndex].data[index];
            }
            if (!isNullOrUndef$1(value)) {
              valueCategory = me.isHorizontal() ? value.x : value.y;
            }
            if (valueCategory !== void 0 || value !== void 0 && isNaN(index)) {
              labels = me._getLabels();
              value = helpers$1.valueOrDefault(valueCategory, value);
              idx = labels.indexOf(value);
              index = idx !== -1 ? idx : index;
              if (isNaN(index)) {
                index = value;
              }
            }
            return me.getPixelForDecimal((index - me._startValue) / me._valueRange);
          },
          getPixelForTick: function(index) {
            var ticks = this.ticks;
            return index < 0 || index > ticks.length - 1 ? null : this.getPixelForValue(ticks[index], index + this.minIndex);
          },
          getValueForPixel: function(pixel) {
            var me = this;
            var value = Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);
            return Math.min(Math.max(value, 0), me.ticks.length - 1);
          },
          getBasePixel: function() {
            return this.bottom;
          }
        });
        var _defaults = defaultConfig;
        scale_category._defaults = _defaults;
        var noop = helpers$1.noop;
        var isNullOrUndef$2 = helpers$1.isNullOrUndef;
        function generateTicks(generationOptions, dataRange) {
          var ticks = [];
          var MIN_SPACING = 1e-14;
          var stepSize = generationOptions.stepSize;
          var unit = stepSize || 1;
          var maxNumSpaces = generationOptions.maxTicks - 1;
          var min = generationOptions.min;
          var max = generationOptions.max;
          var precision = generationOptions.precision;
          var rmin = dataRange.min;
          var rmax = dataRange.max;
          var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
          var factor, niceMin, niceMax, numSpaces;
          if (spacing < MIN_SPACING && isNullOrUndef$2(min) && isNullOrUndef$2(max)) {
            return [rmin, rmax];
          }
          numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
          if (numSpaces > maxNumSpaces) {
            spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
          }
          if (stepSize || isNullOrUndef$2(precision)) {
            factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
          } else {
            factor = Math.pow(10, precision);
            spacing = Math.ceil(spacing * factor) / factor;
          }
          niceMin = Math.floor(rmin / spacing) * spacing;
          niceMax = Math.ceil(rmax / spacing) * spacing;
          if (stepSize) {
            if (!isNullOrUndef$2(min) && helpers$1.almostWhole(min / spacing, spacing / 1e3)) {
              niceMin = min;
            }
            if (!isNullOrUndef$2(max) && helpers$1.almostWhole(max / spacing, spacing / 1e3)) {
              niceMax = max;
            }
          }
          numSpaces = (niceMax - niceMin) / spacing;
          if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
            numSpaces = Math.round(numSpaces);
          } else {
            numSpaces = Math.ceil(numSpaces);
          }
          niceMin = Math.round(niceMin * factor) / factor;
          niceMax = Math.round(niceMax * factor) / factor;
          ticks.push(isNullOrUndef$2(min) ? niceMin : min);
          for (var j = 1; j < numSpaces; ++j) {
            ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
          }
          ticks.push(isNullOrUndef$2(max) ? niceMax : max);
          return ticks;
        }
        var scale_linearbase = core_scale.extend({
          getRightValue: function(value) {
            if (typeof value === "string") {
              return +value;
            }
            return core_scale.prototype.getRightValue.call(this, value);
          },
          handleTickRangeOptions: function() {
            var me = this;
            var opts = me.options;
            var tickOpts = opts.ticks;
            if (tickOpts.beginAtZero) {
              var minSign = helpers$1.sign(me.min);
              var maxSign = helpers$1.sign(me.max);
              if (minSign < 0 && maxSign < 0) {
                me.max = 0;
              } else if (minSign > 0 && maxSign > 0) {
                me.min = 0;
              }
            }
            var setMin = tickOpts.min !== void 0 || tickOpts.suggestedMin !== void 0;
            var setMax = tickOpts.max !== void 0 || tickOpts.suggestedMax !== void 0;
            if (tickOpts.min !== void 0) {
              me.min = tickOpts.min;
            } else if (tickOpts.suggestedMin !== void 0) {
              if (me.min === null) {
                me.min = tickOpts.suggestedMin;
              } else {
                me.min = Math.min(me.min, tickOpts.suggestedMin);
              }
            }
            if (tickOpts.max !== void 0) {
              me.max = tickOpts.max;
            } else if (tickOpts.suggestedMax !== void 0) {
              if (me.max === null) {
                me.max = tickOpts.suggestedMax;
              } else {
                me.max = Math.max(me.max, tickOpts.suggestedMax);
              }
            }
            if (setMin !== setMax) {
              if (me.min >= me.max) {
                if (setMin) {
                  me.max = me.min + 1;
                } else {
                  me.min = me.max - 1;
                }
              }
            }
            if (me.min === me.max) {
              me.max++;
              if (!tickOpts.beginAtZero) {
                me.min--;
              }
            }
          },
          getTickLimit: function() {
            var me = this;
            var tickOpts = me.options.ticks;
            var stepSize = tickOpts.stepSize;
            var maxTicksLimit = tickOpts.maxTicksLimit;
            var maxTicks;
            if (stepSize) {
              maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
            } else {
              maxTicks = me._computeTickLimit();
              maxTicksLimit = maxTicksLimit || 11;
            }
            if (maxTicksLimit) {
              maxTicks = Math.min(maxTicksLimit, maxTicks);
            }
            return maxTicks;
          },
          _computeTickLimit: function() {
            return Number.POSITIVE_INFINITY;
          },
          handleDirectionalChanges: noop,
          buildTicks: function() {
            var me = this;
            var opts = me.options;
            var tickOpts = opts.ticks;
            var maxTicks = me.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            var numericGeneratorOptions = {
              maxTicks,
              min: tickOpts.min,
              max: tickOpts.max,
              precision: tickOpts.precision,
              stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
            };
            var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
            me.handleDirectionalChanges();
            me.max = helpers$1.max(ticks);
            me.min = helpers$1.min(ticks);
            if (tickOpts.reverse) {
              ticks.reverse();
              me.start = me.max;
              me.end = me.min;
            } else {
              me.start = me.min;
              me.end = me.max;
            }
          },
          convertTicksToLabels: function() {
            var me = this;
            me.ticksAsNumbers = me.ticks.slice();
            me.zeroLineIndex = me.ticks.indexOf(0);
            core_scale.prototype.convertTicksToLabels.call(me);
          },
          _configure: function() {
            var me = this;
            var ticks = me.getTicks();
            var start = me.min;
            var end = me.max;
            var offset;
            core_scale.prototype._configure.call(me);
            if (me.options.offset && ticks.length) {
              offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
              start -= offset;
              end += offset;
            }
            me._startValue = start;
            me._endValue = end;
            me._valueRange = end - start;
          }
        });
        var defaultConfig$1 = {
          position: "left",
          ticks: {
            callback: core_ticks.formatters.linear
          }
        };
        var DEFAULT_MIN = 0;
        var DEFAULT_MAX = 1;
        function getOrCreateStack(stacks, stacked, meta) {
          var key = [
            meta.type,
            stacked === void 0 && meta.stack === void 0 ? meta.index : "",
            meta.stack
          ].join(".");
          if (stacks[key] === void 0) {
            stacks[key] = {
              pos: [],
              neg: []
            };
          }
          return stacks[key];
        }
        function stackData(scale2, stacks, meta, data2) {
          var opts = scale2.options;
          var stacked = opts.stacked;
          var stack = getOrCreateStack(stacks, stacked, meta);
          var pos = stack.pos;
          var neg = stack.neg;
          var ilen = data2.length;
          var i, value;
          for (i = 0; i < ilen; ++i) {
            value = scale2._parseValue(data2[i]);
            if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {
              continue;
            }
            pos[i] = pos[i] || 0;
            neg[i] = neg[i] || 0;
            if (opts.relativePoints) {
              pos[i] = 100;
            } else if (value.min < 0 || value.max < 0) {
              neg[i] += value.min;
            } else {
              pos[i] += value.max;
            }
          }
        }
        function updateMinMax(scale2, meta, data2) {
          var ilen = data2.length;
          var i, value;
          for (i = 0; i < ilen; ++i) {
            value = scale2._parseValue(data2[i]);
            if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {
              continue;
            }
            scale2.min = Math.min(scale2.min, value.min);
            scale2.max = Math.max(scale2.max, value.max);
          }
        }
        var scale_linear = scale_linearbase.extend({
          determineDataLimits: function() {
            var me = this;
            var opts = me.options;
            var chart = me.chart;
            var datasets = chart.data.datasets;
            var metasets = me._getMatchingVisibleMetas();
            var hasStacks = opts.stacked;
            var stacks = {};
            var ilen = metasets.length;
            var i, meta, data2, values;
            me.min = Number.POSITIVE_INFINITY;
            me.max = Number.NEGATIVE_INFINITY;
            if (hasStacks === void 0) {
              for (i = 0; !hasStacks && i < ilen; ++i) {
                meta = metasets[i];
                hasStacks = meta.stack !== void 0;
              }
            }
            for (i = 0; i < ilen; ++i) {
              meta = metasets[i];
              data2 = datasets[meta.index].data;
              if (hasStacks) {
                stackData(me, stacks, meta, data2);
              } else {
                updateMinMax(me, meta, data2);
              }
            }
            helpers$1.each(stacks, function(stackValues) {
              values = stackValues.pos.concat(stackValues.neg);
              me.min = Math.min(me.min, helpers$1.min(values));
              me.max = Math.max(me.max, helpers$1.max(values));
            });
            me.min = helpers$1.isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
            me.max = helpers$1.isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;
            me.handleTickRangeOptions();
          },
          _computeTickLimit: function() {
            var me = this;
            var tickFont;
            if (me.isHorizontal()) {
              return Math.ceil(me.width / 40);
            }
            tickFont = helpers$1.options._parseFont(me.options.ticks);
            return Math.ceil(me.height / tickFont.lineHeight);
          },
          handleDirectionalChanges: function() {
            if (!this.isHorizontal()) {
              this.ticks.reverse();
            }
          },
          getLabelForIndex: function(index, datasetIndex) {
            return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);
          },
          getPixelForValue: function(value) {
            var me = this;
            return me.getPixelForDecimal((+me.getRightValue(value) - me._startValue) / me._valueRange);
          },
          getValueForPixel: function(pixel) {
            return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
          },
          getPixelForTick: function(index) {
            var ticks = this.ticksAsNumbers;
            if (index < 0 || index > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index]);
          }
        });
        var _defaults$1 = defaultConfig$1;
        scale_linear._defaults = _defaults$1;
        var valueOrDefault$b = helpers$1.valueOrDefault;
        var log10 = helpers$1.math.log10;
        function generateTicks$1(generationOptions, dataRange) {
          var ticks = [];
          var tickVal = valueOrDefault$b(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
          var endExp = Math.floor(log10(dataRange.max));
          var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
          var exp, significand;
          if (tickVal === 0) {
            exp = Math.floor(log10(dataRange.minNotZero));
            significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
            ticks.push(tickVal);
            tickVal = significand * Math.pow(10, exp);
          } else {
            exp = Math.floor(log10(tickVal));
            significand = Math.floor(tickVal / Math.pow(10, exp));
          }
          var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
          do {
            ticks.push(tickVal);
            ++significand;
            if (significand === 10) {
              significand = 1;
              ++exp;
              precision = exp >= 0 ? 1 : precision;
            }
            tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
          } while (exp < endExp || exp === endExp && significand < endSignificand);
          var lastTick = valueOrDefault$b(generationOptions.max, tickVal);
          ticks.push(lastTick);
          return ticks;
        }
        var defaultConfig$2 = {
          position: "left",
          ticks: {
            callback: core_ticks.formatters.logarithmic
          }
        };
        function nonNegativeOrDefault(value, defaultValue) {
          return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
        }
        var scale_logarithmic = core_scale.extend({
          determineDataLimits: function() {
            var me = this;
            var opts = me.options;
            var chart = me.chart;
            var datasets = chart.data.datasets;
            var isHorizontal = me.isHorizontal();
            function IDMatches(meta2) {
              return isHorizontal ? meta2.xAxisID === me.id : meta2.yAxisID === me.id;
            }
            var datasetIndex, meta, value, data2, i, ilen;
            me.min = Number.POSITIVE_INFINITY;
            me.max = Number.NEGATIVE_INFINITY;
            me.minNotZero = Number.POSITIVE_INFINITY;
            var hasStacks = opts.stacked;
            if (hasStacks === void 0) {
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== void 0) {
                  hasStacks = true;
                  break;
                }
              }
            }
            if (opts.stacked || hasStacks) {
              var valuesPerStack = {};
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                var key = [
                  meta.type,
                  opts.stacked === void 0 && meta.stack === void 0 ? datasetIndex : "",
                  meta.stack
                ].join(".");
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                  if (valuesPerStack[key] === void 0) {
                    valuesPerStack[key] = [];
                  }
                  data2 = datasets[datasetIndex].data;
                  for (i = 0, ilen = data2.length; i < ilen; i++) {
                    var values = valuesPerStack[key];
                    value = me._parseValue(data2[i]);
                    if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {
                      continue;
                    }
                    values[i] = values[i] || 0;
                    values[i] += value.max;
                  }
                }
              }
              helpers$1.each(valuesPerStack, function(valuesForType) {
                if (valuesForType.length > 0) {
                  var minVal = helpers$1.min(valuesForType);
                  var maxVal = helpers$1.max(valuesForType);
                  me.min = Math.min(me.min, minVal);
                  me.max = Math.max(me.max, maxVal);
                }
              });
            } else {
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                  data2 = datasets[datasetIndex].data;
                  for (i = 0, ilen = data2.length; i < ilen; i++) {
                    value = me._parseValue(data2[i]);
                    if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {
                      continue;
                    }
                    me.min = Math.min(value.min, me.min);
                    me.max = Math.max(value.max, me.max);
                    if (value.min !== 0) {
                      me.minNotZero = Math.min(value.min, me.minNotZero);
                    }
                  }
                }
              }
            }
            me.min = helpers$1.isFinite(me.min) ? me.min : null;
            me.max = helpers$1.isFinite(me.max) ? me.max : null;
            me.minNotZero = helpers$1.isFinite(me.minNotZero) ? me.minNotZero : null;
            this.handleTickRangeOptions();
          },
          handleTickRangeOptions: function() {
            var me = this;
            var tickOpts = me.options.ticks;
            var DEFAULT_MIN2 = 1;
            var DEFAULT_MAX2 = 10;
            me.min = nonNegativeOrDefault(tickOpts.min, me.min);
            me.max = nonNegativeOrDefault(tickOpts.max, me.max);
            if (me.min === me.max) {
              if (me.min !== 0 && me.min !== null) {
                me.min = Math.pow(10, Math.floor(log10(me.min)) - 1);
                me.max = Math.pow(10, Math.floor(log10(me.max)) + 1);
              } else {
                me.min = DEFAULT_MIN2;
                me.max = DEFAULT_MAX2;
              }
            }
            if (me.min === null) {
              me.min = Math.pow(10, Math.floor(log10(me.max)) - 1);
            }
            if (me.max === null) {
              me.max = me.min !== 0 ? Math.pow(10, Math.floor(log10(me.min)) + 1) : DEFAULT_MAX2;
            }
            if (me.minNotZero === null) {
              if (me.min > 0) {
                me.minNotZero = me.min;
              } else if (me.max < 1) {
                me.minNotZero = Math.pow(10, Math.floor(log10(me.max)));
              } else {
                me.minNotZero = DEFAULT_MIN2;
              }
            }
          },
          buildTicks: function() {
            var me = this;
            var tickOpts = me.options.ticks;
            var reverse = !me.isHorizontal();
            var generationOptions = {
              min: nonNegativeOrDefault(tickOpts.min),
              max: nonNegativeOrDefault(tickOpts.max)
            };
            var ticks = me.ticks = generateTicks$1(generationOptions, me);
            me.max = helpers$1.max(ticks);
            me.min = helpers$1.min(ticks);
            if (tickOpts.reverse) {
              reverse = !reverse;
              me.start = me.max;
              me.end = me.min;
            } else {
              me.start = me.min;
              me.end = me.max;
            }
            if (reverse) {
              ticks.reverse();
            }
          },
          convertTicksToLabels: function() {
            this.tickValues = this.ticks.slice();
            core_scale.prototype.convertTicksToLabels.call(this);
          },
          getLabelForIndex: function(index, datasetIndex) {
            return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);
          },
          getPixelForTick: function(index) {
            var ticks = this.tickValues;
            if (index < 0 || index > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index]);
          },
          _getFirstTickValue: function(value) {
            var exp = Math.floor(log10(value));
            var significand = Math.floor(value / Math.pow(10, exp));
            return significand * Math.pow(10, exp);
          },
          _configure: function() {
            var me = this;
            var start = me.min;
            var offset = 0;
            core_scale.prototype._configure.call(me);
            if (start === 0) {
              start = me._getFirstTickValue(me.minNotZero);
              offset = valueOrDefault$b(me.options.ticks.fontSize, core_defaults.global.defaultFontSize) / me._length;
            }
            me._startValue = log10(start);
            me._valueOffset = offset;
            me._valueRange = (log10(me.max) - log10(start)) / (1 - offset);
          },
          getPixelForValue: function(value) {
            var me = this;
            var decimal = 0;
            value = +me.getRightValue(value);
            if (value > me.min && value > 0) {
              decimal = (log10(value) - me._startValue) / me._valueRange + me._valueOffset;
            }
            return me.getPixelForDecimal(decimal);
          },
          getValueForPixel: function(pixel) {
            var me = this;
            var decimal = me.getDecimalForPixel(pixel);
            return decimal === 0 && me.min === 0 ? 0 : Math.pow(10, me._startValue + (decimal - me._valueOffset) * me._valueRange);
          }
        });
        var _defaults$2 = defaultConfig$2;
        scale_logarithmic._defaults = _defaults$2;
        var valueOrDefault$c = helpers$1.valueOrDefault;
        var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
        var resolve$4 = helpers$1.options.resolve;
        var defaultConfig$3 = {
          display: true,
          animate: true,
          position: "chartArea",
          angleLines: {
            display: true,
            color: "rgba(0,0,0,0.1)",
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0
          },
          gridLines: {
            circular: false
          },
          ticks: {
            showLabelBackdrop: true,
            backdropColor: "rgba(255,255,255,0.75)",
            backdropPaddingY: 2,
            backdropPaddingX: 2,
            callback: core_ticks.formatters.linear
          },
          pointLabels: {
            display: true,
            fontSize: 10,
            callback: function(label) {
              return label;
            }
          }
        };
        function getTickBackdropHeight(opts) {
          var tickOpts = opts.ticks;
          if (tickOpts.display && opts.display) {
            return valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
          }
          return 0;
        }
        function measureLabelSize(ctx, lineHeight, label) {
          if (helpers$1.isArray(label)) {
            return {
              w: helpers$1.longestText(ctx, ctx.font, label),
              h: label.length * lineHeight
            };
          }
          return {
            w: ctx.measureText(label).width,
            h: lineHeight
          };
        }
        function determineLimits(angle, pos, size, min, max) {
          if (angle === min || angle === max) {
            return {
              start: pos - size / 2,
              end: pos + size / 2
            };
          } else if (angle < min || angle > max) {
            return {
              start: pos - size,
              end: pos
            };
          }
          return {
            start: pos,
            end: pos + size
          };
        }
        function fitWithPointLabels(scale2) {
          var plFont = helpers$1.options._parseFont(scale2.options.pointLabels);
          var furthestLimits = {
            l: 0,
            r: scale2.width,
            t: 0,
            b: scale2.height - scale2.paddingTop
          };
          var furthestAngles = {};
          var i, textSize, pointPosition;
          scale2.ctx.font = plFont.string;
          scale2._pointLabelSizes = [];
          var valueCount = scale2.chart.data.labels.length;
          for (i = 0; i < valueCount; i++) {
            pointPosition = scale2.getPointPosition(i, scale2.drawingArea + 5);
            textSize = measureLabelSize(scale2.ctx, plFont.lineHeight, scale2.pointLabels[i]);
            scale2._pointLabelSizes[i] = textSize;
            var angleRadians = scale2.getIndexAngle(i);
            var angle = helpers$1.toDegrees(angleRadians) % 360;
            var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
            var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
            if (hLimits.start < furthestLimits.l) {
              furthestLimits.l = hLimits.start;
              furthestAngles.l = angleRadians;
            }
            if (hLimits.end > furthestLimits.r) {
              furthestLimits.r = hLimits.end;
              furthestAngles.r = angleRadians;
            }
            if (vLimits.start < furthestLimits.t) {
              furthestLimits.t = vLimits.start;
              furthestAngles.t = angleRadians;
            }
            if (vLimits.end > furthestLimits.b) {
              furthestLimits.b = vLimits.end;
              furthestAngles.b = angleRadians;
            }
          }
          scale2.setReductions(scale2.drawingArea, furthestLimits, furthestAngles);
        }
        function getTextAlignForAngle(angle) {
          if (angle === 0 || angle === 180) {
            return "center";
          } else if (angle < 180) {
            return "left";
          }
          return "right";
        }
        function fillText(ctx, text, position, lineHeight) {
          var y = position.y + lineHeight / 2;
          var i, ilen;
          if (helpers$1.isArray(text)) {
            for (i = 0, ilen = text.length; i < ilen; ++i) {
              ctx.fillText(text[i], position.x, y);
              y += lineHeight;
            }
          } else {
            ctx.fillText(text, position.x, y);
          }
        }
        function adjustPointPositionForLabelHeight(angle, textSize, position) {
          if (angle === 90 || angle === 270) {
            position.y -= textSize.h / 2;
          } else if (angle > 270 || angle < 90) {
            position.y -= textSize.h;
          }
        }
        function drawPointLabels(scale2) {
          var ctx = scale2.ctx;
          var opts = scale2.options;
          var pointLabelOpts = opts.pointLabels;
          var tickBackdropHeight = getTickBackdropHeight(opts);
          var outerDistance = scale2.getDistanceFromCenterForValue(opts.ticks.reverse ? scale2.min : scale2.max);
          var plFont = helpers$1.options._parseFont(pointLabelOpts);
          ctx.save();
          ctx.font = plFont.string;
          ctx.textBaseline = "middle";
          for (var i = scale2.chart.data.labels.length - 1; i >= 0; i--) {
            var extra = i === 0 ? tickBackdropHeight / 2 : 0;
            var pointLabelPosition = scale2.getPointPosition(i, outerDistance + extra + 5);
            var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
            ctx.fillStyle = pointLabelFontColor;
            var angleRadians = scale2.getIndexAngle(i);
            var angle = helpers$1.toDegrees(angleRadians);
            ctx.textAlign = getTextAlignForAngle(angle);
            adjustPointPositionForLabelHeight(angle, scale2._pointLabelSizes[i], pointLabelPosition);
            fillText(ctx, scale2.pointLabels[i], pointLabelPosition, plFont.lineHeight);
          }
          ctx.restore();
        }
        function drawRadiusLine(scale2, gridLineOpts, radius, index) {
          var ctx = scale2.ctx;
          var circular = gridLineOpts.circular;
          var valueCount = scale2.chart.data.labels.length;
          var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
          var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
          var pointPosition;
          if (!circular && !valueCount || !lineColor || !lineWidth) {
            return;
          }
          ctx.save();
          ctx.strokeStyle = lineColor;
          ctx.lineWidth = lineWidth;
          if (ctx.setLineDash) {
            ctx.setLineDash(gridLineOpts.borderDash || []);
            ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0;
          }
          ctx.beginPath();
          if (circular) {
            ctx.arc(scale2.xCenter, scale2.yCenter, radius, 0, Math.PI * 2);
          } else {
            pointPosition = scale2.getPointPosition(0, radius);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for (var i = 1; i < valueCount; i++) {
              pointPosition = scale2.getPointPosition(i, radius);
              ctx.lineTo(pointPosition.x, pointPosition.y);
            }
          }
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
        function numberOrZero(param) {
          return helpers$1.isNumber(param) ? param : 0;
        }
        var scale_radialLinear = scale_linearbase.extend({
          setDimensions: function() {
            var me = this;
            me.width = me.maxWidth;
            me.height = me.maxHeight;
            me.paddingTop = getTickBackdropHeight(me.options) / 2;
            me.xCenter = Math.floor(me.width / 2);
            me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
            me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
          },
          determineDataLimits: function() {
            var me = this;
            var chart = me.chart;
            var min = Number.POSITIVE_INFINITY;
            var max = Number.NEGATIVE_INFINITY;
            helpers$1.each(chart.data.datasets, function(dataset, datasetIndex) {
              if (chart.isDatasetVisible(datasetIndex)) {
                var meta = chart.getDatasetMeta(datasetIndex);
                helpers$1.each(dataset.data, function(rawValue, index) {
                  var value = +me.getRightValue(rawValue);
                  if (isNaN(value) || meta.data[index].hidden) {
                    return;
                  }
                  min = Math.min(value, min);
                  max = Math.max(value, max);
                });
              }
            });
            me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
            me.max = max === Number.NEGATIVE_INFINITY ? 0 : max;
            me.handleTickRangeOptions();
          },
          _computeTickLimit: function() {
            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
          },
          convertTicksToLabels: function() {
            var me = this;
            scale_linearbase.prototype.convertTicksToLabels.call(me);
            me.pointLabels = me.chart.data.labels.map(function() {
              var label = helpers$1.callback(me.options.pointLabels.callback, arguments, me);
              return label || label === 0 ? label : "";
            });
          },
          getLabelForIndex: function(index, datasetIndex) {
            return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
          },
          fit: function() {
            var me = this;
            var opts = me.options;
            if (opts.display && opts.pointLabels.display) {
              fitWithPointLabels(me);
            } else {
              me.setCenterPoint(0, 0, 0, 0);
            }
          },
          setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
            var me = this;
            var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
            var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
            var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
            var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
            radiusReductionLeft = numberOrZero(radiusReductionLeft);
            radiusReductionRight = numberOrZero(radiusReductionRight);
            radiusReductionTop = numberOrZero(radiusReductionTop);
            radiusReductionBottom = numberOrZero(radiusReductionBottom);
            me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
            me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
          },
          setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
            var me = this;
            var maxRight = me.width - rightMovement - me.drawingArea;
            var maxLeft = leftMovement + me.drawingArea;
            var maxTop = topMovement + me.drawingArea;
            var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
            me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
            me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
          },
          getIndexAngle: function(index) {
            var chart = this.chart;
            var angleMultiplier = 360 / chart.data.labels.length;
            var options2 = chart.options || {};
            var startAngle = options2.startAngle || 0;
            var angle = (index * angleMultiplier + startAngle) % 360;
            return (angle < 0 ? angle + 360 : angle) * Math.PI * 2 / 360;
          },
          getDistanceFromCenterForValue: function(value) {
            var me = this;
            if (helpers$1.isNullOrUndef(value)) {
              return NaN;
            }
            var scalingFactor = me.drawingArea / (me.max - me.min);
            if (me.options.ticks.reverse) {
              return (me.max - value) * scalingFactor;
            }
            return (value - me.min) * scalingFactor;
          },
          getPointPosition: function(index, distanceFromCenter) {
            var me = this;
            var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
            return {
              x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
              y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
            };
          },
          getPointPositionForValue: function(index, value) {
            return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
          },
          getBasePosition: function(index) {
            var me = this;
            var min = me.min;
            var max = me.max;
            return me.getPointPositionForValue(index || 0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
          },
          _drawGrid: function() {
            var me = this;
            var ctx = me.ctx;
            var opts = me.options;
            var gridLineOpts = opts.gridLines;
            var angleLineOpts = opts.angleLines;
            var lineWidth = valueOrDefault$c(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
            var lineColor = valueOrDefault$c(angleLineOpts.color, gridLineOpts.color);
            var i, offset, position;
            if (opts.pointLabels.display) {
              drawPointLabels(me);
            }
            if (gridLineOpts.display) {
              helpers$1.each(me.ticks, function(label, index) {
                if (index !== 0) {
                  offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
                  drawRadiusLine(me, gridLineOpts, offset, index);
                }
              });
            }
            if (angleLineOpts.display && lineWidth && lineColor) {
              ctx.save();
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = lineColor;
              if (ctx.setLineDash) {
                ctx.setLineDash(resolve$4([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
                ctx.lineDashOffset = resolve$4([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0]);
              }
              for (i = me.chart.data.labels.length - 1; i >= 0; i--) {
                offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);
                position = me.getPointPosition(i, offset);
                ctx.beginPath();
                ctx.moveTo(me.xCenter, me.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
              }
              ctx.restore();
            }
          },
          _drawLabels: function() {
            var me = this;
            var ctx = me.ctx;
            var opts = me.options;
            var tickOpts = opts.ticks;
            if (!tickOpts.display) {
              return;
            }
            var startAngle = me.getIndexAngle(0);
            var tickFont = helpers$1.options._parseFont(tickOpts);
            var tickFontColor = valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);
            var offset, width;
            ctx.save();
            ctx.font = tickFont.string;
            ctx.translate(me.xCenter, me.yCenter);
            ctx.rotate(startAngle);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            helpers$1.each(me.ticks, function(label, index) {
              if (index === 0 && !tickOpts.reverse) {
                return;
              }
              offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
              if (tickOpts.showLabelBackdrop) {
                width = ctx.measureText(label).width;
                ctx.fillStyle = tickOpts.backdropColor;
                ctx.fillRect(-width / 2 - tickOpts.backdropPaddingX, -offset - tickFont.size / 2 - tickOpts.backdropPaddingY, width + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);
              }
              ctx.fillStyle = tickFontColor;
              ctx.fillText(label, 0, -offset);
            });
            ctx.restore();
          },
          _drawTitle: helpers$1.noop
        });
        var _defaults$3 = defaultConfig$3;
        scale_radialLinear._defaults = _defaults$3;
        var deprecated$1 = helpers$1._deprecated;
        var resolve$5 = helpers$1.options.resolve;
        var valueOrDefault$d = helpers$1.valueOrDefault;
        var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
        var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        var INTERVALS = {
          millisecond: {
            common: true,
            size: 1,
            steps: 1e3
          },
          second: {
            common: true,
            size: 1e3,
            steps: 60
          },
          minute: {
            common: true,
            size: 6e4,
            steps: 60
          },
          hour: {
            common: true,
            size: 36e5,
            steps: 24
          },
          day: {
            common: true,
            size: 864e5,
            steps: 30
          },
          week: {
            common: false,
            size: 6048e5,
            steps: 4
          },
          month: {
            common: true,
            size: 2628e6,
            steps: 12
          },
          quarter: {
            common: false,
            size: 7884e6,
            steps: 4
          },
          year: {
            common: true,
            size: 3154e7
          }
        };
        var UNITS = Object.keys(INTERVALS);
        function sorter(a, b) {
          return a - b;
        }
        function arrayUnique(items) {
          var hash = {};
          var out = [];
          var i, ilen, item;
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            item = items[i];
            if (!hash[item]) {
              hash[item] = true;
              out.push(item);
            }
          }
          return out;
        }
        function getMin(options2) {
          return helpers$1.valueOrDefault(options2.time.min, options2.ticks.min);
        }
        function getMax(options2) {
          return helpers$1.valueOrDefault(options2.time.max, options2.ticks.max);
        }
        function buildLookupTable(timestamps, min, max, distribution) {
          if (distribution === "linear" || !timestamps.length) {
            return [
              { time: min, pos: 0 },
              { time: max, pos: 1 }
            ];
          }
          var table = [];
          var items = [min];
          var i, ilen, prev, curr, next;
          for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
            curr = timestamps[i];
            if (curr > min && curr < max) {
              items.push(curr);
            }
          }
          items.push(max);
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            next = items[i + 1];
            prev = items[i - 1];
            curr = items[i];
            if (prev === void 0 || next === void 0 || Math.round((next + prev) / 2) !== curr) {
              table.push({ time: curr, pos: i / (ilen - 1) });
            }
          }
          return table;
        }
        function lookup(table, key, value) {
          var lo = 0;
          var hi = table.length - 1;
          var mid, i0, i1;
          while (lo >= 0 && lo <= hi) {
            mid = lo + hi >> 1;
            i0 = table[mid - 1] || null;
            i1 = table[mid];
            if (!i0) {
              return { lo: null, hi: i1 };
            } else if (i1[key] < value) {
              lo = mid + 1;
            } else if (i0[key] > value) {
              hi = mid - 1;
            } else {
              return { lo: i0, hi: i1 };
            }
          }
          return { lo: i1, hi: null };
        }
        function interpolate$1(table, skey, sval, tkey) {
          var range = lookup(table, skey, sval);
          var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
          var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
          var span = next[skey] - prev[skey];
          var ratio = span ? (sval - prev[skey]) / span : 0;
          var offset = (next[tkey] - prev[tkey]) * ratio;
          return prev[tkey] + offset;
        }
        function toTimestamp(scale2, input) {
          var adapter = scale2._adapter;
          var options2 = scale2.options.time;
          var parser = options2.parser;
          var format3 = parser || options2.format;
          var value = input;
          if (typeof parser === "function") {
            value = parser(value);
          }
          if (!helpers$1.isFinite(value)) {
            value = typeof format3 === "string" ? adapter.parse(value, format3) : adapter.parse(value);
          }
          if (value !== null) {
            return +value;
          }
          if (!parser && typeof format3 === "function") {
            value = format3(input);
            if (!helpers$1.isFinite(value)) {
              value = adapter.parse(value);
            }
          }
          return value;
        }
        function parse3(scale2, input) {
          if (helpers$1.isNullOrUndef(input)) {
            return null;
          }
          var options2 = scale2.options.time;
          var value = toTimestamp(scale2, scale2.getRightValue(input));
          if (value === null) {
            return value;
          }
          if (options2.round) {
            value = +scale2._adapter.startOf(value, options2.round);
          }
          return value;
        }
        function determineUnitForAutoTicks(minUnit, min, max, capacity) {
          var ilen = UNITS.length;
          var i, interval, factor;
          for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
            interval = INTERVALS[UNITS[i]];
            factor = interval.steps ? interval.steps : MAX_INTEGER;
            if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
              return UNITS[i];
            }
          }
          return UNITS[ilen - 1];
        }
        function determineUnitForFormatting(scale2, numTicks, minUnit, min, max) {
          var i, unit;
          for (i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
            unit = UNITS[i];
            if (INTERVALS[unit].common && scale2._adapter.diff(max, min, unit) >= numTicks - 1) {
              return unit;
            }
          }
          return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
        }
        function determineMajorUnit(unit) {
          for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
            if (INTERVALS[UNITS[i]].common) {
              return UNITS[i];
            }
          }
        }
        function generate(scale2, min, max, capacity) {
          var adapter = scale2._adapter;
          var options2 = scale2.options;
          var timeOpts = options2.time;
          var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
          var stepSize = resolve$5([timeOpts.stepSize, timeOpts.unitStepSize, 1]);
          var weekday = minor === "week" ? timeOpts.isoWeekday : false;
          var first = min;
          var ticks = [];
          var time;
          if (weekday) {
            first = +adapter.startOf(first, "isoWeek", weekday);
          }
          first = +adapter.startOf(first, weekday ? "day" : minor);
          if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
            throw min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor;
          }
          for (time = first; time < max; time = +adapter.add(time, stepSize, minor)) {
            ticks.push(time);
          }
          if (time === max || options2.bounds === "ticks") {
            ticks.push(time);
          }
          return ticks;
        }
        function computeOffsets(table, ticks, min, max, options2) {
          var start = 0;
          var end = 0;
          var first, last;
          if (options2.offset && ticks.length) {
            first = interpolate$1(table, "time", ticks[0], "pos");
            if (ticks.length === 1) {
              start = 1 - first;
            } else {
              start = (interpolate$1(table, "time", ticks[1], "pos") - first) / 2;
            }
            last = interpolate$1(table, "time", ticks[ticks.length - 1], "pos");
            if (ticks.length === 1) {
              end = last;
            } else {
              end = (last - interpolate$1(table, "time", ticks[ticks.length - 2], "pos")) / 2;
            }
          }
          return { start, end, factor: 1 / (start + 1 + end) };
        }
        function setMajorTicks(scale2, ticks, map, majorUnit) {
          var adapter = scale2._adapter;
          var first = +adapter.startOf(ticks[0].value, majorUnit);
          var last = ticks[ticks.length - 1].value;
          var major, index;
          for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
            index = map[major];
            if (index >= 0) {
              ticks[index].major = true;
            }
          }
          return ticks;
        }
        function ticksFromTimestamps(scale2, values, majorUnit) {
          var ticks = [];
          var map = {};
          var ilen = values.length;
          var i, value;
          for (i = 0; i < ilen; ++i) {
            value = values[i];
            map[value] = i;
            ticks.push({
              value,
              major: false
            });
          }
          return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale2, ticks, map, majorUnit);
        }
        var defaultConfig$4 = {
          position: "bottom",
          distribution: "linear",
          bounds: "data",
          adapters: {},
          time: {
            parser: false,
            unit: false,
            round: false,
            displayFormat: false,
            isoWeekday: false,
            minUnit: "millisecond",
            displayFormats: {}
          },
          ticks: {
            autoSkip: false,
            source: "auto",
            major: {
              enabled: false
            }
          }
        };
        var scale_time = core_scale.extend({
          initialize: function() {
            this.mergeTicksOptions();
            core_scale.prototype.initialize.call(this);
          },
          update: function() {
            var me = this;
            var options2 = me.options;
            var time = options2.time || (options2.time = {});
            var adapter = me._adapter = new core_adapters._date(options2.adapters.date);
            deprecated$1("time scale", time.format, "time.format", "time.parser");
            deprecated$1("time scale", time.min, "time.min", "ticks.min");
            deprecated$1("time scale", time.max, "time.max", "ticks.max");
            helpers$1.mergeIf(time.displayFormats, adapter.formats());
            return core_scale.prototype.update.apply(me, arguments);
          },
          getRightValue: function(rawValue) {
            if (rawValue && rawValue.t !== void 0) {
              rawValue = rawValue.t;
            }
            return core_scale.prototype.getRightValue.call(this, rawValue);
          },
          determineDataLimits: function() {
            var me = this;
            var chart = me.chart;
            var adapter = me._adapter;
            var options2 = me.options;
            var unit = options2.time.unit || "day";
            var min = MAX_INTEGER;
            var max = MIN_INTEGER;
            var timestamps = [];
            var datasets = [];
            var labels = [];
            var i, j, ilen, jlen, data2, timestamp, labelsAdded;
            var dataLabels = me._getLabels();
            for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
              labels.push(parse3(me, dataLabels[i]));
            }
            for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
              if (chart.isDatasetVisible(i)) {
                data2 = chart.data.datasets[i].data;
                if (helpers$1.isObject(data2[0])) {
                  datasets[i] = [];
                  for (j = 0, jlen = data2.length; j < jlen; ++j) {
                    timestamp = parse3(me, data2[j]);
                    timestamps.push(timestamp);
                    datasets[i][j] = timestamp;
                  }
                } else {
                  datasets[i] = labels.slice(0);
                  if (!labelsAdded) {
                    timestamps = timestamps.concat(labels);
                    labelsAdded = true;
                  }
                }
              } else {
                datasets[i] = [];
              }
            }
            if (labels.length) {
              min = Math.min(min, labels[0]);
              max = Math.max(max, labels[labels.length - 1]);
            }
            if (timestamps.length) {
              timestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter) : timestamps.sort(sorter);
              min = Math.min(min, timestamps[0]);
              max = Math.max(max, timestamps[timestamps.length - 1]);
            }
            min = parse3(me, getMin(options2)) || min;
            max = parse3(me, getMax(options2)) || max;
            min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
            max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max;
            me.min = Math.min(min, max);
            me.max = Math.max(min + 1, max);
            me._table = [];
            me._timestamps = {
              data: timestamps,
              datasets,
              labels
            };
          },
          buildTicks: function() {
            var me = this;
            var min = me.min;
            var max = me.max;
            var options2 = me.options;
            var tickOpts = options2.ticks;
            var timeOpts = options2.time;
            var timestamps = me._timestamps;
            var ticks = [];
            var capacity = me.getLabelCapacity(min);
            var source = tickOpts.source;
            var distribution = options2.distribution;
            var i, ilen, timestamp;
            if (source === "data" || source === "auto" && distribution === "series") {
              timestamps = timestamps.data;
            } else if (source === "labels") {
              timestamps = timestamps.labels;
            } else {
              timestamps = generate(me, min, max, capacity);
            }
            if (options2.bounds === "ticks" && timestamps.length) {
              min = timestamps[0];
              max = timestamps[timestamps.length - 1];
            }
            min = parse3(me, getMin(options2)) || min;
            max = parse3(me, getMax(options2)) || max;
            for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
              timestamp = timestamps[i];
              if (timestamp >= min && timestamp <= max) {
                ticks.push(timestamp);
              }
            }
            me.min = min;
            me.max = max;
            me._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, capacity) : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));
            me._majorUnit = !tickOpts.major.enabled || me._unit === "year" ? void 0 : determineMajorUnit(me._unit);
            me._table = buildLookupTable(me._timestamps.data, min, max, distribution);
            me._offsets = computeOffsets(me._table, ticks, min, max, options2);
            if (tickOpts.reverse) {
              ticks.reverse();
            }
            return ticksFromTimestamps(me, ticks, me._majorUnit);
          },
          getLabelForIndex: function(index, datasetIndex) {
            var me = this;
            var adapter = me._adapter;
            var data2 = me.chart.data;
            var timeOpts = me.options.time;
            var label = data2.labels && index < data2.labels.length ? data2.labels[index] : "";
            var value = data2.datasets[datasetIndex].data[index];
            if (helpers$1.isObject(value)) {
              label = me.getRightValue(value);
            }
            if (timeOpts.tooltipFormat) {
              return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
            }
            if (typeof label === "string") {
              return label;
            }
            return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
          },
          tickFormatFunction: function(time, index, ticks, format3) {
            var me = this;
            var adapter = me._adapter;
            var options2 = me.options;
            var formats = options2.time.displayFormats;
            var minorFormat = formats[me._unit];
            var majorUnit = me._majorUnit;
            var majorFormat = formats[majorUnit];
            var tick = ticks[index];
            var tickOpts = options2.ticks;
            var major = majorUnit && majorFormat && tick && tick.major;
            var label = adapter.format(time, format3 ? format3 : major ? majorFormat : minorFormat);
            var nestedTickOpts = major ? tickOpts.major : tickOpts.minor;
            var formatter = resolve$5([
              nestedTickOpts.callback,
              nestedTickOpts.userCallback,
              tickOpts.callback,
              tickOpts.userCallback
            ]);
            return formatter ? formatter(label, index, ticks) : label;
          },
          convertTicksToLabels: function(ticks) {
            var labels = [];
            var i, ilen;
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
            }
            return labels;
          },
          getPixelForOffset: function(time) {
            var me = this;
            var offsets = me._offsets;
            var pos = interpolate$1(me._table, "time", time, "pos");
            return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);
          },
          getPixelForValue: function(value, index, datasetIndex) {
            var me = this;
            var time = null;
            if (index !== void 0 && datasetIndex !== void 0) {
              time = me._timestamps.datasets[datasetIndex][index];
            }
            if (time === null) {
              time = parse3(me, value);
            }
            if (time !== null) {
              return me.getPixelForOffset(time);
            }
          },
          getPixelForTick: function(index) {
            var ticks = this.getTicks();
            return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
          },
          getValueForPixel: function(pixel) {
            var me = this;
            var offsets = me._offsets;
            var pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            var time = interpolate$1(me._table, "pos", pos, "time");
            return me._adapter._create(time);
          },
          _getLabelSize: function(label) {
            var me = this;
            var ticksOpts = me.options.ticks;
            var tickLabelWidth = me.ctx.measureText(label).width;
            var angle = helpers$1.toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
            var cosRotation = Math.cos(angle);
            var sinRotation = Math.sin(angle);
            var tickFontSize = valueOrDefault$d(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
            return {
              w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
              h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
            };
          },
          getLabelWidth: function(label) {
            return this._getLabelSize(label).w;
          },
          getLabelCapacity: function(exampleTime) {
            var me = this;
            var timeOpts = me.options.time;
            var displayFormats = timeOpts.displayFormats;
            var format3 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
            var exampleLabel = me.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format3);
            var size = me._getLabelSize(exampleLabel);
            var capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h);
            if (me.options.offset) {
              capacity--;
            }
            return capacity > 0 ? capacity : 1;
          }
        });
        var _defaults$4 = defaultConfig$4;
        scale_time._defaults = _defaults$4;
        var scales = {
          category: scale_category,
          linear: scale_linear,
          logarithmic: scale_logarithmic,
          radialLinear: scale_radialLinear,
          time: scale_time
        };
        var FORMATS = {
          datetime: "MMM D, YYYY, h:mm:ss a",
          millisecond: "h:mm:ss.SSS a",
          second: "h:mm:ss a",
          minute: "h:mm a",
          hour: "hA",
          day: "MMM D",
          week: "ll",
          month: "MMM YYYY",
          quarter: "[Q]Q - YYYY",
          year: "YYYY"
        };
        core_adapters._date.override(typeof moment5 === "function" ? {
          _id: "moment",
          formats: function() {
            return FORMATS;
          },
          parse: function(value, format3) {
            if (typeof value === "string" && typeof format3 === "string") {
              value = moment5(value, format3);
            } else if (!(value instanceof moment5)) {
              value = moment5(value);
            }
            return value.isValid() ? value.valueOf() : null;
          },
          format: function(time, format3) {
            return moment5(time).format(format3);
          },
          add: function(time, amount, unit) {
            return moment5(time).add(amount, unit).valueOf();
          },
          diff: function(max, min, unit) {
            return moment5(max).diff(moment5(min), unit);
          },
          startOf: function(time, unit, weekday) {
            time = moment5(time);
            if (unit === "isoWeek") {
              return time.isoWeekday(weekday).valueOf();
            }
            return time.startOf(unit).valueOf();
          },
          endOf: function(time, unit) {
            return moment5(time).endOf(unit).valueOf();
          },
          _create: function(time) {
            return moment5(time);
          }
        } : {});
        core_defaults._set("global", {
          plugins: {
            filler: {
              propagate: true
            }
          }
        });
        var mappers = {
          dataset: function(source) {
            var index = source.fill;
            var chart = source.chart;
            var meta = chart.getDatasetMeta(index);
            var visible = meta && chart.isDatasetVisible(index);
            var points = visible && meta.dataset._children || [];
            var length = points.length || 0;
            return !length ? null : function(point, i) {
              return i < length && points[i]._view || null;
            };
          },
          boundary: function(source) {
            var boundary = source.boundary;
            var x = boundary ? boundary.x : null;
            var y = boundary ? boundary.y : null;
            if (helpers$1.isArray(boundary)) {
              return function(point, i) {
                return boundary[i];
              };
            }
            return function(point) {
              return {
                x: x === null ? point.x : x,
                y: y === null ? point.y : y
              };
            };
          }
        };
        function decodeFill(el, index, count) {
          var model = el._model || {};
          var fill = model.fill;
          var target;
          if (fill === void 0) {
            fill = !!model.backgroundColor;
          }
          if (fill === false || fill === null) {
            return false;
          }
          if (fill === true) {
            return "origin";
          }
          target = parseFloat(fill, 10);
          if (isFinite(target) && Math.floor(target) === target) {
            if (fill[0] === "-" || fill[0] === "+") {
              target = index + target;
            }
            if (target === index || target < 0 || target >= count) {
              return false;
            }
            return target;
          }
          switch (fill) {
            case "bottom":
              return "start";
            case "top":
              return "end";
            case "zero":
              return "origin";
            case "origin":
            case "start":
            case "end":
              return fill;
            default:
              return false;
          }
        }
        function computeLinearBoundary(source) {
          var model = source.el._model || {};
          var scale2 = source.el._scale || {};
          var fill = source.fill;
          var target = null;
          var horizontal;
          if (isFinite(fill)) {
            return null;
          }
          if (fill === "start") {
            target = model.scaleBottom === void 0 ? scale2.bottom : model.scaleBottom;
          } else if (fill === "end") {
            target = model.scaleTop === void 0 ? scale2.top : model.scaleTop;
          } else if (model.scaleZero !== void 0) {
            target = model.scaleZero;
          } else if (scale2.getBasePixel) {
            target = scale2.getBasePixel();
          }
          if (target !== void 0 && target !== null) {
            if (target.x !== void 0 && target.y !== void 0) {
              return target;
            }
            if (helpers$1.isFinite(target)) {
              horizontal = scale2.isHorizontal();
              return {
                x: horizontal ? target : null,
                y: horizontal ? null : target
              };
            }
          }
          return null;
        }
        function computeCircularBoundary(source) {
          var scale2 = source.el._scale;
          var options2 = scale2.options;
          var length = scale2.chart.data.labels.length;
          var fill = source.fill;
          var target = [];
          var start, end, center, i, point;
          if (!length) {
            return null;
          }
          start = options2.ticks.reverse ? scale2.max : scale2.min;
          end = options2.ticks.reverse ? scale2.min : scale2.max;
          center = scale2.getPointPositionForValue(0, start);
          for (i = 0; i < length; ++i) {
            point = fill === "start" || fill === "end" ? scale2.getPointPositionForValue(i, fill === "start" ? start : end) : scale2.getBasePosition(i);
            if (options2.gridLines.circular) {
              point.cx = center.x;
              point.cy = center.y;
              point.angle = scale2.getIndexAngle(i) - Math.PI / 2;
            }
            target.push(point);
          }
          return target;
        }
        function computeBoundary(source) {
          var scale2 = source.el._scale || {};
          if (scale2.getPointPositionForValue) {
            return computeCircularBoundary(source);
          }
          return computeLinearBoundary(source);
        }
        function resolveTarget(sources, index, propagate) {
          var source = sources[index];
          var fill = source.fill;
          var visited = [index];
          var target;
          if (!propagate) {
            return fill;
          }
          while (fill !== false && visited.indexOf(fill) === -1) {
            if (!isFinite(fill)) {
              return fill;
            }
            target = sources[fill];
            if (!target) {
              return false;
            }
            if (target.visible) {
              return fill;
            }
            visited.push(fill);
            fill = target.fill;
          }
          return false;
        }
        function createMapper(source) {
          var fill = source.fill;
          var type = "dataset";
          if (fill === false) {
            return null;
          }
          if (!isFinite(fill)) {
            type = "boundary";
          }
          return mappers[type](source);
        }
        function isDrawable(point) {
          return point && !point.skip;
        }
        function drawArea(ctx, curve0, curve1, len0, len1) {
          var i, cx, cy, r;
          if (!len0 || !len1) {
            return;
          }
          ctx.moveTo(curve0[0].x, curve0[0].y);
          for (i = 1; i < len0; ++i) {
            helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
          }
          if (curve1[0].angle !== void 0) {
            cx = curve1[0].cx;
            cy = curve1[0].cy;
            r = Math.sqrt(Math.pow(curve1[0].x - cx, 2) + Math.pow(curve1[0].y - cy, 2));
            for (i = len1 - 1; i > 0; --i) {
              ctx.arc(cx, cy, r, curve1[i].angle, curve1[i - 1].angle, true);
            }
            return;
          }
          ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);
          for (i = len1 - 1; i > 0; --i) {
            helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
          }
        }
        function doFill(ctx, points, mapper, view, color, loop) {
          var count = points.length;
          var span = view.spanGaps;
          var curve0 = [];
          var curve1 = [];
          var len0 = 0;
          var len1 = 0;
          var i, ilen, index, p0, p1, d0, d1, loopOffset;
          ctx.beginPath();
          for (i = 0, ilen = count; i < ilen; ++i) {
            index = i % count;
            p0 = points[index]._view;
            p1 = mapper(p0, index, view);
            d0 = isDrawable(p0);
            d1 = isDrawable(p1);
            if (loop && loopOffset === void 0 && d0) {
              loopOffset = i + 1;
              ilen = count + loopOffset;
            }
            if (d0 && d1) {
              len0 = curve0.push(p0);
              len1 = curve1.push(p1);
            } else if (len0 && len1) {
              if (!span) {
                drawArea(ctx, curve0, curve1, len0, len1);
                len0 = len1 = 0;
                curve0 = [];
                curve1 = [];
              } else {
                if (d0) {
                  curve0.push(p0);
                }
                if (d1) {
                  curve1.push(p1);
                }
              }
            }
          }
          drawArea(ctx, curve0, curve1, len0, len1);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
        }
        var plugin_filler = {
          id: "filler",
          afterDatasetsUpdate: function(chart, options2) {
            var count = (chart.data.datasets || []).length;
            var propagate = options2.propagate;
            var sources = [];
            var meta, i, el, source;
            for (i = 0; i < count; ++i) {
              meta = chart.getDatasetMeta(i);
              el = meta.dataset;
              source = null;
              if (el && el._model && el instanceof elements.Line) {
                source = {
                  visible: chart.isDatasetVisible(i),
                  fill: decodeFill(el, i, count),
                  chart,
                  el
                };
              }
              meta.$filler = source;
              sources.push(source);
            }
            for (i = 0; i < count; ++i) {
              source = sources[i];
              if (!source) {
                continue;
              }
              source.fill = resolveTarget(sources, i, propagate);
              source.boundary = computeBoundary(source);
              source.mapper = createMapper(source);
            }
          },
          beforeDatasetsDraw: function(chart) {
            var metasets = chart._getSortedVisibleDatasetMetas();
            var ctx = chart.ctx;
            var meta, i, el, view, points, mapper, color;
            for (i = metasets.length - 1; i >= 0; --i) {
              meta = metasets[i].$filler;
              if (!meta || !meta.visible) {
                continue;
              }
              el = meta.el;
              view = el._view;
              points = el._children || [];
              mapper = meta.mapper;
              color = view.backgroundColor || core_defaults.global.defaultColor;
              if (mapper && color && points.length) {
                helpers$1.canvas.clipArea(ctx, chart.chartArea);
                doFill(ctx, points, mapper, view, color, el._loop);
                helpers$1.canvas.unclipArea(ctx);
              }
            }
          }
        };
        var getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;
        var noop$1 = helpers$1.noop;
        var valueOrDefault$e = helpers$1.valueOrDefault;
        core_defaults._set("global", {
          legend: {
            display: true,
            position: "top",
            align: "center",
            fullWidth: true,
            reverse: false,
            weight: 1e3,
            onClick: function(e, legendItem) {
              var index = legendItem.datasetIndex;
              var ci = this.chart;
              var meta = ci.getDatasetMeta(index);
              meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;
              ci.update();
            },
            onHover: null,
            onLeave: null,
            labels: {
              boxWidth: 40,
              padding: 10,
              generateLabels: function(chart) {
                var datasets = chart.data.datasets;
                var options2 = chart.options.legend || {};
                var usePointStyle = options2.labels && options2.labels.usePointStyle;
                return chart._getSortedDatasetMetas().map(function(meta) {
                  var style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                  return {
                    text: datasets[meta.index].label,
                    fillStyle: style.backgroundColor,
                    hidden: !chart.isDatasetVisible(meta.index),
                    lineCap: style.borderCapStyle,
                    lineDash: style.borderDash,
                    lineDashOffset: style.borderDashOffset,
                    lineJoin: style.borderJoinStyle,
                    lineWidth: style.borderWidth,
                    strokeStyle: style.borderColor,
                    pointStyle: style.pointStyle,
                    rotation: style.rotation,
                    datasetIndex: meta.index
                  };
                }, this);
              }
            }
          },
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var datasets = chart.data.datasets;
            var i, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            for (i = 0, ilen = datasets.length; i < ilen; i++) {
              listItem = list.appendChild(document.createElement("li"));
              listItemSpan = listItem.appendChild(document.createElement("span"));
              listItemSpan.style.backgroundColor = datasets[i].backgroundColor;
              if (datasets[i].label) {
                listItem.appendChild(document.createTextNode(datasets[i].label));
              }
            }
            return list.outerHTML;
          }
        });
        function getBoxWidth(labelOpts, fontSize) {
          return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
        }
        var Legend = core_element.extend({
          initialize: function(config) {
            var me = this;
            helpers$1.extend(me, config);
            me.legendHitBoxes = [];
            me._hoveredItem = null;
            me.doughnutMode = false;
          },
          beforeUpdate: noop$1,
          update: function(maxWidth, maxHeight, margins) {
            var me = this;
            me.beforeUpdate();
            me.maxWidth = maxWidth;
            me.maxHeight = maxHeight;
            me.margins = margins;
            me.beforeSetDimensions();
            me.setDimensions();
            me.afterSetDimensions();
            me.beforeBuildLabels();
            me.buildLabels();
            me.afterBuildLabels();
            me.beforeFit();
            me.fit();
            me.afterFit();
            me.afterUpdate();
            return me.minSize;
          },
          afterUpdate: noop$1,
          beforeSetDimensions: noop$1,
          setDimensions: function() {
            var me = this;
            if (me.isHorizontal()) {
              me.width = me.maxWidth;
              me.left = 0;
              me.right = me.width;
            } else {
              me.height = me.maxHeight;
              me.top = 0;
              me.bottom = me.height;
            }
            me.paddingLeft = 0;
            me.paddingTop = 0;
            me.paddingRight = 0;
            me.paddingBottom = 0;
            me.minSize = {
              width: 0,
              height: 0
            };
          },
          afterSetDimensions: noop$1,
          beforeBuildLabels: noop$1,
          buildLabels: function() {
            var me = this;
            var labelOpts = me.options.labels || {};
            var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];
            if (labelOpts.filter) {
              legendItems = legendItems.filter(function(item) {
                return labelOpts.filter(item, me.chart.data);
              });
            }
            if (me.options.reverse) {
              legendItems.reverse();
            }
            me.legendItems = legendItems;
          },
          afterBuildLabels: noop$1,
          beforeFit: noop$1,
          fit: function() {
            var me = this;
            var opts = me.options;
            var labelOpts = opts.labels;
            var display = opts.display;
            var ctx = me.ctx;
            var labelFont = helpers$1.options._parseFont(labelOpts);
            var fontSize = labelFont.size;
            var hitboxes = me.legendHitBoxes = [];
            var minSize = me.minSize;
            var isHorizontal = me.isHorizontal();
            if (isHorizontal) {
              minSize.width = me.maxWidth;
              minSize.height = display ? 10 : 0;
            } else {
              minSize.width = display ? 10 : 0;
              minSize.height = me.maxHeight;
            }
            if (!display) {
              me.width = minSize.width = me.height = minSize.height = 0;
              return;
            }
            ctx.font = labelFont.string;
            if (isHorizontal) {
              var lineWidths = me.lineWidths = [0];
              var totalHeight = 0;
              ctx.textAlign = "left";
              ctx.textBaseline = "middle";
              helpers$1.each(me.legendItems, function(legendItem, i) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                if (i === 0 || lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {
                  totalHeight += fontSize + labelOpts.padding;
                  lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                }
                hitboxes[i] = {
                  left: 0,
                  top: 0,
                  width,
                  height: fontSize
                };
                lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
              });
              minSize.height += totalHeight;
            } else {
              var vPadding = labelOpts.padding;
              var columnWidths = me.columnWidths = [];
              var columnHeights = me.columnHeights = [];
              var totalWidth = labelOpts.padding;
              var currentColWidth = 0;
              var currentColHeight = 0;
              helpers$1.each(me.legendItems, function(legendItem, i) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                if (i > 0 && currentColHeight + fontSize + 2 * vPadding > minSize.height) {
                  totalWidth += currentColWidth + labelOpts.padding;
                  columnWidths.push(currentColWidth);
                  columnHeights.push(currentColHeight);
                  currentColWidth = 0;
                  currentColHeight = 0;
                }
                currentColWidth = Math.max(currentColWidth, itemWidth);
                currentColHeight += fontSize + vPadding;
                hitboxes[i] = {
                  left: 0,
                  top: 0,
                  width: itemWidth,
                  height: fontSize
                };
              });
              totalWidth += currentColWidth;
              columnWidths.push(currentColWidth);
              columnHeights.push(currentColHeight);
              minSize.width += totalWidth;
            }
            me.width = minSize.width;
            me.height = minSize.height;
          },
          afterFit: noop$1,
          isHorizontal: function() {
            return this.options.position === "top" || this.options.position === "bottom";
          },
          draw: function() {
            var me = this;
            var opts = me.options;
            var labelOpts = opts.labels;
            var globalDefaults = core_defaults.global;
            var defaultColor2 = globalDefaults.defaultColor;
            var lineDefault = globalDefaults.elements.line;
            var legendHeight = me.height;
            var columnHeights = me.columnHeights;
            var legendWidth = me.width;
            var lineWidths = me.lineWidths;
            if (!opts.display) {
              return;
            }
            var rtlHelper = getRtlHelper$1(opts.rtl, me.left, me.minSize.width);
            var ctx = me.ctx;
            var fontColor = valueOrDefault$e(labelOpts.fontColor, globalDefaults.defaultFontColor);
            var labelFont = helpers$1.options._parseFont(labelOpts);
            var fontSize = labelFont.size;
            var cursor;
            ctx.textAlign = rtlHelper.textAlign("left");
            ctx.textBaseline = "middle";
            ctx.lineWidth = 0.5;
            ctx.strokeStyle = fontColor;
            ctx.fillStyle = fontColor;
            ctx.font = labelFont.string;
            var boxWidth = getBoxWidth(labelOpts, fontSize);
            var hitboxes = me.legendHitBoxes;
            var drawLegendBox = function(x, y, legendItem) {
              if (isNaN(boxWidth) || boxWidth <= 0) {
                return;
              }
              ctx.save();
              var lineWidth = valueOrDefault$e(legendItem.lineWidth, lineDefault.borderWidth);
              ctx.fillStyle = valueOrDefault$e(legendItem.fillStyle, defaultColor2);
              ctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);
              ctx.lineDashOffset = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);
              ctx.lineJoin = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle, defaultColor2);
              if (ctx.setLineDash) {
                ctx.setLineDash(valueOrDefault$e(legendItem.lineDash, lineDefault.borderDash));
              }
              if (labelOpts && labelOpts.usePointStyle) {
                var radius = boxWidth * Math.SQRT2 / 2;
                var centerX = rtlHelper.xPlus(x, boxWidth / 2);
                var centerY = y + fontSize / 2;
                helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);
              } else {
                ctx.fillRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
                if (lineWidth !== 0) {
                  ctx.strokeRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
                }
              }
              ctx.restore();
            };
            var fillText2 = function(x, y, legendItem, textWidth) {
              var halfFontSize = fontSize / 2;
              var xLeft = rtlHelper.xPlus(x, boxWidth + halfFontSize);
              var yMiddle = y + halfFontSize;
              ctx.fillText(legendItem.text, xLeft, yMiddle);
              if (legendItem.hidden) {
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.moveTo(xLeft, yMiddle);
                ctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);
                ctx.stroke();
              }
            };
            var alignmentOffset = function(dimension, blockSize) {
              switch (opts.align) {
                case "start":
                  return labelOpts.padding;
                case "end":
                  return dimension - blockSize;
                default:
                  return (dimension - blockSize + labelOpts.padding) / 2;
              }
            };
            var isHorizontal = me.isHorizontal();
            if (isHorizontal) {
              cursor = {
                x: me.left + alignmentOffset(legendWidth, lineWidths[0]),
                y: me.top + labelOpts.padding,
                line: 0
              };
            } else {
              cursor = {
                x: me.left + labelOpts.padding,
                y: me.top + alignmentOffset(legendHeight, columnHeights[0]),
                line: 0
              };
            }
            helpers$1.rtl.overrideTextDirection(me.ctx, opts.textDirection);
            var itemHeight = fontSize + labelOpts.padding;
            helpers$1.each(me.legendItems, function(legendItem, i) {
              var textWidth = ctx.measureText(legendItem.text).width;
              var width = boxWidth + fontSize / 2 + textWidth;
              var x = cursor.x;
              var y = cursor.y;
              rtlHelper.setWidth(me.minSize.width);
              if (isHorizontal) {
                if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
                  y = cursor.y += itemHeight;
                  cursor.line++;
                  x = cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);
                }
              } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
                x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
                cursor.line++;
                y = cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);
              }
              var realX = rtlHelper.x(x);
              drawLegendBox(realX, y, legendItem);
              hitboxes[i].left = rtlHelper.leftForLtr(realX, hitboxes[i].width);
              hitboxes[i].top = y;
              fillText2(realX, y, legendItem, textWidth);
              if (isHorizontal) {
                cursor.x += width + labelOpts.padding;
              } else {
                cursor.y += itemHeight;
              }
            });
            helpers$1.rtl.restoreTextDirection(me.ctx, opts.textDirection);
          },
          _getLegendItemAt: function(x, y) {
            var me = this;
            var i, hitBox, lh;
            if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
              lh = me.legendHitBoxes;
              for (i = 0; i < lh.length; ++i) {
                hitBox = lh[i];
                if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
                  return me.legendItems[i];
                }
              }
            }
            return null;
          },
          handleEvent: function(e) {
            var me = this;
            var opts = me.options;
            var type = e.type === "mouseup" ? "click" : e.type;
            var hoveredItem;
            if (type === "mousemove") {
              if (!opts.onHover && !opts.onLeave) {
                return;
              }
            } else if (type === "click") {
              if (!opts.onClick) {
                return;
              }
            } else {
              return;
            }
            hoveredItem = me._getLegendItemAt(e.x, e.y);
            if (type === "click") {
              if (hoveredItem && opts.onClick) {
                opts.onClick.call(me, e.native, hoveredItem);
              }
            } else {
              if (opts.onLeave && hoveredItem !== me._hoveredItem) {
                if (me._hoveredItem) {
                  opts.onLeave.call(me, e.native, me._hoveredItem);
                }
                me._hoveredItem = hoveredItem;
              }
              if (opts.onHover && hoveredItem) {
                opts.onHover.call(me, e.native, hoveredItem);
              }
            }
          }
        });
        function createNewLegendAndAttach(chart, legendOpts) {
          var legend2 = new Legend({
            ctx: chart.ctx,
            options: legendOpts,
            chart
          });
          core_layouts.configure(chart, legend2, legendOpts);
          core_layouts.addBox(chart, legend2);
          chart.legend = legend2;
        }
        var plugin_legend = {
          id: "legend",
          _element: Legend,
          beforeInit: function(chart) {
            var legendOpts = chart.options.legend;
            if (legendOpts) {
              createNewLegendAndAttach(chart, legendOpts);
            }
          },
          beforeUpdate: function(chart) {
            var legendOpts = chart.options.legend;
            var legend2 = chart.legend;
            if (legendOpts) {
              helpers$1.mergeIf(legendOpts, core_defaults.global.legend);
              if (legend2) {
                core_layouts.configure(chart, legend2, legendOpts);
                legend2.options = legendOpts;
              } else {
                createNewLegendAndAttach(chart, legendOpts);
              }
            } else if (legend2) {
              core_layouts.removeBox(chart, legend2);
              delete chart.legend;
            }
          },
          afterEvent: function(chart, e) {
            var legend2 = chart.legend;
            if (legend2) {
              legend2.handleEvent(e);
            }
          }
        };
        var noop$2 = helpers$1.noop;
        core_defaults._set("global", {
          title: {
            display: false,
            fontStyle: "bold",
            fullWidth: true,
            padding: 10,
            position: "top",
            text: "",
            weight: 2e3
          }
        });
        var Title = core_element.extend({
          initialize: function(config) {
            var me = this;
            helpers$1.extend(me, config);
            me.legendHitBoxes = [];
          },
          beforeUpdate: noop$2,
          update: function(maxWidth, maxHeight, margins) {
            var me = this;
            me.beforeUpdate();
            me.maxWidth = maxWidth;
            me.maxHeight = maxHeight;
            me.margins = margins;
            me.beforeSetDimensions();
            me.setDimensions();
            me.afterSetDimensions();
            me.beforeBuildLabels();
            me.buildLabels();
            me.afterBuildLabels();
            me.beforeFit();
            me.fit();
            me.afterFit();
            me.afterUpdate();
            return me.minSize;
          },
          afterUpdate: noop$2,
          beforeSetDimensions: noop$2,
          setDimensions: function() {
            var me = this;
            if (me.isHorizontal()) {
              me.width = me.maxWidth;
              me.left = 0;
              me.right = me.width;
            } else {
              me.height = me.maxHeight;
              me.top = 0;
              me.bottom = me.height;
            }
            me.paddingLeft = 0;
            me.paddingTop = 0;
            me.paddingRight = 0;
            me.paddingBottom = 0;
            me.minSize = {
              width: 0,
              height: 0
            };
          },
          afterSetDimensions: noop$2,
          beforeBuildLabels: noop$2,
          buildLabels: noop$2,
          afterBuildLabels: noop$2,
          beforeFit: noop$2,
          fit: function() {
            var me = this;
            var opts = me.options;
            var minSize = me.minSize = {};
            var isHorizontal = me.isHorizontal();
            var lineCount, textSize;
            if (!opts.display) {
              me.width = minSize.width = me.height = minSize.height = 0;
              return;
            }
            lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;
            textSize = lineCount * helpers$1.options._parseFont(opts).lineHeight + opts.padding * 2;
            me.width = minSize.width = isHorizontal ? me.maxWidth : textSize;
            me.height = minSize.height = isHorizontal ? textSize : me.maxHeight;
          },
          afterFit: noop$2,
          isHorizontal: function() {
            var pos = this.options.position;
            return pos === "top" || pos === "bottom";
          },
          draw: function() {
            var me = this;
            var ctx = me.ctx;
            var opts = me.options;
            if (!opts.display) {
              return;
            }
            var fontOpts = helpers$1.options._parseFont(opts);
            var lineHeight = fontOpts.lineHeight;
            var offset = lineHeight / 2 + opts.padding;
            var rotation = 0;
            var top = me.top;
            var left = me.left;
            var bottom = me.bottom;
            var right = me.right;
            var maxWidth, titleX, titleY;
            ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor);
            ctx.font = fontOpts.string;
            if (me.isHorizontal()) {
              titleX = left + (right - left) / 2;
              titleY = top + offset;
              maxWidth = right - left;
            } else {
              titleX = opts.position === "left" ? left + offset : right - offset;
              titleY = top + (bottom - top) / 2;
              maxWidth = bottom - top;
              rotation = Math.PI * (opts.position === "left" ? -0.5 : 0.5);
            }
            ctx.save();
            ctx.translate(titleX, titleY);
            ctx.rotate(rotation);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            var text = opts.text;
            if (helpers$1.isArray(text)) {
              var y = 0;
              for (var i = 0; i < text.length; ++i) {
                ctx.fillText(text[i], 0, y, maxWidth);
                y += lineHeight;
              }
            } else {
              ctx.fillText(text, 0, 0, maxWidth);
            }
            ctx.restore();
          }
        });
        function createNewTitleBlockAndAttach(chart, titleOpts) {
          var title2 = new Title({
            ctx: chart.ctx,
            options: titleOpts,
            chart
          });
          core_layouts.configure(chart, title2, titleOpts);
          core_layouts.addBox(chart, title2);
          chart.titleBlock = title2;
        }
        var plugin_title = {
          id: "title",
          _element: Title,
          beforeInit: function(chart) {
            var titleOpts = chart.options.title;
            if (titleOpts) {
              createNewTitleBlockAndAttach(chart, titleOpts);
            }
          },
          beforeUpdate: function(chart) {
            var titleOpts = chart.options.title;
            var titleBlock = chart.titleBlock;
            if (titleOpts) {
              helpers$1.mergeIf(titleOpts, core_defaults.global.title);
              if (titleBlock) {
                core_layouts.configure(chart, titleBlock, titleOpts);
                titleBlock.options = titleOpts;
              } else {
                createNewTitleBlockAndAttach(chart, titleOpts);
              }
            } else if (titleBlock) {
              core_layouts.removeBox(chart, titleBlock);
              delete chart.titleBlock;
            }
          }
        };
        var plugins = {};
        var filler = plugin_filler;
        var legend = plugin_legend;
        var title = plugin_title;
        plugins.filler = filler;
        plugins.legend = legend;
        plugins.title = title;
        core_controller.helpers = helpers$1;
        core_helpers();
        core_controller._adapters = core_adapters;
        core_controller.Animation = core_animation;
        core_controller.animationService = core_animations;
        core_controller.controllers = controllers;
        core_controller.DatasetController = core_datasetController;
        core_controller.defaults = core_defaults;
        core_controller.Element = core_element;
        core_controller.elements = elements;
        core_controller.Interaction = core_interaction;
        core_controller.layouts = core_layouts;
        core_controller.platform = platform;
        core_controller.plugins = core_plugins;
        core_controller.Scale = core_scale;
        core_controller.scaleService = core_scaleService;
        core_controller.Ticks = core_ticks;
        core_controller.Tooltip = core_tooltip;
        core_controller.helpers.each(scales, function(scale2, type) {
          core_controller.scaleService.registerScaleType(type, scale2, scale2._defaults);
        });
        for (var k in plugins) {
          if (plugins.hasOwnProperty(k)) {
            core_controller.plugins.register(plugins[k]);
          }
        }
        core_controller.platform.initialize();
        var src = core_controller;
        if (typeof window !== "undefined") {
          window.Chart = core_controller;
        }
        core_controller.Chart = core_controller;
        core_controller.Legend = plugins.legend._element;
        core_controller.Title = plugins.title._element;
        core_controller.pluginService = core_controller.plugins;
        core_controller.PluginBase = core_controller.Element.extend({});
        core_controller.canvasHelpers = core_controller.helpers.canvas;
        core_controller.layoutService = core_controller.layouts;
        core_controller.LinearScaleBase = scale_linearbase;
        core_controller.helpers.each([
          "Bar",
          "Bubble",
          "Doughnut",
          "Line",
          "PolarArea",
          "Radar",
          "Scatter"
        ], function(klass) {
          core_controller[klass] = function(ctx, cfg) {
            return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
              type: klass.charAt(0).toLowerCase() + klass.slice(1)
            }));
          };
        });
        return src;
      });
    }
  });

  // node_modules/vue-chartjs/es/BaseCharts.js
  function generateChart(chartId, chartType) {
    return {
      render: function render2(createElement3) {
        return createElement3("div", {
          style: this.styles,
          class: this.cssClasses
        }, [createElement3("canvas", {
          attrs: {
            id: this.chartId,
            width: this.width,
            height: this.height
          },
          ref: "canvas"
        })]);
      },
      props: {
        chartId: {
          default: chartId,
          type: String
        },
        width: {
          default: 400,
          type: Number
        },
        height: {
          default: 400,
          type: Number
        },
        cssClasses: {
          type: String,
          default: ""
        },
        styles: {
          type: Object
        },
        plugins: {
          type: Array,
          default: function _default2() {
            return [];
          }
        }
      },
      data: function data2() {
        return {
          _chart: null,
          _plugins: this.plugins
        };
      },
      methods: {
        addPlugin: function addPlugin(plugin) {
          this.$data._plugins.push(plugin);
        },
        generateLegend: function generateLegend() {
          if (this.$data._chart) {
            return this.$data._chart.generateLegend();
          }
        },
        renderChart: function renderChart(data2, options) {
          if (this.$data._chart)
            this.$data._chart.destroy();
          if (!this.$refs.canvas)
            throw new Error("Please remove the <template></template> tags from your chart component. See https://vue-chartjs.org/guide/#vue-single-file-components");
          this.$data._chart = new import_chart.default(this.$refs.canvas.getContext("2d"), {
            type: chartType,
            data: data2,
            options,
            plugins: this.$data._plugins
          });
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (this.$data._chart) {
          this.$data._chart.destroy();
        }
      }
    };
  }
  var import_chart, Bar, HorizontalBar, Doughnut, Line, Pie, PolarArea, Radar, Bubble, Scatter;
  var init_BaseCharts = __esm({
    "node_modules/vue-chartjs/es/BaseCharts.js"() {
      import_chart = __toESM(require_Chart());
      Bar = generateChart("bar-chart", "bar");
      HorizontalBar = generateChart("horizontalbar-chart", "horizontalBar");
      Doughnut = generateChart("doughnut-chart", "doughnut");
      Line = generateChart("line-chart", "line");
      Pie = generateChart("pie-chart", "pie");
      PolarArea = generateChart("polar-chart", "polarArea");
      Radar = generateChart("radar-chart", "radar");
      Bubble = generateChart("bubble-chart", "bubble");
      Scatter = generateChart("scatter-chart", "scatter");
    }
  });

  // node_modules/vue-chartjs/es/index.js
  var init_es = __esm({
    "node_modules/vue-chartjs/es/index.js"() {
      init_mixins();
      init_BaseCharts();
    }
  });

  // resource/js/components/sales/charts/LineChart.vue
  function __vue_normalize__13(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\sales\\charts\\LineChart.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var __vue_script__14, __vue_inject_styles__14, __vue_scope_id__14, __vue_module_identifier__14, __vue_is_functional_template__14, __vue_component__13, LineChart_default;
  var init_LineChart = __esm({
    "resource/js/components/sales/charts/LineChart.vue"() {
      init_es();
      __vue_script__14 = {
        extends: Line,
        mixins: [mixins_default.reactiveProp],
        mounted() {
          this.renderChart(this.chartData, this.options);
        }
      };
      __vue_inject_styles__14 = void 0;
      __vue_scope_id__14 = void 0;
      __vue_module_identifier__14 = void 0;
      __vue_is_functional_template__14 = void 0;
      __vue_component__13 = /* @__PURE__ */ __vue_normalize__13({}, __vue_inject_styles__14, __vue_script__14, __vue_scope_id__14, __vue_is_functional_template__14, __vue_module_identifier__14, false, void 0, void 0, void 0);
      LineChart_default = __vue_component__13;
    }
  });

  // resource/js/components/sales/charts/ChartLineSale.vue
  var ChartLineSale_exports = {};
  __export(ChartLineSale_exports, {
    default: () => ChartLineSale_default
  });
  function __vue_normalize__14(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\sales\\charts\\ChartLineSale.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (true) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  function __vue_create_injector__4() {
    const styles = __vue_create_injector__4.styles || (__vue_create_injector__4.styles = {});
    const isOldIE = typeof navigator !== "undefined" && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
    return function addStyle(id, css) {
      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]'))
        return;
      const group = isOldIE ? css.media || "default" : id;
      const style = styles[group] || (styles[group] = { ids: [], parts: [], element: void 0 });
      if (!style.ids.includes(id)) {
        let code = css.source;
        let index = style.ids.length;
        style.ids.push(id);
        if (false) {
          code += "\n/*# sourceURL=" + css.map.sources[0] + " */";
          code += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + " */";
        }
        if (isOldIE) {
          style.element = style.element || document.querySelector("style[data-group=" + group + "]");
        }
        if (!style.element) {
          const head = document.head || document.getElementsByTagName("head")[0];
          const el = style.element = document.createElement("style");
          el.type = "text/css";
          if (css.media)
            el.setAttribute("media", css.media);
          if (isOldIE) {
            el.setAttribute("data-group", group);
            el.setAttribute("data-next-index", "0");
          }
          head.appendChild(el);
        }
        if (isOldIE) {
          index = parseInt(style.element.getAttribute("data-next-index"));
          style.element.setAttribute("data-next-index", index + 1);
        }
        if (style.element.styleSheet) {
          style.parts.push(code);
          style.element.styleSheet.cssText = style.parts.filter(Boolean).join("\n");
        } else {
          const textNode = document.createTextNode(code);
          const nodes = style.element.childNodes;
          if (nodes[index])
            style.element.removeChild(nodes[index]);
          if (nodes.length)
            style.element.insertBefore(textNode, nodes[index]);
          else
            style.element.appendChild(textNode);
        }
      }
    };
  }
  var __vue_script__15, __vue_render__14, __vue_staticRenderFns__14, __vue_inject_styles__15, __vue_scope_id__15, __vue_module_identifier__15, __vue_is_functional_template__15, __vue_component__14, ChartLineSale_default;
  var init_ChartLineSale = __esm({
    "resource/js/components/sales/charts/ChartLineSale.vue"() {
      init_LineChart();
      __vue_script__15 = {
        name: "sale-linechart",
        props: {
          data: {
            type: Object
          },
          options: {
            type: Object
          }
        },
        components: {
          LineChart: LineChart_default
        },
        data() {
          return {
            chartData: this.data,
            chartOptions: this.options
          };
        }
      };
      __vue_render__14 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", { staticClass: "small" }, [
          _c("line-chart", {
            ref: "chart",
            attrs: { chartData: _vm.chartData, options: _vm.chartOptions }
          })
        ], 1);
      };
      __vue_staticRenderFns__14 = [];
      __vue_render__14._withStripped = true;
      __vue_inject_styles__15 = function(inject2) {
        if (!inject2)
          return;
        inject2("data-v-6781671e_0", { source: "\n.small {\n  max-width: 700px;\n  margin: 50px auto;\n}\n@media (min-width: 796px) {\n.small {\n          margin:  150px auto;\n}\n}\n", map: { "version": 3, "sources": ["resource\\js\\components\\sales\\charts\\ChartLineSale.vue"], "names": [], "mappings": ";AA8BA;EACA,gBAAA;EACA,iBAAA;AACA;AACA;AACA;UACA,mBAAA;AACA;AACA", "file": "ChartLineSale.vue", "sourcesContent": [`<template>\r
    <div class="small">\r
        <line-chart ref="chart" :chartData="chartData" :options="chartOptions"/>\r
    </div>\r
</template>\r
<script>\r
import LineChart from './LineChart.vue'\r
export default {\r
    name: 'sale-linechart',\r
    props:{\r
        data: {\r
            type: Object,\r
        },\r
        options: {\r
            type: Object,\r
        }\r
    },\r
    components:{\r
        LineChart\r
    },\r
    data() {\r
        return {\r
            chartData: this.data,\r
            chartOptions: this.options,\r
        }\r
        \r
    },\r
}\r
<\/script>\r
<style>\r
    .small {\r
    max-width: 700px;\r
    margin: 50px auto;\r
  }\r
    @media (min-width: 796px) {\r
        .small {\r
            margin:  150px auto;\r
        }\r
    }\r
</style>`] }, media: void 0 });
      };
      __vue_scope_id__15 = void 0;
      __vue_module_identifier__15 = void 0;
      __vue_is_functional_template__15 = false;
      __vue_component__14 = /* @__PURE__ */ __vue_normalize__14({ render: __vue_render__14, staticRenderFns: __vue_staticRenderFns__14 }, __vue_inject_styles__15, __vue_script__15, __vue_scope_id__15, __vue_is_functional_template__15, __vue_module_identifier__15, false, __vue_create_injector__4, void 0, void 0);
      ChartLineSale_default = __vue_component__14;
    }
  });

  // resource/js/components/sales/charts/DoughnutChart.vue
  function __vue_normalize__15(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\sales\\charts\\DoughnutChart.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var __vue_script__16, __vue_inject_styles__16, __vue_scope_id__16, __vue_module_identifier__16, __vue_is_functional_template__16, __vue_component__15, DoughnutChart_default;
  var init_DoughnutChart = __esm({
    "resource/js/components/sales/charts/DoughnutChart.vue"() {
      init_es();
      __vue_script__16 = {
        extends: Doughnut,
        mixins: [mixins_default.reactiveProp],
        mounted() {
          this.renderChart(this.chartData, this.options);
        }
      };
      __vue_inject_styles__16 = void 0;
      __vue_scope_id__16 = void 0;
      __vue_module_identifier__16 = void 0;
      __vue_is_functional_template__16 = void 0;
      __vue_component__15 = /* @__PURE__ */ __vue_normalize__15({}, __vue_inject_styles__16, __vue_script__16, __vue_scope_id__16, __vue_is_functional_template__16, __vue_module_identifier__16, false, void 0, void 0, void 0);
      DoughnutChart_default = __vue_component__15;
    }
  });

  // resource/js/components/sales/charts/ChartDoughnutSales.vue
  var ChartDoughnutSales_exports = {};
  __export(ChartDoughnutSales_exports, {
    default: () => ChartDoughnutSales_default
  });
  function __vue_normalize__16(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\sales\\charts\\ChartDoughnutSales.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var __vue_script__17, __vue_render__15, __vue_staticRenderFns__15, __vue_inject_styles__17, __vue_scope_id__17, __vue_module_identifier__17, __vue_is_functional_template__17, __vue_component__16, ChartDoughnutSales_default;
  var init_ChartDoughnutSales = __esm({
    "resource/js/components/sales/charts/ChartDoughnutSales.vue"() {
      init_DoughnutChart();
      __vue_script__17 = {
        name: "sale-doughnut",
        props: {
          data: {
            type: Object
          },
          options: {
            type: Object
          }
        },
        components: {
          DoughnutChart: DoughnutChart_default
        },
        data() {
          return {
            chartData: this.data,
            chartOptions: this.options
          };
        }
      };
      __vue_render__15 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", { staticClass: "small" }, [
          _c("doughnut-chart", {
            attrs: { chartData: _vm.chartData, options: _vm.options }
          })
        ], 1);
      };
      __vue_staticRenderFns__15 = [];
      __vue_render__15._withStripped = true;
      __vue_inject_styles__17 = void 0;
      __vue_scope_id__17 = void 0;
      __vue_module_identifier__17 = void 0;
      __vue_is_functional_template__17 = false;
      __vue_component__16 = /* @__PURE__ */ __vue_normalize__16({ render: __vue_render__15, staticRenderFns: __vue_staticRenderFns__15 }, __vue_inject_styles__17, __vue_script__17, __vue_scope_id__17, __vue_is_functional_template__17, __vue_module_identifier__17, false, void 0, void 0, void 0);
      ChartDoughnutSales_default = __vue_component__16;
    }
  });

  // node_modules/randomcolor/randomColor.js
  var require_randomColor = __commonJS({
    "node_modules/randomcolor/randomColor.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          var randomColor2 = factory();
          if (typeof module === "object" && module && module.exports) {
            exports = module.exports = randomColor2;
          }
          exports.randomColor = randomColor2;
        } else if (typeof define === "function" && define.amd) {
          define([], factory);
        } else {
          root.randomColor = factory();
        }
      })(exports, function() {
        var seed = null;
        var colorDictionary = {};
        loadColorBounds();
        var colorRanges = [];
        var randomColor2 = function(options) {
          options = options || {};
          if (options.seed !== void 0 && options.seed !== null && options.seed === parseInt(options.seed, 10)) {
            seed = options.seed;
          } else if (typeof options.seed === "string") {
            seed = stringToInteger(options.seed);
          } else if (options.seed !== void 0 && options.seed !== null) {
            throw new TypeError("The seed value must be an integer or string");
          } else {
            seed = null;
          }
          var H, S, B;
          if (options.count !== null && options.count !== void 0) {
            var totalColors = options.count, colors = [];
            for (var i = 0; i < options.count; i++) {
              colorRanges.push(false);
            }
            options.count = null;
            while (totalColors > colors.length) {
              var color = randomColor2(options);
              if (seed !== null) {
                options.seed = seed;
              }
              colors.push(color);
            }
            options.count = totalColors;
            return colors;
          }
          H = pickHue(options);
          S = pickSaturation(H, options);
          B = pickBrightness(H, S, options);
          return setFormat([H, S, B], options);
        };
        function pickHue(options) {
          if (colorRanges.length > 0) {
            var hueRange = getRealHueRange(options.hue);
            var hue = randomWithin(hueRange);
            var step = (hueRange[1] - hueRange[0]) / colorRanges.length;
            var j = parseInt((hue - hueRange[0]) / step);
            if (colorRanges[j] === true) {
              j = (j + 2) % colorRanges.length;
            } else {
              colorRanges[j] = true;
            }
            var min = (hueRange[0] + j * step) % 359, max = (hueRange[0] + (j + 1) * step) % 359;
            hueRange = [min, max];
            hue = randomWithin(hueRange);
            if (hue < 0) {
              hue = 360 + hue;
            }
            return hue;
          } else {
            var hueRange = getHueRange(options.hue);
            hue = randomWithin(hueRange);
            if (hue < 0) {
              hue = 360 + hue;
            }
            return hue;
          }
        }
        function pickSaturation(hue, options) {
          if (options.hue === "monochrome") {
            return 0;
          }
          if (options.luminosity === "random") {
            return randomWithin([0, 100]);
          }
          var saturationRange = getSaturationRange(hue);
          var sMin = saturationRange[0], sMax = saturationRange[1];
          switch (options.luminosity) {
            case "bright":
              sMin = 55;
              break;
            case "dark":
              sMin = sMax - 10;
              break;
            case "light":
              sMax = 55;
              break;
          }
          return randomWithin([sMin, sMax]);
        }
        function pickBrightness(H, S, options) {
          var bMin = getMinimumBrightness(H, S), bMax = 100;
          switch (options.luminosity) {
            case "dark":
              bMax = bMin + 20;
              break;
            case "light":
              bMin = (bMax + bMin) / 2;
              break;
            case "random":
              bMin = 0;
              bMax = 100;
              break;
          }
          return randomWithin([bMin, bMax]);
        }
        function setFormat(hsv, options) {
          switch (options.format) {
            case "hsvArray":
              return hsv;
            case "hslArray":
              return HSVtoHSL(hsv);
            case "hsl":
              var hsl = HSVtoHSL(hsv);
              return "hsl(" + hsl[0] + ", " + hsl[1] + "%, " + hsl[2] + "%)";
            case "hsla":
              var hslColor = HSVtoHSL(hsv);
              var alpha = options.alpha || Math.random();
              return "hsla(" + hslColor[0] + ", " + hslColor[1] + "%, " + hslColor[2] + "%, " + alpha + ")";
            case "rgbArray":
              return HSVtoRGB(hsv);
            case "rgb":
              var rgb = HSVtoRGB(hsv);
              return "rgb(" + rgb.join(", ") + ")";
            case "rgba":
              var rgbColor = HSVtoRGB(hsv);
              var alpha = options.alpha || Math.random();
              return "rgba(" + rgbColor.join(", ") + ", " + alpha + ")";
            default:
              return HSVtoHex(hsv);
          }
        }
        function getMinimumBrightness(H, S) {
          var lowerBounds = getColorInfo(H).lowerBounds;
          for (var i = 0; i < lowerBounds.length - 1; i++) {
            var s1 = lowerBounds[i][0], v1 = lowerBounds[i][1];
            var s2 = lowerBounds[i + 1][0], v2 = lowerBounds[i + 1][1];
            if (S >= s1 && S <= s2) {
              var m = (v2 - v1) / (s2 - s1), b = v1 - m * s1;
              return m * S + b;
            }
          }
          return 0;
        }
        function getHueRange(colorInput) {
          if (typeof parseInt(colorInput) === "number") {
            var number = parseInt(colorInput);
            if (number < 360 && number > 0) {
              return [number, number];
            }
          }
          if (typeof colorInput === "string") {
            if (colorDictionary[colorInput]) {
              var color = colorDictionary[colorInput];
              if (color.hueRange) {
                return color.hueRange;
              }
            } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {
              var hue = HexToHSB(colorInput)[0];
              return [hue, hue];
            }
          }
          return [0, 360];
        }
        function getSaturationRange(hue) {
          return getColorInfo(hue).saturationRange;
        }
        function getColorInfo(hue) {
          if (hue >= 334 && hue <= 360) {
            hue -= 360;
          }
          for (var colorName in colorDictionary) {
            var color = colorDictionary[colorName];
            if (color.hueRange && hue >= color.hueRange[0] && hue <= color.hueRange[1]) {
              return colorDictionary[colorName];
            }
          }
          return "Color not found";
        }
        function randomWithin(range) {
          if (seed === null) {
            var golden_ratio = 0.618033988749895;
            var r = Math.random();
            r += golden_ratio;
            r %= 1;
            return Math.floor(range[0] + r * (range[1] + 1 - range[0]));
          } else {
            var max = range[1] || 1;
            var min = range[0] || 0;
            seed = (seed * 9301 + 49297) % 233280;
            var rnd = seed / 233280;
            return Math.floor(min + rnd * (max - min));
          }
        }
        function HSVtoHex(hsv) {
          var rgb = HSVtoRGB(hsv);
          function componentToHex(c) {
            var hex2 = c.toString(16);
            return hex2.length == 1 ? "0" + hex2 : hex2;
          }
          var hex = "#" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);
          return hex;
        }
        function defineColor(name, hueRange, lowerBounds) {
          var sMin = lowerBounds[0][0], sMax = lowerBounds[lowerBounds.length - 1][0], bMin = lowerBounds[lowerBounds.length - 1][1], bMax = lowerBounds[0][1];
          colorDictionary[name] = {
            hueRange,
            lowerBounds,
            saturationRange: [sMin, sMax],
            brightnessRange: [bMin, bMax]
          };
        }
        function loadColorBounds() {
          defineColor("monochrome", null, [[0, 0], [100, 0]]);
          defineColor("red", [-26, 18], [[20, 100], [30, 92], [40, 89], [50, 85], [60, 78], [70, 70], [80, 60], [90, 55], [100, 50]]);
          defineColor("orange", [18, 46], [[20, 100], [30, 93], [40, 88], [50, 86], [60, 85], [70, 70], [100, 70]]);
          defineColor("yellow", [46, 62], [[25, 100], [40, 94], [50, 89], [60, 86], [70, 84], [80, 82], [90, 80], [100, 75]]);
          defineColor("green", [62, 178], [[30, 100], [40, 90], [50, 85], [60, 81], [70, 74], [80, 64], [90, 50], [100, 40]]);
          defineColor("blue", [178, 257], [[20, 100], [30, 86], [40, 80], [50, 74], [60, 60], [70, 52], [80, 44], [90, 39], [100, 35]]);
          defineColor("purple", [257, 282], [[20, 100], [30, 87], [40, 79], [50, 70], [60, 65], [70, 59], [80, 52], [90, 45], [100, 42]]);
          defineColor("pink", [282, 334], [[20, 100], [30, 90], [40, 86], [60, 84], [80, 80], [90, 75], [100, 73]]);
        }
        function HSVtoRGB(hsv) {
          var h = hsv[0];
          if (h === 0) {
            h = 1;
          }
          if (h === 360) {
            h = 359;
          }
          h = h / 360;
          var s = hsv[1] / 100, v = hsv[2] / 100;
          var h_i = Math.floor(h * 6), f = h * 6 - h_i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), r = 256, g = 256, b = 256;
          switch (h_i) {
            case 0:
              r = v;
              g = t;
              b = p;
              break;
            case 1:
              r = q;
              g = v;
              b = p;
              break;
            case 2:
              r = p;
              g = v;
              b = t;
              break;
            case 3:
              r = p;
              g = q;
              b = v;
              break;
            case 4:
              r = t;
              g = p;
              b = v;
              break;
            case 5:
              r = v;
              g = p;
              b = q;
              break;
          }
          var result = [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
          return result;
        }
        function HexToHSB(hex) {
          hex = hex.replace(/^#/, "");
          hex = hex.length === 3 ? hex.replace(/(.)/g, "$1$1") : hex;
          var red = parseInt(hex.substr(0, 2), 16) / 255, green = parseInt(hex.substr(2, 2), 16) / 255, blue = parseInt(hex.substr(4, 2), 16) / 255;
          var cMax = Math.max(red, green, blue), delta = cMax - Math.min(red, green, blue), saturation = cMax ? delta / cMax : 0;
          switch (cMax) {
            case red:
              return [60 * ((green - blue) / delta % 6) || 0, saturation, cMax];
            case green:
              return [60 * ((blue - red) / delta + 2) || 0, saturation, cMax];
            case blue:
              return [60 * ((red - green) / delta + 4) || 0, saturation, cMax];
          }
        }
        function HSVtoHSL(hsv) {
          var h = hsv[0], s = hsv[1] / 100, v = hsv[2] / 100, k = (2 - s) * v;
          return [
            h,
            Math.round(s * v / (k < 1 ? k : 2 - k) * 1e4) / 100,
            k / 2 * 100
          ];
        }
        function stringToInteger(string) {
          var total = 0;
          for (var i = 0; i !== string.length; i++) {
            if (total >= Number.MAX_SAFE_INTEGER)
              break;
            total += string.charCodeAt(i);
          }
          return total;
        }
        function getRealHueRange(colorHue) {
          if (!isNaN(colorHue)) {
            var number = parseInt(colorHue);
            if (number < 360 && number > 0) {
              return getColorInfo(colorHue).hueRange;
            }
          } else if (typeof colorHue === "string") {
            if (colorDictionary[colorHue]) {
              var color = colorDictionary[colorHue];
              if (color.hueRange) {
                return color.hueRange;
              }
            } else if (colorHue.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {
              var hue = HexToHSB(colorHue)[0];
              return getColorInfo(hue).hueRange;
            }
          }
          return [0, 360];
        }
        return randomColor2;
      });
    }
  });

  // resource/js/components/sales/charts/BarChart.vue
  function __vue_normalize__17(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\sales\\charts\\BarChart.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var __vue_script__18, __vue_inject_styles__18, __vue_scope_id__18, __vue_module_identifier__18, __vue_is_functional_template__18, __vue_component__17, BarChart_default;
  var init_BarChart = __esm({
    "resource/js/components/sales/charts/BarChart.vue"() {
      init_es();
      __vue_script__18 = {
        extends: Bar,
        mixins: [mixins_default.reactiveProp],
        mounted() {
          this.renderChart(this.chartData, this.options);
        }
      };
      __vue_inject_styles__18 = void 0;
      __vue_scope_id__18 = void 0;
      __vue_module_identifier__18 = void 0;
      __vue_is_functional_template__18 = void 0;
      __vue_component__17 = /* @__PURE__ */ __vue_normalize__17({}, __vue_inject_styles__18, __vue_script__18, __vue_scope_id__18, __vue_is_functional_template__18, __vue_module_identifier__18, false, void 0, void 0, void 0);
      BarChart_default = __vue_component__17;
    }
  });

  // resource/js/components/sales/CardReportSale.vue
  var CardReportSale_exports = {};
  __export(CardReportSale_exports, {
    default: () => CardReportSale_default
  });
  function __vue_normalize__18(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\sales\\CardReportSale.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var import_moment4, import_vue2_daterange_picker2, import_randomcolor, __vue_script__19, __vue_render__16, __vue_staticRenderFns__16, __vue_inject_styles__19, __vue_scope_id__19, __vue_module_identifier__19, __vue_is_functional_template__19, __vue_component__18, CardReportSale_default;
  var init_CardReportSale = __esm({
    "resource/js/components/sales/CardReportSale.vue"() {
      import_moment4 = __toESM(require_moment());
      import_vue2_daterange_picker2 = __toESM(require_vue2_daterange_picker_umd_min());
      init_ChartLineSale();
      init_ChartDoughnutSales();
      import_randomcolor = __toESM(require_randomColor());
      init_BarChart();
      __vue_script__19 = {
        name: "report-sale",
        props: ["csrf_token"],
        data() {
          let last_week = (0, import_moment4.default)().subtract(7, "days").format("Y-MM-DD 00:00:00");
          let today = (0, import_moment4.default)().format("Y-MM-DD 23:59:59");
          const days_last_week = [
            (0, import_moment4.default)().subtract(7, "days").format("MMMM DD"),
            (0, import_moment4.default)().subtract(6, "days").format("MMMM DD"),
            (0, import_moment4.default)().subtract(5, "days").format("MMMM DD"),
            (0, import_moment4.default)().subtract(4, "days").format("MMMM DD"),
            (0, import_moment4.default)().subtract(3, "days").format("MMMM DD"),
            (0, import_moment4.default)().subtract(2, "days").format("MMMM DD"),
            (0, import_moment4.default)().subtract(1, "days").format("MMMM DD"),
            (0, import_moment4.default)().format("MMMM DD")
          ];
          return {
            dateRange: {
              startDate: last_week,
              endDate: today
            },
            total_sale: 0,
            dataLine: {
              labels: days_last_week,
              datasets: [{
                data: [],
                label: "Sales",
                borderColor: "green",
                backgroundColor: "transparent",
                pointRadius: 10,
                pointHoverRadius: 15,
                fill: false,
                tension: 0.1
              }]
            },
            optionsLine: {
              responsive: true,
              scales: {
                y: {
                  min: 0,
                  suggestedMin: 100,
                  display: true
                }
              }
            },
            loadedLine: false,
            dataDoughnut: {
              labels: [],
              datasets: [{
                label: "Most Sales",
                data: [],
                backgroundColor: []
              }]
            },
            optionsDoughnut: {
              responsive: true
            },
            loadedDoughnut: false,
            doughnutTotal: 0,
            dataBar: {
              labels: [],
              datasets: []
            },
            optionsBar: {
              responsive: true
            },
            loadedBar: false,
            dataBarClient: {
              labels: [],
              datasets: []
            },
            optionsBarClient: {
              responsive: true
            },
            loadedBarClient: false,
            data_excel: []
          };
        },
        filters: {
          date(val) {
            return val ? (0, import_moment4.default)(val).format("Y-MM-DD") : "";
          },
          date2(val) {
            return val ? (0, import_moment4.default)(val).format("MMMM DD, Y") : "";
          },
          addedSales(val) {
            let total = 0;
            val.map((sale) => {
              total += sale;
            });
            return total;
          }
        },
        components: {
          DateRangePicker: import_vue2_daterange_picker2.default,
          SaleChart: ChartLineSale_default,
          DoughnutSale: ChartDoughnutSales_default,
          BarSale: BarChart_default
        },
        methods: {
          salesReport() {
            const start_time = (0, import_moment4.default)(this.dateRange.startDate).format("Y-MM-DD 00:00:00");
            const end_time = (0, import_moment4.default)(this.dateRange.endDate).format("Y-MM-DD 23:59:59");
            this.loadedLine = false;
            axios({
              method: "post",
              url: "/sales/ranges/charts",
              data: {
                csrf_token: this.csrf_token,
                start_date: start_time,
                end_date: end_time
              }
            }).then((response) => {
              const { data: salesDays } = response;
              const keysDays = Object.keys(salesDays);
              this.dataLine.labels.map((d) => {
                let isAdd = false;
                keysDays.map((k) => {
                  let newkey = k.substring(0, k.length - 5).replace("_", " ");
                  if (d == newkey) {
                    this.dataLine.datasets[0].data.push(salesDays[k]);
                    isAdd = true;
                  }
                });
                if (!isAdd) {
                  this.dataLine.datasets[0].data.push(0);
                }
              });
              this.loadedLine = true;
            });
          },
          getDaysDiff(startDate, stopDate) {
            const dateArray = [];
            let currentDate = (0, import_moment4.default)(startDate);
            stopDate = (0, import_moment4.default)(stopDate);
            while (currentDate <= stopDate) {
              dateArray.push((0, import_moment4.default)(currentDate).format("MMMM DD"));
              currentDate = (0, import_moment4.default)(currentDate).add(1, "days");
            }
            return dateArray;
          },
          changeDateRange() {
            this.dataLine.labels = this.getDaysDiff(this.dateRange.startDate, this.dateRange.endDate);
            this.loadedLine = false;
            this.dataLine.datasets[0].data = [];
            this.salesReport();
            this.dataDoughnut.datasets[0].data = [];
            this.dataDoughnut.labels = [];
            this.doughnutTotal = 0;
            this.productMostSell();
            this.dataBar.labels = [];
            this.dataBar.datasets = [];
            this.bestSeller();
            this.dataBarClient.labels = [];
            this.dataBarClient.datasets = [];
            this.bestClient();
          },
          productMostSell() {
            this.loadedDoughnut = false;
            const start_time = (0, import_moment4.default)(this.dateRange.startDate).format("Y-MM-DD 00:00:00");
            const end_time = (0, import_moment4.default)(this.dateRange.endDate).format("Y-MM-DD 23:59:59");
            axios({
              method: "post",
              url: "/sales/products/mostsales",
              data: {
                csrf_token: this.csrf_token,
                start_date: start_time,
                end_date: end_time
              }
            }).then((response) => {
              const { data: products } = response;
              products.map((product) => {
                this.doughnutTotal += parseInt(product.sold);
                this.dataDoughnut.labels.push(product.name);
                this.dataDoughnut.datasets[0].data.push(parseInt(product.sold));
                this.dataDoughnut.datasets[0].backgroundColor.push((0, import_randomcolor.default)());
              });
              if (products.length > 0) {
                this.loadedDoughnut = true;
              }
            });
          },
          percentVal(val) {
            return parseFloat(val / this.doughnutTotal * 100).toFixed(2);
          },
          bestSeller() {
            this.loadedBar = false;
            const start_time = (0, import_moment4.default)(this.dateRange.startDate).format("Y-MM-DD 00:00:00");
            const end_time = (0, import_moment4.default)(this.dateRange.endDate).format("Y-MM-DD 23:59:59");
            axios({
              method: "post",
              url: "/sales/report/bestseller",
              data: {
                csrf_token: this.csrf_token,
                start_date: start_time,
                end_date: end_time
              }
            }).then((response) => {
              const { data: seller } = response;
              this.dataBar.labels = [`${(0, import_moment4.default)(start_time).format("MMMM DD")} to ${(0, import_moment4.default)(end_time).format("MMMM DD")}`];
              seller.map((sel) => {
                this.dataBar.datasets.push({
                  label: sel.name,
                  data: [parseFloat(sel.sold).toFixed(2)],
                  backgroundColor: [(0, import_randomcolor.default)()]
                });
              });
              this.loadedBar = true;
            });
          },
          bestClient() {
            this.loadedBarClient = false;
            const start_time = (0, import_moment4.default)(this.dateRange.startDate).format("Y-MM-DD 00:00:00");
            const end_time = (0, import_moment4.default)(this.dateRange.endDate).format("Y-MM-DD 23:59:59");
            axios({
              method: "post",
              url: "/sales/report/bestclient",
              data: {
                csrf_token: this.csrf_token,
                start_date: start_time,
                end_date: end_time
              }
            }).then((response) => {
              const { data: client } = response;
              this.dataBarClient.labels = [`${(0, import_moment4.default)(start_time).format("MMMM DD")} to ${(0, import_moment4.default)(end_time).format("MMMM DD")}`];
              client.map((cs) => {
                this.dataBarClient.datasets.push({
                  label: cs.name,
                  data: [parseFloat(cs.sold).toFixed(2)],
                  backgroundColor: [(0, import_randomcolor.default)()]
                });
              });
              this.loadedBarClient = true;
            });
          },
          async fetchDataExcel() {
            const start_time = (0, import_moment4.default)(this.dateRange.startDate).format("Y-MM-DD 00:00:00");
            const end_time = (0, import_moment4.default)(this.dateRange.endDate).format("Y-MM-DD 23:59:59");
            const data_excel = [];
            await axios({
              method: "post",
              url: "/sales/report/excel",
              data: {
                csrf_token: this.csrf_token,
                start_date: start_time,
                end_date: end_time
              }
            }).then((response) => {
              const { data: data2 } = response;
              data2.map((sale) => {
                let amount = "";
                let products = "";
                sale.products.map((product) => {
                  amount += product.pivot.quantity + "\n";
                  products += product.name + "\n";
                });
                data_excel.push({
                  "#": sale.id_sale.toString().substr(0, 2) + "-" + sale.id_sale.toString().substr(2, 4),
                  client: sale.customer.name,
                  seller: sale.seller.name,
                  amount,
                  products,
                  tax: sale.tax,
                  net: sale.net,
                  total: sale.total,
                  method: sale.method,
                  date: (0, import_moment4.default)(sale.created_at).format("MM-DD-YYYY, h:mm:ss a")
                });
              });
            });
            return data_excel;
          },
          formatDate3(val) {
            return val ? (0, import_moment4.default)(val).format("Y-MM-DD") : "";
          }
        },
        async mounted() {
          this.salesReport();
          this.productMostSell();
          this.bestSeller();
          this.bestClient();
        }
      };
      __vue_render__16 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", { staticClass: "card" }, [
          _c("div", { staticClass: "card-header" }, [
            _c("div", { staticClass: "d-flex align-items-center justify-content-between" }, [
              _c("date-range-picker", {
                on: { update: _vm.changeDateRange },
                scopedSlots: _vm._u([
                  {
                    key: "input",
                    fn: function(picker) {
                      return [
                        _vm._v("\n            " + _vm._s(_vm._f("date")(picker.startDate)) + " - " + _vm._s(_vm._f("date")(picker.endDate)) + "\n            ")
                      ];
                    }
                  }
                ]),
                model: {
                  value: _vm.dateRange,
                  callback: function($$v) {
                    _vm.dateRange = $$v;
                  },
                  expression: "dateRange"
                }
              }),
              _vm._v(" "),
              _c("download-excel", {
                attrs: {
                  fetch: _vm.fetchDataExcel,
                  type: "xls",
                  worksheet: "Report",
                  name: "Report Sales " + _vm.formatDate3(_vm.dateRange.startDate) + " to " + _vm.formatDate3(_vm.dateRange.endDate) + ".xls"
                }
              }, [
                _c("button", { staticClass: "btn btn-primary" }, [
                  _vm._v("Export Excel")
                ])
              ])
            ], 1)
          ]),
          _vm._v(" "),
          _c("div", { staticClass: "card-body" }, [
            _c("div", { staticClass: "row" }, [
              _c("div", { staticClass: "col-sm-12 col-md-8" }, [
                _vm.loadedLine ? _c("sale-linechart", {
                  ref: "chart",
                  attrs: { data: _vm.dataLine, options: _vm.optionsLine }
                }) : _vm._e()
              ], 1),
              _vm._v(" "),
              _c("div", { staticClass: "col-sm-12 col-md-4 py-2 m-auto" }, [
                _vm.loadedLine ? _c("div", {
                  staticClass: "d-flex flex-column animate__animated animate__backInRight"
                }, [
                  _c("span", {
                    staticClass: "text-center text-success fw-bold fs-2 mb-3 mb-md-0"
                  }, [
                    _vm._v("Total: $ " + _vm._s(_vm._f("addedSales")(_vm.dataLine.datasets[0].data)))
                  ]),
                  _vm._v(" "),
                  _c("span", { staticClass: "text-center" }, [
                    _vm._v("Sales report from " + _vm._s(_vm._f("date2")(_vm.dateRange.startDate)) + " to " + _vm._s(_vm._f("date2")(_vm.dateRange.endDate)))
                  ])
                ]) : _vm._e()
              ]),
              _vm._v(" "),
              _c("div", { staticClass: "col-sm-12 col-md-6 m-auto" }, [
                _vm.loadedDoughnut ? _c("div", {
                  staticClass: "d-flex flex-column justify-content-center animate__animated animate__backInLeft"
                }, [
                  _c("span", {
                    staticClass: "text-center text-success fw-bold fs-2 mb-md-0"
                  }, [_vm._v("Products Most Sold")]),
                  _vm._v(" "),
                  _c("ul", { staticClass: "list-group mt-2" }, _vm._l(_vm.dataDoughnut.datasets[0].data, function(product, index) {
                    return _c("li", {
                      key: index,
                      staticClass: "list-group-item d-flex justify-content-between"
                    }, [
                      _vm._v("\n                            " + _vm._s(_vm.dataDoughnut.labels[index]) + " "),
                      _c("span", {
                        staticClass: "fw-bold",
                        style: "color: " + _vm.dataDoughnut.datasets[0].backgroundColor[index]
                      }, [_vm._v(_vm._s(_vm.percentVal(product)) + "%")])
                    ]);
                  }), 0)
                ]) : _vm._e()
              ]),
              _vm._v(" "),
              _c("div", { staticClass: "col-sm-12 col-md-6" }, [
                _vm.loadedDoughnut ? _c("sale-doughnut", {
                  ref: "chart_doughnut",
                  attrs: {
                    data: _vm.dataDoughnut,
                    options: _vm.optionsDoughnut
                  }
                }) : _vm._e()
              ], 1),
              _vm._v(" "),
              _c("div", { staticClass: "col-sm-12 col-md-6" }, [
                _c("div", {
                  staticClass: "d-flex flex-column animate__animated animate__backInLeft"
                }, [
                  _c("span", {
                    staticClass: "text-center text-success fw-bold fs-2 mb-md-0"
                  }, [_vm._v("Best Seller")]),
                  _vm._v(" "),
                  _vm.loadedBar ? _c("sale-bar", {
                    attrs: {
                      data: _vm.dataBar,
                      options: _vm.optionsBar,
                      classes: "mt-2 m-auto w-75"
                    }
                  }) : _vm._e()
                ], 1)
              ]),
              _vm._v(" "),
              _c("div", { staticClass: "col-sm-12 col-md-6" }, [
                _vm.loadedBarClient ? _c("div", {
                  staticClass: "d-flex flex-column animate__animated animate__backInRight"
                }, [
                  _c("span", {
                    staticClass: "text-center text-success fw-bold fs-2 mb-md-0"
                  }, [_vm._v("Best Customer")]),
                  _vm._v(" "),
                  _c("sale-bar", {
                    attrs: {
                      data: _vm.dataBarClient,
                      options: _vm.optionsBarClient,
                      classes: "mt-2 m-auto w-75"
                    }
                  })
                ], 1) : _vm._e()
              ])
            ])
          ])
        ]);
      };
      __vue_staticRenderFns__16 = [];
      __vue_render__16._withStripped = true;
      __vue_inject_styles__19 = void 0;
      __vue_scope_id__19 = void 0;
      __vue_module_identifier__19 = void 0;
      __vue_is_functional_template__19 = false;
      __vue_component__18 = /* @__PURE__ */ __vue_normalize__18({ render: __vue_render__16, staticRenderFns: __vue_staticRenderFns__16 }, __vue_inject_styles__19, __vue_script__19, __vue_scope_id__19, __vue_is_functional_template__19, __vue_module_identifier__19, false, void 0, void 0, void 0);
      CardReportSale_default = __vue_component__18;
    }
  });

  // resource/js/components/sales/charts/ChartBarSales.vue
  var ChartBarSales_exports = {};
  __export(ChartBarSales_exports, {
    default: () => ChartBarSales_default
  });
  function __vue_normalize__19(template, style, script2, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    const component2 = (typeof script2 === "function" ? script2.options : script2) || {};
    component2.__file = "resource\\js\\components\\sales\\charts\\ChartBarSales.vue";
    if (!component2.render) {
      component2.render = template.render;
      component2.staticRenderFns = template.staticRenderFns;
      component2._compiled = true;
      if (functional)
        component2.functional = true;
    }
    component2._scopeId = scope;
    if (false) {
      let hook;
      if (false) {
        hook = function(context) {
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
          if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
            context = __VUE_SSR_CONTEXT__;
          }
          if (style) {
            style.call(this, createInjectorSSR(context));
          }
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        component2._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function(context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function(context) {
          style.call(this, createInjector(context));
        };
      }
      if (hook !== void 0) {
        if (component2.functional) {
          const originalRender = component2.render;
          component2.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          const existing = component2.beforeCreate;
          component2.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }
    }
    return component2;
  }
  var __vue_script__20, __vue_render__17, __vue_staticRenderFns__17, __vue_inject_styles__20, __vue_scope_id__20, __vue_module_identifier__20, __vue_is_functional_template__20, __vue_component__19, ChartBarSales_default;
  var init_ChartBarSales = __esm({
    "resource/js/components/sales/charts/ChartBarSales.vue"() {
      init_BarChart();
      __vue_script__20 = {
        name: "sale-bar",
        props: {
          data: {
            type: Object
          },
          options: {
            type: Object
          },
          classes: {
            type: String,
            default: "small"
          }
        },
        components: {
          BarChart: BarChart_default
        },
        data() {
          return {
            chartData: this.data,
            chartOptions: this.options
          };
        }
      };
      __vue_render__17 = function() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", { class: _vm.classes }, [
          _c("bar-chart", {
            attrs: { chartData: _vm.chartData, options: _vm.options }
          })
        ], 1);
      };
      __vue_staticRenderFns__17 = [];
      __vue_render__17._withStripped = true;
      __vue_inject_styles__20 = void 0;
      __vue_scope_id__20 = void 0;
      __vue_module_identifier__20 = void 0;
      __vue_is_functional_template__20 = false;
      __vue_component__19 = /* @__PURE__ */ __vue_normalize__19({ render: __vue_render__17, staticRenderFns: __vue_staticRenderFns__17 }, __vue_inject_styles__20, __vue_script__20, __vue_scope_id__20, __vue_is_functional_template__20, __vue_module_identifier__20, false, void 0, void 0, void 0);
      ChartBarSales_default = __vue_component__19;
    }
  });

  // resource/js/app.js
  var import_vue3 = __toESM(require_vue());
  var import_vue_sweetalert2 = __toESM(require_vue_sweetalert_umd());
  var import_vue_select = __toESM(require_vue_select());

  // node_modules/vue-json-excel/dist/vue-json-excel.esm.js
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function createCommonjsModule(fn, module) {
    return module = { exports: {} }, fn(module, module.exports), module.exports;
  }
  var download = createCommonjsModule(function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory();
      }
    })(commonjsGlobal, function() {
      return function download2(data2, strFileName, strMimeType) {
        var self2 = window, defaultMime = "application/octet-stream", mimeType = strMimeType || defaultMime, payload = data2, url = !strFileName && !strMimeType && payload, anchor = document.createElement("a"), toString2 = function(a) {
          return String(a);
        }, myBlob = self2.Blob || self2.MozBlob || self2.WebKitBlob || toString2, fileName = strFileName || "download", blob, reader;
        myBlob = myBlob.call ? myBlob.bind(self2) : Blob;
        if (String(this) === "true") {
          payload = [payload, mimeType];
          mimeType = payload[0];
          payload = payload[1];
        }
        if (url && url.length < 2048) {
          fileName = url.split("/").pop().split("?")[0];
          anchor.href = url;
          if (anchor.href.indexOf(url) !== -1) {
            var ajax = new XMLHttpRequest();
            ajax.open("GET", url, true);
            ajax.responseType = "blob";
            ajax.onload = function(e) {
              download2(e.target.response, fileName, defaultMime);
            };
            setTimeout(function() {
              ajax.send();
            }, 0);
            return ajax;
          }
        }
        if (/^data:([\w+-]+\/[\w+.-]+)?[,;]/.test(payload)) {
          if (payload.length > 1024 * 1024 * 1.999 && myBlob !== toString2) {
            payload = dataUrlToBlob(payload);
            mimeType = payload.type || defaultMime;
          } else {
            return navigator.msSaveBlob ? navigator.msSaveBlob(dataUrlToBlob(payload), fileName) : saver(payload);
          }
        } else {
          if (/([\x80-\xff])/.test(payload)) {
            var i = 0, tempUiArr = new Uint8Array(payload.length), mx = tempUiArr.length;
            for (i; i < mx; ++i)
              tempUiArr[i] = payload.charCodeAt(i);
            payload = new myBlob([tempUiArr], { type: mimeType });
          }
        }
        blob = payload instanceof myBlob ? payload : new myBlob([payload], { type: mimeType });
        function dataUrlToBlob(strUrl) {
          var parts = strUrl.split(/[:;,]/), type = parts[1], decoder = parts[2] == "base64" ? atob : decodeURIComponent, binData = decoder(parts.pop()), mx2 = binData.length, i2 = 0, uiArr = new Uint8Array(mx2);
          for (i2; i2 < mx2; ++i2)
            uiArr[i2] = binData.charCodeAt(i2);
          return new myBlob([uiArr], { type });
        }
        function saver(url2, winMode) {
          if ("download" in anchor) {
            anchor.href = url2;
            anchor.setAttribute("download", fileName);
            anchor.className = "download-js-link";
            anchor.innerHTML = "downloading...";
            anchor.style.display = "none";
            document.body.appendChild(anchor);
            setTimeout(function() {
              anchor.click();
              document.body.removeChild(anchor);
              if (winMode === true) {
                setTimeout(function() {
                  self2.URL.revokeObjectURL(anchor.href);
                }, 250);
              }
            }, 66);
            return true;
          }
          if (/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent)) {
            if (/^data:/.test(url2))
              url2 = "data:" + url2.replace(/^data:([\w\/\-\+]+)/, defaultMime);
            if (!window.open(url2)) {
              if (confirm("Displaying New Document\n\nUse Save As... to download, then click back to return to this page.")) {
                location.href = url2;
              }
            }
            return true;
          }
          var f = document.createElement("iframe");
          document.body.appendChild(f);
          if (!winMode && /^data:/.test(url2)) {
            url2 = "data:" + url2.replace(/^data:([\w\/\-\+]+)/, defaultMime);
          }
          f.src = url2;
          setTimeout(function() {
            document.body.removeChild(f);
          }, 333);
        }
        if (navigator.msSaveBlob) {
          return navigator.msSaveBlob(blob, fileName);
        }
        if (self2.URL) {
          saver(self2.URL.createObjectURL(blob), true);
        } else {
          if (typeof blob === "string" || blob.constructor === toString2) {
            try {
              return saver("data:" + mimeType + ";base64," + self2.btoa(blob));
            } catch (y) {
              return saver("data:" + mimeType + "," + encodeURIComponent(blob));
            }
          }
          reader = new FileReader();
          reader.onload = function(e) {
            saver(this.result);
          };
          reader.readAsDataURL(blob);
        }
        return true;
      };
    });
  });
  var script = {
    props: {
      type: {
        type: String,
        default: "xls"
      },
      data: {
        type: Array,
        required: false,
        default: null
      },
      fields: {
        type: Object,
        default: () => null
      },
      exportFields: {
        type: Object,
        default: () => null
      },
      defaultValue: {
        type: String,
        required: false,
        default: ""
      },
      header: {
        default: null
      },
      footer: {
        default: null
      },
      name: {
        type: String,
        default: "data.xls"
      },
      fetch: {
        type: Function
      },
      meta: {
        type: Array,
        default: () => []
      },
      worksheet: {
        type: String,
        default: "Sheet1"
      },
      beforeGenerate: {
        type: Function
      },
      beforeFinish: {
        type: Function
      },
      escapeCsv: {
        type: Boolean,
        default: true
      },
      stringifyLongNum: {
        type: Boolean,
        default: false
      }
    },
    computed: {
      idName() {
        var now = new Date().getTime();
        return "export_" + now;
      },
      downloadFields() {
        if (this.fields)
          return this.fields;
        if (this.exportFields)
          return this.exportFields;
      }
    },
    methods: {
      async generate() {
        if (typeof this.beforeGenerate === "function") {
          await this.beforeGenerate();
        }
        let data2 = this.data;
        if (typeof this.fetch === "function" || !data2)
          data2 = await this.fetch();
        if (!data2 || !data2.length) {
          return;
        }
        let json = this.getProcessedJson(data2, this.downloadFields);
        if (this.type === "html") {
          return this.export(this.jsonToXLS(json), this.name.replace(".xls", ".html"), "text/html");
        } else if (this.type === "csv") {
          return this.export(this.jsonToCSV(json), this.name.replace(".xls", ".csv"), "application/csv");
        }
        return this.export(this.jsonToXLS(json), this.name, "application/vnd.ms-excel");
      },
      export: async function(data2, filename, mime) {
        let blob = this.base64ToBlob(data2, mime);
        if (typeof this.beforeFinish === "function")
          await this.beforeFinish();
        download(blob, filename, mime);
      },
      jsonToXLS(data2) {
        let xlsTemp = '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40"><head><meta name=ProgId content=Excel.Sheet> <meta name=Generator content="Microsoft Excel 11"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet><x:Name>${worksheet}</x:Name><x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions></x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]--><style>br {mso-data-placement: same-cell;}</style></head><body><table>${table}</table></body></html>';
        let xlsData = "<thead>";
        const colspan = Object.keys(data2[0]).length;
        let _self = this;
        const header = this.header || this.$attrs.title;
        if (header) {
          xlsData += this.parseExtraData(header, '<tr><th colspan="' + colspan + '">${data}</th></tr>');
        }
        xlsData += "<tr>";
        for (let key in data2[0]) {
          xlsData += "<th>" + key + "</th>";
        }
        xlsData += "</tr>";
        xlsData += "</thead>";
        xlsData += "<tbody>";
        data2.map(function(item, index) {
          xlsData += "<tr>";
          for (let key in item) {
            xlsData += "<td>" + _self.preprocessLongNum(_self.valueReformattedForMultilines(item[key])) + "</td>";
          }
          xlsData += "</tr>";
        });
        xlsData += "</tbody>";
        if (this.footer != null) {
          xlsData += "<tfoot>";
          xlsData += this.parseExtraData(this.footer, '<tr><td colspan="' + colspan + '">${data}</td></tr>');
          xlsData += "</tfoot>";
        }
        return xlsTemp.replace("${table}", xlsData).replace("${worksheet}", this.worksheet);
      },
      jsonToCSV(data2) {
        let _self = this;
        var csvData = [];
        const header = this.header || this.$attrs.title;
        if (header) {
          csvData.push(this.parseExtraData(header, "${data}\r\n"));
        }
        for (let key in data2[0]) {
          csvData.push(key);
          csvData.push(",");
        }
        csvData.pop();
        csvData.push("\r\n");
        data2.map(function(item) {
          for (let key in item) {
            let escapedCSV = item[key] + "";
            if (_self.escapeCsv) {
              escapedCSV = '="' + escapedCSV + '"';
              if (escapedCSV.match(/[,"\n]/)) {
                escapedCSV = '"' + escapedCSV.replace(/\"/g, '""') + '"';
              }
            }
            csvData.push(escapedCSV);
            csvData.push(",");
          }
          csvData.pop();
          csvData.push("\r\n");
        });
        if (this.footer != null) {
          csvData.push(this.parseExtraData(this.footer, "${data}\r\n"));
        }
        return csvData.join("");
      },
      getProcessedJson(data2, header) {
        let keys = this.getKeys(data2, header);
        let newData = [];
        let _self = this;
        data2.map(function(item, index) {
          let newItem = {};
          for (let label in keys) {
            let property = keys[label];
            newItem[label] = _self.getValue(property, item);
          }
          newData.push(newItem);
        });
        return newData;
      },
      getKeys(data2, header) {
        if (header) {
          return header;
        }
        let keys = {};
        for (let key in data2[0]) {
          keys[key] = key;
        }
        return keys;
      },
      parseExtraData(extraData, format3) {
        let parseData = "";
        if (Array.isArray(extraData)) {
          for (var i = 0; i < extraData.length; i++) {
            if (extraData[i])
              parseData += format3.replace("${data}", extraData[i]);
          }
        } else {
          parseData += format3.replace("${data}", extraData);
        }
        return parseData;
      },
      getValue(key, item) {
        const field = typeof key !== "object" ? key : key.field;
        let indexes = typeof field !== "string" ? [] : field.split(".");
        let value = this.defaultValue;
        if (!field)
          value = item;
        else if (indexes.length > 1)
          value = this.getValueFromNestedItem(item, indexes);
        else
          value = this.parseValue(item[field]);
        if (key.hasOwnProperty("callback"))
          value = this.getValueFromCallback(value, key.callback);
        return value;
      },
      valueReformattedForMultilines(value) {
        if (typeof value == "string")
          return value.replace(/\n/gi, "<br/>");
        else
          return value;
      },
      preprocessLongNum(value) {
        if (this.stringifyLongNum) {
          if (String(value).startsWith("0x")) {
            return value;
          }
          if (!isNaN(value) && value != "") {
            if (value > 99999999999 || value < 1e-13) {
              return '="' + value + '"';
            }
          }
        }
        return value;
      },
      getValueFromNestedItem(item, indexes) {
        let nestedItem = item;
        for (let index of indexes) {
          if (nestedItem)
            nestedItem = nestedItem[index];
        }
        return this.parseValue(nestedItem);
      },
      getValueFromCallback(item, callback) {
        if (typeof callback !== "function")
          return this.defaultValue;
        const value = callback(item);
        return this.parseValue(value);
      },
      parseValue(value) {
        return value || value === 0 || typeof value === "boolean" ? value : this.defaultValue;
      },
      base64ToBlob(data2, mime) {
        let base64 = window.btoa(window.unescape(encodeURIComponent(data2)));
        let bstr = atob(base64);
        let n = bstr.length;
        let u8arr = new Uint8ClampedArray(n);
        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], { type: mime });
      }
    }
  };
  function normalizeComponent(template, style, script2, scopeId, isFunctionalTemplate, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== "boolean") {
      createInjectorSSR = createInjector;
      createInjector = shadowMode;
      shadowMode = false;
    }
    var options = typeof script2 === "function" ? script2.options : script2;
    if (template && template.render) {
      options.render = template.render;
      options.staticRenderFns = template.staticRenderFns;
      options._compiled = true;
      if (isFunctionalTemplate) {
        options.functional = true;
      }
    }
    if (scopeId) {
      options._scopeId = scopeId;
    }
    var hook;
    if (moduleIdentifier) {
      hook = function hook2(context) {
        context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
        if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
          context = __VUE_SSR_CONTEXT__;
        }
        if (style) {
          style.call(this, createInjectorSSR(context));
        }
        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      };
      options._ssrRegister = hook;
    } else if (style) {
      hook = shadowMode ? function() {
        style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
      } : function(context) {
        style.call(this, createInjector(context));
      };
    }
    if (hook) {
      if (options.functional) {
        var originalRender = options.render;
        options.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        var existing = options.beforeCreate;
        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }
    return script2;
  }
  var normalizeComponent_1 = normalizeComponent;
  var __vue_script__ = script;
  var __vue_render__ = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { attrs: { id: _vm.idName }, on: { click: _vm.generate } }, [_vm._t("default", [_vm._v(" Download " + _vm._s(_vm.name) + " ")])], 2);
  };
  var __vue_staticRenderFns__ = [];
  __vue_render__._withStripped = true;
  var __vue_inject_styles__ = void 0;
  var __vue_scope_id__ = void 0;
  var __vue_module_identifier__ = void 0;
  var __vue_is_functional_template__ = false;
  var JsonExcel = normalizeComponent_1({ render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, void 0, void 0);
  var vue_json_excel_esm_default = JsonExcel;

  // resource/js/app.js
  import_vue3.default.config.productionTip = false;
  window.axios = require_axios2();
  window.Vue = require_vue();
  window.moment = require_moment();
  window.numeral = require_numeral();
  import_vue3.default.use(import_vue_sweetalert2.default);
  import_vue3.default.component("v-select", import_vue_select.default);
  import_vue3.default.component("downloadExcel", vue_json_excel_esm_default);
  import_vue3.default.component("login-form", (init_Login(), __toCommonJS(Login_exports)).default);
  import_vue3.default.component("u-table", (init_TableUsers(), __toCommonJS(TableUsers_exports)).default);
  import_vue3.default.component("u-modal", (init_ModalUser(), __toCommonJS(ModalUser_exports)).default);
  import_vue3.default.component("cate-table", (init_TableCategories(), __toCommonJS(TableCategories_exports)).default);
  import_vue3.default.component("cate-modal", (init_ModalCategories(), __toCommonJS(ModalCategories_exports)).default);
  import_vue3.default.component("prod-table", (init_TableProducts(), __toCommonJS(TableProducts_exports)).default);
  import_vue3.default.component("prod-modal", (init_ModalProducts(), __toCommonJS(ModalProducts_exports)).default);
  import_vue3.default.component("customer-table", (init_TableCustomers(), __toCommonJS(TableCustomers_exports)).default);
  import_vue3.default.component("customer-modal", (init_ModalCustomers(), __toCommonJS(ModalCustomers_exports)).default);
  import_vue3.default.component("sales-table", (init_TableSales(), __toCommonJS(TableSales_exports)).default);
  import_vue3.default.component("card-create-sale", (init_CardCreateSale(), __toCommonJS(CardCreateSale_exports)).default);
  import_vue3.default.component("table-add-product", (init_CardAddProduct(), __toCommonJS(CardAddProduct_exports)).default);
  import_vue3.default.component("report-sale", (init_CardReportSale(), __toCommonJS(CardReportSale_exports)).default);
  import_vue3.default.component("sale-linechart", (init_ChartLineSale(), __toCommonJS(ChartLineSale_exports)).default);
  import_vue3.default.component("sale-doughnut", (init_ChartDoughnutSales(), __toCommonJS(ChartDoughnutSales_exports)).default);
  import_vue3.default.component("sale-bar", (init_ChartBarSales(), __toCommonJS(ChartBarSales_exports)).default);
  var app = new import_vue3.default({
    el: "#app"
  });
})();
/*!
 * Chart.js v2.9.4
 * https://www.chartjs.org
 * (c) 2020 Chart.js Contributors
 * Released under the MIT License
 */
/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! @preserve
 * numeral.js
 * version : 2.0.6
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! moment.js
//! momentjs.com
//! version : 2.29.1
